<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NP问题与启发式算法</title>
      <link href="/2021/12/27/NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/27/NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><span id="more"></span><h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><h3 id="多项式时间（polynomial-time）"><a href="#多项式时间（polynomial-time）" class="headerlink" title="多项式时间（polynomial time）"></a>多项式时间（polynomial time）</h3><p>&emsp;&emsp;时间复杂度是指当程序所处理的问题规模扩大后，程序需要的时间长度对应增长得有多快。根据增量的量级划分，可以分为：</p><ul><li>多项式复杂度：O(1)、O(ln(n))、O(n^a)等</li><li>非多项式复杂度：O(a^n)、O(n!)等</li></ul><p>&emsp;&emsp;非多项式复杂度的程序当问题规模扩大时，计算机将无法承受运算时间开销，因此通常使用的算法都是多项式级的复杂度。</p><p>&nbsp;</p><h3 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，在算法的整个执行过程中，每一步都能得到一个确定的解，这样的算法就是确定性算法。</p><h3 id="非确定性算法"><a href="#非确定性算法" class="headerlink" title="非确定性算法"></a>非确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，它将问题分解成两部分，分别为猜测阶段和验证阶段，其中</p><ul><li>猜测阶段：对问题的一个特定的输入实例x产生一个任意字符串y，在算法的每一次运行时，y的值可能不同，因此，猜测以一种非确定的形式工作。</li><li>验证阶段：用一个确定性算法（有限时间内）验证。<ul><li>①检查在猜测阶段产生的y是否是合适的形式，如果不是，则算法停下来并得到no；</li><li>② 如果y是合适的形式，则验证它是否是问题的解，如果是，则算法停下来并得到yes，否则算法停下来并得到no。它是验证所猜测的解的正确性。</li></ul></li></ul><p>&nbsp;</p><h3 id="规约-约化"><a href="#规约-约化" class="headerlink" title="规约/约化"></a>规约/约化</h3><p>&emsp;&emsp;问题A可以约化为问题B，称为“问题A可规约为问题B”，可以理解为问题B的解一定就是问题A的解，因此解决A不会难于解决B。由此可知问题B的时间复杂度一定大于等于问题A。</p><p>&emsp;&emsp;从规约的定义中我们看到，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断规约，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。</p><p>&nbsp;</p><h3 id="P-NP-NPC-NP-Hard问题"><a href="#P-NP-NPC-NP-Hard问题" class="headerlink" title="P/NP/NPC/NP-Hard问题"></a>P/NP/NPC/NP-Hard问题</h3><h4 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h4><p>&emsp;&emsp;能在多项式时间内可解的问题</p><h4 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h4><p>&emsp;&emsp;在多项式时间内”可验证“的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。</p><h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p>&emsp;&emsp;存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：</p><ul><li>是一个NP问题</li><li>所有NO问题都能规约到它</li></ul><h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>&emsp;&emsp;满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130636.png" alt="image-20211227130636049" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="启发式算法（Heuristic-algorithm）"><a href="#启发式算法（Heuristic-algorithm）" class="headerlink" title="启发式算法（Heuristic algorithm）"></a>启发式算法（Heuristic algorithm）</h2><p>&emsp;&emsp;实际工程中有许多优化问题是NP-Hard问题，其最优算法通常因为复杂度过高而效率低下，或者就是没有最优化算法可以用。启发式算法是相对于最优化算法提出的基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解（次优解），该可行解与最优解的偏离程度一般不能被预计。</p><ul><li>无法保证得到某优化问题的全局最优解</li><li>为了快速地求解那些不存在或者暂时未找到多项式时间内算法的问题而提出</li></ul><p><strong>元启发式算法（Metaheuristic algorithm）</strong></p><p>&emsp;&emsp;元启发式算法主要指一类通用型的启发式算法，这类算法的优化机理不过分依赖于算法的组织结构信息（不依赖特定问题，而是具有通用性的策略），可以广泛的应用到函数的组合优化和函数计算中。</p><p><strong>超启发算法（Hyper-heuristic algorithm）</strong></p><p>&emsp;&emsp;超启发式算法提供了某种高层策略（High-Level Strategy，HLS），通过操纵或管理一组低层启发式算法（Low-Level Heuristics, LLH），以获得新启发式算法。这些新启发式算法则被运用于求解各类NP-难解问题。</p><p>&nbsp;</p><h3 id="常用的启发式算法"><a href="#常用的启发式算法" class="headerlink" title="常用的启发式算法"></a>常用的启发式算法</h3><h4 id="模拟退火算法（SA）"><a href="#模拟退火算法（SA）" class="headerlink" title="模拟退火算法（SA）"></a>模拟退火算法（SA）</h4><p>&emsp;&emsp;模拟退火算法(Simulated Annealing, SA)的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化温度T(充分大)，温度下限Tmin(充分小)，初始解X，每个T值迭代次数L</span><br><span class="line"></span><br><span class="line">2. 随机生成临域解x_new;</span><br><span class="line"></span><br><span class="line">3. 设f(x)函数来计算用来计算解得好坏，计算出f(x_new)-f(x);</span><br><span class="line"></span><br><span class="line">4. 如果f(x_new)-f(x)&gt;0，说明新解比原来的解好，则无条件接受，如果f(x_new)-f(x)&lt;0，则说明旧解比新解好，则以概率exp((f(xnew)-f(x))/k*T)接受x_new作为解。</span><br><span class="line"></span><br><span class="line">5. 如果当前温度&lt;Tmin时，则退出循环，输出当前结果，否则减少当前温度，回到第2步继续循环，常用的降温方法为T= a*T (0&lt;a&lt;1)，一般a取接近1的值</span><br></pre></td></tr></table></figure><p>实例：求解函数最小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130659.png" alt="image-20211227130659835" style="zoom: 67%;" /><p>其中-100&lt;=x&lt;=100，给定任意y值，求x为多少时，F(x)最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">2000</span>;        <span class="comment">// 初始化温度</span></span><br><span class="line"><span class="keyword">double</span> Tmin = <span class="number">1</span>;     <span class="comment">// 温度的下界</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">100</span>;         <span class="comment">// 迭代的次数</span></span><br><span class="line"><span class="keyword">double</span> delta = <span class="number">0.98</span>; <span class="comment">// 温度的下降率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x取值范围 0~100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span>) / <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评价函数的值,即对应上文中的f(x)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x目标函数中的一个参数</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的另一个参数</span></span><br><span class="line"><span class="comment"> * @return函数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getFuncResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">5</span> * <span class="built_in">pow</span>(x, <span class="number">2</span>) - <span class="built_in">cos</span>(<span class="number">2</span> * x) * y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟退火算法的过程</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的指定的参数</span></span><br><span class="line"><span class="comment"> * @return最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSA</span><span class="params">(<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x_min = <span class="number">0</span>; <span class="comment">// 初始化最优值点</span></span><br><span class="line">    <span class="keyword">double</span> f_x = <span class="number">0</span>;   <span class="comment">// 初始化函数值</span></span><br><span class="line">    <span class="keyword">double</span> *x = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) * k);</span><br><span class="line">    <span class="comment">// 初始化初始解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代的过程</span></span><br><span class="line">    <span class="keyword">while</span> (T &gt; Tmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算此时的函数结果</span></span><br><span class="line">            <span class="keyword">double</span> funTmp = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">            <span class="comment">// 在邻域内产生新的解</span></span><br><span class="line">            <span class="keyword">double</span> x_new = x[i] + (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span> - <span class="number">5000</span>) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 判断新的x不能超出界</span></span><br><span class="line">            <span class="keyword">if</span> (x_new &gt;= <span class="number">-100</span> &amp;&amp; x_new &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug x=%f\n&quot;</span>, x_new);</span><br><span class="line">                <span class="keyword">double</span> funTmp_new = <span class="built_in">getFuncResult</span>(x_new, y);</span><br><span class="line">                <span class="keyword">if</span> (funTmp_new - funTmp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 替换</span></span><br><span class="line">                    x[i] = x_new;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 以概率替换</span></span><br><span class="line">                    <span class="keyword">double</span> p = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-(funTmp_new - funTmp) / T));</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">rand</span>() % <span class="number">100</span>) / <span class="number">100</span> &lt; p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x[i] = x_new;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T = T * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f_x &gt; <span class="built_in">getFuncResult</span>(x[i], y))</span><br><span class="line">        &#123;</span><br><span class="line">            x_min = x[i];</span><br><span class="line">            f_x = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置y的值</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="built_in">getSA</span>(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%4.2f时，有f(x)最小值为 %5.3f\n&quot;</span>, x, <span class="built_in">getFuncResult</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="遗传算法（GA）"><a href="#遗传算法（GA）" class="headerlink" title="遗传算法（GA）"></a>遗传算法（GA）</h4><p>&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 对潜在问题进行编码，初始化基因组，并根据基因组随机初始化种群，并指定繁衍代数。</span><br><span class="line"></span><br><span class="line">2. 计算种群中每个个体的适应度，选择一定数目的留下，其余淘汰。</span><br><span class="line"></span><br><span class="line">3. 在留下的个体中，随机繁衍，对分母基因进行交叉（极小概率变异），产生下一代。</span><br><span class="line"></span><br><span class="line">4. 回到第2步进行循环。直到达到指定的繁衍代数</span><br></pre></td></tr></table></figure><p><strong>相关术语</strong></p><p>编码(coding)：将物体的表现型用编码的方式转为程序可控的基因型</p><blockquote><p>比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给 它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津-&gt;新疆-&gt;北京-&gt;广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。<br>（1）二进制编码，基因用0或1表示（常用于解决01背包问题）</p><p>如：基因A：00100011010 (代表一个个体的染色体)</p><p>（2）互换编码（用于解决排序问题，如旅行商问题和调度问题）</p><p>如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。</p></blockquote><p>解码(decoding)：基因型到表现型的映射</p><p>基因型(genotype)：参数的因子</p><p>表现型(phenotype)：根据不同因子最终展现的形态</p><p>适应度(fitness)：度量某个结果的好坏</p><p>进化(evolution)：不断剔除差的结果，最终逐步留下好的结果</p><p>选择(selection)：以一定的概率从种群中选择若干个个体留下，并繁殖。选择过程是一种基于适应度的优胜劣汰的过程</p><p>复制(reproduction)：将父本、母本的基因复制，以便产生下一代</p><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交</p><blockquote><p>（1）单交叉点法 （用于二进制编码）</p><p>选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。</p><p>如：交叉前：</p><p>00000|01110000000010000</p><p>11100|00000111111000101</p><p>交叉后：</p><p>00000|00000111111000101</p><p>11100|01110000000010000</p><p>（2）双交叉点法 （用于二进制编码）</p><p>选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.</p><p>如：交叉前：</p><p>01 |0010| 11</p><p>11 |0111| 01</p><p>交叉后：</p><p>11 |0010| 01</p><p>01 |0111| 11</p><p>（3）基于“ 与/或 ”交叉法 （用于二进制编码）</p><p>对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .</p><p>如：交叉前：</p><p>01001011</p><p>11011101</p><p>交叉后：</p><p>01001001</p><p>11011111</p><p>（4）单交叉点法 （用于互换编码）</p><p>选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。</p><p>如：交叉前：</p><p>87213 | 09546</p><p>98356 | 71420</p><p>交叉后：</p><p>87213 | 95640</p><p>98356 | 72104</p><p>（5）部分匹配交叉（PMX）法（用于互换编码）</p><p>先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。</p><p>父代A：872 | 130 | 9546</p><p>父代B：983 | 567 | 1420    变为：</p><p>TEMP A: 872 | 567 | 9546</p><p>TEMP B: 983 | 130 | 1420</p><p>对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1&lt;——&gt;５　３&lt;——&gt;６　７&lt;——&gt;０</p><p>子代Ａ：802 | 567 | 9143</p><p>子代Ｂ：986 | 130 | 5427</p><p>（6）顺序交叉法(OX) （用于互换编码）</p><p>从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。</p><p>父代A: 872 | 139 | 0546</p><p>父代B: 983 | 567 | 1420</p><p>交叉后：</p><p>子代A: 856 | 139 | 7420</p><p>子代B: 821 | 567 | 3904</p><p>（7）循环交叉（CX）（用于互换编码）</p><p>CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。</p><p>父代A：1 2 3 4 5 6 7 8 9</p><p>父代B：5 4 6 9 2 3 7 8 1</p><p>可得循环基因：1-&gt;5-&gt;2-&gt;4-&gt;3-&gt;6-&gt;9-&gt;7-&gt;8</p><p>子代Ｂ的编码同理。（循环基因 5-&gt;1-&gt;4-&gt;2-&gt;6-&gt;3-&gt;9-&gt;7-&gt;8）</p></blockquote><p>变异(mutation)：交叉后可能（很小的概率）对染色体进行更改，来防止算法过早收敛而陷入局部最优解中</p><blockquote><p>变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。</p><p>（1）基本位变异算子（用于二进制编码）</p><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。</p><p>变异前：</p><p>000001110000000010000</p><p>变异后：</p><p>000001110001000010000</p><p>（2）逆转变异算子（用于互换编码）（源代码中使用类似此方法）</p><p>在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。</p><p>变异前：</p><p>1346798205</p><p>变异后：</p><p>1246798305</p></blockquote><p>个体（individual）：指染色体带有特征的实体</p><p>种群（population）：个体的集合，该集合内个体数称为种群的大小</p><p>&nbsp;</p><h4 id="蚁群算法（ACO）"><a href="#蚁群算法（ACO）" class="headerlink" title="蚁群算法（ACO）"></a>蚁群算法（ACO）</h4><p>&emsp;&emsp;蚁群优化算法（Ant Colony Optimization, ACO）来源于自然界觅食的最短路径原理。根据昆虫学家的观察，蚂蚁可以在没有任何提示的情况下找到从食物源到巢穴的最短路径，并且能在环境发生变化(如原有路径上有了障碍物)后，自适应地搜索新的最佳路径。这样由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化蚂蚁数量、可行路段、每条路段距离、每条路段的初始信息素大小等信息</span><br><span class="line"></span><br><span class="line">2. 设定蚂蚁的起点、终点。</span><br><span class="line"></span><br><span class="line">3. 蚂蚁从起点出发根据信息素浓度，有一定的概率性选择路段，浓度越高，概率越大，逐步回到终点。</span><br><span class="line"></span><br><span class="line">4. 在蚂蚁走过的路径上，根据每条路段的长度按比例释放信息素，短的路段释放的信息素多，长的路段释放的信息素少。</span><br><span class="line"></span><br><span class="line">5. 对所有路段的信息素进行挥发。</span><br><span class="line"></span><br><span class="line">6. 回到第二步进行循环，直到蚂蚁数量迭代完。</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="粒子群算法（PSO）"><a href="#粒子群算法（PSO）" class="headerlink" title="粒子群算法（PSO）"></a>粒子群算法（PSO）</h4><p>&emsp;&emsp;粒子群优化算法(PSO：Particle swarm optimization) 来源于对鸟群捕食的行为研究。通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化离子的速度和位置</span><br><span class="line"></span><br><span class="line">2. 计算粒子适应度</span><br><span class="line"></span><br><span class="line">3. 获取粒子个体的最优值</span><br><span class="line"></span><br><span class="line">4. 获取全体的历史最优值</span><br><span class="line"></span><br><span class="line">5. 更新速度和位置</span><br><span class="line"></span><br><span class="line">6. 若不满足结束条件，则重复2~5</span><br></pre></td></tr></table></figure><p><strong>参数设定</strong></p><ul><li>种群数量：粒子群算法的最大特点就是速度快，因此初始种群取50-1000都是可以的，虽然初始种群越大收敛性会更好，不过太大了也会影响速度；</li><li>迭代次数：一般取100~4000，太少解不稳定，太多浪费时间。对于复杂问题，进化代数可以相应地提高；</li><li>惯性权重：该参数反映了个体历史成绩对现在的影响，一般取0.5~1；</li><li>学习因子：一般取0~4，此处要根据自变量的取值范围来定，并且学习因子分为个体和群体两种；</li><li>空间维数：粒子搜索的空间维数即为自变量的个数。</li><li>位置限制：限制粒子搜索的空间，即自变量的取值范围，对于无约束问题此处可以省略。</li><li>速度限制：如果粒子飞行速度过快，很可能直接飞过最优解位置，但是如果飞行速度过慢，会使得收敛速度变慢，因此设置合理的速度限制就很有必要了<br>&nbsp;</li></ul><p>实例：求解函数最大值</p><img src="C:/Users/lrk/AppData/Roaming/Typora/typora-user-images/image-20211227130748742.png" alt="image-20211227130748742" style="zoom:67%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line"><span class="comment">%% 初始化种群</span></span><br><span class="line">f= @(x)x .* <span class="built_in">sin</span>(x) .* <span class="built_in">cos</span>(<span class="number">2</span> * x) - <span class="number">2</span> * x .* <span class="built_in">sin</span>(<span class="number">3</span> * x); <span class="comment">% 函数表达式</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);ezplot(f,[<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">20</span>]);</span><br><span class="line">N = <span class="number">50</span>;                         <span class="comment">% 初始种群个数</span></span><br><span class="line">d = <span class="number">1</span>;                          <span class="comment">% 空间维数</span></span><br><span class="line">ger = <span class="number">100</span>;                      <span class="comment">% 最大迭代次数     </span></span><br><span class="line">limit = [<span class="number">0</span>, <span class="number">20</span>];                <span class="comment">% 设置位置参数限制</span></span><br><span class="line">vlimit = [<span class="number">-1</span>, <span class="number">1</span>];               <span class="comment">% 设置速度限制</span></span><br><span class="line">w = <span class="number">0.8</span>;                        <span class="comment">% 惯性权重</span></span><br><span class="line">c1 = <span class="number">0.5</span>;                       <span class="comment">% 自我学习因子</span></span><br><span class="line">c2 = <span class="number">0.5</span>;                       <span class="comment">% 群体学习因子 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:d</span><br><span class="line">    x = limit(<span class="built_in">i</span>, <span class="number">1</span>) + (limit(<span class="built_in">i</span>, <span class="number">2</span>) - limit(<span class="built_in">i</span>, <span class="number">1</span>)) * <span class="built_in">rand</span>(N, d);<span class="comment">%初始种群的位置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">v = <span class="built_in">rand</span>(N, d);                  <span class="comment">% 初始种群的速度</span></span><br><span class="line">xm = x;                          <span class="comment">% 每个个体的历史最佳位置</span></span><br><span class="line">ym = <span class="built_in">zeros</span>(<span class="number">1</span>, d);                <span class="comment">% 种群的历史最佳位置</span></span><br><span class="line">fxm = <span class="built_in">zeros</span>(N, <span class="number">1</span>);               <span class="comment">% 每个个体的历史最佳适应度</span></span><br><span class="line">fym = -<span class="built_in">inf</span>;                      <span class="comment">% 种群历史最佳适应度</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(xm, f(xm), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;初始状态图&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">%% 群体更新</span></span><br><span class="line">iter = <span class="number">1</span>;</span><br><span class="line">record = <span class="built_in">zeros</span>(ger, <span class="number">1</span>);          <span class="comment">% 记录器</span></span><br><span class="line"><span class="keyword">while</span> iter &lt;= ger</span><br><span class="line">     fx = f(x) ; <span class="comment">% 个体当前适应度   </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N      </span><br><span class="line">        <span class="keyword">if</span> fxm(<span class="built_in">i</span>) &lt; fx(<span class="built_in">i</span>)</span><br><span class="line">            fxm(<span class="built_in">i</span>) = fx(<span class="built_in">i</span>);     <span class="comment">% 更新个体历史最佳适应度</span></span><br><span class="line">            xm(<span class="built_in">i</span>,:) = x(<span class="built_in">i</span>,:);   <span class="comment">% 更新个体历史最佳位置</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> fym &lt; <span class="built_in">max</span>(fxm)</span><br><span class="line">        [fym, nmax] = <span class="built_in">max</span>(fxm);   <span class="comment">% 更新群体历史最佳适应度</span></span><br><span class="line">        ym = xm(nmax, :);      <span class="comment">% 更新群体历史最佳位置</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    v = v * w + c1 * <span class="built_in">rand</span> * (xm - x) + c2 * <span class="built_in">rand</span> * (<span class="built_in">repmat</span>(ym, N, <span class="number">1</span>) - x);<span class="comment">% 速度更新</span></span><br><span class="line">    <span class="comment">% 边界速度处理</span></span><br><span class="line">    v(v &gt; vlimit(<span class="number">2</span>)) = vlimit(<span class="number">2</span>);</span><br><span class="line">    v(v &lt; vlimit(<span class="number">1</span>)) = vlimit(<span class="number">1</span>);</span><br><span class="line">    x = x + v;<span class="comment">% 位置更新</span></span><br><span class="line">    <span class="comment">% 边界位置处理</span></span><br><span class="line">    x(x &gt; limit(<span class="number">2</span>)) = limit(<span class="number">2</span>);</span><br><span class="line">    x(x &lt; limit(<span class="number">1</span>)) = limit(<span class="number">1</span>);</span><br><span class="line">    record(iter) = fym;<span class="comment">%最大值记录</span></span><br><span class="line">     x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;状态位置变化&#x27;</span>)</span><br><span class="line">     pause(<span class="number">0.1</span>)</span><br><span class="line">    iter = iter+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);<span class="built_in">plot</span>(record);title(<span class="string">&#x27;收敛过程&#x27;</span>)</span><br><span class="line">x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);<span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;最终状态位置&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最大值：&#x27;</span>,num2str(fym)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;变量取值：&#x27;</span>,num2str(ym)]);</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;启发式算法其实是一种试探法，相对于梯度下降法等类似方法而言，它更体现了随机性；相对于盲目搜索算法而言，它又具有一定的方向性。</p><p><strong>5个基本要素</strong></p><ul><li>随机初始化可行解</li><li>评价函数或目标函数的确定</li><li>新解的产生机制</li><li>新解的接受机制</li><li>终止准则</li></ul><p><strong>本质</strong></p><p>&emsp;&emsp;试探法的本质是并行、随机、有一定方向的搜索方法。综合试探法的要素和本质可以看出，试探法中新解的产生机制和接受机制对于算法的全局收敛能力十分重要，有助于克服局部最优问题。</p><blockquote><p>并行性的体现：</p><ul><li>遗传算法中每代种群具备一定数量</li><li>蚁群算法中蚂蚁的数量</li><li>模拟退火算法中内循环的体现（要求降温过程足够缓慢）</li><li>粒子群算法中粒子的数量</li></ul><p>随机性的体现：</p><ul><li>遗传算法中新解的产生机制（交叉和变异）</li><li>蚁群算法中新解的产生机制（释放信息素）</li><li>模拟退火算法中新解的产生机制</li><li>粒子群算法中新解的产生机制（自身经验和他人信息前面的随机系数r1和r2）</li></ul><p>方向性的体现（逐渐向最优解逼近）：</p><ul><li>遗传算法中新解的接受机制（精英保留策略、轮盘赌）</li><li>蚁群算法中新解的接受机制（新解的产生来自于所有蚂蚁留下信息素的引导）</li><li>模拟退火算法中新解的接受机制（Metropolis准则：绝对接受更优解，以一定概率接受较差的解，且随着温度的降低，接受较差解的概率降低，即开始降温过程搜索空间大，增强全局收敛能力，接近稳定状态，更不易接受较差解，使局部搜索更为精确）</li><li>粒子群算法中新解的产生机制（新解的产生来自于粒子本身最优解和所有粒子最优解的引导）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> “技术” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化问题 </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G网络切片资源分配文献综述</title>
      <link href="/2021/12/26/Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/"/>
      <url>/2021/12/26/Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;随着网络需求的快速持续增长，5G网络需要为传统网络运营商、垂直行业、OTT、第三方满足不同服务质量 (QoS)、服务水平协议 (SLA) 和关键绩效指标 (KPI)的要求，在这种情况下，第四代 (4G) 电信网络的“一刀切”和“一网通”类型不再适用。</p><p>&emsp;&emsp;网络切片是一种很有前途的技术，它可以建立包含专用和共享资源的定制端到端逻辑网络，通过利用 SDN 和 NFV，可以定制与资源相关的网络切片，以满足不同的 QoS 和 SLA。网络切片的资源分配在负载均衡、资源利用率和网络性能方面起着举足轻重的作用。</p><p><strong>主要内容</strong></p><ul><li>SDN 和 NFV 的原理及其对网络切片的影响</li><li>网络切片的基本管理和编排（MO）架构</li><li>RAN和CN切片中的资源类型和相应的隔离级别</li><li>5G 网络切片资源分配算法的原理和数学模型</li><li>提出网络切片的几个开放问题以及潜在的解决方案</li></ul><p><strong>原文</strong></p><p><a href="Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models.pdf" target="_blank">Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models.pdf</a></p><span id="more"></span><h2 id="网络切片"><a href="#网络切片" class="headerlink" title="网络切片"></a>网络切片</h2><p>&emsp;&emsp;作为 5G 中很有前途的技术之一，网络切片在电信网络基础设施上创建了端到端（即从无线电接入网络 (RAN) 到核心网络 (CN)）逻辑上独立的网络。每个逻辑上独立的网络称为网络切片，是为特定需求而设计的，由从底层通信和网络资源中抽象出来的若干网络功能和资源组成。网络切片的基本思想与云计算中的基础设施（即服务 IaaS） 的基本思想密切相关。 IaaS 在不同租户之间共享计算、存储和网络资源，并提供由软件定义网络 (SDN) 和网络功能虚拟化 (NFV) 支持的全功能虚拟网络。事实上，SDN和NFV被认为是5G背景下网络切片的关键技术。 SDN依靠控制平面和数据平面的分离来增强数据转发效率和网络可编程性，NFV 使虚拟网络功能 (VNF) 能够在通用硬件上运行以降低部署成本。网络切片作为多个 VNF 的组合，不仅可以提供灵活、可扩展和可编程的网络服务，还可以通过高效编排和管理 VNF 来降低资本支出 (CAPEX) 和运营支出 (OPEX)</p><p>&emsp;&emsp;作为5G电信网络的一个主要问题，网络切片的资源分配面临隔离、定制、弹性、端到端协调等诸多挑战。具体而言，在资源隔离方面，由于通信环境的变化，网络切片的共享和隔离资源并不简单。例如，无线电资源的严格隔离可能导致低复用增益。定制化实现网络切片的高效资源利用，满足特定的网络服务需求。如何将网络服务需求有效地转化为所需的网络资源，需要在不同层面进行更多的考虑，包括控制层面、数据平面层面、网络层面。例如，在时变数据流量下无法直接获得具有相应计算、存储和网络资源的虚拟机（VM）的确切数量。共享资源的动态分配可能会影响网络切片的网络性能。端到端资源分配必须跨越不同的域，例如 CN、RAN 和传输网络 (TN)。在不同网络层的异构技术之间实现新的协调并不容易。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="SDN-amp-NFV"><a href="#SDN-amp-NFV" class="headerlink" title="SDN &amp; NFV"></a>SDN &amp; NFV</h2><h4 id="software-defined-networking"><a href="#software-defined-networking" class="headerlink" title="software defined networking"></a>software defined networking</h4><p>&emsp;&emsp;在SDN的框架中，控制平面与数据平面完全分离，数据平面移动到一个由SDN控制器（Controller）实现的集中位置。 SDN控制器根据手头应用的需求，在链路探索、拓扑管理、策略部署、流表下发等方面生成不同的规则并发送给数据平面。数据平面中的转发设备，例如交换机和路由器，只需应用并执行这些规则。</p><h4 id="Network-Function-Virtualization"><a href="#Network-Function-Virtualization" class="headerlink" title="Network Function Virtualization"></a>Network Function Virtualization</h4><p>&emsp;&emsp;与传统电信设备中网络功能和专有硬件之间的紧密耦合不同，NFV 使网络功能能够以软件设备的形式在通用服务器上运行。为了在电信网络中高效灵活地利用虚拟资源和管理 VNF，欧洲电信标准协会 (ETSI) 提出了 NFV 管理和编排器 NFV-MANO，它由 NFV 编排 (NFVO)、VNF管理器 (VNFM) 和虚拟化基础设施管理器 (VIM)组成。 NFV-MANO 通过 VNFM 和 VIM 管理 VNF 的生命周期。 NFVO 负责编排与外部运营/业务支持系统 (BSS/OSS) 相结合的网络服务。</p><p>&emsp;&emsp;由于其可编程性、可扩展性和灵活性，SDN 和 NFV 被认为是网络切片的关键推动因素。例如，受SDN启发，演进分组核心（EPC）实现了控制面和用户面的分离，从而实现了网络功能的灵活部署。此外，因为 NFV-MANO 管理 VM 或容器对网络功能的创建、更新和终止，网络切片可以以低成本进行初始化和修改。 NFVO 可以在不同的网络环境中调整 VNF 与 VNFM 和 VIM 的资源分配，例如数据流量的波动、网络切片中用户的变化等。此外，当某些 VNF 发生故障时，SDN 数据平面中的路由器和交换机可以根据 SDN 控制器配置的流表或调度策略重新路由数据流量。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="MO架构"><a href="#MO架构" class="headerlink" title="MO架构"></a>MO架构</h2><p>&emsp;&emsp;Management and Orchestration Architecture of Network Slicing</p><p>&emsp;&emsp;网络切片的基本问题包括网络切片需求的描述和网络切片的部署及其生命周期管理。为了解决这些问题，第三代合作伙伴计划 (3GPP) 提出了具有相应网络功能的基本 MO 架构，包括通信服务管理功能 (CSMF)、网络切片管理功能 (NSMF) 和网络切片子网管理功能 (NSSMF) ，每个子网都有一个 NSSMF，例如：RAN、CN。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226105342.png" alt="image-20211226105335500" style="zoom: 50%;" /><p>&emsp;&emsp;在这种架构下，特定网络服务的需求由CMSF转换为网络切片的需求（即网络切片需求描述），传递给NSMF。然后，NSMF 将网络切片的需求分解为不同子网的需求。不同子网中的 NSSMF 管理和编排相应子网中的网络切片。例如，CN 中的 NSSMF 可以根据从 NSMF 接收到的网络服务的需求，求解出计算、存储和网络资源（即 VM 的资源）相关联的 VNF 的数量。然后，基本的 VNF 由 NFV-MANO 初始化，如图左侧所示。资源分配依赖于带有NFV-MANO的NSSMF，可以根据网络服务的需求计算所需的资源。此外，带有 NFV-MANO 的 NSSMF 可以通过升级或扩展网络功能来动态调整资源分配，这些功能由流量波动或网络切片需求的变化触发。在网络切片的 MO 架构下，隔离级别和数学模型在资源分配中扮演着重要的角色。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Resouce-Type-and-Isolation"><a href="#Resouce-Type-and-Isolation" class="headerlink" title="Resouce Type and Isolation"></a>Resouce Type and Isolation</h2><h4 id="RAN-Slicing"><a href="#RAN-Slicing" class="headerlink" title="RAN Slicing"></a>RAN Slicing</h4><p>&emsp;&emsp;频谱是 RAN 切片的基本无线资源，在长期演进 (4G LTE) 系统中，频谱资源被提取为资源块 (RB) 或物理资源块 (PRB)。具有专用 PRB 的网络切片严格确保所需的 QoS/SLA，而公共媒体访问控制 (MAC) 调度程序可以分配和管理共享 PRB 以适应弹性流量、变化的信道条件和 QoS 要求，从而增强资源弹性和复用增益。除了频谱资源以外，其他基本物理资源还有：包括传输功率和基站（BS）的缓存空间等。</p><p>&emsp;&emsp;基于 PRB 隔离，数据包调度作为一种高级隔离，负责决定使用空闲 PRB 处理数据流量的时间。最高级别的资源隔离是<strong>准入控制</strong>，它通过估计网络资源使用状态来确定是否在用户和 CN（即无线接入承载）之间建立数据传送服务。更一般地，准入控制还包括确定是否允许用户访问网络或是否接受网络切片请求。此外，<strong>用户关联</strong>是RAN切片中资源分配的重要步骤，它决定了用户是否与特定的BS相关联。用户关联发生在数据传输之前和用户准入控制之后。很难为用户关联确定不同的隔离级别，但值得注意的是它在负载平衡、无线电频谱效率和网络效率方面起着关键作用。</p><p>&emsp;&emsp;与传统的RAN架构相比，Cloud-RAN（C-RAN）将基带过程和远程无线接入分离。集中式基带单元 (BBU) 池、分布式多个远程射频头 (RRH)、通过光链路连接 BBU 池和 RRH 的前传网络以及将 BBU 池连接到 CN 的回程网络是 C-RAN的四个基本部分。 BBU池用于基带处理，建立在具有虚拟化技术的高性能通用硬件上，可以运行在虚拟机或容器上，以提高物理资源（如计算、存储、网络资源）的利用率。由于部署成本低，分布式 RRH 通过天线为用户提供无线接入，以低 CAPEX 和 OPEX 覆盖大面积区域。在设计资源分配算法时，BBU 池和具有前传带宽的 RRH 的容量是重要因素。此外，用户关联和回程容量也会影响资源分配。下图左侧总结了与 RAN 切片的资源类型相关的隔离级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226123601.png" alt="image-20211226123601454" style="zoom:67%;" /><h4 id="CN-Slicing"><a href="#CN-Slicing" class="headerlink" title="CN Slicing"></a>CN Slicing</h4><p>&emsp;&emsp;与4G中的EPC相比，5G核心网采用更加模块化的架构，将网络划分为更细粒度的网络功能。每个网络功能都可以以VM或容器的方式部署在虚拟平台上，由SDN和NFV进行管理和编排，提供灵活、可扩展、可编程的网络服务。CN 切片中的高级资源隔离可以是 VM 或容器，这意味着网络运营商利用 VM 或容器粒度的扩展/扩展操作来初始化或调整资源分配。</p><p>&emsp;&emsp;在NFV-MANO的框架下，一个CN切片由多个VNF组成，形成一个运行在底层网络上的虚拟网络。在这种情况下，CN 切片的资源分配被转换为虚拟网络嵌入 (VNE) 问题。VNE 提出了两个问题：将虚拟节点映射到物理节点，将连接虚拟节点的虚拟链路映射到连接物理节点的路径。物理节点和路径代表计算、存储和网络资源。在我们看来，VNE 可用于对 CN 切片以及 C-RAN 切片的某些部分（例如，BBU 容量的虚拟化）中的资源分配问题进行建模。 </p><p>CN 切片中的隔离级别和资源类型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135025.png" alt="CN 切片中的隔离级别和资源类型" style="zoom: 67%;" /><p>无线资源管理、VNE和网络切片的资源分配之间的关系：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135101.png" alt="image-20211226135101482" style="zoom:50%;" /><p>&nbsp;</p><h2 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h2><h4 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h4><p>&emsp;&emsp;很自然地将网络切片的资源分配问题表述为线性规划 (LP) 问题或非线性规划 (NLP) 问题，优化目标包括网络切片的吞吐量、资源利用率、下一次分配的剩余物理资源等。一般的约束是基站的传输功率、基于服务合同的每个网络切片的最小PRB数量、不同网络切片之间的分配公平性等，这些可能会因网络环境的变化和网络切片的多样化需求而变得复杂。因此，一些一般的优化问题很难在<strong>多项式时间</strong>内解决。采用结合多个隔离级别的<strong>启发式方法</strong>来推导出具有低计算复杂性的近乎最优的解决方案。</p><h5 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h5><blockquote><p>Dynamic Network Slicing for Multitenant Heterogeneous Cloud Radio Access Networks</p><p>“ This paper proposes a dynamic network slicing scheme for multitenant H-CRANs, which takes into account tenants’ priority, baseband resources, fronthaul and backhaul capacities, quality of service (QoS) and interference. The framework of the network slicing scheme consists of an upper-level, which manages admission control, user association and baseband resource allocation; and a lower-level, which performs radio resource allocation among users. ”</p></blockquote><p>如前所述，C-RAN 通过 BBU 池集中基带处理能力，BBU 池通过前传网络连接到多个 RRH，并通过回程网络连接到 CN。因此，BBU 池和前传/回传网络的容量作为新的约束，被用于 C-RAN 切片的一般优化问题的框架中。此文中的作者提出了一种分层资源分配方案，以最大化 C-RAN中所有网络切片的网络吞吐量。分层方案包括准入控制、用户关联、虚拟BBU容量分配作为上层分配，以及相应网络切片中每个用户的PRB和传输功率分配作为下层分配。当上层分配的最佳结果用于下层分配时，计算负担和大的信令开销会显着减轻。</p><p>&nbsp;</p><h5 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h5><blockquote><p>A Service-Oriented Deployment Policy of End-to-End  Network  Slicing  Based  on  Complex  Network  Theory</p><p>“  In this paper, a mathematical model is used to construct network slice requests and map them to the infrastructure network. The mapping process consists of two steps: the placement of virtual network functions and the selection of link paths chaining them. To efficiently utilize the limited physical resources, we pay attention to the service-oriented deployment by offering different deployment policies for three typical slices: eMBB slices, mMTC slices, and uRLLC slices. Furthermore, we adopt complex network theory to obtain the topological information of slices and infrastructure network. With the topological information, we define a node importance metric to rank the nodes in node mapping. To evaluate the performance of deployment policy we proposed, extensive simulations have been conducted.  ”</p></blockquote><p>此文中利用通用数学模型探索了端到端网络切片的资源分配。 RAN、传输网络(TN) 和CN 中的资源被抽象为计算和带宽资源。然后，将资源分配问题转化为VNE问题，根据不同的网络切片类型有不同的目标。例如，优化目标是最小化超可靠和低延迟通信 (uRLLC) 网络切片的数据包延迟。在为海量机器类型通信（mMTC）网络切片分配资源时，应最大化当前网络切片部署后剩余的物理链路数量。</p><p>&nbsp;</p><h4 id="博弈论经济模型"><a href="#博弈论经济模型" class="headerlink" title="博弈论经济模型"></a>博弈论经济模型</h4><blockquote><p>价格差异化是一种基于经济和博弈模型的简单方法，它根据不同的网络切片的特点，如流量模型、资源容量、所需资源数量、网络切片优先级等，为不同的网络切片分配不同的价格。一个典型的优化目标是基础设施提供商的收入。</p></blockquote><p>&emsp;&emsp;网络切片为传统网络运营商、垂直行业和第三方提供了新的商业机会。在5G网络切片的场景中，典型的参与者有3个：网络运营商、网络切片的租户、网络切片的用户。网络运营商（例如基础设施提供商）提供包括物理资源和虚拟资源在内的网络基础设施，并建立网络切片以满足网络服务的要求;网络切片的租户（即网络服务提供商）向网络运营商提出网络服务需求，并为用户提供网络服务;用户（例如，用户设备UE）使用网络切片提供的网络服务。与上面讨论的一般模型相比，经济模型和博弈模型提供了复杂而有效的方法来描述这三个参与者之间的关系，可以制定优化问题，例如网络资源分配的公平性、网络的利润最大化。网络切片的运营商或租户，以及网络切片用户的成本最小化。例如，预算、成本、收入、利润和价格等经济因素对这些玩家在游戏过程中的资源分配有显着影响。经济和博弈模型可以在不牺牲资源分配公平性的前提下，为基础设施提供商的收入或利润最大化提供可行的解决方案。</p><h5 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h5><blockquote><p>Optimising 5G infrastructure markets: The business of network slicing</p><p>“ In this paper, we address this issue by designing an algorithm for the admission and allocation of network slices requests that (i) maximises the infrastructure provider’s revenue and (ii) ensures that the service guarantees provided to tenants are satisfied. Our key contributions include: (i) an analytical model for the admissibility region of a network slicing-capable 5G Network, (ii) the analysis of the system (modelled as a Semi-Markov Decision Process) and the optimisation of the infrastructure provider’s revenue, and (iii) the design of an adaptive algorithm <strong>(based on Q-learning)</strong> that achieves close to optimal performance. ”</p></blockquote><p>网络切片根据其流量模型定价不同，包括<strong>弹性</strong>和<strong>非弹性</strong>数据流量模型 。本文进一步推导出弹性网络切片和非弹性网络切片数量之间的关系，该关系在最大接纳非弹性网络切片数量和非弹性网络切片和弹性网络切片的固定总和的限制下。基于关系和价格差异，提出了一种结合半马尔可夫决策过程（SMDP）的价值迭代算法来搜索网络切片请求的最佳准入控制，以最大化基础设施提供商的收入。</p><p>&nbsp;</p><h5 id="example-4"><a href="#example-4" class="headerlink" title="example 4"></a>example 4</h5><blockquote><p>Network Slicing Games: Enabling Customization in Multi-Tenant Mobile Networks</p><p>“ This paper provides an analysis of a well-known model for resource sharing, the share-constrained proportional allocation mechanism, to realize network slicing. This mechanism enables tenants to reap the performance benefits of sharing, while retaining the ability to customize their own users’ allocation. This results in a network slicing game in which each tenant reacts to the user allocations of the other tenants so as to maximize its own utility. We show that, for elastic traffic, the game associated with such strategic behavior converges to a Nash equilibrium. At the Nash equilibrium, a tenant always achieves the same or better performance than that of a static partitioning of resources, thus providing the same level of protection as static partitioning. We further analyze the efficiency and fairness of the resulting allocations, providing tight bounds for the price of anarchy and envy-freeness. Our analysis and extensive simulation results confirm that the mechanism provides a comprehensive practical solution to realize network slicing. Our theoretical results also fills a gap in the analysis of this resource allocation model under strategic players. ”</p></blockquote><p>费雪（Fisher）市场作为一种著名的经济模型，被用来研究用户和网络切片之间的公平性。 Fisher 市场中预算固定的购买者映射成共享网络资源的网络切片租户、买家的出价被映射成网络切片租户的偏好。在 5G 网络切片场景中，网络切片的租户可以根据资源拥塞情况动态调整其偏好，以最大化自身效用。在这种情况下，资源分配问题转化为如何通过<strong>非合作博弈</strong>共同考虑网络切片的偏好和用户公平性来为网络切片分配资源。</p><p>&nbsp;</p><h5 id="example-5"><a href="#example-5" class="headerlink" title="example 5"></a>example 5</h5><blockquote><p>Coalitional Game for the Creation of Efficient Virtual Core Network Slices in 5G Mobile Systems</p><p>“ Our contribution in this paper is twofold. First, we devise an algorithm that derives the optimal number of virtual instances of 4G (MME, SGW, and PGW) or 5G (AMF, SMF, and AUSF) core network elements to meet the requirements of a specific mobile traffic. Second, we propose an algorithm for the placement of these virtual instances over a federated cloud. While the first algorithm is based on mixed integer linear programming, the second is based on coalition formation game, wherein the aim is to build coalitions of cloud networks to host the virtual instances of the vEPC/5G core elements. ”</p></blockquote><p>与预测和分析非合作博弈中每个玩家的行为不同，<strong>合作博弈</strong>调查由单个玩家或外部强制（例如合同规则）形成的玩家之间的联盟。联盟的组成、联盟产生时的联合行动、联盟已经形成时的集体收益是合作博弈的研究兴趣。以CN切片为例。 VNF放置问题在合作博弈的框架下通过两步解决。首先，在同一个云网络中，制定了一个优化问题，旨在通过调整 VNF 的数量来最小化 VNF 的创建成本。然后讨论如何将这些 VNF 放置在不同的云网络中，以保证 QoS/SLA 并最大化每个云网络的利润。事实上，部署了 VNF 的不同云网络可以形成不同的联盟。</p><p>&nbsp;</p><h4 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h4><p>&emsp;&emsp;预测模型用于根据经验知识或历史信息预测适当或最佳的资源数量。预测对象包括:用户到达率、网络切片中的数据流量、网络切片请求等。简单的预测方法直接使用经验数据或一些众所周知的概率模型。</p><h5 id="example-6"><a href="#example-6" class="headerlink" title="example 6"></a>example 6</h5><blockquote><p>Conformal Mapping  for  Optimal  Network  Slice  Planning  Based  on  Canonical   Domains</p><p>“ This paper addresses this issue by mapping the non-uniform distribution of signaling messages in the physical domain to a new uniform environment (i.e., canonical domain) whereby the placement of core functions is more feasible and efficient by means of Schwartz-Christoffel conformal mappings. The experimentation results, compared to some baseline approaches, have proven the efficiency of the conformal mapping based placement in allocating the virtual resources (i.e., virtual CPU and virtual storage) with regard to the optimal end-to-end delay, cost and activated virtual machines. Another interesting contribution is that all placement decisions are based on a realistic spatio-temporal user-centric model, which defines both the mobility of user equipments and the underlying service usage. “</p></blockquote><p>与使用合作博弈的 VNF 放置不同，VNF 的位置由会话请求到达率的<strong>概率分布</strong>决定。假设会话请求的到达率在物理域中遵循非均匀分布，通过 Schwarz-Christoffel 映射将其转换为规范域中的均匀分布。然后根据会话请求的数量和会话请求的到达率，很容易推导出规范域中 VNF 的最佳数量和位置。而VNFs在物理域中的对应位置可以通过逆空间变换函数得到。</p><p>&nbsp;</p><h5 id="example-7"><a href="#example-7" class="headerlink" title="example 7"></a>example 7</h5><blockquote><p>Mobile Traffic Forecasting for Maximizing 5G Network Slicing Resource Utilization</p><p>“ This paper focuses on the design of three key network slicing building blocks responsible for (i) traffic analysis and prediction per network slice, (ii) admission control decisions for network slice requests, and (iii) adaptive correction of the forecasted load based on measured deviations. Our results show very substantial potential gains in terms of system utilization as well as a trade-off between conservative forecasting configurations versus more aggressive ones (higher gains, SLA risk). ”</p></blockquote><p>基于时间序列的预测模型作为回归预测，根据过去的观察以及<strong>时间序列预测</strong>网络切片中的统计特征。与经验知识相比，基于时间序列的预测模型更实用，适用于不同的网络环境。 Holt-Winters (HW) 模型优于基本模型和双指数平滑模型，作为一种复杂的时间序列模型，不仅可以捕捉数据趋势，还可以捕捉数据季节性。在本文中，当用户数量固定时，HW模型用于分析网络切片中未来的流量请求。此外，当用户在多蜂窝环境中移动时，网络切片的流量模型也由 HW 模型预测。值得注意的是，每个被接纳的网络切片都设计了反馈机制，以提高硬件模型的预测精度。</p><p>&nbsp;</p><h5 id="example-8"><a href="#example-8" class="headerlink" title="example 8"></a>example 8</h5><blockquote><p>Information Prediction and Dynamic Programming Based RAN Slicing for Mobile Edge Computing</p><p>“ In this letter, the work is focused on the RAN slicing between MEC services and traditional services. An information prediction and dynamic programming based RAN slicing algorithm is proposed. It guarantees the inter-slice isolation and realizes the intra-slice customization. Furthermore, it can optimize the network utility with high fairness in polynomial time complexity. ”</p></blockquote><p>机器学习根据历史数据和决策生成最优或次优策略，适用于没有统一概率分布的场景。例如，支持向量回归（SVR）作为机器学习中的典型分类算法，用于预测时分双工(FDD)-OFDMA无线网络中网络切片的统计特征值。更具体地说，本文中的作者针对不同的上行/下行配置实现了移动边缘计算（MEC）和传统网络服务的RAN切片的资源分配。该配置被表述为具有网络切片统计特征的封闭式表达式，包括能量开销、运行时开销以及上下行链路的流量和数据速率。MEC 和传统网络服务的最佳配置是从封闭形式的表达式中导出的，其中包含 SVG 预测的统计特征值。</p><p>&nbsp;</p><h4 id="鲁棒性和故障恢复模型"><a href="#鲁棒性和故障恢复模型" class="headerlink" title="鲁棒性和故障恢复模型"></a>鲁棒性和故障恢复模型</h4><p>&emsp;&emsp;网络切片的资源分配算法不仅要提高资源利用效率，还要处理不可预测的网络事件，以实现电信网络的高可用性。不可预知的网络事件包括网络拥塞（由大量数据流量引起）或网络功能故障（由软件或硬件意外故障引起）。冗余资源预留和网络功能重新映射是两种有效的方法。</p><h5 id="example-9"><a href="#example-9" class="headerlink" title="example 9"></a>example 9</h5><blockquote><p>Optimisation  Models  for  Robust  and Survivable Network Slice Design: A Comparative Analysis</p><p>“ In this work, we first outline a mathematical model for the general network slice design problem and extend it to cope with traffic uncertainties. We employ the Γ-robust uncertainty set [1], [2] to model the uncertainties in the traffic demands. Furthermore, we add survivability aspects to our model by protecting the network slice against single substrate network element (node/link) failures. Finally, both survivability and traffic robustness approaches are considered simultaneously and we present two different optimisation models. A performance evaluation is carried out comparing the different robust and survivable models with their non-robust non-survivable counterpart using network topology examples from SNDlib. ”</p></blockquote><p>冗余资源预留为网络切片提供额外资源，例如多个 VNF 实例，以避免网络功能故障。网络切片的不确定流量由机会约束模型 [14] 表示为对称和随机变量。该变量作为保护级别，分别加入到虚拟节点和虚拟链路的容量约束中，以保证网络切片的鲁棒性。网络功能的重新映射通过将失败的 VNF 映射到好的 VNF 并重新路由失败的虚拟链接来恢复网络服务。</p><p>&nbsp;</p><h5 id="example-10"><a href="#example-10" class="headerlink" title="example 10"></a>example 10</h5><blockquote><p>Protocol Function Block Mapping of Software Defined Protocol for 5G Mobile Networks</p><p>“ In this paper, we propose software-defined protocol (SDP) technique to facilitate flexible service-oriented protocol stack deployment for providing high-throughput, low-latency and elastic mobile services based on platform virtualization and functionality modularization. We first elaborate the principle of SDP and then address one of the most important issues in SDP, namely SDP request mapping (SDPM), where an SDP request is fulfilled by mapping a set of required SDP function blocks and virtual links onto underlying SDP servers. We formulate the SDPM problem as a mixed integer programming (MIP). To address the NP-hardness and scalability of SDPM problem, we propose a decomposition algorithm which breaks down the SDPM problem into inter-block link and block mapping problems to accomplish the upper bound (UB) and lower bound (LB) of the MIP solution, respectively. The optimality can be achieved when the UB and the LB converges by using iterations. We employ LTE Layer-2 data-plane processing as a benchmark for validating the effectiveness of the SDP technique and evaluate the performance of SDPM algorithm. Numerical results show that SDP is effective to provide elastic low-latency mobile services and the proposed SDPM algorithm significantly outperforms the benchmark in stack processing delay, mapping cost, and resource utilization. “</p></blockquote><p>优化目标是在重新映射期间最小化总带宽消耗。</p><p>&nbsp;</p><h3 id="4种模型对比"><a href="#4种模型对比" class="headerlink" title="4种模型对比"></a>4种模型对比</h3><p>图中说明了四种数学模型之间的关系，每个饼图中每种方法的比例代表了相应的研究潜力：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161345.png" alt="image-20211226161345382" style="zoom: 33%;" /><p>表中根据目标、资源类型、场景和关键描述总结了所讨论的算法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161507.png" alt="image-20211226161507843" style="zoom:50%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="网络切片潜力研究方向"><a href="#网络切片潜力研究方向" class="headerlink" title="网络切片潜力研究方向"></a>网络切片潜力研究方向</h3><h4 id="资源分配的更新周期"><a href="#资源分配的更新周期" class="headerlink" title="资源分配的更新周期"></a>资源分配的更新周期</h4><p>&emsp;&emsp;为了尽可能降低资源分配算法的计算复杂度，前面提出了启发式方法以提供具有低计算复杂度的次优解决方案。而<strong>多级资源分配</strong>则是另一种方式，包括准入控制、用户关联等。然而，很少有研究报告或出版物讨论资源分配算法的更新周期。合适的更新间隔不仅可以提高资源利用率，还可以减少信令开销和计算负担。在example1中，作者指出分配PRB的周期不能短于信道条件报告的周期。较长的更新周期在慢变通道中是可行的解决方案，但在快变通道中可能无法实现高性能。此外，在设计资源分配更新周期时，可以综合考虑用户数量的变化、数据流量的波动以及网络功能故障的平均周期。</p><p>&nbsp;</p><h4 id="无线电接入技术-RATs-的异质性"><a href="#无线电接入技术-RATs-的异质性" class="headerlink" title="无线电接入技术 (RATs) 的异质性"></a>无线电接入技术 (RATs) 的异质性</h4><p>&emsp;&emsp;5G 预计将跨越和聚合多种异构 RAT，例如 3G、4G、LTE 和 WiFi。 5G网络切片中不同RAT的协作变得尤为重要，应满足网络切片的多样化需求。例如，车联网 (V2X) 网络切片中的车载信息娱乐应用依赖 LTE 和 WiFi 来提高网络吞吐量。在 mMTC 网络切片上运行的窄带物联网 (NB-IoT) 应用可能需要多种 RAT 来增强网络连接。当前的算法侧重于密集的异构无线网络，并研究宏蜂窝和小蜂窝之间的合作，对于不同的网络切片，可以在无缝切换、流量隔离和网络切片公平性等方面进一步研究多制式的资源分配，以增强用户体验，提高资源利用率。</p><p>&nbsp;</p><h4 id="端到端网络切片的资源分配"><a href="#端到端网络切片的资源分配" class="headerlink" title="端到端网络切片的资源分配"></a>端到端网络切片的资源分配</h4><p>&emsp;&emsp;大多数当前的资源分配算法都集中在单个子网，例如 RAN 或 CN。除了example2中的解决方案，很少有研究人员考虑端到端的网络切片。无线电和虚拟机的资源分别抽象为带宽和计算资源，在为特定的网络切片类型设计资源分配方案时只考虑其中之一。事实上，SLA 分解和多子网协调是端到端网络切片资源分配的主要挑战。由于缺乏基本的通信知识，网络切片的租户可能只向 NSMF 提供端到端的 SLA，而不需要每个子网。因此，如何将端到端的 SLA 分解为各个子网的需求是资源分配的必然步骤。SLA分解不仅要考虑端到端的容量，还要考虑每个子网的容量。多个子网之间的协调也很重要，尤其是在更新资源分配时。每个子网应定期通过 NSSMF 向 NSMF 报告其剩余容量，NSMF 可以实现资源分配的适当调整，以适应不断变化的网络环境。例如，如果某些子网过载，则应向 NSMF 报告，然后允许剩余的子网获得更多资源以保证所需的端到端 SLA。潜在的数学模型应该基于多运营商核心网（MOCN）和网关核心网（GWCN）精心设计，这是不同子网之间资源共享的两种基本架构。</p>]]></content>
      
      
      <categories>
          
          <category> “论文阅读” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每月歌单</title>
      <link href="/2021/12/09/test/"/>
      <url>/2021/12/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分享每月歌单</p><span id="more"></span><h5 id="2021-12"><a href="#2021-12" class="headerlink" title="2021-12"></a>2021-12</h5><p># 歌曲模板</p>    <div id="aplayer-RBPOAhiN" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p># 歌单模板</p>    <div id="aplayer-kgDCKsVO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div>]]></content>
      
      
      <categories>
          
          <category> “日常小记” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于令牌桶算法的LTE下行链路调度器设计</title>
      <link href="/2021/12/03/DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/"/>
      <url>/2021/12/03/DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;LTE网络支持共享无线接入和核心网络资源的不同类型的服务，包括：尽力而为、延迟敏感和实时（RT）服务。每种服务在比特率、延迟和分组丢失方面都有不同的QoS要求。</p><p>&emsp;&emsp;基站eNB的第一个目标是为UE提供高频谱效率，使更多的活跃用户可以在网络中接收服务。第二个目标是用户对接收的服务质量（QoS）的满意度。为了实现这些目标，eNB中的资源分配必须知道信道条件、UE请求的服务类型和其他参数。</p><p>&emsp;&emsp;eNB将一个小区中的可用无线电资源分配给活动用户（Active UE）。因此需要设计合适的调度算法来支持具有不同QoS要求的业务，尤其是RT业务。</p><p><strong>原文</strong></p><p><a href="A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems.pdf" target="_blank">A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems</a></p><span id="more"></span><h3 id="现有调度算法研究"><a href="#现有调度算法研究" class="headerlink" title="现有调度算法研究"></a>现有调度算法研究</h3><ol><li><p>LTE下行链路中指数/比例公平（EXP/PF）和改进的最大加权延迟优先（M-LDWF）</p><p>都只在一个域中执行调度过程</p><p>带宽为5MHz的系统中，M-LDWF比EXP/PF提供了更多的吞吐量，但是EXP/PF满足了更多用户的QoS要求（RT用户所需的带宽因素所导致）</p><p>建议在低负载网络中使用M-LDWF，在网络负载增加时使用EXP/PF[2]</p></li><li><p>利用CQI反馈发送来自用户的空闲缓冲区值的报告以及实时和非实时服务的QoS需求，比PF具有更高的吞吐量，并且降低了丢包概率。[3]</p></li><li><p>VOIP流量调度的一些算法满足了该服务的QoS要求，并防止了由于优先考虑网络中的VOIP服务引起的不良影响。它通过分组丢弃来调整给予VOIP的优先级的持续时间。[4]</p></li><li><p>有的算法使用了时域和频域两级调度器，在用户之间保证了公平性，时域（TD）调度器提供用户所需的QoS参数，而频域（FD）调度器根据TD调度器给定的输入实现最高的频谱效率。[8]</p><p>该论文的另一个结论是，TD-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></li><li><p>另一个算法也是时域和频域两级调度器，在时域中使用PF算法来实现用户之间的公平性，而在FD中比较不同的算法。结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。[9]</p></li><li><p>还有一个算法也是时域和频域两级调度器，将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。[12]</p></li></ol><p>&emsp;&emsp;在之前的工作中，与GBR相关的流量通常在eNB中处理的优先级最高。虽然保障了GBR业务的时延性能，但是会导致小区的整体性能降低。</p><p>&emsp;&emsp;本论文提出了一种QoS感知的调度方法，包含时域和频域。先使用经典的五元组将不同的流映射到不同的载波。将VOIP和video流量分为GBR类、FTP和HTTP分为nGBR类。在GBR类中利用令牌桶算法来阻止其使用所有资源。这种不仅保证了两个类间资源分配的公平性，还提高了系统的总吞吐量。</p><p>&nbsp;</p><h3 id="LTE下行链路调度器"><a href="#LTE下行链路调度器" class="headerlink" title="LTE下行链路调度器"></a>LTE下行链路调度器</h3><p>&emsp;&emsp;正交频分多址（OFDMA）将分布在整个频谱中的一组子载波专用于用户。带宽被划分为180kHz的子信道，包括12个连续的子载波。时间/频率无线电资源扩展到时域中的两个时隙和频域中的一个子信道上，称为资源块（RB），是LTE中用于资源分配的最小单元。RBs的数量取决于系统带宽，例如，对于5 MHz系统，RBs数量为25，而在10 MHz系统中，RBs数量为50。</p><p>&emsp;&emsp;eNB使用信道状态信息获取每个用户链路上的信息。用户在每个TTI中向eNB报告其下行链路流状态。数据包优先级由eNB的调度器根据数据包延迟、下行链路状态、缓冲区状态、流量类型等参数确定。而特定数据包流的专用RB数量取决于调度器中使用的资源分配算法。以前大多数工作中的数据包调度器有两个阶段。先是时域调度器基于调度算法（自行设计）的输入参数选出请求服务的用户，然后频域调度器按照算法（自行设计）将资源分配给时域中选择出的用户。分组调度器使用CQI获取所有rb中的每个信道的质量信息。</p><p>&nbsp;</p><h3 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h3><h5 id="业务分类"><a href="#业务分类" class="headerlink" title="业务分类"></a>业务分类</h5><p>&emsp;&emsp;VOIP、Conversational Video 归为 GBR业务</p><p>&emsp;&emsp;FTP、HTTP 归为 nGBR业务</p><h5 id="时域调度"><a href="#时域调度" class="headerlink" title="时域调度"></a>时域调度</h5><p>&emsp;&emsp;TD调度器最重要的功能是根据QoS参数和信道的当前状态选择请求资源的活动用户（Activate UE）。</p><p>&emsp;&emsp;在没有资源分配给用户的第一阶段，TD调度器确定不同类别的活动Bearer（activate bearers），并根据不同的需求对它们进行优先级排序。由于TD调度器没有关于分配给每个用户的RBs的信息，因此利用所有RBs上的用户cqi的平均值来比较用户的信道条件，获取最大度量值的用户具有最高优先级。TD调度器创建用户和活动Bearer，分为GBR组和nGBR组并按优先级排序，并向FD调度器发送这两个单独的列表。</p><h6 id="GBR"><a href="#GBR" class="headerlink" title="GBR"></a>GBR</h6><p>&emsp;&emsp;GBR Bearer必须保证数据速率，与对延迟敏感的应用相关。本算法中GBR Bearer的QoS参数计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080439.png" alt="image-20211201173407839" style="zoom:50%;" /><p>&emsp;&emsp;注意，在eNB缓冲区中花费更多时间的数据包具有更高的服务交付优先级。</p><h6 id="nGBR"><a href="#nGBR" class="headerlink" title="nGBR"></a>nGBR</h6><p>&emsp;&emsp;nGBR Bearer通常包括尽力而为的服务，对延迟不敏感。nGBR类的不同活动Bearer根据不同的条件进行优先级排序。优先级排序使用nGBR的优先级因子完成，其行为类似于WPF算法，做了一些轻微的修改。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184317.png" alt="image-20211201184317270" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184346.png" alt="image-20211201184346056" style="zoom:50%;" /><p>&emsp;&emsp;参数 r 较大的nGBR用户在资源分配中优先于其他用户。</p><p>&nbsp;</p><h5 id="频域调度"><a href="#频域调度" class="headerlink" title="频域调度"></a>频域调度</h5><p>&emsp;&emsp;FD调度器负责将RBs分配给不同的持有人。FD调度器根据TD调度器发来的候选列表来确定在特定TTI中必须服务哪些Bearer。FD调度器优先服务于GBR Bearer，然后服务于nGBR Bearer。通过令牌桶算法确定允许分配资源的GBR Bearer，然后使用改进的LWDF、M-LWDFS对这些Bearer进行调度。<strong>（这里与流程图不符，流程图是PF算法调度）</strong></p><p>&emsp;&emsp;当GBR流量或相关令牌分配完后，FD调度器开始将资源分配给nGBR用户。采用了PF算法，在用户公平性和小区整体性能之间取得了较好的平衡。该算法计算用户信道的当前状态和先前接收的服务但是却不考虑QoS，因此PF适合非RT流量而不适合RT流量。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201185426.png" alt="image-20211201185425952" style="zoom:50%;" /><p>&emsp;&emsp;FD完整流程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201191306.png" alt="image-20211201191306507" style="zoom:50%;" /><p>&nbsp;</p><h3 id="仿真比较结果"><a href="#仿真比较结果" class="headerlink" title="仿真比较结果"></a>仿真比较结果</h3><p>&emsp;&emsp;为了研究提出的调度器在RT流量情况下对资源分配系统的影响，文章还模拟了TD-PF/FD-PF算法以及无令牌桶的情况。TD-PF/FD-PF算法虽然依据信道状态和服务质量，但是却并不考虑QoS，因此在RT流量业务的表现不佳。无令牌桶调度虽然考虑了QoS性能，但是由于GBR Bearer的优先级高于nGBR Bearer的优先级，而没有令牌桶对流量进行限制，因此当BGR业务需求较高时，nBGR业务无法顾及导致小区整体吞吐量降低。含令牌桶的调度是二者的折中，即维护了小区整体的吞吐量，又对RT流量业务的时延性能有所保证。</p><h6 id="三种业务情景"><a href="#三种业务情景" class="headerlink" title="三种业务情景"></a>三种业务情景</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192306.png" alt="image-20211201192305975" style="zoom:50%;" /><h6 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080440.png" alt="image-20211201192342289" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192359.png" alt="image-20211201192359425" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192413.png" alt="image-20211201192413873" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192430.png" alt="image-20211201192430785" style="zoom:50%;" /><p>&nbsp;</p><h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>&emsp;&emsp;其实这个令牌桶算法没有什么精巧的地方，无非是限制了对GBR业务资源分配，这样就能发论文，虽然是很多年前的了，但是一下让我觉得发论文也不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> “论文阅读” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab音频滤波</title>
      <link href="/2021/12/02/Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/02/Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Matlab-音频信号处理"><a href="#Matlab-音频信号处理" class="headerlink" title="Matlab 音频信号处理"></a>Matlab 音频信号处理</h2><p>&emsp;&emsp;现有原始音频文件<code>SunshineSquare.wav</code>，后半段音频被人为加上了多频段的噪音，使用matlab工具对其进行分析并消除噪音还原出无噪音频文件。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><span id="more"></span><h3 id="Step1：分析原始音频文件"><a href="#Step1：分析原始音频文件" class="headerlink" title="Step1：分析原始音频文件"></a>Step1：分析原始音频文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[audio_data, fs] = audioread(<span class="string">&#x27;../../SunshineSquare.wav&#x27;</span>);</span><br><span class="line">L = <span class="built_in">length</span>(audio_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一听该音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br></pre></td></tr></table></figure><h4 id="绘制时域图"><a href="#绘制时域图" class="headerlink" title="绘制时域图"></a>绘制时域图</h4><p>&emsp;&emsp;从下面时域图中可以看出，源音频文件时长11秒左右，从第8秒左右开始为一段强噪声。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Original&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = (<span class="number">1</span> : L) * <span class="number">1</span>/fs;</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="built_in">plot</span>(tt, audio_data);grid;</span><br><span class="line">title(<span class="string">&#x27;Time Domain&#x27;</span>);xlabel(<span class="string">&#x27;时间（s）&#x27;</span>);ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><h4 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h4><p>&emsp;&emsp;使用快速傅里叶变换FFT对时域信号进行频谱分析，绘制的频域图反映出有四段噪声频段，后续消除噪声工作就是对这四个频段进行滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="number">2</span>^<span class="built_in">nextpow2</span>(L); <span class="comment">% 先从原始信号长度确定下一个 2 次幂的新长度,用尾随零填充信号以改善 fft 的性能</span></span><br><span class="line">Spectrum = fft(audio_data,L); <span class="comment">% 快速傅里叶变换，转换为频域</span></span><br><span class="line">f_x = fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L; <span class="comment">% 定义频域，即变换横坐标量纲为频率</span></span><br><span class="line">mag_FFT_audio_data = <span class="built_in">abs</span>(Spectrum / L); <span class="comment">% 取幅值，并归一化</span></span><br><span class="line">ang_FFT_audio_data = <span class="built_in">angle</span>(Spectrum)*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="built_in">plot</span>(f_x,mag_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="built_in">plot</span>(f_x,ang_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;ang&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143455.png" alt="image-20211128143455368"></p><h4 id="绘制声谱图"><a href="#绘制声谱图" class="headerlink" title="绘制声谱图"></a>绘制声谱图</h4><p>&emsp;&emsp;声谱图能够以颜色反映各频段信号强度随时间的变化和分布情况，如图所示，从第8秒左右开始有4个频段的强度持续较高，这就是上面频域分析出的4个噪声频段。但需要注意到，在噪声的开始和结束时刻，所有频段的强度都很高，在图中显示为两条垂直的黄线，这两条线仅靠滤波无法消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">spectrogram(audio_data,hann(<span class="number">256</span>),<span class="number">250</span>,<span class="number">256</span>,fs,<span class="string">&#x27;yaxis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143558.png" alt="image-20211128143558882"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step2：滤波"><a href="#Step2：滤波" class="headerlink" title="Step2：滤波"></a>Step2：滤波</h3><h4 id="滤波法1——手动衰减"><a href="#滤波法1——手动衰减" class="headerlink" title="滤波法1——手动衰减"></a>滤波法1——手动衰减</h4><p>&emsp;&emsp;手动衰减各个噪声频段的幅度，注意FFT变换后的频谱图为偶对称，所以共有4对（8个）频段，逐一消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第一个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第二个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第三个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第四个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第五个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第六个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第七个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第八个噪声频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆fft获得处理后的音频</span></span><br><span class="line">ifft_data = <span class="built_in">real</span>(ifft(Spectrum, L));</span><br><span class="line">audio_data = ifft_data(<span class="number">1</span>:<span class="built_in">length</span>(audio_data));</span><br></pre></td></tr></table></figure><h5 id="滤波效果"><a href="#滤波效果" class="headerlink" title="滤波效果"></a>滤波效果</h5><p>&emsp;&emsp;绘制滤波后音频信号的时域图、频域图、声谱图，可看见时域图上噪声被消除，频谱图上4个频段的信号全部被消除，声谱图有四条水平的消磨痕迹。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211130213111.png" alt="image-20211130213111056"></p><p>&nbsp;</p><h4 id="滤波法2——数字滤波器"><a href="#滤波法2——数字滤波器" class="headerlink" title="滤波法2——数字滤波器"></a>滤波法2——数字滤波器</h4><p>&emsp;&emsp;设计梳状滤波器，因为有4个噪声频段，所以设计4个带阻滤波器逐一滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%h1[n] = [1,-2,1];</span></span><br><span class="line">h1 = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>];</span><br><span class="line">h2 = [<span class="number">1</span>,<span class="number">-1.24698</span>,<span class="number">1</span>];</span><br><span class="line">h3 = [<span class="number">1</span>,<span class="number">0.44504</span>,<span class="number">1</span>];</span><br><span class="line">h4 = [<span class="number">1</span>,<span class="number">1.80194</span>,<span class="number">1</span>];</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波过程</span></span><br><span class="line">audio_data_h1 = filter(h1,a,audio_data);</span><br><span class="line">audio_data_h2 = filter(h2,a,audio_data_h1);</span><br><span class="line">audio_data_h3 = filter(h3,a,audio_data_h2);</span><br><span class="line">audio_data_h4 = filter(h4,a,audio_data_h3);</span><br><span class="line"></span><br><span class="line">audio_data = audio_data_h4;</span><br></pre></td></tr></table></figure><h6 id="滤波器分析"><a href="#滤波器分析" class="headerlink" title="滤波器分析"></a>滤波器分析</h6><p>&emsp;&emsp;绘制4个滤波器的幅频、相频、衰减及每次滤波后的信号时域图。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145815.png" alt="image-20211128145815600" style="zoom: 25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145835.png" alt="image-20211128145835590" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128153455.png" alt="image-20211128145856791" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145920.png" alt="image-20211128145920683" style="zoom:25%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step3：后续处理"><a href="#Step3：后续处理" class="headerlink" title="Step3：后续处理"></a>Step3：后续处理</h3><p>&emsp;&emsp;上面已分析，在噪声开始和结束时刻都有全频段的高强度信号，不是滤波能消除的，这里采用时域衰减，即在时域采用同第一种滤波方法相同的思想，手动衰减这两个时刻的信号强度。随后输出处理过的音频文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第一个高音时段</span></span><br><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第二个高音频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一下处理后的音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出音频文件</span></span><br><span class="line">audiowrite(<span class="string">&#x27;SunshineSquare_Processed.wav&#x27;</span>,audio_data,fs); </span><br></pre></td></tr></table></figure><p>使用滤波法2的最终输出信号的分析如下：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128150059.png" alt="image-20211128150059309"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="对数字信号处理的认识"><a href="#对数字信号处理的认识" class="headerlink" title="对数字信号处理的认识"></a>对数字信号处理的认识</h2><p>&emsp;&emsp;《数字信号处理》这门课我觉得其实是两大主题，第一是信号分析，第二是信号处理。</p><p>&emsp;&emsp;信号分析在《信号与线性系统》中有所讲解，但是那时所研究的是连续时间信号的傅里叶级数或傅里叶变换，离散时间信号的傅里叶变换，它们的特点都是：信号无限长，导致计算机无法处理。而为了使用计算机工具帮助对信号进行分析，《数字信号处理》这门课引入了采样、增/减采样和离散傅里叶变换DFT的概念。后续考虑到DFT算法的时间复杂度太高，因此又提出快速傅里叶变换FFT来代替之。</p><p>&emsp;&emsp;信号处理在这门课中主要指滤波。低通、高通、带通、带阻、全通，《信号与线性系统》中共提出过五种模拟滤波器，如何根据所需指标将其转化为对应的数字滤波器来在计算机上使用，是这门课的第二个重点。</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>&emsp;&emsp;模拟信号经过采样、抽取（减采样）后成为计算机可以处理的有限长离散信号。采样后，仍是连续时间信号，但频域上是原始模拟信号频域的周期延拓和幅度放缩。抽取后，变为有限长离散信号，频域点数和时域相同，但横坐标频率被按比例压缩在 0~2pi 范围内，幅值和采样后的一样。</p><h5 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h5><p>&emsp;&emsp;在傅里叶变换中，离散/连续 和 周期/非周期 相对偶，离散周期序列的傅里叶变换仍是离散周期序列。因为计算机容量有限，其处理的信号长度有限，因此从离散周期信号中取一个周期来代替整个信号分析是一种行之有效的方法。DFT也正是在这种思想下被引出，重点在于循环卷积、旋转因子、各种变换性质。</p><p>&emsp;&emsp;但是，用定义计算DFT的时间复杂度太高，计算机效率低。借助公式中“旋转因子”的周期性，长序列的DFT可以不断分解至一组组两点DFT的组合，大大减少了计算量，这就是FFT算法。</p><h5 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h5><p>&emsp;&emsp;数字滤波器有很多值得关注的地方，首先是截止频率、纹波幅度等性能指标，然后是幅频特性、相频特性，还有系统函数的极零点、信号流图等。根据冲激响应长度可分为有限脉冲响应滤波器FIR和无限脉冲响应滤波器IIR。从模拟滤波器转换为数字滤波器的方法有冲激响应不变法、双线性变换法。常用的滤波器有巴特沃斯滤波器、切比雪夫滤波器、椭圆滤波器等。</p>]]></content>
      
      
      <categories>
          
          <category> “技术分享” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大二一年</title>
      <link href="/2021/12/02/%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/"/>
      <url>/2021/12/02/%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在华科度过了两年时间里，我看过东九楼前路边的银杏一夜间被北风吹去满树黄叶，也曾在凌晨五点的晨雾中从百景园自习区一路徒步走回韵苑。回想大一大二的时光，涌上我心头的并不是特别的成就感，亦不是其他大喜大悲，而是平淡与坦然。如果要用一句话概括这一年，我想用大物老师曾提到过的——看山不是山。</p><span id="more"></span><p>&emsp;&emsp;现在看来，大一一年里我只做了两件对现在仍有影响的事，一是熟悉了大学的学习方式，把加权拉得很高；二是认识到，每天都在自习室度过，这样和高中没太大区别，我不喜欢只是这样的大学生活。大二开学那阵，我因为加权高并且也有一些课外的成绩所以拿到了国奖，有些自傲，那是心里总觉得大学生活怎么和高中没什么区别呀，无非是可以用iPad记笔记、带手机上课罢了。禅宗里描述有三种境界，“看山是山，看山不是山，看山还是山。”第一次听到这句话是在大物老师的课上，我发觉自己对华科这所学校和大学本身的认识也只是在“看山是山”的层面上，我还没有发现它真正的精彩。</p><p>&emsp;&emsp;大一下学期因为疫情所以一学期都在家，期间不能出门，所以从高中坚持到大学的夜跑习惯也丢掉了，但是也恰好喜欢上了室内健身，大二来到学校后，在一位朋友的影响下去了一学期的健身房，每周会有三四天专门去锻炼。一整天没课时会和这位朋友专门去主图自习，中午步行穿过青年园到百景园或西边小吃城用餐，吃完回来会在图书馆外草地边讨论一些很有意思的话题，时间似乎都变得慢了下来。大一的每天是做不完的事情，时间匆匆流过，却总觉得自己什么都没做，而大二上就这样以一种比较悠闲的节奏度过，虽然加权没有大一时那么高，但那相差的那几点几分换来了我对大学、对自己的另一种认识。</p><p>&emsp;&emsp;大二上的国奖答辩期间认识了不少优秀的同学，寒假我和其中两位同学组队参加了美赛，比赛期间我们异地合作，每天都连麦从天还没亮肝到晚上凌晨，最后一晚通宵修改论文，没有人是在划水摸鱼。对比其他许多队伍我发现，能够遇到值得信任的靠谱队友是多么重要。我们虽然都是第一次接触数模，但是扎实的功底和高效的合作帮助我们出乎意料地最终取得了特等奖提名，其实奖项只是次要的，弥足珍贵的是经历和友谊。</p><p>&emsp;&emsp;大二下在两位队友的建议下，我加入了电信学院大名鼎鼎的科创团队——Dian团队。其实大一就知道Dian团队，但是当时一心只读圣贤书，两耳不闻东九窗外事，没有想过加入这样的团队，算是一个小小的遗憾。不过悟已往之不谏，知来者之可追，加入团队的半年里认识了许多优秀的同学，也学到了好玩并实用的项目知识和技能。在智慧交通项目组我接触到了计算机视觉与实际应用的结合，我们组与萍乡市警方合作设计了用于重点车辆检测的软件，申请到了国家版权局的软件著作权。虽然到了大二下期末，我的总成绩从半年前刚分完专业时的专业第一掉到了第二，学年成绩更是滑落不少，但想象中的懊悔与失落并没有如期而至，倒不如说是现在的我看开了，有些东西和成绩一样重要。</p><p>&emsp;&emsp;代表大二学年尾声的暑假对我而言也是一段不平凡的记忆。七月基本上是在团队中度过的，原本AI组的项目已经结题了，我转到团队与Intel亚太研发有限公司合作的项目中，一直在补习无线通信方面的知识。七月末我本着走入社会、感悟基层的初衷，又一次参与到了暑期社会实践当中，我们到河南洛阳的一家养老院展开调研，却碰上了百年难得一遇的暴雨，火车高铁停运，我也被困回不到郑州的家或学校。后续终于返校，但是因为河南疫情爆发，我被学校组织隔离了28天。被放出来后的第一件事就是去当疫苗接种志愿者，毕竟自己是一名预备党员，只是可惜没能给涝疫同至的家乡献一份力。</p><p>&emsp;&emsp;最后一个比较有意义的事就是去火车站迎新了，以前高中课上老师激励我们说，每年开学期间各个城市的大学都会在火车站设迎新点，越是有名的大学迎新点也越大。虽然最后一句在我当时来到武汉站看见华科的迎新点后就不信了，但是它带给我的归属感却一直萦绕在我心头，所以今年我也要把这种关怀传承下去。</p><p>&emsp;&emsp;其实大二这一年还经历过好多事情，我心里明白自己和一年前不一样了。再一次走向国奖答辩的讲台，我已不再是一年前那患得患失、喜忧参半的心态。既然我的成绩支持我站在这里，那么我所走过的路、感悟到的事情足够让我自信地向台下展示出自己。因为没有刻意把国奖当作目标，也不需要用它来证明什么，毕竟身边有许多同样如此的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> “心得感悟” </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Love actually is all around</title>
      <link href="/2021/12/01/hello-world/"/>
      <url>/2021/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hello World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
