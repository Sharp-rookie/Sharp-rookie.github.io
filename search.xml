<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/12/09/test/"/>
      <url>/2021/12/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>插入歌曲</p><p># 歌曲模板</p>    <div id="aplayer-xaehvkPm" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p># 歌单模板</p>    <div id="aplayer-MYxxtDyi" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p>插入视频</p><p>直接外用链接</p><iframe src="//player.bilibili.com/player.html?aid=74371709&cid=127218978&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>使用hexo-tag-dplayer</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"https://什么什么什么.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于令牌桶算法的LTE下行链路调度器设计</title>
      <link href="/2021/12/03/DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/"/>
      <url>/2021/12/03/DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;LTE网络支持共享无线接入和核心网络资源的不同类型的服务，包括：尽力而为、延迟敏感和实时（RT）服务。每种服务在比特率、延迟和分组丢失方面都有不同的QoS要求。</p><p>&emsp;&emsp;基站eNB的第一个目标是为UE提供高频谱效率，使更多的活跃用户可以在网络中接收服务。第二个目标是用户对接收的服务质量（QoS）的满意度。为了实现这些目标，eNB中的资源分配必须知道信道条件、UE请求的服务类型和其他参数。</p><p>&emsp;&emsp;eNB将一个小区中的可用无线电资源分配给活动用户（Active UE）。因此需要设计合适的调度算法来支持具有不同QoS要求的业务，尤其是RT业务。</p><p>&nbsp;</p><span id="more"></span><h3 id="现有调度算法研究"><a href="#现有调度算法研究" class="headerlink" title="现有调度算法研究"></a>现有调度算法研究</h3><ol><li><p>LTE下行链路中指数/比例公平（EXP/PF）和改进的最大加权延迟优先（M-LDWF）</p><p>都只在一个域中执行调度过程</p><p>带宽为5MHz的系统中，M-LDWF比EXP/PF提供了更多的吞吐量，但是EXP/PF满足了更多用户的QoS要求（RT用户所需的带宽因素所导致）</p><p>建议在低负载网络中使用M-LDWF，在网络负载增加时使用EXP/PF[2]</p></li><li><p>利用CQI反馈发送来自用户的空闲缓冲区值的报告以及实时和非实时服务的QoS需求，比PF具有更高的吞吐量，并且降低了丢包概率。[3]</p></li><li><p>VOIP流量调度的一些算法满足了该服务的QoS要求，并防止了由于优先考虑网络中的VOIP服务引起的不良影响。它通过分组丢弃来调整给予VOIP的优先级的持续时间。[4]</p></li><li><p>有的算法使用了时域和频域两级调度器，在用户之间保证了公平性，时域（TD）调度器提供用户所需的QoS参数，而频域（FD）调度器根据TD调度器给定的输入实现最高的频谱效率。[8]</p><p>该论文的另一个结论是，TD-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></li><li><p>另一个算法也是时域和频域两级调度器，在时域中使用PF算法来实现用户之间的公平性，而在FD中比较不同的算法。结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。[9]</p></li><li><p>还有一个算法也是时域和频域两级调度器，将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。[12]</p></li></ol><p>&emsp;&emsp;在之前的工作中，与GBR相关的流量通常在eNB中处理的优先级最高。虽然保障了GBR业务的时延性能，但是会导致小区的整体性能降低。</p><p>&emsp;&emsp;本论文提出了一种QoS感知的调度方法，包含时域和频域。先使用经典的五元组将不同的流映射到不同的载波。将VOIP和video流量分为GBR类、FTP和HTTP分为nGBR类。在GBR类中利用令牌桶算法来阻止其使用所有资源。这种不仅保证了两个类间资源分配的公平性，还提高了系统的总吞吐量。</p><p>&nbsp;</p><h3 id="LTE下行链路调度器"><a href="#LTE下行链路调度器" class="headerlink" title="LTE下行链路调度器"></a>LTE下行链路调度器</h3><p>&emsp;&emsp;正交频分多址（OFDMA）将分布在整个频谱中的一组子载波专用于用户。带宽被划分为180kHz的子信道，包括12个连续的子载波。时间/频率无线电资源扩展到时域中的两个时隙和频域中的一个子信道上，称为资源块（RB），是LTE中用于资源分配的最小单元。RBs的数量取决于系统带宽，例如，对于5 MHz系统，RBs数量为25，而在10 MHz系统中，RBs数量为50。</p><p>&emsp;&emsp;eNB使用信道状态信息获取每个用户链路上的信息。用户在每个TTI中向eNB报告其下行链路流状态。数据包优先级由eNB的调度器根据数据包延迟、下行链路状态、缓冲区状态、流量类型等参数确定。而特定数据包流的专用RB数量取决于调度器中使用的资源分配算法。以前大多数工作中的数据包调度器有两个阶段。先是时域调度器基于调度算法（自行设计）的输入参数选出请求服务的用户，然后频域调度器按照算法（自行设计）将资源分配给时域中选择出的用户。分组调度器使用CQI获取所有rb中的每个信道的质量信息。</p><p>&nbsp;</p><h3 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h3><h5 id="业务分类"><a href="#业务分类" class="headerlink" title="业务分类"></a>业务分类</h5><p>&emsp;&emsp;VOIP、Conversational Video 归为 GBR业务</p><p>&emsp;&emsp;FTP、HTTP 归为 nGBR业务</p><h5 id="时域调度"><a href="#时域调度" class="headerlink" title="时域调度"></a>时域调度</h5><p>&emsp;&emsp;TD调度器最重要的功能是根据QoS参数和信道的当前状态选择请求资源的活动用户（Activate UE）。</p><p>&emsp;&emsp;在没有资源分配给用户的第一阶段，TD调度器确定不同类别的活动Bearer（activate bearers），并根据不同的需求对它们进行优先级排序。由于TD调度器没有关于分配给每个用户的RBs的信息，因此利用所有RBs上的用户cqi的平均值来比较用户的信道条件，获取最大度量值的用户具有最高优先级。TD调度器创建用户和活动Bearer，分为GBR组和nGBR组并按优先级排序，并向FD调度器发送这两个单独的列表。</p><h6 id="GBR"><a href="#GBR" class="headerlink" title="GBR"></a>GBR</h6><p>&emsp;&emsp;GBR Bearer必须保证数据速率，与对延迟敏感的应用相关。本算法中GBR Bearer的QoS参数计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080439.png" alt="image-20211201173407839" style="zoom:50%;" /><p>&emsp;&emsp;注意，在eNB缓冲区中花费更多时间的数据包具有更高的服务交付优先级。</p><h6 id="nGBR"><a href="#nGBR" class="headerlink" title="nGBR"></a>nGBR</h6><p>&emsp;&emsp;nGBR Bearer通常包括尽力而为的服务，对延迟不敏感。nGBR类的不同活动Bearer根据不同的条件进行优先级排序。优先级排序使用nGBR的优先级因子完成，其行为类似于WPF算法，做了一些轻微的修改。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184317.png" alt="image-20211201184317270" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184346.png" alt="image-20211201184346056" style="zoom:50%;" /><p>&emsp;&emsp;参数 r 较大的nGBR用户在资源分配中优先于其他用户。</p><p>&nbsp;</p><h5 id="频域调度"><a href="#频域调度" class="headerlink" title="频域调度"></a>频域调度</h5><p>&emsp;&emsp;FD调度器负责将RBs分配给不同的持有人。FD调度器根据TD调度器发来的候选列表来确定在特定TTI中必须服务哪些Bearer。FD调度器优先服务于GBR Bearer，然后服务于nGBR Bearer。通过令牌桶算法确定允许分配资源的GBR Bearer，然后使用改进的LWDF、M-LWDFS对这些Bearer进行调度。<strong>（这里与流程图不符，流程图是PF算法调度）</strong></p><p>&emsp;&emsp;当GBR流量或相关令牌分配完后，FD调度器开始将资源分配给nGBR用户。采用了PF算法，在用户公平性和小区整体性能之间取得了较好的平衡。该算法计算用户信道的当前状态和先前接收的服务但是却不考虑QoS，因此PF适合非RT流量而不适合RT流量。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201185426.png" alt="image-20211201185425952" style="zoom:50%;" /><p>&emsp;&emsp;FD完整流程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201191306.png" alt="image-20211201191306507" style="zoom:50%;" /><p>&nbsp;</p><h3 id="仿真比较结果"><a href="#仿真比较结果" class="headerlink" title="仿真比较结果"></a>仿真比较结果</h3><p>&emsp;&emsp;为了研究提出的调度器在RT流量情况下对资源分配系统的影响，文章还模拟了TD-PF/FD-PF算法以及无令牌桶的情况。TD-PF/FD-PF算法虽然依据信道状态和服务质量，但是却并不考虑QoS，因此在RT流量业务的表现不佳。无令牌桶调度虽然考虑了QoS性能，但是由于GBR Bearer的优先级高于nGBR Bearer的优先级，而没有令牌桶对流量进行限制，因此当BGR业务需求较高时，nBGR业务无法顾及导致小区整体吞吐量降低。含令牌桶的调度是二者的折中，即维护了小区整体的吞吐量，又对RT流量业务的时延性能有所保证。</p><h6 id="三种业务情景"><a href="#三种业务情景" class="headerlink" title="三种业务情景"></a>三种业务情景</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192306.png" alt="image-20211201192305975" style="zoom:50%;" /><h6 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080440.png" alt="image-20211201192342289" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192359.png" alt="image-20211201192359425" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192413.png" alt="image-20211201192413873" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192430.png" alt="image-20211201192430785" style="zoom:50%;" /><p>&nbsp;</p><h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>&emsp;&emsp;其实这个令牌桶算法没有什么精巧的地方，无非是限制了对GBR业务资源分配，这样就能发论文，虽然是很多年前的了，但是一下让我觉得发论文也不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> “论文阅读” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab音频滤波</title>
      <link href="/2021/12/02/Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/02/Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Matlab-音频信号处理"><a href="#Matlab-音频信号处理" class="headerlink" title="Matlab 音频信号处理"></a>Matlab 音频信号处理</h2><p>&emsp;&emsp;现有原始音频文件<code>SunshineSquare.wav</code>，后半段音频被人为加上了多频段的噪音，使用matlab工具对其进行分析并消除噪音还原出无噪音频文件。</p><p>&nbsp;</p><span id="more"></span><h3 id="Step1：分析原始音频文件"><a href="#Step1：分析原始音频文件" class="headerlink" title="Step1：分析原始音频文件"></a>Step1：分析原始音频文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[audio_data, fs] = audioread(<span class="string">&#x27;../../SunshineSquare.wav&#x27;</span>);</span><br><span class="line">L = <span class="built_in">length</span>(audio_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一听该音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br></pre></td></tr></table></figure><h4 id="绘制时域图"><a href="#绘制时域图" class="headerlink" title="绘制时域图"></a>绘制时域图</h4><p>&emsp;&emsp;从下面时域图中可以看出，源音频文件时长11秒左右，从第8秒左右开始为一段强噪声。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Original&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = (<span class="number">1</span> : L) * <span class="number">1</span>/fs;</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="built_in">plot</span>(tt, audio_data);grid;</span><br><span class="line">title(<span class="string">&#x27;Time Domain&#x27;</span>);xlabel(<span class="string">&#x27;时间（s）&#x27;</span>);ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><h4 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h4><p>&emsp;&emsp;使用快速傅里叶变换FFT对时域信号进行频谱分析，绘制的频域图反映出有四段噪声频段，后续消除噪声工作就是对这四个频段进行滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="number">2</span>^<span class="built_in">nextpow2</span>(L); <span class="comment">% 先从原始信号长度确定下一个 2 次幂的新长度,用尾随零填充信号以改善 fft 的性能</span></span><br><span class="line">Spectrum = fft(audio_data,L); <span class="comment">% 快速傅里叶变换，转换为频域</span></span><br><span class="line">f_x = fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L; <span class="comment">% 定义频域，即变换横坐标量纲为频率</span></span><br><span class="line">mag_FFT_audio_data = <span class="built_in">abs</span>(Spectrum / L); <span class="comment">% 取幅值，并归一化</span></span><br><span class="line">ang_FFT_audio_data = <span class="built_in">angle</span>(Spectrum)*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="built_in">plot</span>(f_x,mag_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="built_in">plot</span>(f_x,ang_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;ang&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143455.png" alt="image-20211128143455368"></p><h4 id="绘制声谱图"><a href="#绘制声谱图" class="headerlink" title="绘制声谱图"></a>绘制声谱图</h4><p>&emsp;&emsp;声谱图能够以颜色反映各频段信号强度随时间的变化和分布情况，如图所示，从第8秒左右开始有4个频段的强度持续较高，这就是上面频域分析出的4个噪声频段。但需要注意到，在噪声的开始和结束时刻，所有频段的强度都很高，在图中显示为两条垂直的黄线，这两条线仅靠滤波无法消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">spectrogram(audio_data,hann(<span class="number">256</span>),<span class="number">250</span>,<span class="number">256</span>,fs,<span class="string">&#x27;yaxis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143558.png" alt="image-20211128143558882"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step2：滤波"><a href="#Step2：滤波" class="headerlink" title="Step2：滤波"></a>Step2：滤波</h3><h4 id="滤波法1——手动衰减"><a href="#滤波法1——手动衰减" class="headerlink" title="滤波法1——手动衰减"></a>滤波法1——手动衰减</h4><p>&emsp;&emsp;手动衰减各个噪声频段的幅度，注意FFT变换后的频谱图为偶对称，所以共有4对（8个）频段，逐一消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第一个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第二个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第三个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第四个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第五个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第六个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第七个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第八个噪声频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆fft获得处理后的音频</span></span><br><span class="line">ifft_data = <span class="built_in">real</span>(ifft(Spectrum, L));</span><br><span class="line">audio_data = ifft_data(<span class="number">1</span>:<span class="built_in">length</span>(audio_data));</span><br></pre></td></tr></table></figure><h5 id="滤波效果"><a href="#滤波效果" class="headerlink" title="滤波效果"></a>滤波效果</h5><p>&emsp;&emsp;绘制滤波后音频信号的时域图、频域图、声谱图，可看见时域图上噪声被消除，频谱图上4个频段的信号全部被消除，声谱图有四条水平的消磨痕迹。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211130213111.png" alt="image-20211130213111056"></p><p>&nbsp;</p><h4 id="滤波法2——数字滤波器"><a href="#滤波法2——数字滤波器" class="headerlink" title="滤波法2——数字滤波器"></a>滤波法2——数字滤波器</h4><p>&emsp;&emsp;设计梳状滤波器，因为有4个噪声频段，所以设计4个带阻滤波器逐一滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%h1[n] = [1,-2,1];</span></span><br><span class="line">h1 = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>];</span><br><span class="line">h2 = [<span class="number">1</span>,<span class="number">-1.24698</span>,<span class="number">1</span>];</span><br><span class="line">h3 = [<span class="number">1</span>,<span class="number">0.44504</span>,<span class="number">1</span>];</span><br><span class="line">h4 = [<span class="number">1</span>,<span class="number">1.80194</span>,<span class="number">1</span>];</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波过程</span></span><br><span class="line">audio_data_h1 = filter(h1,a,audio_data);</span><br><span class="line">audio_data_h2 = filter(h2,a,audio_data_h1);</span><br><span class="line">audio_data_h3 = filter(h3,a,audio_data_h2);</span><br><span class="line">audio_data_h4 = filter(h4,a,audio_data_h3);</span><br><span class="line"></span><br><span class="line">audio_data = audio_data_h4;</span><br></pre></td></tr></table></figure><h6 id="滤波器分析"><a href="#滤波器分析" class="headerlink" title="滤波器分析"></a>滤波器分析</h6><p>&emsp;&emsp;绘制4个滤波器的幅频、相频、衰减及每次滤波后的信号时域图。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145815.png" alt="image-20211128145815600" style="zoom: 25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145835.png" alt="image-20211128145835590" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128153455.png" alt="image-20211128145856791" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145920.png" alt="image-20211128145920683" style="zoom:25%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step3：后续处理"><a href="#Step3：后续处理" class="headerlink" title="Step3：后续处理"></a>Step3：后续处理</h3><p>&emsp;&emsp;上面已分析，在噪声开始和结束时刻都有全频段的高强度信号，不是滤波能消除的，这里采用时域衰减，即在时域采用同第一种滤波方法相同的思想，手动衰减这两个时刻的信号强度。随后输出处理过的音频文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第一个高音时段</span></span><br><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第二个高音频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一下处理后的音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出音频文件</span></span><br><span class="line">audiowrite(<span class="string">&#x27;SunshineSquare_Processed.wav&#x27;</span>,audio_data,fs); </span><br></pre></td></tr></table></figure><p>使用滤波法2的最终输出信号的分析如下：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128150059.png" alt="image-20211128150059309"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="对数字信号处理的认识"><a href="#对数字信号处理的认识" class="headerlink" title="对数字信号处理的认识"></a>对数字信号处理的认识</h2><p>&emsp;&emsp;《数字信号处理》这门课我觉得其实是两大主题，第一是信号分析，第二是信号处理。</p><p>&emsp;&emsp;信号分析在《信号与线性系统》中有所讲解，但是那时所研究的是连续时间信号的傅里叶级数或傅里叶变换，离散时间信号的傅里叶变换，它们的特点都是：信号无限长，导致计算机无法处理。而为了使用计算机工具帮助对信号进行分析，《数字信号处理》这门课引入了采样、增/减采样和离散傅里叶变换DFT的概念。后续考虑到DFT算法的时间复杂度太高，因此又提出快速傅里叶变换FFT来代替之。</p><p>&emsp;&emsp;信号处理在这门课中主要指滤波。低通、高通、带通、带阻、全通，《信号与线性系统》中共提出过五种模拟滤波器，如何根据所需指标将其转化为对应的数字滤波器来在计算机上使用，是这门课的第二个重点。</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>&emsp;&emsp;模拟信号经过采样、抽取（减采样）后成为计算机可以处理的有限长离散信号。采样后，仍是连续时间信号，但频域上是原始模拟信号频域的周期延拓和幅度放缩。抽取后，变为有限长离散信号，频域点数和时域相同，但横坐标频率被按比例压缩在 0~2pi 范围内，幅值和采样后的一样。</p><h5 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h5><p>&emsp;&emsp;在傅里叶变换中，离散/连续 和 周期/非周期 相对偶，离散周期序列的傅里叶变换仍是离散周期序列。因为计算机容量有限，其处理的信号长度有限，因此从离散周期信号中取一个周期来代替整个信号分析是一种行之有效的方法。DFT也正是在这种思想下被引出，重点在于循环卷积、旋转因子、各种变换性质。</p><p>&emsp;&emsp;但是，用定义计算DFT的时间复杂度太高，计算机效率低。借助公式中“旋转因子”的周期性，长序列的DFT可以不断分解至一组组两点DFT的组合，大大减少了计算量，这就是FFT算法。</p><h5 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h5><p>&emsp;&emsp;数字滤波器有很多值得关注的地方，首先是截止频率、纹波幅度等性能指标，然后是幅频特性、相频特性，还有系统函数的极零点、信号流图等。根据冲激响应长度可分为有限脉冲响应滤波器FIR和无限脉冲响应滤波器IIR。从模拟滤波器转换为数字滤波器的方法有冲激响应不变法、双线性变换法。常用的滤波器有巴特沃斯滤波器、切比雪夫滤波器、椭圆滤波器等。</p>]]></content>
      
      
      <categories>
          
          <category> “技术分享” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大二一年</title>
      <link href="/2021/12/02/%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/"/>
      <url>/2021/12/02/%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在华科度过了两年时间里，我看过东九楼前路边的银杏一夜间被北风吹去满树黄叶，也曾在凌晨五点的晨雾中从百景园自习区一路徒步走回韵苑。回想大一大二的时光，涌上我心头的并不是特别的成就感，亦不是其他大喜大悲，而是平淡与坦然。如果要用一句话概括这一年，我想用大物老师曾提到过的——看山不是山。</p><span id="more"></span><p>&emsp;&emsp;现在看来，大一一年里我只做了两件对现在仍有影响的事，一是熟悉了大学的学习方式，把加权拉得很高；二是认识到，每天都在自习室度过，这样和高中没太大区别，我不喜欢只是这样的大学生活。大二开学那阵，我因为加权高并且也有一些课外的成绩所以拿到了国奖，有些自傲，那是心里总觉得大学生活怎么和高中没什么区别呀，无非是可以用iPad记笔记、带手机上课罢了。禅宗里描述有三种境界，“看山是山，看山不是山，看山还是山。”第一次听到这句话是在大物老师的课上，我发觉自己对华科这所学校和大学本身的认识也只是在“看山是山”的层面上，我还没有发现它真正的精彩。</p><p>&emsp;&emsp;大一下学期因为疫情所以一学期都在家，期间不能出门，所以从高中坚持到大学的夜跑习惯也丢掉了，但是也恰好喜欢上了室内健身，大二来到学校后，在一位朋友的影响下去了一学期的健身房，每周会有三四天专门去锻炼。一整天没课时会和这位朋友专门去主图自习，中午步行穿过青年园到百景园或西边小吃城用餐，吃完回来会在图书馆外草地边讨论一些很有意思的话题，时间似乎都变得慢了下来。大一的每天是做不完的事情，时间匆匆流过，却总觉得自己什么都没做，而大二上就这样以一种比较悠闲的节奏度过，虽然加权没有大一时那么高，但那相差的那几点几分换来了我对大学、对自己的另一种认识。</p><p>&emsp;&emsp;大二上的国奖答辩期间认识了不少优秀的同学，寒假我和其中两位同学组队参加了美赛，比赛期间我们异地合作，每天都连麦从天还没亮肝到晚上凌晨，最后一晚通宵修改论文，没有人是在划水摸鱼。对比其他许多队伍我发现，能够遇到值得信任的靠谱队友是多么重要。我们虽然都是第一次接触数模，但是扎实的功底和高效的合作帮助我们出乎意料地最终取得了特等奖提名，其实奖项只是次要的，弥足珍贵的是经历和友谊。</p><p>&emsp;&emsp;大二下在两位队友的建议下，我加入了电信学院大名鼎鼎的科创团队——Dian团队。其实大一就知道Dian团队，但是当时一心只读圣贤书，两耳不闻东九窗外事，没有想过加入这样的团队，算是一个小小的遗憾。不过悟已往之不谏，知来者之可追，加入团队的半年里认识了许多优秀的同学，也学到了好玩并实用的项目知识和技能。在智慧交通项目组我接触到了计算机视觉与实际应用的结合，我们组与萍乡市警方合作设计了用于重点车辆检测的软件，申请到了国家版权局的软件著作权。虽然到了大二下期末，我的总成绩从半年前刚分完专业时的专业第一掉到了第二，学年成绩更是滑落不少，但想象中的懊悔与失落并没有如期而至，倒不如说是现在的我看开了，有些东西和成绩一样重要。</p><p>&emsp;&emsp;代表大二学年尾声的暑假对我而言也是一段不平凡的记忆。七月基本上是在团队中度过的，原本AI组的项目已经结题了，我转到团队与Intel亚太研发有限公司合作的项目中，一直在补习无线通信方面的知识。七月末我本着走入社会、感悟基层的初衷，又一次参与到了暑期社会实践当中，我们到河南洛阳的一家养老院展开调研，却碰上了百年难得一遇的暴雨，火车高铁停运，我也被困回不到郑州的家或学校。后续终于返校，但是因为河南疫情爆发，我被学校组织隔离了28天。被放出来后的第一件事就是去当疫苗接种志愿者，毕竟自己是一名预备党员，只是可惜没能给涝疫同至的家乡献一份力。</p><p>&emsp;&emsp;最后一个比较有意义的事就是去火车站迎新了，以前高中课上老师激励我们说，每年开学期间各个城市的大学都会在火车站设迎新点，越是有名的大学迎新点也越大。虽然最后一句在我当时来到武汉站看见华科的迎新点后就不信了，但是它带给我的归属感却一直萦绕在我心头，所以今年我也要把这种关怀传承下去。</p><p>&emsp;&emsp;其实大二这一年还经历过好多事情，我心里明白自己和一年前不一样了。再一次走向国奖答辩的讲台，我已不再是一年前那患得患失、喜忧参半的心态。既然我的成绩支持我站在这里，那么我所走过的路、感悟到的事情足够让我自信地向台下展示出自己。因为没有刻意把国奖当作目标，也不需要用它来证明什么，毕竟身边有许多同样如此的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> “心得感悟” </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Love actually is all around</title>
      <link href="/2021/12/01/hello-world/"/>
      <url>/2021/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
