<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络知识总结</title>
      <link href="/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络知识点总结</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160706.png" alt="20201001111251542" style="zoom: 50%;" /><p>改自18级种子班“卢神”：<a href="http://lwdreamofly.love/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/">计算机网络考试复习</a></p><p>参考：<a href="https://www.icourse163.org/learn/HIT-154005?tid=1465409451#/learn/content">哈工大计网mooc</a>、<a href="https://blog.csdn.net/lydms/article/details/106736730?ops_request_misc=%7B%22request_id%22:%22164118867316780261951158%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164118867316780261951158&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-106736730.pc_search_insert_es_download_v2&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">计算机网络博客</a>、《计算机网络—系统方法》、华科电信计网教学PPT</p><span id="more"></span><p>&nbsp;</p><h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ul><li>计算机网络可以视为是 <code>计算机技术</code> 和 <code>通信技术</code> 的合成</li><li>计算机网络设计需求<ul><li>可拓展的连通性<ul><li>为每个结点定义一个地址，路由转发消息</li></ul></li><li>高性价比的资源共享<ul><li>分组交换而不是电路交换</li></ul></li><li>支持通用服务<ul><li>设计传输协议</li></ul></li><li>可管理性</li></ul></li><li>网络通信方式包括 <code>点到点</code> 、 <code>广播</code> 、 <code>点到多点</code> 、 <code>多点到多点</code></li><li>公用电话交换网（PSTN）中的交换设备提供 <code>电路交换</code> 方式</li><li>世界上第一个投入运行的分组交换网是 <code>ARPAnet</code></li><li><code>ARPAnet</code>是最早验证分组交换的网络之一</li><li>Internet起源于<code>ARPAnet</code></li><li>根据计算机网络的定义，其主要特征包括<code>支持计算机资源的共享</code>、<code>互联的计算机系统是自治的系统</code>、<code>联网的计算机系统之间需要遵循共同的网络协议</code></li><li>关于计算机网络的最简单定义是：一些相互连接的、以共享资源为目的的、自治的计算机的集合<ul><li>自治：无主从关系</li></ul></li><li>计算机网络按照网络规模大小可以分为：<code>PAN</code>、<code>LAN</code>、<code>MAN</code>、<code>WAN</code><ul><li>PAN：personal area network 个人区域网络<ul><li>无线连接：蓝牙、红外、NFC</li><li>有线连接：USB电缆</li><li>常用于传输小文件，如：音乐、照片、日历、约定等</li></ul></li><li>LAN：local area network 局域网<ul><li>基于广播技术发展而来</li><li>由一组设备组成，如：计算机+服务器+交换机+打印机、校园网、公司内网等</li><li>最常见的局域网类型是<code>以太网</code>，两台或多台计算机通过电缆连接到以太网交换机上</li></ul></li><li>MAN：metropolitan area network 城域网<ul><li>一种比校园网区域还大的网络</li><li>一种横跨一个城市或城镇的多个建筑的网络</li><li>通常使用高速连接，如：光缆</li><li>一种高速网路，能够在城市中共享数据和资源提供服务</li></ul></li><li>WAN：wide area network 广域网<ul><li>基于交换技术发展而来</li><li>WAN是最大的网络类型，一个WAN可以包含多个MAN、LAN、PAN</li></ul></li></ul></li><li>局域网LAN和广域网WAN的区别<ul><li>覆盖范围</li><li>协议</li></ul></li><li>网络分类方法：<code>局域网/广域网</code>、<code>有线网/无线网</code>、<code>环形网/星形网</code></li><li>常见的网络拓扑：<code>环形结构</code>、<code>总线结构</code>、<code>网状结构</code>、<code>星形结构</code>、<code>树形结构</code>、<code>混合性结构</code></li><li>网络结构<ul><li>网络边缘<ul><li>主机（端系统）、客户/服务器、对等（P2P）应用模型</li></ul></li><li>接入网络<ul><li>家庭接入网络、机构接入网络、</li><li>数字用户线路（DSL）、电缆网络、无线接入网络</li></ul></li><li>网络核心<ul><li>互联的路由器网络</li><li>关键功能：路由+转发</li></ul></li></ul></li></ul><h2 id="1-2-交换原理"><a href="#1-2-交换原理" class="headerlink" title="1.2 交换原理"></a>1.2 交换原理</h2><ul><li><p><code>虚电路</code>、<code>TCP</code>能提供面向连接的服务</p></li><li><p>三中交换方式：电路交换、报文交换、分组交换</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103184648.png" alt="image-20220103184648837" style="zoom:50%;" /></li><li><p>使用存储—转发技术的是：报文交换、分组交换</p></li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在通信之前需要在通信双方间建立一条双方独占的物理信道，这个信道由双方之间的交换设备和链路逐段连接而建成的<ul><li>优点：<ul><li>带宽保证。数据直达，传输延迟小，具有很强的实时性</li><li>通信可靠。双方通信是有序的，不存在乱序问题，并且丢包概率低</li><li>路由机制简单。基于时分或频分复用，不需要进行数据包头部地址识别</li><li>既可以用于传输模拟信号，也可以用于传输数字信号</li><li>适用于实时和交互式通信</li></ul></li><li>缺点：<ul><li>建立连接平均时间较长，影响效率</li><li>对信道利用率低，建立的物理通路即使空闲仍占用通路</li><li>不同类型、规格、速率的终端难以相互进行通信，且易发生差错</li></ul></li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li><p>以<code>报文</code>为数据交换的单位，报文中携带目标地址、源地址等信息</p></li><li><p>优点：</p><ul><li>不存在建立时延，可以即时发送</li><li>当某条传输路径发生故障时能够自动选择另一条路径进行传输，提高了传输稳定性</li><li>即使不同类型、规格、速率的终端也可以实现通信</li><li>可以多目标发送</li><li>交换方式会自动建立数据传输的优先级，提高信道利用率</li></ul></li><li><p>缺点：</p><ul><li>数据交换结点需要经历存储、转发这个过程，所以会引起转发时延</li><li>只能用于数字信号</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>报文交换的升级版，仍采用<strong>存储转发</strong>的方式，但会将一个长报文先分割为若干个较短的分组，然后将短分组添加包头后逐个发送</p><ul><li>优点：<ul><li>不存在链路空闲时的带宽浪费，加速了数据的网络传输</li><li>简化了存储管理，从而减少了出错机率和重发数据量</li><li>由于其分组的特点，在优先级策略传输中更具优势</li><li>相较电路交换，更加适用于突发数据的传输</li></ul></li><li>缺点：<ul><li>时延问题仍存在，但得到减少</li><li>每个分组需要包含源地址和目的地址等信息的首部</li><li>存在乱序、分组丢失或重复问题</li><li>通信效率不高</li></ul></li></ul></li><li><p>报文交换以完整报文进行存储和转发，分组交换以分割后的报文分组进行存储和转发</p></li><li><p><strong>这里涉及报文交换和分组交换的时间计算题</strong></p><ul><li><p>分组交换时间计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164253.png" alt="image-20220102164253412" style="zoom: 33%;" /></li></ul></li><li><p>现有的公共数据网主要采用的技术是<code>分组交换</code>，包含：<code>数据报</code>、<code>信元交换</code>、<code>虚电路</code></p><ul><li><strong>信元交换</strong><ul><li>又叫做异步传输模式（Asynchronous Transfer Mode，ATM），是一种面向连接的快速分组交换技术，通过建立虚电路来进行数据传输</li></ul></li><li><strong>数据报服务</strong><ul><li>为网络层提供<strong>无连接方式</strong></li><li>无连接服务<ul><li>不事先为分组的传输确定一个具体的路径，每个分组会独立确定传输路径，不同分组传输路径可能不同</li><li>可能会乱序到达</li><li>主机<strong>不知道</strong>网络是否可以传送该分组</li></ul></li><li>发短消息时，数据报比虚电路报文分组交换甚至电路交换更快（不需要耗时建立连接）</li></ul></li><li><strong>虚电路服务</strong><ul><li>为网络层提供<strong>连接方式</strong></li><li>连接方式<ul><li>首先为分组的传输确定一个传输路径，即建立连接，然后沿着该连接对应的同一个传输路径传输系列分组</li></ul></li><li>健壮性不如数据报服务</li><li>分组不需要选择路由</li><li>电路交换需要在两站之间建立一条专用通路，但是虚电路服务不需要；虚电路的分组需要含电路号，但是电路交换不需要，电路交换不是分组</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103085634.png" alt="image-20220103085633946" style="zoom: 33%;" /><table><thead><tr><th></th><th>数据报服务</th><th>虚电路服务</th></tr></thead><tbody><tr><td>连接的建立</td><td>不需要</td><td>需要</td></tr><tr><td>目的地址</td><td>每个分组中都包含都有完整的目的地址</td><td>仅在建立连接时使用，之后每个分组使用长度较短的虚电路号判断路径即可，不需要包含目的地址</td></tr><tr><td>路由的选择</td><td>每个分组独立进行路由选择和转发</td><td>属于同一条虚电路所有分组按照同一路由转发</td></tr><tr><td>分组顺序</td><td>不保证分组有序到达</td><td>保证分组有序到达</td></tr><tr><td>可靠性</td><td>不保证可靠通信，可靠性由用户主机（更高层协议）保证</td><td>可靠性由网络保证</td></tr><tr><td>对网络故障的适应性</td><td>出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td><td>所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td>差错处理和流量控制</td><td>由用户主机进行流量控制，不保证数据报的可靠性</td><td>可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></li></ul></li></ul><h2 id="1-3-网络应用"><a href="#1-3-网络应用" class="headerlink" title="1.3 网络应用"></a>1.3 网络应用</h2><ul><li>计算机网络通信的显著特点：<code>间歇性</code>、<code>突发性</code></li><li>如果源端发送的每一个消息均希望被目的端接收，可以采用<code>请求/响应</code>的通信方式</li></ul><h2 id="1-4-网络体系架构"><a href="#1-4-网络体系架构" class="headerlink" title="1.4 网络体系架构"></a>1.4 网络体系架构</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>实体（Entity）</p><ul><li>定义：构成网络系统各个层次的抽象对象</li><li>向高层提供服务</li><li>通过调用底层实体提供的服务与远程计算机的对等实体进行通信<ul><li>对等实体：网络中不同主机（结点）的相同层次之间互为对等实体</li></ul></li></ul></li><li><p>协议（Protocol）</p><ul><li>定义：两个或多个网络对等实体之间通信所需遵从的特定规则</li><li>是为进行网络的数据交换和网络通信而建立的规则、标准或约定</li><li>向上层实体提供服务</li><li>协议三要素：<strong>语法</strong>、<strong>语义</strong>、<strong>时序</strong><ul><li>语法：数据与控制信息的结构或格式、信号电平</li><li>语义：需要发出何种控制信息、完成何种动作以及做出何种响应、差错控制</li><li>时序：事件顺序、速度匹配</li></ul></li></ul></li><li><p>实体的接口（Interface）</p><ul><li>垂直（向上）：服务接口</li><li>水平（对端）：与远程计算机对等实体的对等接口</li></ul></li><li><p>同一系统相邻两层的实体进行交互的地方称为：<strong>服务访问点</strong></p></li><li><p>网络体系结构是网络层次结构和各层协议的集合</p></li><li><p>协议与服务</p><ul><li>协议的实现保证了能够向上一层提供服务，要实现本层协议还需要使用下面一层所提供的服务</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务</li><li>协议是水平的，即协议是控制对等实体间通信的规则</li><li>服务是垂直的，即服务是下层向上层通过层间接口提供的</li></ul></li></ul><h3 id="层次化网络体系结构"><a href="#层次化网络体系结构" class="headerlink" title="层次化网络体系结构"></a>层次化网络体系结构</h3><ul><li><p>计算机网络架构的分层</p><ul><li>每一层都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面清晰，交互接口尽可能简单</li><li>下层对上层相对独立，上层调用下层提供的服务</li><li>各层的定义主要在功能方面，不应指定具体的实现方法</li></ul></li><li><p>计算机网络体系采用层次结构的主要原因</p><ul><li>使各层次的功能相对独立，使得各层次实现技术的进步不影响相邻层次，从而保证体系结构的完整性</li><li>层次结构的方法可以简化计算机网络的实现</li></ul></li><li><p>分层的实现</p><ul><li>封装<ul><li>通过封装，协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li><li>首部、尾部的加载和分离</li></ul></li><li>复用与解复用<ul><li>复用来自源结点不同高层实体的数据，将数据解复用至目的结点对应的高层实体</li><li>在发送端主机复用，在接收端主机解复用</li></ul></li></ul></li><li><p>下层协议的实现对上层的服务用户是透明的</p></li></ul><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><ul><li><p>在 OSI 参考模型中，第 N 层是第 N+1 层的服务提供者</p></li><li><p>在分层网络模型中，第N层提供的服务是利用第N-1层提供的服务和第N层协议，与对等实体交换信息实现的</p></li><li><p><strong>OSI七层网络体系</strong></p><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>为应用进程提供服务：文件传输、电子邮件、文件服务、虚拟终端</td><td>TFTP、HTTP、SNMP、DNS、Telnet等</td></tr><tr><td>表示层</td><td>数据格式转换、代码转换、数据加密</td><td>无</td></tr><tr><td>会话层</td><td>建立、管理和维护会话</td><td>无</td></tr><tr><td>传输层</td><td>建立、管理和维护端对端（进程间）的连接</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>为数据包IP选址和路由</td><td>IP、ICMP、OSPF、EIGRP、IGMP等</td></tr><tr><td>数据链路层</td><td>帧传输及错误检测功能、提供介质访问和链路管理</td><td>SLIP、CSLIP、PPP、MTU</td></tr><tr><td>物理层</td><td>以二进制数据形式在物理媒介上传输数据</td><td>ISO2110、IEEE802、IEEE802.2</td></tr></tbody></table></li><li><p>示意图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164610.png" alt="image-20220102164610829" style="zoom:33%;" /></li><li><p>数据封装与通信过程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164642.png" alt="image-20220102164642039" style="zoom: 33%;" /></li><li><p><strong>物理层（Physical）</strong></p><ul><li>透明地传输原始比特流</li><li>定义物理设备的标准，如：网线的接口类型、光纤的接口类型、各种传输介质的传输速率等</li><li>规定：比特编码、数据率、比特同步方式、传输模式</li></ul></li><li><p><strong>数据链路层（Data Link）</strong></p><ul><li>负责物理链路上相邻结点间的数据传输</li><li>物理层比特流数据组合成帧并利用协议发送帧</li><li>控制对物理介质的访问 </li><li>提供差错检测/纠正、流量控制</li></ul></li><li><p><strong>网络层（Network）</strong></p><ul><li>负责源主机到目的主机的数据分组（packet）交付</li><li>定义了IP地址，通过IP进行逻辑寻址，遵循IP协议</li><li>在不同网络之间实现路由+转发（交换机、路由器）</li></ul></li><li><p><strong>传输层（Transport）</strong></p><ul><li>提供源主机到目的主机（端到端进程间）的完整报文传输服务</li><li>连接控制、流量控制、差错控制</li></ul></li><li><p><strong>会话层（Session）</strong></p><ul><li>建立和管理应用程序之间的通信</li><li>建立/解除与物理其他接口的联系</li></ul></li><li><p><strong>表示层（Presentation）</strong></p><ul><li>数据格式化、代码转换、数据加密、数据压缩</li><li>解决不同系统之间的通信语法问题</li></ul></li><li><p><strong>应用层（Application）</strong></p><ul><li>文件传输、电子邮件、文件服务、虚拟终端</li><li>传输的数据根据应用层的协议进行服务</li></ul></li><li><p><strong>记忆口诀</strong></p><ul><li><strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>ell <strong>S</strong>tupid <strong>P</strong>eople <strong>A</strong>nything</li></ul></li></ul></li></ul><h3 id="TCP-IP四层体系结构"><a href="#TCP-IP四层体系结构" class="headerlink" title="TCP/IP四层体系结构"></a><strong>TCP/IP四层体系结构</strong></h3><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>协议或组件</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、DNS、FTP</td></tr><tr><td>运输层（传输层）</td><td>TCP、UDP</td></tr><tr><td>网际层（IP层）</td><td>IP</td></tr><tr><td>网络接口层（网络接入层）</td><td>网络接口</td></tr></tbody></table></li><li><p>瘦腰结构</p></li><li><p>解决计算机之间通信问题是在：网际层（对应网络层）</p></li><li><p>TCP/IP协议族的网络层提供的是：<strong>无连接不可靠的数据报服务</strong></p></li><li><p>物理层、数据链路层、网络层传送的数据单位分别为：<code>比特</code>、<code>帧</code>、<code>分组</code></p></li><li><p>对比OSI七层参考模型</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103190907.png" alt="image-20220103190906970" style="zoom:50%;" /></li></ul><h3 id="几种物理设备"><a href="#几种物理设备" class="headerlink" title="几种物理设备"></a>几种物理设备</h3><table><thead><tr><th>设备</th><th>功能</th><th>层级</th></tr></thead><tbody><tr><td>中继器 RP</td><td>根据输入端的信号重新生成原始信号，再通过输出端传送出去，扩大网络传输的距离</td><td>L1</td></tr><tr><td>集线器 Hub</td><td>将网线集中到一起的机器，也就是多台主机和设备的连接器</td><td>L1</td></tr><tr><td>网桥 Bridge</td><td>根据数据帧内容转发数据给其他相邻的网络</td><td>L2</td></tr><tr><td>交换机 Switch</td><td>MAC寻址，将数据帧转发到另一个目标MAC地址。和网桥的升级，具有集线器一样的集中连接功能，又具有网桥的数据交换功能</td><td>L2</td></tr><tr><td>路由器 Router</td><td>IP寻址，将分组报文转发到另一个目标路由器地址</td><td>L3</td></tr><tr><td>网关 Gateway</td><td>在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连</td><td>&gt;L3</td></tr></tbody></table><ul><li><p>集线器的缺点是：<strong>不能过滤网络流量</strong></p></li><li><p>连接在集线器上的结点<strong>共享</strong>集线器带宽（均分），连接在交换机上的结点独占交换机带宽</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125432.jpg" alt="img" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125445.jpg" alt="img" style="zoom:33%;" /></li></ul><h2 id="1-5-网络性能评估"><a href="#1-5-网络性能评估" class="headerlink" title="1.5 网络性能评估"></a>1.5 网络性能评估</h2><h3 id="链路带宽"><a href="#链路带宽" class="headerlink" title="链路带宽"></a>链路带宽</h3><ul><li>指链路上每秒所能传输的比特数，单位bps</li><li>取决于链路时钟和信道编码</li><li>带宽往往大于吞吐量</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li><p>端到端时延</p><ul><li>将报文从网络一端传到另一端所花费的时间</li><li>= 处理时延 + 排队时延 + 传输时延 + 传播时延</li></ul></li><li><p>传输时延（发送时延）：</p><ul><li>主机或路由器发送数据帧所需的时间，即从帧的一个比特开始到最后一个比特发送完毕所需的时间</li><li>传输时延 = 分组长度 / 链路带宽</li></ul></li><li><p>传播时延</p><ul><li>电磁波在信道中传播一定距离所需的时间</li><li>与数据大小无关</li><li>传播时延 = 物理链路长度 / 电磁波传播速率（注意环境）</li></ul></li><li><p>处理时延</p><ul><li>主机或路由器在收到分组时分析首部、提取数据主体、差错检测等<strong>存储转发</strong>操作处理花费的时间</li></ul></li><li><p>排队时延</p><ul><li>分组通过网络传输时要经过很多路由器，进入路由器后要先输入队列中排队等待处理。在路由器确定了转发接口后还要在输出队列中等待转发</li></ul></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>等效于第一个比特到达接收方之前，发送方可以发送的比特数上限</li><li>是网络中能够保持的最大比特数</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103192043.png" alt="image-20220103192042971" style="zoom:50%;" /></li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><p>单位时间内发送方和接收方之间成功传输的数据量</p></li><li><p>受到各种因素影响，带宽10Mbps的链路一吞吐量只能达到2Mbps左右</p></li><li><p><strong>链路吞吐量</strong>为：A端结点、B端结点、通信线路三者吞吐量的最小值</p></li><li><p><strong>网络设备吞吐量</strong></p><ul><li>单位时间内，网络设备各端口存储转发的比特数之和</li><li>取决于输入输出端口硬件和程序算法设计</li><li>是没有帧丢失时，设备能接收并转发的最大数据速率</li></ul></li><li><p>计算机网络最主要的性能指标：<code>带宽</code>、<code>时延</code></p></li></ul><p>&nbsp;</p><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络适配器</p><ul><li>功能<ul><li>进行串行/并行转换</li><li>对数据进行缓存</li><li>设备驱动程序</li></ul></li><li>接口特性<ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>规程特性</li></ul></li></ul></li><li><p><code>链路</code>：物理传输媒质</p></li><li><p>信息传输速率单位：<code>bps</code></p></li><li><p>码元传输速率单位：<code>波特（Baud, 1/s）</code></p></li><li><p>承载信息量的基本信号单位：<code>码元</code></p></li><li><p>通信系统必备的三个基本要素：<code>信源</code>、<code>通信媒介</code>、<code>信宿</code></p></li><li><p><code>调制速率</code>：每秒钟载波调制状态改变的数值，单位：波特，又称为波特率，即码元的传输速率</p></li><li><p><code>比特率</code>：数据的传输速率，单位：bps</p></li><li><p>两台设备之间实现通信必备：<code>网卡</code>、<code>传输媒介</code>、<code>协议</code></p></li><li><p>链路层的数据封装和解封都由<code>网卡</code>完成</p></li><li><p>常见通信方式：</p><ul><li><p>单工通信（Simplex Communication）</p><p>信息只能单方向传输，发送端和接收端是固定的</p></li><li><p>半双工通信（Half-duplex Communication）</p><p>可以对调发送端和接收端，但是不能同时双边互发信息</p></li><li><p>全双工通信（Full-duplex Communication）</p><p>任意时刻都可以在双向同时传输信息</p></li></ul></li></ul><h3 id="网络通信编码"><a href="#网络通信编码" class="headerlink" title="网络通信编码"></a>网络通信编码</h3><ul><li><p>不归零（NRZ）</p><ul><li>编码方式<ul><li>1——&gt;高电平</li><li>0——&gt;低电平</li></ul></li><li>问题<ul><li>连续的0可能被误认为没有信号</li><li>连续的1可能导致基线漂移</li><li>时钟恢复困难</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194708.png" alt="image-20220103194708738" style="zoom: 50%;" /></li></ul></li><li><p>不归零反转（NRZI）</p><ul><li>编码方式<ul><li>1——&gt;信号跳变</li><li>0——&gt;信号保持</li></ul></li><li>问题<ul><li>可以解决连续1的问题，但是不能解决连续0的问题</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194833.png" alt="image-20220103194833948" style="zoom:50%;" /></li></ul></li><li><p>曼彻斯特编码（Manchester）</p><ul><li>编码方式<ul><li>1——&gt;高到低跳变</li><li>0——&gt;低到高跳变</li></ul></li><li>问题<ul><li>信号跳变速率翻倍</li><li>比特率是信号跳变速率的一般，编码效率:50%</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195035.png" alt="image-20220103195035160" style="zoom:50%;" /></li></ul></li><li><p>4B/5B</p><ul><li>编码方式<ul><li>用5个比特对4个比特的数据进行编码, 其中每个代码(5个比特)中最多有1个前导0, 且末端最多有2个0</li><li>采用NRZI对5比特编码</li><li>编码效率：80%</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195154.png" alt="image-20220103195154290" style="zoom: 67%;" /></li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><h2 id="3-1-相关概念"><a href="#3-1-相关概念" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h2><ul><li><p>链路层在每台主机的网络适配器（网卡）上实现，或者集成在芯片上</p></li><li><p>网络适配器之间的通信</p><ul><li>发送端<ul><li>将分组封装为数据帧</li><li>增加差错检测、可靠传输、流量控制等功能</li></ul></li><li>接收端<ul><li>完成差错检测、实施可靠传输、流量控制等</li><li>提取分组并交付至上层协议</li></ul></li></ul></li><li><p>链路层服务：</p><ul><li>组帧（framing）<ul><li>封装数据报构成数据帧，加首部和尾部</li><li>帧同步</li></ul></li><li>链路接入（link access）<ul><li>如果是共享介质，需要解决信道接入问题</li><li>帧首部中的MAC地址用于标识帧的源和目的</li></ul></li><li>相邻节点间可靠交付</li><li>流量控制</li><li>差错检测</li></ul></li><li><p>MAC地址</p><ul><li>又称为LAN地址、物理地址、以太网地址</li><li>局域网中每块网卡都有一个唯一的MAC地址，是硬件设备的唯一标识</li><li>作用：用于局域网标识一个帧从哪个接口发出，到达哪个物理相连的其他接口</li><li>48位MAC地址固化在网卡的ROM中，一般不会软件改动</li></ul></li><li><p>ARP地址解析</p><ul><li>ARP表<ul><li>LAN中每个IP结点（主机、路由器）维护一个表，存储某些LAN结点的IP/MAC地址映射关系</li><li>经过TTL时间后遗弃此映射关系（一般是20min）</li></ul></li><li>ARP即插即用，结点自主广播ARP查询分组，获得对应IP的主机应答其MAC地址，创建ARP表，超时（TTL）会自动刷新，无需干预</li></ul></li><li><p>透明传输1：传输的数据内容、格式、编码方式无限制</p></li></ul><h3 id="组帧（帧定界问题）"><a href="#组帧（帧定界问题）" class="headerlink" title="组帧（帧定界问题）"></a>组帧（帧定界问题）</h3><ul><li>面向字节的协议<ul><li>把每一帧看作一个字节集合</li><li>两种方法<ul><li>字符计数法</li><li>起止标记法</li></ul></li></ul></li><li>面向比特的协议<ul><li>把数据帧看作比特的集合</li><li>高级链路控制规程（HDLC）</li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>应用最广泛的LAN技术</p></li><li><p>网络速率:10Mbps——10Gbps</p></li><li><p>以太网的优点是：<code>可扩充性好</code>、<code>成本低</code>、<code>施工方便</code></p></li><li><p>以太网参考模型一般只包括：<code>物理层</code>和<code>数据链路层</code></p></li><li><p>以太网的碰撞窗口或争用期为：<strong>往返时延</strong></p></li><li><p>不可靠的服务：差错帧直接丢弃，丢弃帧中数据的恢复依靠高层协议（<strong>无确认</strong>）</p></li><li><p><strong>无连接</strong>的服务：发送帧的网卡与接受帧的网卡没有握手过程</p></li><li><p>MAC协议：二进制指数退避算法的CSMA/CD（不是必须）</p><ul><li>检测到冲突中止发送后，进入二进制指数退避</li></ul></li><li><p>以太网交换机：</p><ul><li>是链路层设备<ul><li>存储—转发以太网帧</li><li>检验到达帧的目的MAC地址，选择向一个或多个输出链路转发帧</li><li>利用CSMA/CD访问链路，发送帧</li></ul></li><li>透明：主机感受不到交换机的存在</li><li>即插即用</li><li>自学习，无需配置（目的帧不在交换表中时泛洪查找）</li><li>全双工通信</li><li>注意，交换机使用泛洪构建转发表；路由器则通过路由算法计算IP转发表</li><li>洪泛法的基本思想是：收到的信息都会往所有可能连接的路径上转发</li></ul></li><li><p>虚拟局域网VLAN：</p><ul><li>VLAN（Virtual Local Area Network）是由一些局域网网段构成的与物理位置无关的逻辑组</li><li>利用以太网交换机可以很方便地实现 VLAN</li><li>每一个 VLAN 的工作站可处在不同的局域网中</li></ul></li></ul><h3 id="无线局域网-IEEE802-11"><a href="#无线局域网-IEEE802-11" class="headerlink" title="无线局域网 IEEE802.11"></a>无线局域网 IEEE802.11</h3><ul><li><p>无线链路特性</p><ul><li>信号强度递减（路径损耗）</li><li>其他信号源干扰（各种频段）</li><li>多径传播（乱序到达）</li><li>隐藏终端问题（中间隔着障碍物）</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102214759.png" alt="image-20220102214759049" style="zoom:33%;" /></li><li><p>均使用CSMA/CA多路访问控制协议</p></li><li><p><strong>截断二进制指数</strong>类型退避算法解决了：站点检测到冲突后延迟发送的时间</p></li><li><p>无线局域网不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>是因为无线局域网：并非所有站点都能听见对方、无线介质传输特征复杂，存在隐藏终端、暴露终端等问题</p></li><li><p>无线通信网中，应对隐藏终端、暴露终端问题的方法是：<code>RTS/CTS 机制</code>（CSMA/CA）</p></li><li><p>无线局域网：</p><ul><li>无线局域网可分为两大类，即有固定基础设施的和无固定基础设施的</li><li>无固定基础设施的无线局域网又叫做自组织(AD HOC)网络</li><li>有固定基础设施的无线局域网，使用无线接入点（AP）作为基础设施</li></ul></li><li><p>无线局域网主要采用了<strong>预约信道</strong>方法解决数据帧的碰撞问题</p></li></ul><h3 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h3><ul><li>网桥<ul><li>实现：<code>过滤数据帧</code>、<code>转发数据帧</code>、<code>拓展LAN</code>功能</li><li>工作在<strong>数据链路层</strong></li><li>可以访问同一个网络中站点的<strong>物理</strong>地址</li><li>透明网桥是通过查找端口—地址表来决定转发路径的，而端口—地址表是网桥通过<strong>自学习算法</strong>生成的</li><li>通过将帧中的<strong>目的结点的物理地址</strong>和自己地址表中的信息比较，实现帧的转发和过滤</li></ul></li><li>交换机根据<code>数据报</code>、<code>虚电路</code>、<code>源路由</code>选择分组转发时的输出端口</li></ul><h2 id="3-2-差错检测"><a href="#3-2-差错检测" class="headerlink" title="3.2 差错检测"></a>3.2 差错检测</h2><ul><li><p>二维奇偶校验</p><ul><li>奇偶校验码可以检查出奇数个比特错误</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200424.png" alt="image-20220103200424868" style="zoom:50%;" /></li></ul></li><li><p>循环冗余校验（CRC）</p><ul><li><p>M(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200819.png" alt="image-20220103200819939" style="zoom:50%;" /></li><li><p>C(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200844.png" alt="image-20220103200844704" style="zoom:50%;" /></li><li><p>P(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200907.png" alt="image-20220103200907613" style="zoom:50%;" /></li><li><p>判错条件：接收方判断P(x)是否可以整除C(x)</p></li><li><p>不同C(x)可以检测出特定的比特错误：</p><ul><li><p>所有1 &amp; 2-比特的错误</p></li><li><p>任意奇数个错误</p></li><li><p>任何小于k 比特的连续比特错误序列</p></li><li><p>部分大于 k 比特的连续比特错误序列</p></li></ul></li></ul></li><li><p>Internet校验和</p><ul><li>计算接受数据的校验和，并与发来的校验和字段内容比较是否一致</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151136.png" alt="image-20220103151136608" style="zoom: 33%;" /></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151200.png" alt="image-20220103151200255" style="zoom:33%;" /></li></ul></li></ul><h2 id="3-3-可靠传输机制"><a href="#3-3-可靠传输机制" class="headerlink" title="3.3 可靠传输机制"></a>3.3 可靠传输机制</h2><ul><li><p>基本方法：<code>确认ACK</code>、<code>定时器超时</code>、<code>帧序号</code></p></li><li><p>核心机制：<code>差错检测CRC</code>、<code>ACK确认</code>、<code>定时器</code>、<code>超时重传</code>、<code>帧序号</code>、<code>滑动窗口</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204529.png" alt="image-20220103204529325" style="zoom:50%;" /></li></ul><h3 id="自动请求重传（ARQ）机制"><a href="#自动请求重传（ARQ）机制" class="headerlink" title="自动请求重传（ARQ）机制"></a>自动请求重传（ARQ）机制</h3><ul><li>采用ACK确认和超时定时器的可靠传输机制</li><li>接收方<ul><li>对数据帧进行差错检测</li><li>对正确帧进行确认, 丢失错误帧</li><li>丢弃禁止接收的数据帧</li></ul></li><li>发送方<ul><li>发送原始数据帧</li><li>对错误帧和丢失帧进行重传</li></ul></li></ul><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul><li><p>最简单的ARQ机制</p></li><li><p>内容</p><ul><li>每发送完一个数据帧, 发送方在继续发送下一个数据帧之前必须等待确认</li><li>如果在一定的时间范围内，发送方未收到确认(ACK), 则发送定时器超时激发, 发送方重传原始数据帧</li></ul></li><li><p>两种不同的帧丢失情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103201722.png" alt="image-20220103201722314" style="zoom:50%;" /></li><li><p>使用帧序号的目的是<strong>处理重复帧</strong></p></li><li><p>缺点</p><ul><li>链路带宽利用率低</li></ul></li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul><li>采取流水线设计，允许未收到确认，连续发送数据帧</li></ul><h4 id="后退N帧（Go-Back-N）"><a href="#后退N帧（Go-Back-N）" class="headerlink" title="后退N帧（Go-Back-N）"></a>后退N帧（Go-Back-N）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202238.png" alt="image-20220103202238229" style="zoom:50%;" /></li></ul></li><li><p>优点: 接收方不需要缓存接收到的乱序帧，确认简单</p></li><li><p>缺点: 正确帧也可能被重传，效率较低</p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203815.png" alt="image-20220103203815365" style="zoom:67%;" /></li><li><p>例题：</p><ul><li><p>两台主机之间的数据链路层采用后退 N 帧协议传输数据，数据传输速率为 16kbps，单</p><p>向传播时延为 270ms，数据帧长度范围是 128-512 字节，接收方总是以与数据帧等长</p><p>的帧进行确认，为使信道利用率达到最高，帧序列的比特数至少为多少？</p><p>答：</p><p>&emsp;&emsp;即求从发送一个帧到接收到这个帧的确认为止的时间内最多可以发送数据帧的数量，对这个数量进行二进制编码所需的位数。</p><p>要尽可能多发帧，应以短的数据帧（传输时延短，发的快）计算，首先计算出发送一帧的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192243.png" alt="image-20220102192243529" style="zoom:50%;" /><p>发送一帧到收到确认的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103161327.png" alt="image-20220103161327331" style="zoom: 67%;" /><p>这段时间总共可以发送：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192351.png" alt="image-20220102192351213" style="zoom:50%;" /><p>发送10个左右的帧，编号至少需要4位二进制数，因此至少4比特。</p></li></ul></li></ul><h4 id="选择性重传（SR）"><a href="#选择性重传（SR）" class="headerlink" title="选择性重传（SR）"></a>选择性重传（SR）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>如果第k个帧丢失, 仅重传第k个帧</p></li><li><p>接收方对每一个帧进行确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202252.png" alt="image-20220103202252901" style="zoom:50%;" /></li></ul></li><li><p>优点: 链路利用率较高</p></li><li><p>缺点: 接收方更复杂</p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203849.png" alt="image-20220103203849702" style="zoom:67%;" /></li><li><p>存在问题</p><ul><li><p>无法区分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204012.png" alt="image-20220103204012029" style="zoom:50%;" /></li><li><p>解决方法：（k为序号数量）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204146.png" alt="image-20220103204146783" style="zoom:50%;" /></li></ul></li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><ul><li><p>引入滑动窗口对收发行为进行控制</p></li><li><p>基本思路</p><ul><li><p>发送方</p><ul><li><p>发送窗口大小: 发送方在未收到确认前能够发送的数据帧的最大个数</p></li><li><p>发送方在未收到确认前最多可以发送多个数据帧 (受限于 发送窗口大小)</p></li><li><p>对未确认的数据帧缓存</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203220.png" alt="image-20220103203220318" style="zoom:50%;" /></li></ul></li><li><p>接收方</p><ul><li><p>接收窗口大小: 接收方所能接收的乱序期望数据帧的最大个数</p></li><li><p>接收方通过ACK告知发送方下一次期望其传送的数据帧编号, 避免每次收到数据帧都发送确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203238.png" alt="image-20220103203238050" style="zoom:50%;" /></li></ul></li></ul></li><li><p>接收方行为</p><ul><li>接收数据帧<ul><li>如果一个数据帧到达(帧序号为SeqNum )</li><li>如果SeqNum ≤ LFR 或SeqNum &gt; LAF<ul><li>n数据帧落在接收窗口外, 则丢弃该数据帧</li></ul></li><li>如果LFR &lt; SeqNum ≤ LAF<ul><li>数据帧落在接收窗口内, 则接收</li></ul></li></ul></li><li>回复ACK<ul><li>SeqNumToAck = 未确认数据帧的最大SeqNum</li><li>接收方进确认 SeqNumToAck之前的数据帧, 即使更大序号的数据已接收</li><li>设置LFR = SeqNumToAck , 调整LAF = LFR + RWS</li></ul></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203742.png" alt="image-20220103203742576" style="zoom: 67%;" /></li><li><p>优点</p><ul><li>不仅保证帧在物理链路上的可靠传输</li><li>而且保证帧传输的顺序</li><li>支持流量控制，接收方通过反馈机制可以抑制发送方速率</li></ul></li></ul><h2 id="3-4-媒质接入控制（MAC协议）"><a href="#3-4-媒质接入控制（MAC协议）" class="headerlink" title="3.4 媒质接入控制（MAC协议）"></a>3.4 媒质接入控制（MAC协议）</h2><ul><li>解决多路访问问题的前提是：<strong>寻址</strong></li></ul><h3 id="静态信道划分MAC协议"><a href="#静态信道划分MAC协议" class="headerlink" title="静态信道划分MAC协议"></a>静态信道划分MAC协议</h3><ul><li>多路复用技术<ul><li>s时分复用（TDMA）</li><li>频分复用（FDMA）</li><li>码分复用（CDMA）</li><li>……</li></ul></li><li>网络负载重时效率高、公平，负载轻时效率低</li></ul><h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><ul><li>基本思想及特点<ul><li>信道不划分，允许冲突</li><li>采用冲突“恢复”机制</li><li>网络负载轻时效率高，负载重时冲突严重</li></ul></li></ul><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><ul><li>内容<ul><li>一旦数据帧到达, 立即发送 </li><li>如果发生冲突, 节点等待随机时间后重发数据直到发送成功</li></ul></li><li>效率 = 0.18</li></ul><h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><ul><li>内容<ul><li>当节点获得新的数据帧, 等待下一时隙到达开始发送</li><li>如果不存在冲突: 节点可以在下一时隙到达发送新的数据帧</li><li>如果发生冲突: 节点以概率p在每一个后续时隙内发送数据直到发送成功</li></ul></li><li>优点<ul><li>一个活跃节点可以持续以全速(信道带宽)发送数据帧</li><li>高度去中心化: 不需要中央调度</li><li>简单</li></ul></li><li>缺点<ul><li>存在冲突, 浪费时隙</li><li>存在空闲时隙</li><li>节点可能花费较长的时间进行冲突监测与退避重传</li><li>要求时钟同步</li></ul></li><li>效率 = 0.37</li></ul><h4 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h4><h5 id="普通CSMA"><a href="#普通CSMA" class="headerlink" title="普通CSMA"></a>普通CSMA</h5><ul><li><p>载波监听多路访问（Carrier Sensing Multiple Access）</p></li><li><p>内容</p><ul><li>发送前监听信道</li><li>如果信道空闲, 发送整个数据帧</li><li>如果信道忙, 延迟发送 </li></ul></li><li><p>冲突</p><ul><li><p>传播时延导致两个结点无法监听到对方的发送</p></li><li><p>导致整个数据帧被浪费</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103210353.png" alt="image-20220103210353350" style="zoom: 33%;" /></li></ul></li></ul><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><ul><li><p>要点：<code>冲突检测</code>、<code>多点接入</code>、<code>载波监听</code></p></li><li><p>机制：<strong>争用带宽</strong></p></li><li><p>内容</p><ul><li><p>边发边听，听到马上停止发送以减少信道浪费；不发就不听</p></li><li><p>有线局域网易实现；无线局域网难以实现（接收信号强度太低，无法与噪声区分）</p></li><li><p>为保证不发生碰撞，在传输时间内必须能收到最远端主机发送的信号（见下面最差冲突情况），即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102203719.png" alt="image-20220102203719361" style="zoom: 25%;" /></li></ul></li><li><p>冲突</p><ul><li><p>结点检测数据帧发送过程中是否发生冲突</p></li><li><p>如果发生冲突，则立即停止发送当前帧，改发送冲突信号广播通知其他结点，然后进行退避处理</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103224755.png" alt="image-20220103224755596" style="zoom: 50%;" /></li><li><p><strong>二进制退避算法</strong></p><ul><li>第k次冲突，则选择{0,1,2,…,2^k-1}中随机选择一个数乘以512bit，这个值对应的时延作为本次退避的等待时间</li><li>512bit对应51.2us，这是最初时最大覆盖以太网(2500米)往返最大时延</li></ul></li><li><p>冲突的最差情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225225.png" alt="image-20220103225225595" style="zoom: 67%;" /></li></ul></li><li><p>效率</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225357.png" alt="image-20220103225357197" style="zoom:50%;" /></li><li><p><strong>以太网</strong>MAC协议用的就是这个</p></li><li><p>计算题</p><p>在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1Gbps，电缆中的信号传播速度是200000km/s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要______？</p><p>答：</p><p>&emsp;&emsp;本题隐藏条件是应该在最坏情况下计算，这样才能保证一定免数据帧冲突问题：（）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102194429.png" alt="image-20220102194429684" style="zoom:50%;" /><p>&emsp;&emsp;设传输线路的长度是L，那么信号在电缆中传输一个来回的时间是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193852.png" alt="image-20220102193852730" style="zoom:50%;" /><p>&emsp;&emsp;设最短帧长度是：（最短帧长度 = 传播一个来回时间 * 传输速率）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193926.png" alt="image-20220102193926664" style="zoom:50%;" /><p>&emsp;&emsp;所以如果MIN减小了800bit，则对应L需要<strong>减小80m</strong>。</p><p>&emsp;&emsp;标准答案：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211555.png" alt="image-20220103211555710" style="zoom: 50%;" /></li></ul><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><ul><li><p>机制：<strong>预约带宽</strong></p></li><li><p>思想</p><ul><li>无线信道传输存在隐藏终端和信道衰落问题，导致难以进行碰撞检测</li><li>与CSMA/CD不同，CSMA/CA目标不是监测碰撞，而是避免碰撞</li></ul></li><li><p>内容</p><ul><li><p>发送端</p><ul><li>如果监听到信道空闲<ul><li>将在一个被称作分布式帧间间隔（DIFS）的短时间段后发送该帧</li></ul></li><li>如果监听到信道正忙 <ul><li>选取一个随机回退值计时</li><li>当信道空闲时递减该值</li><li>当计数值减为0时，该站点发送整个数据帧并等待确认</li><li>如果未收到确认，增加回退值，重复第2步</li></ul></li></ul></li><li><p>接收端</p><ul><li>如果数据帧接收成功<ul><li>在SIFS时间后返回确认信息（确认信息在隐藏终端问题中是必须的）</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103233916.png" alt="image-20220103233916031" style="zoom:50%;" /></li><li><p>虚拟载波监听（预约信道）</p><ul><li><p>在发送数据帧之前交换控制信息</p><ul><li><p>发送方 询问 “Request-to-Send” (RTS)，包括数据帧长度</p></li><li><p>接收方 广播 “Clear-to-Send” (CTS)</p></li></ul></li><li><p>如果发送方收到 CTS，则开始发送数据 (指定长度)</p></li><li><p>其他节点收到 CTS，则认定信道在指定长度数据帧发送期间处于繁忙状态</p></li><li><p>如果多个节点同时检测到一个空闲链路并试图发送一个RTS，那么他们的RTS帧将彼此冲突。当发送端在一段时间内没有收到CTS帧时，节点知道发生冲突，会<strong>等待一段随机时间后</strong>再试</p></li><li><p>RTS、CTS都很短，因此开销小，并且可以完全避免数据帧碰撞</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103234630.png" alt="image-20220103234630447" style="zoom:50%;" /></li></ul></li></ul></li><li><p><strong>无线局域网</strong>MAC协议用的就是这个</p><ul><li>不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>的原因<ul><li>无线信道传输中并非所有站点都能听见对方、无线介质传输特征复杂，无线信道传输存在隐藏终端、暴露终端等问题</li><li>无线信道传输难以同时收发，接收信号强度明显弱于发送信号</li></ul></li></ul></li></ul><h3 id="轮转MAC协议"><a href="#轮转MAC协议" class="headerlink" title="轮转MAC协议"></a>轮转MAC协议</h3><ul><li><p>特点</p><ul><li>结点轮流发送</li><li>待发送数据量大的节点占用信道更长时间</li><li>无冲突</li></ul></li><li><p>方式一：轮询</p><ul><li><p>主节点 “邀请” 从节点轮流发送数据</p></li><li><p>典型应用于“dumb” 从设备</p></li><li><p>关注点：轮询开销、时延、主节点失效</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211115.png" alt="image-20220103211115624" style="zoom:50%;" /></li></ul></li><li><p>方式二：令牌传递</p><ul><li><p>控制<strong>令牌</strong>在节点之间依序传递.</p></li><li><p>令牌帧</p></li><li><p>关注点：令牌开销、时延、令牌丢失</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211204.png" alt="image-20220103211204403" style="zoom:50%;" /></li><li><p>例：蓝牙、FDDI、令牌环网</p></li></ul></li></ul><h2 id="3-5-其他知识点"><a href="#3-5-其他知识点" class="headerlink" title="3.5 其他知识点"></a>3.5 其他知识点</h2><ul><li>IEEE802将数据链路层划分为两个子层，上为：<code>LLC</code>、下为：<code>MAC</code><ul><li>IEEE802 又称为LMSC（LAN /MAN Standards Committee， 局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）</li><li>IEEE802系列标准把数据链路层分成LLC（Logical Link Control，逻辑链路控制）和MAC（Media Access Control，媒介接入控制）两个子层。LLC子层在IEEE802.2标准中定义，为802标准系列共用；而MAC子层协议则依赖于各自的物理层</li></ul></li><li>10Mb/s和100Mb/s自适应系统是指：端口之间10Mb/s和100Mb/s传输率的自动匹配功能</li><li>局域网采用的拓扑结构包括：<code>总线型</code>、<code>星型</code></li><li>对于术语10base-T，base表示连接线上的信号时基带信号<ul><li>10base-T是双绞线以太网，1990年由IEEE新认可，编号IEEE802.3i，T表示采用双绞线，现10base-T采用的是非屏蔽双绞线（UTP）</li><li>技术指标<ul><li>数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Base表示基带传输，T代表双绞线</li><li>每段双绞线最大有效长度 100m，采用高质量的双绞线（5类线），最大长度可到<strong>150m</strong>(HUB与工作站间及两个HUB之间)</li><li>支持共享式和交换式两种组网方式</li><li>一条通路允许最大连接HUB数 4个</li><li>拓扑结构：星形或总线形</li><li>访问控制方式 CSMA/CD</li><li>帧长度可变，最大1518个字节</li><li>每个HUB可连接的工作站 96个</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络互联与路由器"><a href="#4-1-网络互联与路由器" class="headerlink" title="4.1 网络互联与路由器"></a>4.1 网络互联与路由器</h2><ul><li>网络层核心功能：转发+路由</li><li>面向无连接的IP协议的信息传输方式是：<code>数据报</code></li><li>路由器的功能<ul><li>解决异构网络之间的互联问题</li><li>路由选择</li><li>分组转发</li><li>数据分段</li><li>协议转换</li><li>数据封装</li><li>不包括流量控制</li></ul></li><li>路由器在能够开始向输出链路传输分组的第一bit之前，必须先接收到整个分组，这种机制称为：<strong>存储转发</strong></li><li><code>ARP</code>协议的作用是：将IP地址映射到数据链路层地址（MAC地址），反过来是<code>RARP</code></li><li>每台路由器都依赖<strong>ARP</strong>协议，否则无法正确工作</li><li><code>ARP</code>将IP地址转换为物理地址，<code>RARP</code>将物理地址转换为IP地址</li><li>路由器连接的<strong>异构网络</strong>指的是：<strong>数据链路层和物理层均不同</strong></li><li>路由器涉及Internet体系结构的<strong>网络接口层</strong>和<strong>网络层</strong></li><li>路由器可以隔离<code>ARP</code>广播帧</li><li><code>intranet</code>与<code>internet</code>互联，必须的互联设备是路由器</li><li>路由器 VS 交换机<ul><li>路由器第三层，交换机第二层</li><li>路由器：寻址，转发（依靠 IP 地址）<br>交换机：过滤，转发（依靠 MAC 地址）</li></ul></li></ul><h2 id="4-2-交换和桥接"><a href="#4-2-交换和桥接" class="headerlink" title="4.2 交换和桥接"></a>4.2 交换和桥接</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>定义<ul><li>有多个输入端和多个输出端的设备</li><li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口<ul><li>数据链路层交换机——交换——数据帧——mac地址</li><li>网络层交换机——转发——数据报datagram/数据包packet/分组——ip地址</li></ul></li><li>交换机各端口速率和交换机自身带宽一致，不论端口数量</li></ul></li><li>电路交换机（Circuit switch）<ul><li>不是直接相连的</li><li>每部电话连到一个交换设备：交换机</li><li>保证两部电话机建立单独的电路链接</li></ul></li><li>分组交换机（Packet switch）<ul><li>计算机连接到分组交换机</li><li>分组可从一台主机传输到另外一台主机</li><li>采取存储转发将分组从输入端口交换到正确的输出端口</li><li>每个端口发送速率和交换机本身带宽一直，相当于<strong>独占</strong>带宽</li></ul></li></ul><h3 id="交换网络"><a href="#交换网络" class="headerlink" title="交换网络"></a>交换网络</h3><ul><li><p>分类</p><ul><li><p>电路交换网络</p></li><li><p>分组交换网络：数据报、虚电路、源路由</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082156.png" alt="image-20220104082156187" style="zoom:50%;" /></li></ul></li></ul><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a><strong>数据报网络</strong></h4><ul><li>无连接</li><li>标识：每一个分组包含的目的地址</li><li>交换机决策：基于转发表<ul><li>交换机查询转发表确定分组的输出端口</li><li>转发表的构造与维护: 基于收集的桥接/路由信息</li></ul></li><li>数据报网络<ul><li>主机可以随时随地发送分组</li><li>主机无法知道网络是否可以传送该分组或目的主机是否可以接收</li><li>每个分组的转发均基于首部的目的地址, 分组之间相互独立</li><li>一台交换机或一条链路出现故障时, 并不会对通信产生任何严重的影响</li><li>实例：ARPnet</li></ul></li></ul><h4 id="虚电路（VC）网络"><a href="#虚电路（VC）网络" class="headerlink" title="虚电路（VC）网络"></a><strong>虚电路（VC）网络</strong></h4><ul><li><p>面向连接：预先建立连接</p></li><li><p>转发方式</p><ul><li><p>分组标识: 虚电路标识 (VCI)</p><ul><li>每一个分组包含一个 VCI</li></ul></li><li><p>交换机决策: 基于虚电路表</p><ul><li>交换机查询转发表确定分组的输出端口</li></ul></li><li><p>连接过程</p><ul><li>连接建立, 数据传输, 连接释放</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104074943.png" alt="image-20220104074943281" style="zoom:50%;" /></li></ul></li><li><p>虚电路的建立</p><ul><li>永久型虚电路（Permanent Virtual Circuit，PVC）<ul><li>网络管理员手工配置, 或由网络管理员产生信令探测形成</li><li>长期生存的虚电路</li></ul></li><li>交换型虚电路（Switched Virtual Circuit，SVC）<ul><li>主机动态发送信令建立连接</li><li>实际网络中SVC更为普遍</li><li>SVC信令<ul><li>建立<ul><li>源主机发送建立连接请求<ul><li>建立连接请求包含目的主机的完整地址</li></ul></li><li>中间交换机<ul><li>记录建立连接请求消息的输入端口</li><li>选择一个未使用的VCI值</li><li>确定输出端口</li><li>在虚电路表中插入一条记录</li><li>转发建立连接请求至下一个交换机</li></ul></li><li>目的主机<ul><li>选择一个可用的VCI值</li><li>沿着连接建立请求消息的路径反向发送确认消息</li></ul></li><li>中间交换机<ul><li>形成VC表记录</li></ul></li></ul></li><li>释放<ul><li>源主机发送释放连接消息</li><li>……</li></ul></li></ul></li></ul></li></ul></li><li><p>特点</p><ul><li>主机发送第一个数据分组前至少有一个RTT的时延, 用于连接建立</li><li>虽然建立连接请求包含目的主机的完整地址, 但每一个数据分组中仅带有一个很小的标识, 分组首部开销较小</li><li>如果一个连接上的交换机或链路出现故障, 连接就会被破坏, 需要建立新的连接</li><li>连接建立过程为虚电路提供了资源预留避免拥塞（对比：数据报网络是拥塞后恢复的策略）</li></ul></li></ul><h4 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a><strong>源路由</strong></h4><ul><li><p>源节点为每一个分组提供网络交换分组时所需的路由信息</p></li><li><p>源路由方法</p><ul><li>分组识别: 整条路径上所有交换机的端口序列<ul><li>分组首部包含从源节点到目的节点的整条路径的所有交换机的输出端口编号</li></ul></li><li>交换决策: 基于分组首部的路由<ul><li>交换机通过首部中的”下一个端口”指针读取下一个转发端口进行分组转发</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104075700.png" alt="image-20220104075700182" style="zoom:50%;" /></li><li><p>特点</p><ul><li>源节点知道全部的网络拓扑结构信息, 从而构造分组首部的源路由来指导交换机的分组转发</li><li>首部长度不固定, 由整条路径的跳数确定</li><li>源路由选择存在一个网络的规模性问题</li></ul></li></ul><h3 id="网桥和局域网交换机"><a href="#网桥和局域网交换机" class="headerlink" title="网桥和局域网交换机"></a>网桥和局域网交换机</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul><li>传统以太网局限性<ul><li>最多2500m的覆盖范围</li><li>最多容纳1024台主机</li></ul></li><li>拓展网络<ul><li>通过中继器再生放大信号</li><li>设计一种新的节点实现多个以太网之间的数据帧转发——&gt;网桥，有时通称为 以太网交换机</li></ul></li></ul><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><ul><li><p>是交换机的一种实现，实现了Ethernet的拓展</p></li><li><p>单一局域网的总通信量为10Mbps, 连接n个网桥的吞吐量最多能够达到<em>n</em> *10Mbps</p></li><li><p>在数据链路层拓展局域网使用网桥，在物理层拓展局域网使用转发器和集线器</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104081701.png" alt="image-20220104081701849" style="zoom:50%;" /></li></ul><h5 id="1-解决无脑全转发的问题：透明网桥"><a href="#1-解决无脑全转发的问题：透明网桥" class="headerlink" title="1. 解决无脑全转发的问题：透明网桥"></a>1. 解决无脑全转发的问题：透明网桥</h5><ul><li>网桥启动时, 转发表为空</li><li>通过<strong>逆向</strong>学习法构建<strong>端口—地址表</strong><ul><li>示例：洪泛法</li></ul></li><li>如果转发表中无对应记录, 则向所有其他端口转发数据帧</li><li>丢弃超时的记录(一段时间内未更新)，即 soft state</li><li>通过将帧中的目的结点的物理地址和自己地址表中的信息进行比较，实现帧的转发和过滤</li></ul><h5 id="2-解决网络环路问题：生成树算法"><a href="#2-解决网络环路问题：生成树算法" class="headerlink" title="2. 解决网络环路问题：生成树算法"></a>2. 解决网络环路问题：生成树算法</h5><ul><li>内容<ul><li>发送数据的源网桥的id</li><li>发送网桥认定的根网桥的id</li><li>从发送网桥到根网桥的距离 (跳数)</li><li>最初每个网桥认为自己是根节点</li><li>每个网桥生成配置消息并从每个端口发送出去</li><li>当网桥的某个端口收到新的配置消息后, 更新每个端口的配置消息</li><li>当网桥学习发现自己既不是根节点也不是指派节点时则停止发送配置信息</li><li>系统稳定时, 仅根网桥产生配置消息, 其他网桥仅在那些指派网桥的端口上转发这些配置消息</li><li>根节点周期性的发送配置消息</li><li>如果网桥在一段时间后仍未收到配置消息, 则重新宣布自己是根节点, 重新生成配置消息并转发</li></ul></li></ul><h5 id="3-解决广播和多播问题"><a href="#3-解决广播和多播问题" class="headerlink" title="3. 解决广播和多播问题"></a>3. 解决广播和多播问题</h5><ul><li>问题<ul><li>上述仅考虑了网桥的单播数据帧 </li><li>网桥的目标是透明的扩展局域网, 必须支持广播和多播</li></ul></li><li>解决<ul><li>广播：每个网桥将带有目标广播地址的数据帧传到除了接收它的端口以外的其他活动(选择)的端口</li><li>多播：扩展生成树算法用来裁减掉那些不需要转发多播帧的网络</li></ul></li></ul><h5 id="4-解决拓展性问题：虚拟局域网VLAN"><a href="#4-解决拓展性问题：虚拟局域网VLAN" class="headerlink" title="4. 解决拓展性问题：虚拟局域网VLAN"></a>4. 解决拓展性问题：虚拟局域网VLAN</h5><ul><li>拓展性差<ul><li>当连接网段的数量增加时, 生成树算法扩展性存在局限性</li><li>在一个大规模的网络中, 广播帧会影响网络的性能</li></ul></li><li>解决：虚拟局域网VLAN<ul><li>每一个虚拟局域网分配一个标识符</li><li>只有两个网段的标识符相同时, 才能完成数据帧的转发</li></ul></li></ul><h5 id="网桥-VS-交换机"><a href="#网桥-VS-交换机" class="headerlink" title="网桥 VS 交换机"></a>网桥 VS 交换机</h5><ul><li>网桥一般只有2个输入或输出端口，交换机有多个</li><li>网桥里的 MAC 地址表则是一个端口对应多个地址，交换机里则是一个端口对应一个 MAC 地址</li></ul><h3 id="共享式VS交换式以太网"><a href="#共享式VS交换式以太网" class="headerlink" title="共享式VS交换式以太网"></a>共享式VS交换式以太网</h3><h4 id="设备对比"><a href="#设备对比" class="headerlink" title="设备对比"></a>设备对比</h4><ul><li>共享式以太网：集线器Hub</li><li>交换式以太网：交换机Switch</li><li>以太网集线器——&gt;网桥——&gt;交换机<ul><li>集线器：在共享媒介局域网的核心设备，CSMA/CD</li><li>网桥：早期版本的交换机，用于局域网扩展，在不同网段之间转发数据帧</li><li>交换机：每个端口是个网桥，端口之间转发数据帧，不同端口之间可以传输隔离</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082122.png" alt="image-20220104082122447" style="zoom:50%;" /><h4 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h4><ul><li>共享式：共享带宽，用CSMA/CD应对冲突</li><li>交换式：除非两个源端口发往同一目的端口，否则不存在冲突（专用带宽）</li></ul><h2 id="4-3-IP服务模型与协议"><a href="#4-3-IP服务模型与协议" class="headerlink" title="4.3 IP服务模型与协议"></a>4.3 IP服务模型与协议</h2><ul><li><p>IP协议提供的服务类型是：<strong>无连接的数据报服务</strong></p><ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li></ul></li><li><p>为了防止IP数据报在Internet上无限制地传递，告知路由器是否应该丢弃某个数据报，在IP数据报首部设置了<code>生存时间TTL</code>字段</p></li><li><p>IP服务模型</p><ul><li><p>数据报传输</p><ul><li><p><strong>尽力而为</strong>的不可靠传输服务</p></li><li><p>数据报的路由选择与转发</p><ul><li>无连接方式</li></ul></li><li><p>分段与重组</p><ul><li><p>最大传输单元MTU</p><ul><li><p>是链路层数据可封装数据的上限，不同链路不同</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103103928.png" alt="image-20220103103928162" style="zoom: 33%;" /></li><li><p>大IP分组向较小MTU链路转发时，可以被分片，用IP首部相关字段标识分片的序号</p></li></ul></li><li><p>IP数据报分片发生在<strong>路由器</strong>，而重组发生在<strong>目的主机</strong></p></li><li><p>如果某一个分段丢失, 目的主机将放弃重组进程并丢弃已收到的分段</p></li><li><p>计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104114.png" alt="image-20220103104114780" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104156.png" alt="image-20220103104156874" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104222.png" alt="image-20220103104222098" style="zoom: 33%;" /></li></ul></li></ul></li></ul></li></ul><h2 id="4-4-IP地址及其划分"><a href="#4-4-IP地址及其划分" class="headerlink" title="4.4 IP地址及其划分"></a>4.4 IP地址及其划分</h2><h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><ul><li><p>IP地址是网络层中识别主机的<code>逻辑地址</code></p></li><li><p>层次化寻址：两级地址空间（网络号+主机号）</p></li><li><p>网络地址</p><ul><li>IP地址的网络号唯一标识一个网络</li><li>在同一个局域网上的主机或路由器的IP地址中的网络号必须一样</li><li>用网桥互连的网段仍然是一个局域网，只能有一个网络号</li><li>路由器总是具有两个或以上的IP地址</li><li>IP地址不能直接用来通信，在实际网络的链路上传送数据必须使用硬件地址（MAC）</li></ul></li><li><p>主机没有IP地址但要加入网络时，使用<code>DHCP</code>；主机发送数据但不知目的主机的硬件地址时，使用<code>ARP</code>；数据报传输过程中出现差错时，使用<code>ICMP</code></p></li></ul><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><ul><li><p>有类IP地址</p><ul><li><p>A类网络IP地址范围：1.0.0.1 - 127.255.255.254（<code>16777216-2</code>个主机/子网，2^24）</p></li><li><p>B类网络IP地址范围：128.0.0.1 - 191.255.255.254（<code>65536-2</code>个主机/子网，2^16）</p></li><li><p>C类网络IP地址范围：192.0.0.1 - 223.255.255.254（<code>256-2</code>个主机/子网，2^8）</p></li><li><p>D类网络IP地址范围：224.0.0.1 - 239.255.255.254（只用于多播）</p></li><li><p>E类网络IP地址范围：240.0.0.1 - 255.255.255.254（留给未来使用）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104634.png" alt="image-20220103104634464" style="zoom: 33%;" /></li></ul></li><li><p>私有IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104904.png" alt="image-20220103104904787" style="zoom: 25%;" /></li></ul><h3 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h3><ul><li><p>网络号与主机号</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104547.png" alt="image-20220103104547071" style="zoom: 33%;" /></li><li><p>特殊IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104827.png" alt="image-20220103104827382" style="zoom:33%;" /></li><li><p>子网划分</p><ul><li><p>IP地址：原本的主机号高位比特改为子网号（SubID）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105116.png" alt="image-20220103105116448" style="zoom:25%;" /></li><li><p>子网掩码：NetID、SubID位全取1，用于表示利用多少位划分子网</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105245.png" alt="image-20220103105245490" style="zoom:33%;" /><ul><li><p>用于确定子网IP信息：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105333.png" alt="image-20220103105333288" style="zoom:33%;" /></li></ul></li><li><p>划分子网时，优先分配<strong>较大</strong>的子网</p></li><li><p>一个C类网络子网划分例子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105529.png" alt="image-20220103105529431" style="zoom:33%;" /></li><li><p>IP子网寻址示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085055.png" alt="image-20220104085055931" style="zoom:50%;" /></li><li><p>切记，子网中网络地址（全0）和广播地址（全1）占用了2个地址，因此子网主机数量实际上是<strong>可用主机号数量加2</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085338.png" alt="image-20220104085338005" style="zoom: 50%;" /></li><li><p>已知网络类型和子网掩码，计算子网和主机数</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104150405.jpg" alt="img" style="zoom: 25%;" /><p>B类有16位（后16位）的主机位，依题，其中前10（8+2）位用作子网号，则子网有2^10=1024个，主机有2^6-2=62个</p></li></ul></li><li><p>优点</p><ul><li>提高了地址分配效率，加入一个新的物理网络时不需要用光B类或C类网络的所有地址</li><li>有利于信息聚合，减少路由器为了转发数据报到这些网络所需存储的信息量</li></ul></li></ul><h3 id="无分类编址CIDR与路由聚合"><a href="#无分类编址CIDR与路由聚合" class="headerlink" title="无分类编址CIDR与路由聚合"></a>无分类编址CIDR与路由聚合</h3><ul><li>CIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号，消除传统的A、B、C类网络地址界限</li><li>CIDR将网络前缀都相同的连续IP地址组成CIDR地址块</li><li>融合子网地址与子网掩码，方便子网划分<ul><li><p>无类地址格式：<code>a.b.c.d/x</code>，其中x是前缀长度（子网掩码里1的个数）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103110934.png" alt="image-20220103110927258" style="zoom: 33%;" /></li></ul></li><li>优点<ul><li><p>提高IPv4地址空间分配效率</p></li><li><p>提高路由效率，减少了路由表和转发表的记录数量（这是子网划分处理不了的）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103111123.png" alt="image-20220103111123578" style="zoom:33%;" /></li></ul></li><li>最长前缀匹配优先<ul><li><p>在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口</p></li><li><p>使用CIDR查找路由表时可能会得到多个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，路由就越具体</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104145741.jpg" alt="Screenshot_20220104-145630_Superstar" style="zoom: 25%;" /></li></ul></li></ul><h3 id="地址转换协议（ARP）"><a href="#地址转换协议（ARP）" class="headerlink" title="地址转换协议（ARP）"></a>地址转换协议（ARP）</h3><ul><li>给定目的主机的IP地址, ARP可以找到同属一个物理网络内部的目的主机的物理地址</li><li>ARP采用<strong>广播机制</strong>，路由器可以隔绝ARP广播</li><li>每一个主机维护一个ARP表：<ul><li>并不是由一个服务器来负责回答请求，而是“自给自足”</li><li>15分钟记录未更新则超时失效</li></ul></li><li>当ARP表中无目的IP地址的对应记录，则ARP协议开始启动</li><li>工作原理<ul><li>主机X广播一个 ARP请求报文来探寻未知的节点D的IP地址</li><li>节点D 向源节点反馈其物理地址<ul><li>D节点 在本地ARP表中增加或更新节点X对应的记录</li></ul></li><li>节点X将收到的信息写入其ARP表</li><li>同一网络内的其他主机<ul><li>如果本地的ARP表中已存在节点X的IP地址对应的记录, 则更新记录</li><li>否则，do nothing</li></ul></li></ul></li></ul><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><ul><li><p>DHCP协议在应用层实现，借助UDP数据报在链路层广播</p></li><li><p>DHCP允许主机自动从服务器获取：IP地址、子网掩码、默认网关地址、DNS服务器与IP地址</p></li><li><p>即插即用</p></li><li><p>允许地址重复使用</p></li><li><p>支持在用地址续租</p></li><li><p>支持移动用户加入网络</p></li><li><p>DHCP服务器会给出包含配置参数的提议供主机选择</p></li><li><p>新到主机（DHCP客户）获取IP地址的过程：</p><ul><li><p>主机广播：“DHCP discover”</p></li><li><p>DHCP服务器利用“DHCP offer”进行响应</p></li><li><p>主机请求IP地址：“DHCP request”</p></li><li><p>DHCP服务器分配IP地址：“DHCP ack”</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103135749.png" alt="image-20220103135749025" style="zoom: 33%;" /></li></ul></li></ul><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><ul><li><p>网络地址转换（NAT）</p></li><li><p>实现<code>本地设备IP地址</code>和<code>与外界通信时所用IP地址</code>之间的转换</p></li><li><p>本地网络内不同设备有不同IP地址，但是在对外交流时使用<strong>同一NAT IP地址</strong>的<strong>不同端口号</strong></p></li><li><p>内部网络设备对外界网络不可见，即外界无法直接寻址（安全）</p></li><li><p>本地网络IP地址的变更无需通告外界网络</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103140400.png" alt="image-20220103140400114" style="zoom:33%;" /></li></ul><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><ul><li><p>互联网控制报文协议（ICMP）</p></li><li><p><code>ping</code>发出的是ICMP报文，目的IP回复对应ICMP报文，用于检测网络连通性</p></li><li><p><code>traceroute</code>发出TTL=1的数据包，第一个接收到路由器回回传ICMP报文（TTL=0），然后<code>traceroute</code>发出TTL=2的数据包给第二个路由器，递推得到到达目的节点所经过的路由器序列</p></li><li><p>支持主机或服务器：差错检测、网络探寻</p></li><li><p>ICMP差错报文</p><ul><li><p>终点不可达</p><ul><li>终点不可达分为：网络不可达、主机不可达、协议不可达、端口不可达、需要分片但DF比特已置1、源路由失败，共6种情况，向源站发送对应的代码字段0~5的不可达报文</li></ul></li><li><p>端口不可达</p><ul><li>UDP的规则之一是：如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP报文</li></ul></li><li><p>源站抑制：</p><ul><li>当路由器或主机由于拥塞而丢弃数据报时，就向源站发送源站抑制报文，使源站知道应当将数据报发送速率放慢</li></ul></li><li><p>时间超时</p><ul><li>当路由器收到生存时间TTL为0的数据报时，除了丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送超时报文</li></ul></li><li><p>参数问题</p><ul><li>当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文</li></ul></li><li><p>改变路由（重定向）</p><ul><li>将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器</li></ul></li></ul></li><li><p>以下几种数据报不会导致产生ICMP差错报文：</p><ul><li>ICMP差错报文（但是ICMP查询报文可能会产生ICMP差错报文）</li><li>目的地址是广播地址或多播地址的数据报</li><li>作为链路层广播的数据报</li><li>不是IP分片的第1片</li><li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址</li></ul></li><li><p>ICMP网络探寻报文</p><ul><li>回声（Echo）请求与应答（Reply）报文</li><li>时间戳请求与应答报文</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul><li><p>RFC2373中详细定义了IPv6地址，按照定义，一个完整的IPv6地址的表示法：xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx<br>例如：2031:0000:1F1F:0000:0000:0100:11A0:ADDF（4位×8段）</p><p>为了简化其表示法，rfc2373提出<strong>每段中前面的0可以省略</strong> ；<strong>连续的0可省略为”::”，但只能出现一次</strong>。例如：</p><table><thead><tr><th>原地址</th><th>简写</th></tr></thead><tbody><tr><td>1080:0:0:0:8:800:200C:417A</td><td>1080::8:800:200C:417A</td></tr><tr><td>FF01:0:0:0:0:0:0:101</td><td>FF01::101</td></tr><tr><td>0:0:0:0:0:0:0:1</td><td>::1</td></tr><tr><td>0:0:0:0:0:0:0:0</td><td>::</td></tr></tbody></table></li><li><p>数据格式</p><ul><li>定长40字节报头</li><li>不允许片段</li></ul></li><li><p>IP隧道（IPv4向IPv6过渡）</p><ul><li><p>IPv4路由器中IPv6数据报作为IPv4数据报的负载</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104101322.png" alt="image-20220104101322686" style="zoom:50%;" /></li></ul></li></ul><h2 id="4-5-路由算法与协议"><a href="#4-5-路由算法与协议" class="headerlink" title="4.5 路由算法与协议"></a>4.5 路由算法与协议</h2><h3 id="转发-VS-路由"><a href="#转发-VS-路由" class="headerlink" title="转发 VS 路由"></a>转发 VS 路由</h3><ul><li><p>转发（数据平面）</p><ul><li>过程：获得一个分组, 查看其目的地址，查询本地转发表，将分组从输出端口发送出去</li><li>节点(路由器/交换机)本地执行</li></ul></li><li><p>路由（控制平面）</p><ul><li>转发表的构建过程</li><li>通常由基于复杂分布式算法的路由协议完成</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104084242.png" alt="image-20220104084242379" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104090244.png" alt="image-20220104090244257" style="zoom: 67%;" /></li></ul><h3 id="距离向量（DV）路由选择"><a href="#距离向量（DV）路由选择" class="headerlink" title="距离向量（DV）路由选择"></a>距离向量（DV）路由选择</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>与路由器直接连接的网络的距离值为0</li><li>每个节点构造一个包含到所有其他节点的”距离”(代价)的一维数组(一个向量)</li><li>并将该向量分发给其邻节点</li><li>节点根据接收到的距离向量计算到达其他所有节点的最短路径</li><li>经过距离向量的迭代交换和计算过程最终构造完整的路由表</li><li>注意，只能找到去每个网络的最短路径中的一条，不能所有都找到</li></ul></li><li><p>步骤</p><ul><li><p>步骤1：最初节点将向量中可直接到达的邻节点的代价设置为<strong>1</strong>，到所有其他节点的代价赋值为<strong>∞</strong></p></li><li><p>步骤2：节点将距离向量发送至直接可达的邻节点</p></li><li><p>步骤3：根据从邻节点<strong>Y</strong>收到的距离向量，节点<strong>X</strong></p><ul><li>计算本节点到达所有其他节点的距离：将来自<strong>Y</strong>的向量中到达所有其他节点的距离(例如 <strong>Z</strong>)加上本节点到<strong>Y</strong>的距离 (即<strong>1</strong>）</li><li>比较计算结果与本地向量中对应结果的大小：如果计算结果更小，则用该值替换本地距离向量的对应结果，并记录NextHop 为<strong>Y</strong></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091156.png" alt="image-20220104091156375" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091222.png" alt="image-20220104091222480" style="zoom:50%;" /></li></ul></li><li><p>链路代价变化</p><ul><li>节点检测到本地链路代价改变 </li><li>更新路由信息，重新计算距离矢量</li><li>如果DV发生改变，通知相应的邻居</li></ul></li><li><p>无穷计算问题</p><ul><li><p>场景</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091516.png" alt="image-20220104091516434" style="zoom:50%;" /></li><li><p>方案A：采用最大跳数取代无穷大</p></li><li><p>方案B：水平分割</p><ul><li>不向提供路由的邻节点发送更新报文</li><li>例如：节点B不向节点A发送有关节点E的更新信息，因为节点B到达节点的用路由是从节点学习而来的</li></ul></li><li><p>方案C：带反向抑制的水平分割</p><ul><li>节点B通告到达节点E的代价为无穷大，以确保节点A最终不会使用节点B来到达节点E</li></ul></li><li><p>上述解决方案在路由循环超过3节点的网络环境中网络会失效</p></li></ul></li></ul><h4 id="路由选择信息协议（RIP）"><a href="#路由选择信息协议（RIP）" class="headerlink" title="路由选择信息协议（RIP）"></a>路由选择信息协议（RIP）</h4><ul><li>基于距离向量算法</li><li>30s更新一次距离向量</li><li>跳数最大值为15，16意味无穷大</li></ul><h3 id="链路状态（LS）路由选择"><a href="#链路状态（LS）路由选择" class="headerlink" title="链路状态（LS）路由选择"></a>链路状态（LS）路由选择</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>每个节点都知道怎样到达它的邻节点(link state), 并向通告给其他所有节点, 因此<strong>每个节点都可以获得完整的网络信息</strong>来建立其路由表</li><li>链路状态的度量可以是：距离、带宽、时延、费用等</li></ul></li><li><p>依赖链路状态的<strong>可靠洪范</strong></p><ul><li>链路状态报文(Link State Message)<ul><li>链路状态分组, LSP (Link State Packet)</li><li>创建LSP的节点ID</li><li>与该节点直接相邻的节点信息列表 &lt;AdjacentNode, Cost&gt;, 其中包括到这些邻节点的链路代价</li><li>序号 Seq</li><li>LSP的生命周期</li></ul></li><li>保证链路状态分组的洪泛<ul><li>采用确认和重传机制</li><li>通过序号</li><li>不发回发送LSP的节点</li></ul></li><li>新的链路状态分组快速洪泛, 旧的分组快速被删除<ul><li>采用序列号和TTL</li><li>长序列号</li><li>逐跳递减TTL</li></ul></li><li>链路状态洪泛的触发器<ul><li>周期性计时器超时</li><li>拓扑结构变化</li></ul></li></ul></li><li><p>路由计算（基于Dijkstra算法）</p><ul><li><p>算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092709.png" alt="image-20220104092709471" style="zoom: 67%;" /></li><li><p>示例1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092448.png" alt="image-20220104092448663" style="zoom:50%;" /></li><li><p>示例2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103100722.png" alt="image-20220103100722586" style="zoom: 33%;" /></li></ul></li><li><p>算法分析</p><ul><li>时间复杂度：O(n^2)，可优化为O(nlogn)</li><li>可能存在路由震荡（无穷计算）</li><li>优点<ul><li>快速稳定</li><li>不会产生过多的通信量</li><li>快速响应拓扑变化</li></ul></li><li>缺点<ul><li>节点存储的信息量大(所有其他节点的LSP)</li></ul></li></ul></li><li><p>如果在一个使用链路状态路由的互联网络中有5个路由器和6个网络，那么存在<code>5</code>个路由表，每个表中至少有<code>6</code>个表项，在路由器中存在<code>1</code>个不同的链路状态数据库</p></li><li><p>链路状态 VS 距离向量</p><ul><li>链路状态：每个节点只告诉所有其他节点与之<strong>相邻</strong>的链路状态</li><li>距离向量：每个节点只与直接相连的节点通信，但是包含到达<strong>所有</strong>节点的距离</li></ul></li></ul><h4 id="开放最短路径优先（OSPF）"><a href="#开放最短路径优先（OSPF）" class="headerlink" title="开放最短路径优先（OSPF）"></a>开放最短路径优先（OSPF）</h4><ul><li>基于链路状态算法</li><li>高级特征（RIP没有）<ul><li>安全性：所有OSPF报文需要认证 (避免恶意入侵)</li><li>允许多条相同代价的路径存在 (RIP中仅允许一条路径)</li><li>对一条链路而言，可以依据不同的TOS分配不同的代价值(例如：卫星链路从实时性考虑代价较大, 但从尽最大努力交付能力来说代价较小)</li><li>支持单播和多播<ul><li>多播OSPF (MOSPF)使用与OSPF相同的拓扑数据</li></ul></li><li>在一个较大的域内采用<strong>层次化</strong>OSPF</li></ul></li><li>OSPF协议将一个自治域划分成若干区域，有一种特殊区域叫做主干区域<ul><li>域之间通过边界路由器互联</li><li>在自治系统中有4中路由器：区域内部路由器、主干路由器、区域边界路由器、自治域边界路由器</li><li>主干路由器可以兼做区域边界路由器</li></ul></li></ul><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Internet将整个网络划分为许多较小单位AS：由同一个管理机构管理，使用统一的路由策略的路由器的集合</li><li>每一个自治系统(AS)在一个独立的管理实体的控制之下<ul><li>示例：校园网络、公司网络</li></ul></li><li>由此，路由协议也分为两大类：<strong>内部网关协议IGP</strong>、<strong>外部网关协议EGP</strong></li></ul><h4 id="内部网关协议（IGP）"><a href="#内部网关协议（IGP）" class="headerlink" title="内部网关协议（IGP）"></a>内部网关协议（IGP）</h4><ul><li>内部网关协议（Interior Gateway Protocol）是一个在自治网络内部网关（主机和路由器）间交换路由信息的协议。路由信息用于网间协议（IP）或者其他网络协议来说明路由传送是如何进行的</li><li>包括：RIP、OSPF、IS-IS、IGRP、EIGRP等</li><li>选路原则：优先级、开销、负载均衡</li><li>典型协议<ul><li>RIP协议<ul><li>RIP协议是一种内部网关协议，底层是贝尔曼福特算法，是一种动态路由选择协议。</li><li>基于<strong>距离向量</strong>算法，使用跳数来衡量到达目标地址的路由距离</li><li>运行在<strong>UDP</strong>协议之上，使用520端口，使用224.0.0.9作为组播地址向外组播路由信息</li><li>以跳数作为选择路由的度量标准，只适用于<strong>小区域</strong></li><li>通过广播UDP报文来交换信息，<strong>30s</strong>发送一次路由信息更新</li><li>最多支持的跳数为15，16及以上就表示为不可达</li><li>要求路由器维护从它到每个内部路由器的距离向量</li><li>使用<strong>毒性逆转</strong>法预防乒乓环路无穷计算，设置无穷大距离为16</li></ul></li><li>OSPF协议<ul><li>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议</li><li>基于<strong>链路状态</strong>路由协议</li><li>运行于<strong>IP</strong>协议之上</li><li>允许使用多条相同费用的路径（RIP只能选择一条）</li><li>以带宽、延迟作为选择路由的度量标准，适用于<strong>大中型</strong>网络</li></ul></li></ul></li></ul><h4 id="外部网关协议（EGP：BGP）"><a href="#外部网关协议（EGP：BGP）" class="headerlink" title="外部网关协议（EGP：BGP）"></a>外部网关协议（EGP：BGP）</h4><ul><li>外部网关协议（Exterior Gateway Protocol）是AS之间使用的路由协议，目前只有一个协议：BGP</li><li><strong>边界网关（BGP）协议</strong><ul><li>运行于<strong>TCP</strong>基础上</li><li>属于域间路由选择，“把互联网粘合在一起”</li><li>基于<strong>路径向量</strong>算法（不使用距离向量（收敛慢）、链路状态（强迫告知敏感信息，不安全））<ul><li>支持灵活的路由策略（商业要求）</li><li>避免无穷计算</li><li>核心思想: 通告整个路径<ul><li>路由表要包括分组到达目的网络的路径</li><li>所交换的网络可达性信息是：<strong>到达某个网络所经过的路径</strong></li></ul></li></ul></li><li>使用<strong>TCP</strong>作为传输层协议</li><li>内容：<ul><li>节点知道多条到达目的地的路径<ul><li>在路由表中存储所有的路由</li><li>采用策略选择一条最好的路由</li></ul></li><li>增量更新<ul><li>通告<ul><li>一旦选择一条新的路由, 则将节点id加入路径向量</li><li>… 并(有选择性的)通告其他邻居</li></ul></li><li>撤销<ul><li>如果路由不再有效</li><li>… 发送撤销路由消息</li></ul></li></ul></li></ul></li><li>主要功能是和其他的 BGP 系统交换网络可达信息</li><li>BGP的邻居关系（或称通信对端/对等实体）是通过人工配置实现的，对等实体之间通过TCP（端口179)会话交互数据</li><li>BGP路由器会周期地发送19字节的保持存活keep-alive消息来维护连接（默认周期为30秒）</li><li>热土豆路由<ul><li>有多个网关路由器可以到达目的子网时，选择最小费用路径的区域间路由器</li></ul></li></ul></li></ul><p><strong>直接封装RIP、OSPF、BGP报文的协议分别为：UDP、IP、TCP</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>又称为 组播，与一组主机进行通信，指多个接收者可以收到同一个或者同一组源节点发送的相同内容的分组</li><li>避免单播的低效和广播的无区分性</li><li>发送主机使用多播地址发送分组时不需要了解接收者的位置信息和状态信息</li><li>组播协议（IGMP）<ul><li>IGMP协议运行于主机与组播路由器之间，这描述了IGMP的应用场景</li><li>只有主机和路由器才会使用，如果是路由器和路由器之间，是不会使用IGMP的</li><li>IGMP提供了在转发组播数据包到目的地的最后阶段所需的信息，实现如下双向的功能：<ol><li>主机通过IGMP通知路由器希望接收或离开某个特定组播组的信息</li><li>路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护</li></ol></li></ul></li></ul><h4 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h4><ul><li>ISP使用</li><li>解决BGP的路由黑洞问题</li></ul><h4 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h4><ul><li>目的地址为家乡地址的IP分组，将会以标准的IP路由机制发送到家乡网络</li><li>家乡链路与外地链路比家乡网络与外地网络更精确地表示出移动结点接入点位置</li><li>家乡代理通过隧道将发送给移动节点的 IP 分组转发给移动节点</li><li>终端系统处理<ul><li>间接选路: 从通信者到漫游节点的通信，通过本地代理，然后被转发到漫游网络</li><li>直接选路: 通信者获得漫游节点的外部地址/转交地址, 直接发送给漫游节点</li></ul></li><li>三角路由（间接选路）<ul><li>通信者-本地网络-漫游节点</li></ul></li></ul><p>&nbsp;</p><h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><ul><li><p>网络层负责主机到主机的通信，传输层负责进程到进程的通信</p></li><li><p>基本理论和基本机制</p><ul><li><p>发送端多路复用，接收端解复用</p></li><li><p>复用/解复用</p><ul><li>无连接的解复用：UDP的Socket，用二元组（目的IP地址，目的端口号）标识</li><li>面向连接的解复用：TCP的Socket，用四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识</li></ul></li><li><p>可靠数据传输机制</p><ul><li>差错检测（校验和）</li><li>确认机制（含序号分组和ACK）</li><li>确认重传机制（ARQ协议）</li><li>停—等协议——&gt;流水线机制——&gt;滑动窗口协议：后退N帧（GBN）、选择性路由（SR）</li></ul></li></ul></li><li><p>TCP/IP协议族的层次中，解决计算机之间通信问题是在<strong>网络层</strong></p></li><li><p>在OSI参考模型中，提供流量控制功能的是：<strong>数据链路层</strong>、<strong>传输层</strong></p></li></ul><h2 id="5-2-用户数据报（UDP）协议"><a href="#5-2-用户数据报（UDP）协议" class="headerlink" title="5.2 用户数据报（UDP）协议"></a>5.2 用户数据报（UDP）协议</h2><ul><li>关于UDP的描述<ul><li>发送数据之前不需要建立连接（减少延迟）</li><li>没有拥塞控制，应用可以更好地控制发送时间和速率</li><li>相对于IP数据报服务，UDP在IP之上只增加了<strong>端口</strong>的功能和<strong>差错检测</strong>功能（校验和，checksum）</li><li>UDP用户数据报只能提供不可靠的交付，可能乱序、丢失</li></ul></li><li>关于端口的描述<ul><li>端口就是传输层服务访问点</li><li>端口号只具有本地意义，在Internet中不同计算机的相同端口号是没有联系的</li><li>Socket由IP地址和端口号组成</li></ul></li><li>UDP协议中，伪首部的作用是：为差错检测提供帮助</li><li>为解决UDP报文的可靠传输问题：<ul><li>在应用层增加可靠性机制</li><li>应用特定的错误恢复机制</li></ul></li><li>优点<ul><li>控制数据发送的内容和时间</li><li>不存在连接建立时延</li><li>无状态连接</li><li>报文首部开销较小</li></ul></li><li>缺点<ul><li>不保证报文的传送, 可能出现乱序到达</li><li>无拥塞控制</li><li>抑制TCP流</li></ul></li><li>应用<ul><li>域名解析系统：DNS</li><li>多媒体应用</li></ul></li></ul><h2 id="5-3-可靠字节流（TCP）协议"><a href="#5-3-可靠字节流（TCP）协议" class="headerlink" title="5.3 可靠字节流（TCP）协议"></a>5.3 可靠字节流（TCP）协议</h2><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><ul><li>面向连接<ul><li>终端主机在数据交换之前需要连接连接</li><li>全双工：数据可双向传输</li></ul></li><li>可靠性<ul><li>保证数据的传送</li><li>数据按序到达</li></ul></li><li>流量控制<ul><li>控制发送方的速率避免接收方过载</li><li>在链路层也存在流量控制</li></ul></li><li>拥塞控制<ul><li>控制发送方速率避免网络过载</li><li>拥塞控制由网络层和传输层协作解决</li></ul></li></ul><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><ul><li><p>Client发送建立连接请求（SYNbit=1，Seq=x）至Server</p></li><li><p>Server回复确认前序请求（ACKbit=1，ACKnum=x+1），同时请求（SYNbit=1，Seq=y）</p></li><li><p>Client回复确认前序请求（ACKbit=1，ACKnum=y+1）</p></li><li><p>为什么三次握手？</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104103543.png" alt="image-20220104103543736" style="zoom: 67%;" /></li></ul><h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><ul><li>Client发送连接断开请求（FINbit=1，Seq=u）至Server</li><li>Server回复确认前序请求（ACKbit=1，ACKnum=u+1），同时继续发送待传输数据（Swq=v）</li><li>Server等待上层应用数据传输完毕之后，Server重复确认前序请求（ACKbit=1，Seq=u+1），同时发送连接断开请求（FINbit=1，Seq=w）</li><li>Client回复确认前序请求（ACKbit=1，ACKnum=w+1，Seq=u+1），继续等待2<code>MSL</code>时间后关闭</li></ul><h2 id="5-4-TCP滑动窗口算法"><a href="#5-4-TCP滑动窗口算法" class="headerlink" title="5.4 TCP滑动窗口算法"></a>5.4 TCP滑动窗口算法</h2><ul><li><p>TCP采用改进的滑动窗口算法实现：</p><ul><li>保证数据的可靠传送</li><li>确保数据的有序传送</li><li><strong>流量控制</strong> (基于变化的 AdvertisedWindow 字段)</li></ul></li><li><p>滑动窗口算法采用变化的接收窗口大小</p><ul><li><p>接收方通知发送方其窗口大小，该值可能随时间变化</p></li><li><p>接收窗口大小通过TCP首部的AdvertisedWindow字段描述</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104104349.png" alt="image-20220104104349810" style="zoom:50%;" /></li></ul></li><li><p>ACK信息还包括期望接受的下一字节</p></li><li><p>触发传输</p><ul><li>当收集到的字节数达到MSS 时</li><li>发送进程明确要求TCP发送时</li><li>定时器激活</li></ul></li><li><p>超时重传</p><ul><li><p>采用自适应机制估计当前RTT作为定时依据</p></li><li><p>原始算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105042.png" alt="image-20220104105041940" style="zoom: 67%;" /></li><li><p>Karn/Partridge算法</p><ul><li>TCP重传时停止计算RTT样本值</li><li>每次重传后设置下次超时的值为上次的两倍（指数退避）</li></ul></li><li><p>Jacobson/Karn算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105153.png" alt="image-20220104105153647" style="zoom:50%;" /></li></ul></li></ul><h2 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h2><ul><li><p>发送端限制发送速率</p><ul><li><p>拥塞窗口CongWin</p><ul><li><p>发送端的发送窗口上限值应取<strong>接收方窗口</strong>和<strong>拥塞窗口</strong>中的较小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143429.png" alt="image-20220103143429277" style="zoom: 33%;" /></li></ul></li><li><p>接收窗口 VS 拥塞窗口</p><ul><li>接受窗口用于流量控制，避免快速发送方使慢速接收方过载</li><li>拥塞窗口用于拥塞控制，避免多个发送方使网络过载</li></ul></li><li><p>发送窗口 = min（接收窗口，拥塞窗口）</p></li></ul></li><li><p>拥塞事件</p><ul><li>超时</li><li>3个重复ACK</li></ul></li><li><p>调整发送速率</p><ul><li>加性增——乘性减：AIMD<ul><li>加性增：每个RTT将CongWin增大一个MSS——<strong>拥塞避免</strong></li><li>乘性减：发生拥塞事件后将CongWin减半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143712.png" alt="image-20220103143712710" style="zoom: 50%;" /></li></ul></li><li>慢启动：SS<ul><li>TCP初始时，CongWin=1</li><li>开始阶段，指数性增长：每个RTT（收到ACK时）将CongWin翻倍</li><li>考虑在一个具有 10ms 往返时延的线路上采用慢启动拥塞机制。假设没有发生网络拥塞，该 TCP 的报文段大小为 2KB，接收方可用接收窗口为 24KB。那么发送方需要<code>40</code>ms 时间才能达到该接收窗口大小<ul><li>已知最大报文段式2KB，开始的突发量分别是2KB、4KB、8KB、16KB，接下来即为24KB，因为不能超过接收窗口，因此，需要40ms才能发送第一个完全窗口</li></ul></li></ul></li><li>状态切换：<ul><li>变量Threshold记录AIMD和SS切换的阈值</li><li>朴素思想：<ul><li>CongWin小于Threshold时采用SS，大于Threshold时采用AIMD</li><li>发生拥塞事件时Threshold置为拥塞事件瞬间CongWin大小的一半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144059.png" alt="image-20220103144059883" style="zoom:50%;" /></li></ul></li><li>实际规定：<ul><li>收到3个重复ACK时，<strong>快速恢复</strong><ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin减少一半</li><li>采用AIMD</li></ul></li><li>发生超时事件时<ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin置为1</li><li>采用SS</li><li>达到Threshold时再换为AIMD</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144605.png" alt="image-20220103144605452" style="zoom:50%;" /></li><li>设 TCP 的拥塞窗口的慢启动门限值初始为 12（单位为报文段），当拥塞窗口达到 16 时出现超时，再次进入慢启动过程。问从这时起，需要<code>12</code>次往返时延才能恢复到超时那时的拥塞窗口大小<ul><li>出现超时后，拥塞窗口设为1，拥塞避免门限为8<br>因此经过3个RTT后拥塞窗口增加为8<br>在经过8个RTT后拥塞窗口增加到16<br>因此共需要8+3=11个RTT才能使拥塞窗口恢复为超时时的16</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>快速重传</strong></p><ul><li>在收到3次重复ACK时，不必等待超时计时器，立刻重传对应序号的分组以避免超时</li></ul></li><li><p>公平性</p><ul><li><p>TCP具有公平性，带宽平均分配（原因：加性增、乘性减）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104110059.png" alt="image-20220104110059041" style="zoom:50%;" /></li><li><p>但与UDP同时抢占资源时不占优势</p></li></ul></li><li><p>其他</p><ul><li>TCP协议中观察网络拥塞的办法是 <code>以超时作为网络拥塞的标志</code></li><li>在 TCP/IP 中，实施流量控制的目的是 <code>保证接收方总是来得及接收发送方发出的报文或分组</code></li><li>在 TCP 协议中，如果发送窗口直接按照接收方的通知窗口设置，其结果是 <code>突发流量导致分组无法到达接收方</code></li><li>在 TCP 协议中，如果发送方收到三个重复的 ACK 后, 发送方将会 <code>快速重传未被确认的报文段</code></li><li>多媒体应用经常不使用 TCP 的原因可能是 <code>不希望数据传输速率受限于拥塞窗口</code></li><li>主机 A 和主机 B 之间建立了一个 TCP 连接，TCP 最大的数据段长度为 1000 字节，若主机 A 当前的拥塞窗口为 4000 字节，在主机 A 向主机 B 连续发送两个最大段之后，成功收到主机 B 回复的第一段的确认，确认报文中通告的接收窗口大小为 2000 字节，则此时主机 A 还可以向主机 B 发送的最大字节数是 <code>1000</code><ul><li>第一个段的确认段中通告的接收窗口大小为2000字节，即表明在接受到第一个报文段后，还有2000字节的缓存空间可用。 由于发送方发送了二个报文段，第二个段将占用剩下的2000字节中的1000字节，即一共还有（ 2000-1000=1000 ）字节，因而，此时主机甲还可以向主机乙发送的最大字节数是1000字节</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h3 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络应用体系结构</p><ul><li>客户机/服务器（C/S）结构<ul><li>Web应用</li><li>Email应用</li><li>DNS应用</li></ul></li><li>点对点结构(P2P)结构<ul><li>BitTorrent、文件共享（电驴）、即时消息（QQ）</li></ul></li><li>混合型结构</li></ul></li><li><p>通过<code>IP地址</code>对主机进行寻址后通过<code>端口号</code>标识不同进程</p><ul><li>HTTP Server：80</li><li>Email Server：25</li></ul></li><li><p>在整个Internet上，使用<code>IP地址+端口号</code>唯一标识一个特定的应用进程</p></li><li><p>在 Internet 域名体系中，域的下面可以划分子域，各级域名用圆点分开，按照 <code>从右到左越来越小的方式分多层排列</code></p></li><li><p>当一台计算机从 FTP 服务器下载文件时，在该 FTP 服务器上对数据进行封装的五个转换步骤是 <code>消息，报文段，数据报，数据帧，比特</code></p></li><li><p>网络应用实例</p><ul><li>E-mail</li><li>Web</li><li>即时通信（QQ）</li><li>远程登陆（ssh、telnet）</li><li>P2P文件共享（BitTorrent）</li><li>IP电话（Skype）</li><li>……</li></ul></li></ul><h3 id="Web应用与HTTP协议"><a href="#Web应用与HTTP协议" class="headerlink" title="Web应用与HTTP协议"></a>Web应用与HTTP协议</h3><ul><li><p>万维网WWW（World Wide Web）</p><ul><li>浏览器是运行于计算机上的万维网客户端程序；万维网文档所驻留的计算机则运行服务器程序</li><li>WWW工作过程可简要描述为：<ul><li>浏览器于服务器之间建立TCP连接</li><li>浏览器发出HTTP请求报文</li><li>服务器给出HTTP响应报文</li><li>断开TCP连接</li><li>响应时间 = 2×RTT+文件传输时间</li></ul></li><li>一个超文本由多个信息源链接而成，利用一个链接可使用户找到因特网上的另一个文档<ul><li>超文本：含有链接到其他文本的链接点的文本</li></ul></li></ul></li><li><p>Web</p><ul><li>网页由某些<strong>对象</strong>组成</li><li>对象可以是HTML文件、JPEG图片、Java Applet、音频文件……</li><li>网页由包含以上某些对象的基本HTML文件构成</li><li>每个对象都由一个URL定位</li></ul></li><li><p>超文本传输协议（HTTP）</p><ul><li>网络的应用层协议</li><li>无状态协议，服务器不保存客户端之前请求的信息记录</li><li>客户机/服务器模型（C/S）<ul><li>客户机：浏览器请求和接收消息，显示web对象</li><li>服务器：Web 服务器发送对象给浏览器，作为对请求的响应</li></ul></li><li>使用TCP传输协议<ul><li>客户端发送连接请求（产生socket）给服务器的80端口</li><li>服务器接收从客户端发送来的TCP连接请求</li><li>浏览器（HTTP客户端）和Web服务器（HTTP服务器）之间交换HTTP 消息 (应用层协议消息)</li><li>关闭TCP连接</li></ul></li></ul></li><li><p>Web使用<code>HTTP</code>协议进行信息传输</p></li><li><p>用户—服务器状态：Cookies技术</p><ul><li><p>因为HTTP协议为无状态，所以为了保存上次浏览内容，引入Cookie技术</p></li><li><p>Client访问Server时带上Cookie编号，Server为每个编号Client维护后台数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103155836.png" alt="image-20220103155836735" style="zoom: 33%;" /></li></ul></li></ul><h3 id="域名解析服务DNS"><a href="#域名解析服务DNS" class="headerlink" title="域名解析服务DNS"></a>域名解析服务DNS</h3><ul><li><p>实现主机名到IP地址的映射</p><ul><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录</li><li>当客户请求域名服务器转换名字时，服务器首先按标准过程检查它是否被授权管理该名字</li><li>域名服务器向客户报告缓存中有关名字与地址的绑定(binding)信息</li></ul></li><li><p>采用分布式数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104111337.png" alt="image-20220104111337451" style="zoom:50%;" /></li><li><p>查询过程示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160151.png" alt="image-20220103160151420" style="zoom:33%;" /></li><li><p>例题</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160126.png" alt="image-20220103160126557" style="zoom: 33%;" /></li></ul><h3 id="Email服务与SMTP协议"><a href="#Email服务与SMTP协议" class="headerlink" title="Email服务与SMTP协议"></a>Email服务与SMTP协议</h3><ul><li>Email应用组件<ul><li>邮件客户端</li><li>邮件服务器</li><li>SMTP协议（Simple Mail Transfer Protocol）、MIME、POP协议<ul><li>使用TCP协议从客户端向服务器可靠的发送电子邮件消息，端口号25</li><li>直接传输: 发送服务器到接收服务器</li><li>传输的三个阶段<ul><li>握手 (问候)</li><li>消息发送</li><li>终止</li></ul></li><li>命令/响应的交互<ul><li>命令：ASCII文本信息</li><li>响应：状态码与短语</li></ul></li><li>消息必须是7位ASCII码</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmap内存映射——用户空间与内核空间的直接交流</title>
      <link href="/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;<code>mmap</code>是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read()</code>、<code>write()</code>等系统调用函数。同时，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><span id="more"></span><p>&nbsp;</p><h2 id="Linux虚拟内存"><a href="#Linux虚拟内存" class="headerlink" title="Linux虚拟内存"></a>Linux虚拟内存</h2><p>&emsp;&emsp;进程的虚拟地址空间由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质空间，即具有同样特性的连续地址范围。下图中的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射都是一个独立的虚拟内存区域，而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092829.png" alt="image-20220102092829331" style="zoom:33%;" /><p>&emsp;&emsp;Linux内核使用<code>vm_area_struct</code>结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个<code>vm_area_struct</code>结构来表示不同类型的内存区域。各个<code>vm_area_struct</code>结构使用链表或者树形结构来链接，方便进程快速访问。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220101235153.png" alt="image-20220101235152947" style="zoom:50%;" /><p>&emsp;&emsp;<code>vm_area_struct</code>结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个<code>vm_ops</code>指针，其内部可引出所有针对这个区域能使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用的信息都可以从<code>vm_area_struct</code>中获得。<code>mmap</code>就是创建一个新的<code>vm_area_struct</code>结构并将其与文件的物理磁盘地址相连。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a>mmap内存映射</h2><h3 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h3><p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p><ol><li>进程在用户空间调用库函数<code>mmap()</code></li><li>在当前进程的虚拟地址空间中寻找一段空闲的满足要求的连续虚拟地址</li><li>为此虚拟地址分配一个<code>vm_area_struct</code>结构，并对其各域进行初始化</li><li>将新建的虚拟结构<code>vm_area_struct</code>插入进程的虚拟地址区域链表或树中</li></ol><p><strong>（二）调用内核空间的系统调用函数<code>mmap()</code>（不同于用户空间的<code>mmap()</code>），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p><ol><li>为映射分配新的虚拟地址后，通过映射的文件指针在文件描述符表中找到其对应的文件描述符，再通过文件描述符链接到内核“已打开文件集”中该文件的文件结构体<code>struct file</code>，每个文件结构体维护着这个已打开文件的各项相关信息</li><li>通过该文件的文件结构体链接到<code>file_operations</code>模块，调用内核函数<code>mmap()</code></li><li>内核<code>mmap()</code>函数通过虚拟文件系统<code>inode</code>模块定位到文件磁盘物理地址</li><li>通过<code>remap_pfn_range()</code>函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。注意：此时这片虚拟地址仍没有任何数据关联到主内存中</li></ol><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，接下来系统会自动实现文件内容到物理内存（主存)的拷贝</strong></p><ol><li>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</li><li>缺页异常进行一系列判断，确定无非法操作后内核发起请求调页过程</li><li>调页过程现在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用<code>nopage()</code>函数把所缺页从磁盘装入主存中</li><li>之后进程即可对这片主存进行读或写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，即完成了写入文件的过程。</li></ol><p>注：修改过的脏页面不会立即更新到文件中而是有延迟，可以调用<code>msync()</code>函数强制同步</p><p>&nbsp;</p><h3 id="对比常规文件操作"><a href="#对比常规文件操作" class="headerlink" title="对比常规文件操作"></a>对比常规文件操作</h3><h4 id="常规文件操作"><a href="#常规文件操作" class="headerlink" title="常规文件操作"></a>常规文件操作</h4><ol><li>进程发起读取文件请求</li><li>内核通过查找进程文件符表，定位到内核“已打开文件集”上的文件信息，从而找到此文件的<code>inode</code></li><li><code>inode</code>在<code>address_space</code>上查找要请求的文件页是否已经缓存在页缓存中。<ul><li>如果在，则直接返回这片文件页的内容</li><li>如果不在，则通过<code>inode</code>定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程</li></ul></li></ol><p>&emsp;&emsp;总结来说常规文件操作需要从磁盘到页缓存再到用户主存两次数据拷贝。而<code>mmap</code>操控文件只需要从磁盘到用户主存一次数据拷贝过程。即<code>mmap</code>实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此效率更高时延更小。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102002540.png" alt="image-20220102002540469" style="zoom:50%;" /><p>&nbsp;</p><h3 id="优点及作用"><a href="#优点及作用" class="headerlink" title="优点及作用"></a>优点及作用</h3><ol><li>对文件的读取操作跨过了页缓存，减少了数据拷贝次数和时间开销，用内存读写取代了I/O读写，提高文件读取效率</li><li>实现了内核空间和用户空间的高效交互方式，彼此的修改操作可以直接反映在映射的内存区域内并被对方空间捕捉</li><li>提供进程间共享内存的通信方式，并且进程A第一次读取地址内容时通过缺页从磁盘复制文件到页面中后，进程B再读同样地址内容时虽然也会缺页，但是不需要再从文件磁盘里复制，而是直接使用已保存在内存中的文件数据</li><li>可用于实现高效的大规模数据传输，避免了大量文件I/O操作的时间开销</li></ol><p>&nbsp;</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    start：映射区的开始地址</span></span><br><span class="line"><span class="function">    length：映射区长度</span></span><br><span class="line"><span class="function">    prot：期望的内存保护标志，不能与文件的打开模式冲突，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    PROT_READ：页内容可以被读取</span></span><br><span class="line"><span class="function">    PROT_WRITE：页可以被写入</span></span><br><span class="line"><span class="function">    PROT_EXEC：页内容可以被执行</span></span><br><span class="line"><span class="function">PROT_NONE：页不可访问</span></span><br><span class="line"><span class="function">   flags：指定映射对象的类型，映射选项和映射页是否可以共享，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    MAP_SHARED：与其它所有映射这个对象的进程共享映射空间</span></span><br><span class="line"><span class="function">    MAP_PRIVATE： 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</span></span><br><span class="line"><span class="function">    MAP_ANONYMOUS：匿名映射，映射区不与任何文件关联</span></span><br><span class="line"><span class="function">    fd：文件描述符，如果flags设定为MAP_ANONYMOUS，为了兼容问题，其值应为-1</span></span><br><span class="line"><span class="function">    offset：被映射对象内容的起点</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">在进程地址空间中解除一个映射关系，addr是调用<span class="title">mmap</span><span class="params">()</span>返回的地址，len是映射区大小，成功则返回0，失败返回-1。当映射关系解除后，对原来地址的访问会引发段错误。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    flags：</span></span><br><span class="line"><span class="function">    MS_ASYNC：采用异步写方式</span></span><br><span class="line"><span class="function">MS_SYNC：采用同步写方式</span></span><br><span class="line"><span class="function">MS_INVALIDATE：从文件中读回数据</span></span><br><span class="line"><span class="function">一般进程在映射空间对共享内存的改变不会直接回写到磁盘中，调用<span class="title">munmap</span><span class="params">()</span>后才同步，调用<span class="title">msync</span><span class="params">()</span>可以强制同步修改过的脏页面使其立即更新到磁盘文件中。</span></span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><code>mmap()</code>映射区域的大小必须是物理页大小（page_size）的整数倍（32位系统中通常是4k字节）。因为内存的最小粒度是页，而进程的虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，<code>mmap()</code>从磁盘到虚拟地址空间的映射也必须是页</li><li>内核可以跟踪被内存映射的底层对象（文件）大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的字节。如果文件大小一直在扩张，只要还在映射区域范围内就能够被合法访问到。但如果文件本身大小有限，则内存中写入的数据超过文件大小时，超出部分不会被写入文件</li><li>映射建立之后，即使文件关闭，映射也依然存在。因为映射的是磁盘地址而不是文件本身，和文件句柄无关。同时可用于进程通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射</li></ol><p>&nbsp;</p><h5 id="情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中"><a href="#情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中" class="headerlink" title="情形一：一个文件大小是5000字节，mmap()函数从文件的起始位置开始，映射5000字节到虚拟内存中"></a>情形一：一个文件大小是5000字节，<code>mmap()</code>函数从文件的起始位置开始，映射5000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;因为单位物理页的大小是4096字节，所以实际映射到虚拟内存区域的有8192个字节，5000~8192的字节部分用零填充。此时：</p><ul><li>读/写0~4999字节时会返回操作文件内容</li><li>读5000~8191字节时，结果全是0；写5000~8191字节时，进程不报错但是所写内容不会回写到文件中</li><li>读/写8192以外的磁盘部分时，返回<code>SIGSECV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102093046.png" alt="image-20220102093046402" style="zoom:33%;" /><p>&nbsp;</p><h5 id="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"><a href="#情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中" class="headerlink" title="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"></a>情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;文件实际映射到虚拟内存区域的有8192个字节，对应两个物理页，因此这两个物理页都可以合法读写，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常：</p><ul><li>进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中</li><li>对于5000~8191字节，进程可以进行读写过程不报错，但是内容在写入前均为0，另外，写入后不会反映在文件中</li><li>对于8192~14999字节，进程不能对其进行读写，会报<code>SIGBUS</code>错误</li><li>对于15000以外的字节，进程不能对其读写，会引发<code>SIGSEGV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102090515.png" alt="image-20220102090515453" style="zoom: 50%;" /><p>&nbsp;</p><h5 id="情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"><a href="#情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr" class="headerlink" title="情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"></a>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;如果在建立之初就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，会返回<code>SIGBUS</code>错误。但是如果每次操作<code>ptr</code>前先增加文件大小，那么<code>ptr</code>在文件大小内部的操作就是合法的。这样方便随时扩充文件空间，不造成空间浪费。</p><p>&nbsp;</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>p1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">match_file</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">int</span> *length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *length = sb.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_mmap</span><span class="params">(<span class="keyword">char</span> *mmap, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read[%d]:  %s\n&quot;</span>, count++, mmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    mapped = match_file(argv[<span class="number">1</span>], &amp;length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每隔一秒查看存储映射区是否被修改 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read_mmap(mapped, length);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="keyword">char</span> *context[<span class="number">6</span>] = &#123;<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;てんどう万象&quot;</span>, <span class="string">&quot;today is Thursday&quot;</span>, <span class="string">&quot;Xi Nei&quot;</span>, <span class="string">&quot;54618888&quot;</span>, <span class="string">&quot;德丽莎世界第一可爱&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有文件映射将无法修改文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;read[%d]:  %s\n&quot;, count++, mapped);</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(mapped, <span class="string">&#x27;0&#x27;</span>, sb.st_size);</span><br><span class="line">            <span class="built_in">strcpy</span>(mapped, context[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wirte[%d]:  %s\n&quot;</span>, count++, context[i]);</span><br><span class="line"></span><br><span class="line">            msync(mapped, PAGE_SIZE, MS_ASYNC);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 间隔一秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，修改内容长度不能大于原文件长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092156.png" alt="image-20220102092156158"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C自定义Python内置模块</title>
      <link href="/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;Python 可以非常方便地和 C 进行相互的调用。</p><p>&emsp;&emsp;一般不会使用 C 去直接编写一个 Python 的模块。通常是需要把 C 的相关模块包装一下，然后在 Python 中可以直接调用它。或者是，把 Python 逻辑中的某一效率要求很高的部分使用 C 来实现。整个过程大概是：</p><ol><li>引入 Python.h 头文件</li><li>编写包装函数</li><li>函数中处理从 Python 传入的参数</li><li>实现功能逻辑</li><li>处理 C 中的返回值，包装成 Python 对象</li><li>在一个 PyMethodDef 结构体中注册需要的函数</li><li>在一个初始化方法中注册模块名</li><li>把这个 C 源文件编译成链接库</li></ol><span id="more"></span><p>&nbsp;</p><h3 id="用C写Python扩展模块的文件"><a href="#用C写Python扩展模块的文件" class="headerlink" title="用C写Python扩展模块的文件"></a>用C写Python扩展模块的文件</h3><h4 id="Step1：引入Python-h头文件"><a href="#Step1：引入Python-h头文件" class="headerlink" title="Step1：引入Python.h头文件"></a>Step1：引入Python.h头文件</h4><p>&emsp;&emsp;下面用到的函数都在该头文件中定义好了，并且它还包含了一些标准头文件: <code>&lt;stdio.h&gt;</code>，<code>&lt;string.h&gt;</code>，<code>&lt;errno.h&gt;</code> 和 <code>&lt;stdlib.h&gt;</code>。这个头文件一般位于 Python 的主目录中，例如在我ubuntu中是<code>/usr/include/Python3.8</code></p><h4 id="Step2：编写包装函数"><a href="#Step2：编写包装函数" class="headerlink" title="Step2：编写包装函数"></a>Step2：编写包装函数</h4><p>&emsp;&emsp;因为 Python 用到的函数与普通的 C 函数在输入和输出上会有一些不同，所以需要把普通的 C 做一些封装来给 Python 用。本质是定义暴露给<code>CPython</code>解析器的C函数</p><p>&emsp;&emsp;在实现功能的过程中可以先完全不考虑这东西是拿给 Python 用的，只专注于使用 C 把它写好就可以了。功能写好并测试没有问题之后再做 Python 封装的工作。包装函数一般声明成 static ，并且函数类型和传参都是<code>PyObject*</code>类型。这是因为Python是C语言实现的，在C语言中Python对象都由<code>PyObject</code>结构体表示。但虽然C语言是强类型语言，只用一种类型是没办法正常工作，但其实<code>PyObject</code>结构体内包含了大部分C语言数据类型的存储方式，通过不同的解析函数或者参数即可指定解析出对应C类型。</p><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>&emsp;&emsp;在C程序中，函数的定义统一用<code>PyObject</code>，并且无论原Python程序中对应函数传的参数有几个，统一写两个参数：<code>PyObject* self, PyObject* args</code>（若没有传参则都不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参解析"><a href="#传参解析" class="headerlink" title="传参解析"></a>传参解析</h5><p>&emsp;&emsp;上面说过，无论参数数量和类型，一律用<code>PyObject* self, PyObject* args</code>来声明，实际在函数定义中会使用Python的API函数<code>PyArg_ParseTuple()</code>来获得真正的参数，它会检查参数类型并将其转换为 C 值，使用模板字符串确定需要的参数类型以及存储被转换的值的 C 变量类型。当解析成功时返回<code>True</code>，若其传入参数无效则返回<code>False</code>并抛出<code>PyExc_TypeError</code>异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(count: <span class="keyword">int</span>, saying: <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数这样解析参数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> *saying;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PyArg_ParseTuple(args, <span class="string">&quot;is&quot;</span>, &amp;symbol, &amp;symbol) == False)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h5><p>&emsp;&emsp;注意函数在声明时和传参一样也是<code>PyObject*</code>类型，所以很自然能想到其返回值也是该类型。但与传参时相反，返回值是从C语言数据类型构造为<code>PyObject*</code>类型，这里使用的是另一个Python的API函数：<code>Py_BuildValue()</code>，它与<code>PyArg_ParseTuple()</code>类似，都是使用格式字符串解析参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span> -&gt; <span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> count, saying</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;is&quot;</span>, count, saying);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用<code>Py_BuildValue()</code>的格式化字符串形式：</p><table><thead><tr><th>调用语句</th><th>解析值</th></tr></thead><tbody><tr><td>Py_BuildValue(“”)</td><td>None</td></tr><tr><td>Py_BuildValue(“i”, 123)</td><td>123</td></tr><tr><td>Py_BuildValue(“iii”, 123, 456, 789)</td><td>(123, 456, 789)</td></tr><tr><td>Py_BuildValue(“s”, “hello”)</td><td>‘hello’</td></tr><tr><td>Py_BuildValue(“y”, “hello”)</td><td>b’hello’</td></tr><tr><td>Py_BuildValue(“ss”, “hello”, “world”)</td><td>(‘hello’, ‘world’)</td></tr><tr><td>Py_BuildValue(“s#”, “hello”, 4)</td><td>‘hell’</td></tr><tr><td>Py_BuildValue(“y#”, “hello”, 4)</td><td>b’hell’</td></tr><tr><td>Py_BuildValue(“()”)</td><td>()</td></tr><tr><td>Py_BuildValue(“(i)”, 123)</td><td>(123,)</td></tr><tr><td>Py_BuildValue(“(ii)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“(i,i)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“[i,i]”, 123, 456)</td><td>[123, 456]</td></tr><tr><td>Py_BuildValue(“{s:i,s:i}”, “abc”, 123, “def”, 456)</td><td>{‘abc’: 123, ‘def’: 456}</td></tr><tr><td>Py_BuildValue(“((ii)(ii)) (ii)”, 1, 2, 3, 4, 5, 6)</td><td>(((1, 2), (3, 4)), (5, 6))</td></tr></tbody></table><p>&nbsp;</p><h4 id="Step3：把定义好的C函数注册为API"><a href="#Step3：把定义好的C函数注册为API" class="headerlink" title="Step3：把定义好的C函数注册为API"></a>Step3：把定义好的C函数注册为API</h4><p>&emsp;&emsp;注册API，需要用到一个<code>PyMethodDef</code>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_name;   <span class="comment">/* API被调用时的名称 */</span></span><br><span class="line">    PyCFunction ml_meth;    <span class="comment">/* 对应C函数的函数名 */</span></span><br><span class="line">    <span class="keyword">int</span>         ml_flags;   <span class="comment">/* 对应C函数传递的参数类型 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_doc;    <span class="comment">/* 函数说明 */</span></span><br><span class="line">&#125;PyMethodDef;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在C程序中定义一个由<code>PyMethodDef</code>类型成员组成的数组，每个成员对应一个定义好的C函数。这里需要注意第三个参数<code>ml_flags</code>，它代表C函数传参的规范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">METH_VARARGS：</span><br><span class="line">这是最常用的ml_flags值，代表该C函数需要两个 PyObject* 类型参数。第一个是此方法的 self 对象（对于模块函数，它是模块本身(class)，对于非模块函数，它是NULL）；第二个参数（通常称为 args）是一个表示所有参数的元组对象。此参数通常使用 PyArg_ParseTuple() 或 PyArg_UnpackTuple() 处理。</span><br><span class="line"></span><br><span class="line">METH_KEYWORDS：</span><br><span class="line">表示接受关键字参数。这种情况下C函数需要接受第三个 PyObject * 对象，表示字典参数，使用 PyArg_ParseTupleAndKeywords() 来解析出参数。</span><br><span class="line"></span><br><span class="line">METH_FASTCALL：</span><br><span class="line">仅支持位置参数的快速调用约定。第一个参数是 self，第二个参数是 PyObject* 值的 C 数组，指示参数，第三个参数是参数的数量（数组的长度）</span><br><span class="line"></span><br><span class="line">METH_NOARGS：</span><br><span class="line">表示第一个参数通常命名为 self 并将保存对模块或对象实例的引用。在所有情况下，第二个参数将为 NULL。</span><br><span class="line"></span><br><span class="line">更多类型详见：https://docs.python.org/3/c-api/structures.html#c.PyMethodDef</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func1</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func2</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyMethodDef my_methods[] </span>= &#123;</span><br><span class="line">    &#123; <span class="string">&quot;name1&quot;</span>, func1, METH_VARARGS, <span class="string">&quot;description of func1&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name2&quot;</span>, func2, METH_VARARGS, <span class="string">&quot;description of func2&quot;</span> &#125;</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step4：把注册好的API注册到模块中"><a href="#Step4：把注册好的API注册到模块中" class="headerlink" title="Step4：把注册好的API注册到模块中"></a>Step4：把注册好的API注册到模块中</h4><p>&emsp;&emsp;&emsp;与注册API类似，注册模块也用到一个结构体<code>PyModuleDef</code>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span>&#123;</span></span><br><span class="line">  PyModuleDef_Base m_base;<span class="comment">/* 通常都填为PyModuleDef_HEAD_INIT */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_name; <span class="comment">/* Python导入时用的模块名&lt;module_name&gt; */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_doc; <span class="comment">/* 对模块的说明，Python调用时通过__doc__查看 */</span></span><br><span class="line">  Py_ssize_t m_size;<span class="comment">/* 填 -1 */</span></span><br><span class="line">  PyMethodDef *m_methods;<span class="comment">/* 这里填上面注册API的PyMethodDef类型数组 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef_Slot</span>* <span class="title">m_slots</span>;</span></span><br><span class="line">  traverseproc m_traverse;</span><br><span class="line">  inquiry m_clear;</span><br><span class="line">  freefunc m_free;</span><br><span class="line">&#125;PyModuleDef;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;LrkModule&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lrk’s module&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step5：定义构造函数PyInit-lt-ModuleName-gt"><a href="#Step5：定义构造函数PyInit-lt-ModuleName-gt" class="headerlink" title="Step5：定义构造函数PyInit_&lt;ModuleName&gt;"></a>Step5：定义构造函数<code>PyInit_&lt;ModuleName&gt;</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;中后半部分必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_LrkModule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="方法一：直接编译"><a href="#方法一：直接编译" class="headerlink" title="方法一：直接编译"></a>方法一：直接编译</h4><p>注意链接<code>Python.h</code>所在的目录，并指定输出.so文件名称，后续调用此模块的python文件导入时用的就是这个名字：</p><p><code>gcc LrkModule.c -I /usr/include/python3.8 -shared -o LrkModule.so</code></p><h4 id="方法二：用编译脚本"><a href="#方法二：用编译脚本" class="headerlink" title="方法二：用编译脚本"></a>方法二：用编译脚本</h4><p>写一个编译此文件的Python脚本setup.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行<code>python setup.py install</code>编译生成build/目录并装载下面的.so文件</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><code>my_module.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">echo</span><span class="params">(PyObject* self, PyObject* args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* what;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> count;</span><br><span class="line">    PyArg_ParseTuple(args, <span class="string">&quot;si&quot;</span>, &amp;what, &amp;count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Python said: %s %d\n&quot;</span>, what, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> feedback = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;i&quot;</span>, feedback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PyMethodDef 是一个结构体</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;echo&quot;</span>, echo, METH_VARARGS, <span class="string">&quot;echo something&quot;</span> &#125;, </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;lrk&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;后面必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_lrk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lrk</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="built_in">print</span>(lrk.echo(<span class="string">&quot;hello\n&quot;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br><span class="line">python test.py</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p><strong>References</strong><br><a href="https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function">https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function</a><br><a href="https://docs.python.org/3/c-api/index.html">https://docs.python.org/3/c-api/index.html</a><br><a href="https://www.python.org/dev/peps/pep-0007/">https://www.python.org/dev/peps/pep-0007/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】时序差分模型：SARSA &amp; Q-Learning</title>
      <link href="/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/"/>
      <url>/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;时序差分法是求解强化学习问题的重要方法，按照在线学习和离线学习可以分为两大类，其中最基础的两个代表算法就是 SARSA 和 Q-Learning</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229105335.png" alt="image-20211229105335429"></p><span id="more"></span><p>&nbsp;</p><h2 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h2><h3 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>&emsp;&emsp;Sarsa是一种使用时序差分法求解强化学习控制问题的经典方法，即给定强化学习的5个要素：状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ，求解最优的动作价值函数q∗和最优策略π∗。</p><p>&emsp;&emsp;作为一种时序差分法模型，Sarsa是不基于环境模型的Model-free算法，它对控制问题的求解和蒙特卡罗法类似，都是价值迭代，即通过价值函数的更新，来更新当前的策略，再通过新的策略，来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;时序差分法的控制问题可以分为两类：</p><ul><li><p>在线控制(on policy)：</p><p>​        一直使用同一个策略来更新价值函数和选择新的动作</p></li><li><p>离线控制(off policy)：</p><p>​        会使用两个不同的控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数</p></li></ul><p>​        Sarsa属于在线控制类，即一直使用一个策略来更新价值函数和选择新的动作，而这个策略就是ϵ−greedy法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084500.png" alt="image-20211229084500896" style="zoom: 50%;" /><p>&nbsp;</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>&emsp;&emsp;Sarsa的名字其实包含了其算法执行流程，Sarsa = S(状态)+A(动作)+R(奖励)+S‘(新状态)+A’(新动作)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084714.png" alt="image-20211229084714235" style="zoom:50%;" /><p><strong>迭代</strong></p><p>&emsp;&emsp;首先基于ϵ−greedy算法在当前状态<code>S</code>选择一个动作<code>A</code>，这样系统会转到一个新的状态<code>S′</code>，同时给一个即时奖励<code>R</code>，在新的状态<code>S′</code>下基于ϵ−greedy算法在状态<code>S‘</code> 选择一个动作<code>A′</code>，但是注意这时候并不执行这个动作<code>A′</code>，只是用来更新价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 67%;" /><p>&emsp;&emsp;其中，<code>γ</code>是衰减因子，<code>α</code>是迭代步长。这里和蒙特卡罗法求解在线控制问题的迭代公式的区别主要是，收获<code>Gt</code>的表达式不同，对于时序差分，收获<code>Gt</code>的表达式是<code>R+γQ(S′,A′)</code>。除了收获<code>Gt</code>的表达式不同，Sarsa算法和蒙特卡罗在线控制算法基本类似。</p><p>&nbsp;</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229090934.png" alt="image-20211229090934145"></p><p>输入：迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</p><p>输出：所有的状态和动作对应的价值Q</p><p>​        1. 随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p><p>​        2. for i in [ 1, T ]：</p><p>​                a）初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A</p><p>​                b）执行动作A，由环境得到新状态S‘ 和奖励R</p><p>​                c）依据ϵ−greedy算法对状态S‘ 选出动作A’</p><p>​                d）对当前状态S和动作A，更新价值函数Q（S，A）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 50%;" /><p>​                e）前进一步：S = S’，A = A‘</p><p>​                f）if  S’是终止状态，break；else 跳回步骤b</p><p>（注意：步长α一般需要随着迭代逐渐变小，这样才能保证动作价值函数Q可以收敛。当Q收敛时，策略ϵ−greedy算法也就收敛了）</p><p>&nbsp;</p><h4 id="示例一：Windy-GridWorld"><a href="#示例一：Windy-GridWorld" class="headerlink" title="示例一：Windy GridWorld"></a>示例一：Windy GridWorld</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>&emsp;&emsp;一个10×7的长方形格子世界，标记有一个起始位置 S 和一个终止目标位置 G，格子下方的数字表示对应的列中一定强度的风。当个体进入该列的某个格子时，会按图中箭头所示的方向自动移动数字表示的格数，借此来模拟世界中风的作用。同样格子世界是有边界的，个体任意时刻只能处在世界内部的一个格子中。个体并不清楚这个世界的构造以及有风，也就是说它不知道格子是长方形的，也不知道边界在哪里，也不知道自己在里面移动移步后下一个格子与之前格子的相对位置关系，当然它也不清楚起始位置、终止目标的具体位置。但是个体会记住曾经经过的格子，下次在进入这个格子时，它能准确的辨认出这个格子曾经什么时候来过。格子可以执行的行为是朝上、下、左、右移动一步，每移动一步只要不是进入目标位置都给予一个 -1 的惩罚，直至进入目标位置后获得奖励 0 同时永久停留在该位置。现在要求解的问题是个体应该遵循怎样的策略才能尽快的从起始位置到达目标位置。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># world height</span></span><br><span class="line">WORLD_HEIGHT = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># world width</span></span><br><span class="line">WORLD_WIDTH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wind strength for each column</span></span><br><span class="line">WIND = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># possible actions</span></span><br><span class="line">ACTION_UP = <span class="number">0</span></span><br><span class="line">ACTION_DOWN = <span class="number">1</span></span><br><span class="line">ACTION_LEFT = <span class="number">2</span></span><br><span class="line">ACTION_RIGHT = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># probability for exploration</span></span><br><span class="line">EPSILON = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sarsa step size</span></span><br><span class="line">ALPHA = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reward for each step</span></span><br><span class="line">REWARD = -<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">START = [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">GOAL = [<span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">ACTIONS = [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">state, action</span>):</span></span><br><span class="line">    <span class="comment"># (i, j) is bird&#x27;s location, i++ while go down and j++ while go right</span></span><br><span class="line">    i, j = state</span><br><span class="line">    <span class="keyword">if</span> action == ACTION_UP:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - <span class="number">1</span> - WIND[j], <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_DOWN:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(<span class="built_in">min</span>(i + <span class="number">1</span> - WIND[j], WORLD_HEIGHT - <span class="number">1</span>), <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_LEFT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_RIGHT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">min</span>(j + <span class="number">1</span>, WORLD_WIDTH - <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># play for an episode</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">episode</span>(<span class="params">q_value</span>):</span></span><br><span class="line">    <span class="comment"># track the total time steps in this episode</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize state</span></span><br><span class="line">    state = START</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose an action based on epsilon-greedy algorithm</span></span><br><span class="line">    <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">        action = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_ = q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], :]</span><br><span class="line">        action = np.random.choice([action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">            values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># keep going until get to the goal state</span></span><br><span class="line">    <span class="keyword">while</span> state != GOAL:</span><br><span class="line">        next_state = step(state, action)</span><br><span class="line">        <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">            next_action = np.random.choice(ACTIONS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            values_ = q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], :]</span><br><span class="line">            next_action = np.random.choice(</span><br><span class="line">                [action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sarsa update</span></span><br><span class="line">        q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action] += \</span><br><span class="line">            ALPHA * (REWARD + q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], next_action] -</span><br><span class="line">                     q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action])</span><br><span class="line">        state = next_state</span><br><span class="line">        action = next_action</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sarsa</span>():</span></span><br><span class="line">    q_value = np.zeros((WORLD_HEIGHT, WORLD_WIDTH, <span class="number">4</span>))</span><br><span class="line">    episode_limit = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    steps = []</span><br><span class="line">    ep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ep &lt; episode_limit:</span><br><span class="line">        steps.append(episode(q_value))</span><br><span class="line">        <span class="comment"># time = episode(q_value)</span></span><br><span class="line">        <span class="comment"># episodes.extend([ep] * time)</span></span><br><span class="line">        ep += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    steps = np.add.accumulate(steps)</span><br><span class="line"></span><br><span class="line">    plt.plot(steps, np.arange(<span class="number">1</span>, <span class="built_in">len</span>(steps) + <span class="number">1</span>))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Time steps&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Episodes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.savefig(<span class="string">&#x27;./sarsa.png&#x27;</span>)</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the optimal policy</span></span><br><span class="line">    optimal_policy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_HEIGHT):</span><br><span class="line">        optimal_policy.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_WIDTH):</span><br><span class="line">            <span class="keyword">if</span> [i, j] == GOAL:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            bestAction = np.argmax(q_value[i, j, :])</span><br><span class="line">            <span class="keyword">if</span> bestAction == ACTION_UP:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_DOWN:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_LEFT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_RIGHT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Optimal policy is:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> optimal_policy:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wind strength for each column:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>([<span class="built_in">str</span>(w) <span class="keyword">for</span> w <span class="keyword">in</span> WIND]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sarsa()</span><br></pre></td></tr></table></figure><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229092057.png" alt="image-20211229092057649" style="zoom:67%;" /><h4 id="示例二：3×3迷宫"><a href="#示例二：3×3迷宫" class="headerlink" title="示例二：3×3迷宫"></a>示例二：3×3迷宫</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa/Sarsa_maze">github</a></p><h5 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h5><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="Sarsa-λ-算法"><a href="#Sarsa-λ-算法" class="headerlink" title="Sarsa(λ)算法"></a>Sarsa(λ)算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​        多步时序差分TD(λ)的价值函数迭代方法对应就是SARSA(λ)在线控制算法。TD(λ)有前向和后向这两种等价的价值函数迭代方式，在控制问题的求解时，基于反向认识的 SARSA(λ)算法将可以有效地在线学习，数据学习完即可丢弃。因此SARSA(λ)算法默认都是基于反向来进行价值函数迭代。</p><p><strong>状态价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p><strong>动作价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100235.png" alt="image-20211229100235740" style="zoom:50%;" /><p>&emsp;&emsp;除了状态价值函数<code>Q(S,A)</code>的更新方式，多步参数λ以及反向认识引入的效用迹<code>E(S,A)</code>，其余算法思想和SARSA类似。</p><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100839.png" alt="image-20211229100839670"></p><p>输入：迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ、多步参数λ</p><p>输出：所有的状态和动作对应的价值Q</p><p>​        1. 随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p><p>​        2. for i in [ 1, T ]：</p><p>​                a）初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A，初始化所有状态动作的效用迹E为0</p><p>​                b）执行动作A，由环境得到新状态S‘ 和奖励R</p><p>​                c）依据ϵ−greedy算法对状态S‘ 选出动作A’</p><p>​                d）更新效用迹函数E(S, A) 和 误差 δ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101924.png" alt="image-20211229101924200" style="zoom:50%;" /><p>​                e）对当前序列中<strong>所有</strong>状态S和对应动作A，更新价值函数Q(S, A)和效用迹函数E(S, A) ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101944.png" alt="image-20211229101944186" style="zoom:50%;" /><p>​                f）前进一步：S = S’，A = A‘</p><p>​                g）if  S’是终止状态，break；else 跳回步骤b</p><p>&emsp;&emsp;（注意：对于步长α，和Sarsa一样，一般也需要随着迭代的进行逐渐变小才能保证动作价值函数Q收敛）</p><p>&nbsp;</p><h4 id="示例：3×3迷宫"><a href="#示例：3×3迷宫" class="headerlink" title="示例：3×3迷宫"></a>示例：3×3迷宫</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa(lamda)/Sarsa_lamda_maze">github</a></p><h5 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h5><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        SARSA算法和动态规划法比起来，不需要环境的状态转换模型，和蒙特卡罗法比起来，不需要完整的状态序列，因此比较灵活。在传统的强化学习方法中使用比较广泛。</p><p>　　但是SARSA算法也有一个传统强化学习方法共有的问题，就是无法求解太复杂的问题。在 SARSA 算法中，Q(S,A) 的值使用一张大表来存储的，如果状态和动作都达到百万乃至千万级，需要在内存里保存的这张大表会超级大，甚至溢出，因此不是很适合解决规模很大的问题。当然，对于不是特别复杂的问题，使用SARSA还是很不错的一种强化学习问题求解方法。</p><p>&nbsp;&nbsp;</p><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><blockquote><p>关键词：时序差分、model-free、off-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>&emsp;&emsp;Q-Learning也是一种使用时序差分求解强化学习控制问题的方法，它通过价值函数的更新来更新策略，通过策略来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;它与Sarsa最大的区别在于Q-Learning是离线控制(off-policy)算法，会使用两个控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数。具体而言，Q-Learning会使用ϵ−greedy算法来选择新的动作，这部分和SARSA完全相同。但是对于价值函数的更新，Q-Learning使用的是greedy法，而不是SARSA的ϵ−greedy法。这一点就是SARSA和Q-Learning本质区别。</p><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p><strong>算法思想</strong></p><p>&emsp;&emsp;Q-Learning是强化学习算法中value-based的算法，Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取 动作a (a∈A)动作能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward，所以算法的主要思想就是将State与Action构建成一张Q-table来存储Q值，然后根据Q值来选取能够获得最大的收益的动作。<br><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229104840.png" alt="image-20211229104840695"></p><p><strong>算法拓扑图</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103423.png" alt="image-20211229103423423" style="zoom: 33%;" /><p>&emsp;&emsp;首先基于状态S，用ϵ−greedy策略选择到动作<code>A</code>，然后执行动作<code>A</code>，得到奖励<code>R</code>，并进入状态<code>S′</code>，此时如果是Sarsa，会继续基于状态<code>S′</code>，用ϵ−greedy策略选择<code>A′</code>，然后来更新价值函数。但是Q-Learning则不同。对于Q-Learning，它基于状态<code>S′</code>，没有使用ϵ−greedy策略而是使用贪婪策略选择<code>A′</code>，也就是说，选择使Q(S′,a)最大的<code>a</code>作为<code>A′</code>来更新价值函数而不存在探索的可能：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103904.png" alt="image-20211229103904453" style="zoom:50%;" /><p>&emsp;&emsp;对应拓扑图中最下面三个黑球中选择一个使<code>Q(S&#39;,a)</code>最大的动作<code>A&#39;</code>，此时选择的动作只会参与价值函数的更新，不会真正的执行。价值函数更新后，新的执行动作需要基于状态<code>S′</code>，用ϵ−greedy法重新选择得到。这一点也和SARSA稍有不同。对于SARSA，价值函数更新使用的<code>A′</code>会作为下一阶段开始时候的执行动作。</p><p>&nbsp;</p><h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229091010.png" alt="image-20211229091010771"></p><p>输入：迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</p><p>输出：所有的状态和动作对应的价值Q</p><p>​        1. 随机初始化所有的状态和动作对应的价值Q，终止状态的Q初始化为0</p><p>​        2. for i in [ 1, T ]：</p><p>​            a）初始化S为当前序列的第一个状态</p><p>​            b）用ε-greedy策略在当前状态S选择出动作A</p><p>​            c）执行动作A，由环境得到新状态S’ 和奖励R</p><p>​            d）按公式更新价值函数</p><p>​            e）前进一步：S = S’</p><p>​            f）if  S’是终止状态，break；else 跳回步骤b</p><p>&nbsp;</p><h4 id="示例：直线寻宝"><a href="#示例：直线寻宝" class="headerlink" title="示例：直线寻宝"></a>示例：直线寻宝</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>&emsp;&emsp;宝藏在长度为6的直线的另一端，训练一个不知环境的小车以最短步数到达宝藏处。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)  <span class="comment"># reproducible</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N_STATES = <span class="number">6</span>   <span class="comment"># the length of the 1 dimensional world</span></span><br><span class="line">ACTIONS = [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>]     <span class="comment"># available actions</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>   <span class="comment"># greedy police</span></span><br><span class="line">ALPHA = <span class="number">0.1</span>     <span class="comment"># learning rate</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>    <span class="comment"># discount factor</span></span><br><span class="line">MAX_EPISODES = <span class="number">10</span>   <span class="comment"># maximum episodes</span></span><br><span class="line">FRESH_TIME = <span class="number">0.08</span>    <span class="comment"># fresh time for one move</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span>(<span class="params">n_states, actions</span>):</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, <span class="built_in">len</span>(actions))),     <span class="comment"># q_table initial values</span></span><br><span class="line">        columns=actions,    <span class="comment"># actions&#x27;s name</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># print(table)    # show table</span></span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">state, q_table</span>):</span></span><br><span class="line">    <span class="comment"># This is how to choose an action</span></span><br><span class="line">    state_actions = q_table.iloc[state, :]</span><br><span class="line">    <span class="comment"># act non-greedy or state-action have no value</span></span><br><span class="line">    <span class="keyword">if</span> (np.random.uniform() &gt; EPSILON) <span class="keyword">or</span> ((state_actions == <span class="number">0</span>).<span class="built_in">all</span>()):</span><br><span class="line">        action_name = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># act greedy</span></span><br><span class="line">        <span class="comment"># replace argmax to idxmax as argmax means a different function in newer version of pandas</span></span><br><span class="line">        action_name = state_actions.idxmax()</span><br><span class="line">    <span class="keyword">return</span> action_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_env_feedback</span>(<span class="params">S, A</span>):</span></span><br><span class="line">    <span class="comment"># This is how agent will interact with the environment</span></span><br><span class="line">    <span class="keyword">if</span> A == <span class="string">&#x27;right&#x27;</span>:    <span class="comment"># move right</span></span><br><span class="line">        <span class="keyword">if</span> S == N_STATES - <span class="number">2</span>:   <span class="comment"># terminate</span></span><br><span class="line">            S_ = <span class="string">&#x27;terminal&#x27;</span></span><br><span class="line">            R = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S + <span class="number">1</span></span><br><span class="line">            R = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># move left</span></span><br><span class="line">        R = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">            S_ = S  <span class="comment"># reach the wall</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> S_, R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span>(<span class="params">S, episode, step_counter</span>):</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">&#x27;-&#x27;</span>]*(N_STATES-<span class="number">1</span>) + [<span class="string">&#x27;T&#x27;</span>]   <span class="comment"># &#x27;---------T&#x27; our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">        interaction = <span class="string">&#x27;Episode %s: total_steps = %s&#x27;</span> % (</span><br><span class="line">            episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r                                &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">&#x27;o&#x27;</span></span><br><span class="line">        interaction = <span class="string">&#x27;&#x27;</span>.join(env_list)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rl</span>():</span></span><br><span class="line">    <span class="comment"># main part of RL loop</span></span><br><span class="line">    q_table = build_q_table(N_STATES, ACTIONS)</span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EPISODES):</span><br><span class="line">        step_counter = <span class="number">0</span></span><br><span class="line">        S = <span class="number">0</span></span><br><span class="line">        is_terminated = <span class="literal">False</span></span><br><span class="line">        update_env(S, episode, step_counter)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_terminated:</span><br><span class="line"></span><br><span class="line">            A = choose_action(S, q_table)</span><br><span class="line">            <span class="comment"># take action &amp; get next state and reward</span></span><br><span class="line">            S_, R = get_env_feedback(S, A)</span><br><span class="line">            q_predict = q_table.loc[S, A]</span><br><span class="line">            <span class="keyword">if</span> S_ != <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">                <span class="comment"># next state is not terminal</span></span><br><span class="line">                q_target = R + GAMMA * q_table.iloc[S_, :].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q_target = R     <span class="comment"># next state is terminal</span></span><br><span class="line">                is_terminated = <span class="literal">True</span>    <span class="comment"># terminate this episode</span></span><br><span class="line"></span><br><span class="line">            q_table.loc[S, A] += ALPHA * (q_target - q_predict)  <span class="comment"># update</span></span><br><span class="line">            S = S_  <span class="comment"># move to next state</span></span><br><span class="line"></span><br><span class="line">            update_env(S, episode, step_counter+<span class="number">1</span>)</span><br><span class="line">            step_counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> q_table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q_table = rl()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nQ-table:\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(q_table)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h5 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h5><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229104502.png" alt="image-20211229104502770" style="zoom: 67%;" /><p>其他示例见<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Q-Learning">github</a></p><p>&nbsp;</p><h4 id="Q-Learning-vs-Sarsa"><a href="#Q-Learning-vs-Sarsa" class="headerlink" title="Q-Learning  vs  Sarsa"></a>Q-Learning  vs  Sarsa</h4><p>&emsp;&emsp;Q-Learning直接学习的是最优策略，而Sarsa在学习最优策略的同时还在做探索。这导致在学习最优策略的时候，如果用Sarsa，为了保证收敛，需要制定一个策略，使ϵ−greedy策略的超参数ϵ在迭代的过程中逐渐变小。Q-Learning没有这个烦恼。</p><p>&emsp;&emsp;另外一个就是Q-Learning直接学习最优策略，但是最优策略会依赖于训练中产生的一系列数据，所以受样本数据的影响较大，因此受到训练数据方差的影响很大，甚至会影响Q函数的收敛。Q-Learning的深度强化学习版Deep Q-Learning也有这个问题。</p><p>&emsp;&emsp;在学习过程中，Sarsa在收敛的过程中鼓励探索，这样学习过程会比较平滑，不至于过于激进，导致出现像Q-Learning可能遇到一些特殊的最优“陷阱”。比如经典的强化学习问题”Cliff Walk”。</p><p>&emsp;&emsp;在实际应用中，如果是在模拟环境中训练强化学习模型，推荐使用Q-Learning，如果是在线生产环境中训练模型，则推荐使用SARSA。</p><p>&nbsp;</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;对于Q-Learning和Sarsa这样的时序差分算法，对于小型的强化学习问题是非常灵活有效的，但是在大数据时代，异常复杂的状态和可选动作，使Q-Learning和Sarsa要维护的Q表异常的大，甚至远远超出内存，这限制了时序差分算法的应用场景。在深度学习兴起后，基于深度学习的强化学习开始占主导地位。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】基础知识</title>
      <link href="/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;强化学习 (Reinforcement Learning) 是一个机器学习大家族中的分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用。比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事。强化学习让程序从对当前环境完全陌生, 成长为一个在环境中游刃有余的高手。</p><span id="more"></span><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="在机器学习中的位置"><a href="#在机器学习中的位置" class="headerlink" title="在机器学习中的位置"></a>在机器学习中的位置</h3><p>&emsp;&emsp;强化学习是和监督学习，非监督学习并列的第三种机器学习方法。</p><p>&emsp;&emsp;强化学习和监督学习最大的区别是它没有监督学习已经准备好的训练数据输出值。强化学习只有奖励值，但是这个奖励值和监督学习的输出值不一样，它不是事先给出的，而是延后给出的。同时，强化学习的每一步与时间顺序前后关系紧密。而监督学习的训练数据之间一般都是独立的，没有这种前后的依赖关系。</p><p>&emsp;&emsp;强化学习和非监督学习的区别。也还是在奖励值这个地方。非监督学习是没有输出值也没有奖励值的，它只有数据特征。同时和监督学习一样，数据之间也都是独立的，没有强化学习这样的前后依赖关系。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229085342.png" alt="image-20211229085342314" style="zoom:50%;" /><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p><strong>目标：</strong>找到一个策略 a = π(s) 来确定在状态 s 下选择的动作 a，从而最大化价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090245.png" alt="image-20211228090244956" style="zoom:50%;" /><table><thead><tr><th>组成</th><th>内容</th></tr></thead><tbody><tr><td>两个主体</td><td>Agent、Environment</td></tr><tr><td>状态、行动和策略</td><td>Agent依据策略Policy做出在当前状态State下采取的行动Action，环境Environment给出相应的新状态State</td></tr><tr><td>状态转化模型</td><td>相当于一个概率状态机、一个概率模型，即在状态s下采取动作a，转到下一个状态s′的概率，表示为Pss′a或P(s’|s,a)</td></tr><tr><td>两种奖励</td><td>行动价值Action_Value（当前奖励+衰减折算后的后续奖励，有远见性）、行动奖励Reward（仅当前的奖励R(s,a)）</td></tr><tr><td>衰减因子与探索率</td><td>衰减因子γ决定Action_Value的远见性，探索率决定Agent采取Action时的创新性(ε-greedy)</td></tr></tbody></table><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227234235.png" alt="image-20211227234234718" style="zoom: 33%;" /><h3 id="所解决问题的特点"><a href="#所解决问题的特点" class="headerlink" title="所解决问题的特点"></a>所解决问题的特点</h3><ul><li>智能体Agent和环境Environment之间不断进行交互</li><li>搜索和试错</li><li>延迟奖励（当前所做的动作可能很多步之后才会产生相应的结果）</li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="马尔可夫决策过程MDP"><a href="#马尔可夫决策过程MDP" class="headerlink" title="马尔可夫决策过程MDP"></a>马尔可夫决策过程MDP</h2><p>&emsp;&emsp;在强化学习中，agent与environment一直在互动。在每个时刻t，agent会接收到来自环境的状态s，基于这个状态s，agent会做出动作a，然后这个动作作用在环境上，于是agent可以接收到一个奖赏Rt+1Rt+1，并且agent就会到达新的状态。所以，其实agent与environment之间的交互就是产生了一个序列：</p><p>&emsp;&emsp;<code>S0,A0,R1,S1,A1,R2,...</code></p><p>&emsp;&emsp;我们称这个为序列决策过程。而马尔科夫决策过程（Morkov Decision Process）就是一个典型的序列决策过程的一种公式化。有了马尔科夫的假设，在求解强化学习模型时才比较方便。</p><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="MDP定义"><a href="#MDP定义" class="headerlink" title="MDP定义"></a>MDP定义</h5><p>下一个状态的产生只和当前的状态有关，即：</p><p>&emsp;&emsp;<code>P(St+1 | St) = P(St+1 | S1,...,St)</code></p><p>直观上讲，下一个状态的产生跟所有历史状态是有关的，也就是等式右边所示。但是Markov的定义则是忽略掉历史信息，只保留了当前状态的信息来预测下一个状态，这称为无后效性/马尔可夫性。</p><p>一个 MDP 可以由一个 5 元组表示为 <code>M = &lt;S,A,P(s&#39;|s,a),R,γ&gt;</code>：</p><p><strong>S</strong> → 一个状态（state）的集合<br><strong>P</strong> → 一个受行为影响的状态转移概率矩阵<br><strong>A</strong> →一个有限动作集<br><strong>R</strong> →  一个用于计算回报的函数<br><strong>γ</strong> → 一个折扣因子，用于做未来回报计算时的衰减系数，γ ∈ ( 0 , 1 )<br>&nbsp;</p><h5 id="状态转移概率Pss′a"><a href="#状态转移概率Pss′a" class="headerlink" title="状态转移概率Pss′a"></a>状态转移概率Pss′a</h5><p>对于一个具体的状态s和它的下一个状态s’ ，它们的状态转移概率(就是从s转移到s’的概率)定义为：</p><p>&emsp;&emsp;<code>Pss′a = P(St+1=s′|St=s,At=a)</code></p><p>也就是说，下一个状态的产生只受到当前状态和动作的影响。</p><p>&nbsp;</p><h5 id="策略π"><a href="#策略π" class="headerlink" title="策略π"></a>策略π</h5><p>&emsp;&emsp;<code>Policy： π(a|s) = P(At=a|St=s)</code></p><p>policy π表示的是在给定的state下，一个关于action的概率分布。即表示在一个状态s下，agent接下来可能会采取的任意一个action的概率分布（可能一开始不知道概率是多少）。对于每一个状态s都会有这样一个π(a|s)，所有状态的π(a|s）就形成整体策略π。策略π是指所有状态都要使用这个策略，不是单独指某一个状态。</p><p>无论怎样，我们的目标是最大化累积奖赏，所以我们可以通过不断地改进我们的策略，使得我们最后能够获得最大累积奖赏。</p><p>&nbsp;</p><h5 id="状态价值函数Vπ"><a href="#状态价值函数Vπ" class="headerlink" title="状态价值函数Vπ"></a>状态价值函数Vπ</h5><p>在策略π和状态s下，采取一系列行动会到达终止状态。期间得到的累计折扣回报就是该策略下状态s的价值，用Vπ(s)表示。因为从状态s开始到终止状态的路径不唯一，为了确定性的衡量状态s的价值，Vπ(s)一般是一个期望函数：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085646.png" alt="image-20211228085646607" style="zoom: 50%;" /></p><p>物理意义：如果到达了状态s，那么接下来直到到达终止状态的回报值就是Vπ(s) 。</p><p>t时刻状态St和t+1时刻状态St+1之间的递推关系（贝尔曼方程)：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /><p>计算机通常使用第二个递推式迭代地求出MDP中每个状态的价值函数，而不是用公式一硬算。</p><p>&nbsp;</p><h5 id="动作价值函数Qπ"><a href="#动作价值函数Qπ" class="headerlink" title="动作价值函数Qπ"></a>动作价值函数<em>Qπ</em></h5><p>在状态s下做动作a后的即时奖励虽然是确定的，但是依概率转移到下一个状态s′这个s′是不确定的。因此通过求期望来消除价值函数的不确定性：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085745.png" alt="image-20211228085745128" style="zoom:50%;" /><p>​                                                                              <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085806.png" alt="image-20211228085806768" style="zoom:50%;" /></p><p>t时刻动作At和t+1时刻动作At+1之间的递推关系（贝尔曼方程)：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>计算机通常使用第二个递推式迭代地求出MDP中每个状态的价值函数，而不是用公式一硬算。</p><p>&nbsp;</p><h5 id="状态价值与动作价值的递推关系"><a href="#状态价值与动作价值的递推关系" class="headerlink" title="状态价值与动作价值的递推关系"></a>状态价值与动作价值的递推关系</h5><p>状态价值函数是所有动作价值函数基于策略π的期望：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085947.png" style="zoom:50%;" /></p><p>利用上贝尔曼方程，也很容易从状态价值函数vπ(s)vπ(s)表示动作价值函数qπ(s,a)qπ(s,a)，即：</p><p>​                                                                    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090008.png" style="zoom:50%;" /></p><p>二者转化关系如图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090154.png" alt="image-20211228090154012" style="zoom: 33%;" /><p>&emsp;&emsp;总而言之，状态 / 动作价值有两部分相加组成，第一部分是即时奖励，第二部分是环境所有可能出现的下一个状态的概率乘以该下一状态的状态价值，最后求和，并加上衰减。两式联立得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090245.png" alt="image-20211228090244956" style="zoom:50%;" /><p>&nbsp;</p><h4 id="最优价值函数"><a href="#最优价值函数" class="headerlink" title="最优价值函数"></a>最优价值函数</h4><p>&emsp;&emsp;解决强化学习问题意味着要寻找一个最优的策略让个体在与环境交互过程中获得始终比其它策略都要多的收获，这个最优策略可以用 π∗表示。一旦找到这个最优策略π∗，那么就解决了这个强化学习问题。一般来说，找到一个最优策略很难，但是可以通过比较若干不同策略的优劣来确定一个较好的策略，也就是局部最优解。而策略的优劣可由价值函数反映，因此最优策略——&gt;最优价值函数：</p><ol><li><strong>最优状态价值函数</strong>是所有策略下产生的众多状态价值函数中的最大者：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090541.png" alt="image-20211228090541867" style="zoom:50%;" /></li><li><strong>最优动作价值函数</strong>是所有策略下产生的众多动作状态价值函数中的最大者：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090616.png" alt="image-20211228090616747" style="zoom: 50%;" /></li></ol><p><strong>转化关系：</strong><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228091126.png" alt="image-20211228091126423" style="zoom: 50%;" /></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><h3 id="强化学习两个基本问题"><a href="#强化学习两个基本问题" class="headerlink" title="强化学习两个基本问题"></a>强化学习两个基本问题</h3><h6 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h6><p>给定：状态集S, 动作集A, 模型状态转化概率矩阵P, 即时奖励R，衰减因子γ,  策略π，求解该策略的状态价值函数v(π)</p><h6 id="控制问题"><a href="#控制问题" class="headerlink" title="控制问题"></a>控制问题</h6><p>给定：状态集S, 动作集A, 模型状态转化概率矩阵P, 即时奖励R，衰减因子γ，求解最优策略π和最优状态价值函数v(π)</p><h6 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228091621.png" alt="image-20211228091621142" style="zoom: 67%;" /><p>&nbsp;</p><h3 id="动态规划DP（Model-based）"><a href="#动态规划DP（Model-based）" class="headerlink" title="动态规划DP（Model-based）"></a>动态规划DP（Model-based）</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>问题的最优解可以由若干小问题的最优解构成，即通过寻找子问题的最优解来得到问题的最优解。</p><p>可以找到子问题状态之间的递推关系，通过较小的子问题状态递推出较大的子问题的状态。</p><p>&nbsp;</p><h4 id="同步动态规划算法"><a href="#同步动态规划算法" class="headerlink" title="同步动态规划算法"></a>同步动态规划算法</h4><h5 id="策略评估求解预测问题"><a href="#策略评估求解预测问题" class="headerlink" title="策略评估求解预测问题"></a>策略评估求解预测问题</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140008.png" alt="image-20211228140008098"></p><p>&emsp;&emsp;从任意一个状态价值函数开始，依据给定的策略，结合贝尔曼期望方程、状态转移概率和奖励同步迭代更新状态价值函数，直至其收敛，得到该策略下最终的状态价值函数。（反复迭代至平稳分布）</p><h5 id="策略迭代求解控制问题"><a href="#策略迭代求解控制问题" class="headerlink" title="策略迭代求解控制问题"></a>策略迭代求解控制问题</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140030.png" alt="image-20211228140030255"></p><p>&emsp;&emsp;根据之前基于任意一个给定策略评估得到的状态价值来及时调整动作策略，这个方法叫做策略迭代(Policy Iteration)。最简单的调整方法就是贪婪法：个体在某个状态下选择的行为是其能够到达后续所有可能的状态中状态价值最大的那个状态。</p><ol><li>使用当前策略π∗评估计算当前策略的最终状态价值v∗</li><li>根据状态价值v∗以一定的方法（比如贪婪法）更新策略π∗</li><li>回到第一步，一直迭代下去，最终得到收敛的策略π∗和状态价值v∗</li></ol><h5 id="价值迭代求解控制问题"><a href="#价值迭代求解控制问题" class="headerlink" title="价值迭代求解控制问题"></a>价值迭代求解控制问题</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140047.png" alt="image-20211228140046899"></p><p>&emsp;&emsp;相比策略迭代，不需要等到状态价值收敛才调整策略，而是随着状态价值的迭代及时调整策略, 这样可以大大减少迭代次数。此时的状态价值的更新方法也和策略迭代不同，此时贝尔曼方程迭代式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>&emsp;&emsp;可见由于策略调整，现在价值每次更新倾向于贪婪法选择的最优策略对应的后续状态价值，这样收敛更快。</p><p>&nbsp;</p><h4 id="异步动态规划算法"><a href="#异步动态规划算法" class="headerlink" title="异步动态规划算法"></a>异步动态规划算法</h4><p>&emsp;&emsp;上面几个都是同步动态规划算法，即每轮迭代我会计算出所有的状态价值并保存起来，在下一轮中使用这些保存起来的状态价值来计算新一轮的状态价值。另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。</p><h5 id="原位动态规划-in-place-DP"><a href="#原位动态规划-in-place-DP" class="headerlink" title="原位动态规划 (in-place DP)"></a>原位动态规划 (in-place DP)</h5><p>&emsp;&emsp;此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。</p><h5 id="优先级动态规划-prioritized-sweeping-DP"><a href="#优先级动态规划-prioritized-sweeping-DP" class="headerlink" title="优先级动态规划 (prioritized sweeping DP)"></a>优先级动态规划 (prioritized sweeping DP)</h5><p>&emsp;&emsp;该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。</p><h5 id="实时动态规划-real-time-DP"><a href="#实时动态规划-real-time-DP" class="headerlink" title="实时动态规划 (real-time DP)"></a>实时动态规划 (real-time DP)</h5><p>&emsp;&emsp;实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。</p><p>&nbsp;</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;动态规划算法主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此我们还需要寻找其他的针对复杂问题的强化学习问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="蒙特卡罗法（Model-free）"><a href="#蒙特卡罗法（Model-free）" class="headerlink" title="蒙特卡罗法（Model-free）"></a>蒙特卡罗法（Model-free）</h3><h4 id="不基于模型的强化学习问题"><a href="#不基于模型的强化学习问题" class="headerlink" title="不基于模型的强化学习问题"></a>不基于模型的强化学习问题</h4><p>&emsp;&emsp;在上面动态规划法中，模型状态转化概率矩阵P始终是已知的，即MDP已知，一般称这样的强化学习问题为Model-based的强化学习问题。Model-based强化学习问题可以通过动态规划来评估一个给定的策略，通过不断迭代最终得到最优价值函数，具体的做法有两个：一个是策略迭代，一个是值迭代。</p><p>&emsp;&emsp;然而有很多强化学习问题没有办法事先得到模型状态转化概率Pss’a，即不基于模型的<strong>Model-free</strong>强化学习（面向黑盒子学习），为了能够从环境中学习，需要让agent与environment交互，得到一些经历（样本）。然后通过这些经历来进行策略评估与策略迭代，从而最终得到最优策略。这种做法的理论是从蒙特卡罗方法（Monte-Carlo）中来的。</p><p>&nbsp;</p><h4 id="蒙特卡罗法"><a href="#蒙特卡罗法" class="headerlink" title="蒙特卡罗法"></a>蒙特卡罗法</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135735.png" alt="image-20211228135716095"></p><p>&emsp;&emsp;蒙特卡罗法又叫做统计模拟方法，通过采样若干经历完整的状态序列(episode)后求均值来估计状态的真实价值。所谓的经历完整，就是这个序列<strong>必须是达到终点</strong>的，这样才能拿到最终回报。比如下棋问题要分出输赢，驾车问题要成功到达终点或者失败。有了很多组这样经历完整的状态序列，我们不需要借助模型本身就可以近似的估计状态价值，进而求解预测和控制问题。</p><p>&emsp;&emsp;采样得到的完整序列示例如下：</p><p>&emsp;&emsp;<code>S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</code></p><p><strong>对比动态规划</strong></p><ul><li>不需要依赖于模型状态转化概率</li><li>从经历过的完整序列学习，完整的经历越多，学习效果越好</li></ul><p>&nbsp;</p><h4 id="求解预测问题（基于价值）"><a href="#求解预测问题（基于价值）" class="headerlink" title="求解预测问题（基于价值）"></a>求解预测问题（基于价值）</h4><p>&emsp;&emsp;对于蒙特卡罗法来说，如果要求某一个状态的状态价值，只需要求出所有的完整序列（采到的样本）中该状态的收获R的平均值即可近似求解：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228095438.png" alt="image-20211228095438741" style="zoom:50%;" /><p>其中</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228095500.png" alt="image-20211228095500637" style="zoom:50%;" /><p>&emsp;&emsp;动作价值求解方法同上。</p><p><strong>算法优化</strong></p><ol><li><p>同样一个状态可能在一个完整的状态序列中重复出现，第一种应对方法是仅把状态序列中第一次出现该状态时的收获值纳入到收获平均值的计算中；另一种是针对一个状态序列中每次出现的该状态，都计算对应的收获值并纳入到收获平均值的计算中。两种方法对应的蒙特卡罗法分别称为：<strong>首次访问(first visit)</strong> 和<strong>每次访问(every visit)</strong> 蒙特卡罗法。第二种方法比第一种的计算量要大一些，但是在完整的经历样本序列少的场景下会比第一种方法适用。</p></li><li><p>**累进更新平均值（incremental mean)**。在上面预测问题的求解公式里，有一个average的公式，意味着要保存所有该状态的收获值之和最后取平均，这样浪费了太多的存储空间。一个较好的方法是在迭代计算收获均值，即每次保存上一轮迭代得到的收获均值与次数，当计算得到当前轮的收获时，即可计算当前轮收获均值和次数。</p></li></ol><p>&nbsp;</p><h4 id="求解控制问题（基于价值）"><a href="#求解控制问题（基于价值）" class="headerlink" title="求解控制问题（基于价值）"></a>求解控制问题（基于价值）</h4><p>&emsp;&emsp;蒙特卡罗法求解控制问题的思路和动态规划价值迭代的的思路类似。每轮迭代先做策略评估，计算出价值vk(s)，然后基于据一定的方法（比如贪婪法）更新当前策略π。最后得到最优价值函数v∗和最优策略π∗。</p><p>和动态规划比，蒙特卡罗法不同之处体现在三点：</p><p>​        1.  预测问题策略评估的方法不同，动态规划用贝尔曼方程迭代，蒙特卡罗法用采样数据求平均</p><p>​        2. 蒙特卡罗法一般是优化最优动作价值函数q∗，而不是状态价值函数v∗</p><p>​        3. 动态规划一般基于贪婪法更新策略，而蒙特卡罗法一般采用<strong>ϵ−greedy</strong>法更新（m是可选行动的个数）</p><p>​             <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228141900.png" alt="image-20211228141900761" style="zoom: 25%;" /></p><p>（在实际求解控制问题时，为了使算法可以收敛，一般ϵ会随着算法的迭代过程逐渐减小并趋于0。这样在迭代前期，我们鼓励探索，而在后期，由于我们有了足够的探索量，开始趋于保守，以贪婪为主，使算法可以稳定收敛）</p><p><strong>算法流程：（以在线学习on-policy的every-visit蒙特卡罗法为例）</strong></p><p>输入：状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ</p><p>输出：最有动作价值函数q∗、最优策略π∗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化所有的动作价值Q(s, a)=0，状态次数N(s, a)=0，采样次数k=0，随机初始化一个策略π</span><br><span class="line"></span><br><span class="line">2. k=k+1，基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:</span><br><span class="line">S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</span><br><span class="line"></span><br><span class="line">3. 对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：</span><br><span class="line">    Gt = 对n累加到T[(γ^(t-n))*(Rt+n)]</span><br><span class="line">    N(s, a) ++</span><br><span class="line">    Q(s, a) += (Gt-Q(s, a))/N(s,a)</span><br><span class="line"></span><br><span class="line">4. 基于新计算出的动作价值，更新当前的ϵ−greedy策略：</span><br><span class="line">    ϵ = 1/k</span><br><span class="line">    π = ϵ−greedy()</span><br><span class="line"></span><br><span class="line">5. 若所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗，对应的策略π(a|s)即为最优策略π∗，否则转到第二步</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;蒙特卡罗法是不基于模型的强化问题求解方法，它可以避免动态规划求解过于复杂，同时还可以不事先知道环境转化模型，因此可以用于海量数据和复杂模型。但是它每次采样都需要一个完整的状态序列，如果没有完整的状态序列，或者很难拿到较多的完整的状态序列，因此在实际问题中蒙特卡罗法用的不多，所以还需要寻找其他的更灵活的不基于模型的强化问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="时序差分法TD（Model-free）"><a href="#时序差分法TD（Model-free）" class="headerlink" title="时序差分法TD（Model-free）"></a>时序差分法TD（Model-free）</h3><h4 id="时序差分法"><a href="#时序差分法" class="headerlink" title="时序差分法"></a>时序差分法</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135332.png" alt="image-20211228135332814"></p><p>&emsp;&emsp;时序差分法和蒙特卡罗法类似，都是不基于模型的强化学习问题求解方法。蒙特卡罗法中Gt的计算需要完整序列，而时序差分法没有完整的状态序列，只有部分的状态序列，由贝尔曼方程：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /> 可知，可以用<code>Rt+1+γv(St+1)</code>来近似的代替收获Gt</p><p>一般我们把<code>Rt+1+γV(St+1)</code>称为<strong>目标值</strong>，<code>Rt+1+γV(St+1)−V(St)</code>称为<strong>误差</strong>，将用目标值近似代替收获G(t)的过程称为<strong>引导</strong>(bootstrapping)。这样只需要两个连续的状态与对应的奖励，就有了近似收获Gt的表达式，可以去求解时序差分的预测问题和控制问题了。</p><p>&nbsp;</p><h4 id="求解预测问题（基于价值）-1"><a href="#求解预测问题（基于价值）-1" class="headerlink" title="求解预测问题（基于价值）"></a>求解预测问题（基于价值）</h4><p>&emsp;&emsp;时序差分的预测问题求解和蒙特卡罗法类似，但是主要有两个不同点：</p><ol><li> 收获Gt的表达式不同</li></ol><ul><li>蒙特卡罗 G(t) 需要遍历完整过程才能得出：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228102751.png" alt="image-20211228102751434" style="zoom: 50%;" /></li><li>时序差分 G(t)记录连续两个状态就可得出，称为 <strong>TD Target</strong> ：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110419.png" alt="image-20211228110419330" style="zoom: 50%;" /></li></ul><ol start="2"><li> 迭代式子的系数不同，时序差分没有完整的序列，也就没有对应的次数N(St, At)，一般用一个[0,1]的系数α代替：</li></ol><ul><li>蒙特卡罗:    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110505.png" alt="image-20211228110505164" style="zoom:50%;" /></li><li>时序差分:   <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110514.png" alt="image-20211228110514567" style="zoom:50%;" /></li></ul><p>&emsp;&emsp;（并且蒙特卡罗法一般只优化动作价值函数Q，时序差分状态价值、动作价值函数都会优化）</p><p>&nbsp;</p><h5 id="对比蒙特卡罗法"><a href="#对比蒙特卡罗法" class="headerlink" title="对比蒙特卡罗法"></a>对比蒙特卡罗法</h5><ol><li>时序差分法在知道最终结果之前就可以学习，甚至没有最终结果也可以学习，还可以在持续进行的环境中学习。而蒙特卡罗法则要等到最后结果才能学习，时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。</li><li>时序差分法在更新状态价值时使用的是<strong>TD目标值</strong>，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的<strong>有偏估计</strong>，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的<strong>无偏估计</strong>，这一点蒙特卡罗法占优。</li><li>虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。</li></ol><h5 id="n步时序差分："><a href="#n步时序差分：" class="headerlink" title="n步时序差分："></a>n步时序差分：</h5><p>&emsp;&emsp;上面用TD Target代替收获Gt的公式中，St只向前一步到St+1，若用向前2步、n步来近似代替Gt，则为n步时序差分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228105615.png" alt="image-20211228105615429" style="zoom: 33%;" /><p>&emsp;&emsp;（当n越来越大，趋于无穷，或者说趋于使用完整的状态序列时，n步时序差分就等价于蒙特卡罗法了）</p><p>&nbsp;</p><h4 id="求解控制问题（基于价值）-1"><a href="#求解控制问题（基于价值）-1" class="headerlink" title="求解控制问题（基于价值）"></a>求解控制问题（基于价值）</h4><p>&emsp;&emsp;蒙特卡罗法在线控制的方法使用的是ϵ−greedy法来做价值迭代，时序差分也可以用ϵ−greedy法来价值迭代，和蒙特卡罗法在线控制的区别主要只是在于收获的计算方式不同。时序差分的在线控制(on-policy)算法最常见的是Sarsa算法。</p><p>&emsp;&emsp;除了在线控制，还可以做离线控制(off-policy)。离线控制和在线控制的区别主要在于在线控制一般只有一个策略(最常见的是ϵ−greedy法)。而离线控制一般有两个策略，其中一个策略(最常见的是ϵ−greedy法)用于选择新的动作，另一个策略(最常见的是贪婪法)用于更新价值函数。时序差分的离线控制算法最常见的是Q-Learning算法。</p><p>&nbsp;</p><h4 id="TD-λ"><a href="#TD-λ" class="headerlink" title="TD(λ)"></a>TD(λ)</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112323.png" alt="image-20211228112323589"></p><p>&emsp;&emsp;n步时序差分选择多少步数是一个超参数调优问题(一般3~10比较好)。为了能在不增加计算复杂度的情况下综合考虑所有步数的预测，引入一个[0,1]新的参数λ，定义收获是n从1到∞所有步的收获乘以权重的和：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100620.png" alt="image-20211229100620726" style="zoom:50%;" /><p>每一步的权重是<code>(1−λ)*λ^(n−1)</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112010.png" alt="image-20211228112009881" style="zoom: 33%;" /><p>&emsp;&emsp;进而有价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228142817.png" alt="image-20211228142817279" style="zoom:25%;" /><p>&emsp;&emsp;从前向来看，一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时，就是上面的普通时序差分法；当λ=1时，就是蒙特卡罗法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111541.png" alt="image-20211228111540959" style="zoom:25%;" /><p>&emsp;&emsp;从反向来看，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为<strong>频率启发(frequency heuristic) 式</strong>；而把电击归因于最近少数几次状态的影响，则称为<strong>就近启发(recency heuristic) 式</strong>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111604.png" alt="image-20211228111604749" style="zoom:25%;" /><p><strong>效用迹E</strong></p><p>&emsp;&emsp;给每一个状态引入一个数值：<strong>效用值</strong> 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发(同事反映二者)。而所有状态的效用值总称为**效用迹(eligibility traces, ES)**。定义为：</p><p>​                        <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135203.png" alt="image-20211228135203250" style="zoom:25%;" />    </p><p>&emsp;&emsp;此时价值函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p>&nbsp;</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;时序差分和蒙特卡罗法比它更加灵活，学习能力更强，因此是目前主流的强化学习求解问题的方法，现在绝大部分强化学习乃至深度强化学习的求解都是以时序差分的思想为基础的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token Bucket最优参数的数学推导</title>
      <link href="/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/"/>
      <url>/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文研究了从两种情况下观察到的网络数据流的流量模式中导出<strong>令牌桶参数</strong>的问题：</p><ul><li>给定数据流对应一组令牌桶参数，所有数据包都立即传送，不产生任何延迟或丢失</li><li>在上述模型中添加一个缓存队列，以临时存储在桶中积累足够的令牌之前无法立即传送的数据包。队列具有平滑流量的效果，因此对令牌桶参数的要求较低，同时还使得派生的令牌桶参数随时间的波动较小。</li></ul><p>然后对两个模型严格分析了给定数据流的队列大小和令牌桶参数之间的关系，计算数据流中每个数据包的排队延迟并用于描述调整后的排队后流量模式。</p><p>并且就两个模型分别介绍了用于推导基于测量的流量规范 (MBTS) 的简单高效算法以及经验结果。这种 MBTS 技术减轻了用户为在综合服务网络中保留网络资源而预先明确表征流量的需要。</p><p><strong>原文</strong></p><p><a href="Network traffic characterization using token bucket model.pdf" target="_blank">Network traffic characterization using token bucket model</a></p><span id="more"></span><p>&nbsp;</p><h2 id="令牌桶概念及问题"><a href="#令牌桶概念及问题" class="headerlink" title="令牌桶概念及问题"></a>令牌桶概念及问题</h2><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>&emsp;&emsp;假设一个流存在于一个时间间隔 [t0 , tn ] 中并且由 n 个数据包 p1, p2, … ，pn 组成。它的流量模式 P = { ( p i , ti）|1&lt;i &lt;n}，其中 t0&lt;t1&lt;t2&lt; … &lt; tn, 表示在时间[t0, tn]内，pi由主机中的应用程序生成，表示第 i 个数据包的字节数。</p><h3 id="无缓存队列的令牌桶"><a href="#无缓存队列的令牌桶" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶是一个非负计数器，它以恒定速率 r 累积令牌，直到计数器达到其容量 b 。到达后，一个数据包将被发送出去，令牌计数器减少了数据包大小（以字节为单位），前提是该数据包有足够的令牌。否则，数据包将被丢弃或排队，直到令牌桶积累了足够的令牌以将数据包发送出去。当流空闲或以较低的速率运行，使得令牌计数器达到上限 b 时，令牌的累积将暂停，直到下一个数据包到达。请注意，令牌桶不是数据包的物理容器，而是用于调度数据包释放时间的令牌数字计数器。令牌桶由其令牌补充率 r 和令牌桶大小 b 参数化。</p><p>&emsp;&emsp;流量表征的一个关键问题是，对于时间间隔 [t0, tn] 中模式 P 的数据流，如何从观察到的流量模式导出合适的令牌桶参数 (r, b) ，以便所有数据包在到达时立即发送出去。在这种情况下，我们说数据流符合由 (r, b) 参数化的令牌桶模型。</p><h3 id="含缓存队列的令牌桶"><a href="#含缓存队列的令牌桶" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶模型可以通过向其添加缓存队列来扩展。该缓存队列用于在数据包流等待足够的令牌以在存储桶中累积时保存数据包流。通过排队，突发流量可以被平滑，因此派生的令牌桶参数变得比无缓存队列情况下的要求更低，从而导致网络中更有效的资源分配。另一方面，通过添加缓存队列，给定的令牌桶模型将能够以牺牲存储空间和数据源的数据包延迟为代价来适应更多变化的流量模式。</p><p>对带有队列的令牌桶有如下问题：</p><ol><li>对于给定的数据流和令牌桶模型，最小队列大小 q 应该为多少才能保证数据流不会丢包？</li><li>如果给定令牌速率r、桶容量b之一和队列大小 q，那么另一个参数的最佳选择是什么？</li><li>对于排队情况下的每个数据包，排队延迟是多少？</li><li>如果指定了最大排队延迟，那么应该如何确定最小队列大小和对应的令牌桶参数？</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="两种模型下的参数求解"><a href="#两种模型下的参数求解" class="headerlink" title="两种模型下的参数求解"></a>两种模型下的参数求解</h2><h3 id="无缓存队列的令牌桶-1"><a href="#无缓存队列的令牌桶-1" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>本文Part 2通过严格的数学证明和有效的算法：</p><ul><li><p>找到了 b 和 r 的下限和上限，以便所有满足无时延和丢包要求的合法 ( r , b ) 对都落在这些范围内</p></li><li><p>对任何给定有效的 r ，可以确定最优的（即与 r 耦合最小的） b 以便不丢弃任何数据包这个最优 b 明确表示为 r 的函数，它是单调递减和分段线性的</p></li><li><p>提出了两种有效的算法来计算b(r)函数和相关经验结果</p></li></ul><p>&nbsp;</p><h4 id="r的有效范围"><a href="#r的有效范围" class="headerlink" title="r的有效范围"></a>r的有效范围</h4><p>一方面，如果 r 太小，则无论 b 的容量有多大，桶中都不会为传入的数据包生成足够的令牌。因此满足无延迟要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194837.png" alt="image-20211226194836980" style="zoom:50%;" /><p>c0是t0时刻桶中初始令牌数，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194540.png" alt="image-20211226194540110" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；</p><p>另一方面，也没有必要使 r 无限大，最大 r 恰满足能使一个时间间隔内的所有数据包都被发送即可：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194822.png" alt="image-20211226194822619" style="zoom:50%;" /><p>pk是第k个时间间隔内的数据包流量，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195012.png" alt="image-20211226195012336" style="zoom:50%;" /><p>这是<strong>r的上限</strong>。（文中已证明其必大于r的下限）</p><p>&nbsp;</p><h4 id="b的有效范围"><a href="#b的有效范围" class="headerlink" title="b的有效范围"></a>b的有效范围</h4><p>由上可推出<strong>最大数据速率</strong>为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201839.png" alt="image-20211226201839313" style="zoom:50%;" /><p>当时间间隔k内数据速来p大于rmax且初始令牌数c00时，得到最小桶的容量：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195603.png" alt="image-20211226195603013" style="zoom:50%;" /><p>这是<strong>b的下限</strong>；</p><p>当满足上面r的限定范围时，每个时间间隔k过后内桶中会积累的令牌数量为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195806.png" alt="image-20211226195806153" style="zoom:50%;" /><p>因此桶的大小必须至少能够容下ck的最大值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201417.png" alt="image-20211226201417539" style="zoom:50%;" /><p>这是<strong>b的上限</strong>，可见b的范围是r的函数。</p><p>&nbsp;</p><h4 id="b和r的关系"><a href="#b和r的关系" class="headerlink" title="b和r的关系"></a>b和r的关系</h4><p>给定r，求解满足无时延和丢包前提下的最小b值</p><p>记delta k表示第k个时间间隔大小，ck表示第k个数据包到达前时刻的桶中令牌数量（即上一个时间间隔结尾时刻的），则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224424.png" alt="image-20211226224424621" style="zoom:50%;" /><p>（注意到这里的ck(r,b)不同于前面的ck(r)，ck(r,b)小于等于ck(r)，仅当b大于等于bmax时取等号）</p><p>因为满足无时延和丢包，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224657.png" alt="image-20211226224657804" style="zoom:50%;" /><p>递推得到：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224838.png" alt="image-20211226224838298" style="zoom:50%;" /><p>因此，满足无时延和丢包前提下，给定r时的最优（最小）b为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224920.png" alt="image-20211226224920764" style="zoom:50%;" /><p>若取初始令牌数c0==b，即桶一开始是满的，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226225532.png" alt="image-20211226225532241" style="zoom:50%;" /><p>&nbsp;</p><h4 id="降低b-r-时间复杂度"><a href="#降低b-r-时间复杂度" class="headerlink" title="降低b(r)时间复杂度"></a>降低b(r)时间复杂度</h4><p>&emsp;&emsp;由上可知，求解最优b值是至少要在 n(n-1)/2 个数字中取最大值，评估所有这些 O ( n 2 ) 数的成本太高了。文章中提出了两种有效的算法来计算给定 r 的 最优b值。第一个算法只解析一次输入模式 P ，复杂度为 O ( n ) 。第二个是multi-pass算法，复杂度为 O ( n log n)，但是可以推广到排队情况。</p><h5 id="算法-1-简单数学推导"><a href="#算法-1-简单数学推导" class="headerlink" title="算法 1    简单数学推导"></a>算法 1    简单数学推导</h5><p>&emsp;&emsp;这里省去论文中的推导，直接记录结论。</p><p>&emsp;&emsp;由递推公式  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226231637.png" alt="image-20211226231637615" style="zoom:50%;" /></p><p>&emsp;&emsp;可以计算出以P={(pk,tk) | 1&lt;k&lt;n}为流量模式的情况下，给定r后b的最优值。</p><p>&emsp;&emsp;此算法不仅由于 O(n) 复杂度而具有 CPU 效率，而且在内存方面也很高效。只需要分配两个整数 d 和 b 作为 dk 和 bk 序列的占位符，不需要存储模式数据 P，因为这是一种一次性算法，它可以与到达的数据包流一起实时进行。</p><h5 id="算法-2-二分查找"><a href="#算法-2-二分查找" class="headerlink" title="算法 2    二分查找"></a>算法 2    二分查找</h5><p>&emsp;&emsp;第二种算法没有利用 b(r)的显式解。相反它对其范围内的最小 b 进行二分搜索，使得对所有 k 都有ck(r,b) &gt;= pk。该算法的优点在于它可以推广并激发Part 3中的排队情况解决方案，同时也可以作为我们实验中检查第一个算法的正确性和性能的参考。</p><p>&emsp;&emsp;用 [bl , bu] 表示b 的范围，其中 l 代表下限，u 代表上限。最初设置 bl = bmin、bu=bmax 和 b = 1/2*(bl + bu)。在初始满桶(c0=b)的情况下，选择归纳计算 ck(r,b) 并将其值与 pk 进行比较。如果对任何k都有pk &lt;= ck(r,b)，则设置 bu  = b 和 b = 1/2*(bl + bu) 。否则，当遇到的第一个pk &gt; ck(r,b)的 k 时，我们设置 bl = b 和 b = 1/2*(bl + bu)。重复上述步骤直到 bl = bu。</p><p>&emsp;&emsp;由于用于二分搜索的 b 的初始范围最多为 O ( n ) ，因此 b 上恰好有 O(logn) 次更新。对于 b 的每次更新，最多需要遍历 (pk , tk) 的列表一次。在最坏的情况下也只需要时间 O (n) ，因此二分查找算法的复杂度是 O (n logn) 。</p><h5 id="算法-3-Send-Now算法"><a href="#算法-3-Send-Now算法" class="headerlink" title="算法 3    Send-Now算法"></a>算法 3    Send-Now算法</h5><p>&emsp;&emsp;这是作者提到他们在一个tb程序中看见的算法，可以达到和算法 1相似的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226233525.png" alt="image-20211226233525702" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="含缓存队列的令牌桶-1"><a href="#含缓存队列的令牌桶-1" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>本文Part 3通过严格的数学证明和有效的算法：</p><ul><li>确定了给定缓存队列大小 q 的有效 r 和 b 的边界。发现对于给定的流量模式，在有时延但无丢包情况下，最小缓存队列大小q是 ( r , b ) 对的二元函数，且这个函数 q(r, b ) 是 r 和 b 的减函数</li><li>提出了给定的缓存队列大小 q时最优 b 和 r 之间关系的计算算法。后者实际上是对无缓存队列情况的一般化，如果将缓存队列大小设置为0，则将退化为Part 2中的结果</li><li>明确计算了给定令牌桶模型的数据流中每个数据包的排队延迟。从而推导出数据流的最大和平均排队延迟，以及调整后的排队后流量模式</li><li>提出了在指定最大延迟或平均延迟的上限时确定满足延迟界限的令牌桶模型（r，b）集的算法，并分析了算法的时间复杂度</li></ul><p>&nbsp;</p><h4 id="不考虑容量b的情况"><a href="#不考虑容量b的情况" class="headerlink" title="不考虑容量b的情况"></a>不考虑容量b的情况</h4><h5 id="r的有效范围-1"><a href="#r的有效范围-1" class="headerlink" title="r的有效范围"></a>r的有效范围</h5><p>假定桶容量b无穷大，从而简化推导。记缓存队列大小为q，则满足无丢包要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110252.png" alt="image-20211227110252037" style="zoom:50%;" /><p>其中<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110336.png" alt="image-20211227110336667" style="zoom:50%;" />从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110351.png" alt="image-20211227110351617" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；至于<strong>r的上限</strong>则和上面无缓存队列情况时一致。</p><p>&nbsp;</p><h5 id="b的有效范围-1"><a href="#b的有效范围-1" class="headerlink" title="b的有效范围"></a>b的有效范围</h5><p>注意，在有缓存队列情况下，每个时间间隔内损耗的令牌数不只是时间间隔内新来的数据包pk大小，还包括缓存队列中多个delay的旧数据包。第k个时间间隔内delay的旧数据包大小为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111522.png" alt="image-20211227111522588" style="zoom:50%;" /><p>记 I(k) 为使</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111738.png" alt="image-20211227111738322" style="zoom: 50%;" /><p>成立的最小 k’ 值，即 I(k) 是在pk到达之前令牌桶已经发出的数据包的数量。</p><p>则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111920.png" alt="image-20211227111920444" style="zoom:50%;" /><p>因为有了缓存队列，令牌数不够用时数据包放入缓冲队列，此时的令牌数就是ck。</p><p>数据包pk到达后缓存队列中剩余的字节数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227112321.png" alt="image-20211227112321614" style="zoom:50%;" /><p>即令牌数不够用时放入缓冲队列的数据包总大小。</p><p>（这里文章给出了 “ <em>当r&gt;rmin时，必有qk&lt;q（即缓存队列不会溢出）且无丢包</em> ” 的证明，感兴趣可以自己查阅）</p><p>由上述推导得数据包时延为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124037.png" alt="image-20211227124037294" style="zoom:50%;" /><p><strong>b的下限</strong>和上面无缓存队列情况时一致，<strong>b的上限</strong>则为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124447.png" alt="image-20211227124447620" style="zoom:50%;" /><p>注意其中ck(r)的值有两种情况( I(t) &lt; 或 &gt; pk)，所以用max()函数表述。</p><p>&nbsp;</p><h4 id="考虑桶容量b的情况"><a href="#考虑桶容量b的情况" class="headerlink" title="考虑桶容量b的情况"></a>考虑桶容量b的情况</h4><p>&emsp;&emsp;上面研究了不受 b 限制的排队情况，现在考虑一般情况，即缓存队列q和令牌桶大小 b 都起作用。假设我们给出了位于无延迟 TB 曲线下方的值 ( r , b )，我们想知道这个令牌桶的最小队列大小及其相应的排队后的交通模式P。</p><h5 id="q的有效范围"><a href="#q的有效范围" class="headerlink" title="q的有效范围"></a>q的有效范围</h5><p>I(k) 定义为使得</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125435.png" alt="image-20211227125435320" style="zoom:50%;" /> <p>恒成立的最大 k‘ 值，即在 pk 到达之前已经发出而不是存入缓存队列的数据包的数量</p><p>ck(r, b)定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125547.png" alt="image-20211227125547219" style="zoom:50%;" /><p>qk 定义为需要在 pk到达后立即排队的字节数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125652.png" alt="image-20211227125652836" style="zoom:50%;" /><p>则最小队列长qmin为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125756.png" alt="image-20211227125756422" style="zoom:50%;" /><h5 id="q一定时，求b-r"><a href="#q一定时，求b-r" class="headerlink" title="q一定时，求b(r)"></a>q一定时，求b(r)</h5><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>&emsp;&emsp;同上面类似，只不过搜索时的有效条件改为</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227131254.png" alt="image-20211227131254110" style="zoom:50%;" />，时间复杂度为O(n logn)&gt;</p><h6 id="Send-Smooth算法"><a href="#Send-Smooth算法" class="headerlink" title="Send-Smooth算法"></a>Send-Smooth算法</h6><p>&emsp;这是作者上面提到他们在一个tb程序中看见的算法，可以达到O(n)的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228182254.png" alt="image-20211228182254925" style="zoom:67%;" /><p>&nbsp;</p><h4 id="数据包时延"><a href="#数据包时延" class="headerlink" title="数据包时延"></a>数据包时延</h4><p>这边实在没看懂它这1999年的老论文里说的是什么混乱逻辑，反正项目后面做NSRRM时delay直接测实际值不需要计算获得，不管了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Token Bucket </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题与启发式算法</title>
      <link href="/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</p><p>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据组合，也许永远不会在现实世界出现。因此现实世界中启发式算法常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。</p><p>有一类的通用启发式策略称为元启发式算法，通常使用乱数搜寻技巧。他们可以应用在非常广泛的问题上，但不能保证效率。</p><span id="more"></span><p>&nbsp;</p><h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><h3 id="多项式时间（polynomial-time）"><a href="#多项式时间（polynomial-time）" class="headerlink" title="多项式时间（polynomial time）"></a>多项式时间（polynomial time）</h3><p>&emsp;&emsp;时间复杂度是指当程序所处理的问题规模扩大后，程序需要的时间长度对应增长得有多快。根据增量的量级划分，可以分为：</p><ul><li>多项式复杂度：O(1)、O(log(n))、O(n^a)等</li><li>非多项式复杂度：O(a^n)、O(n!)等</li></ul><p>&emsp;&emsp;非多项式复杂度的程序当问题规模扩大时，计算机将无法承受运算时间开销，因此通常使用的算法都是多项式级的复杂度。</p><p>&nbsp;</p><h3 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，在算法的整个执行过程中，每一步都能得到一个确定的解，这样的算法就是确定性算法。</p><h3 id="非确定性算法"><a href="#非确定性算法" class="headerlink" title="非确定性算法"></a>非确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，它将问题分解成两部分，分别为猜测阶段和验证阶段，其中</p><ul><li>猜测阶段：对问题的一个特定的输入实例x产生一个任意字符串y，在算法的每一次运行时，y的值可能不同，因此，猜测以一种非确定的形式工作。</li><li>验证阶段：用一个确定性算法（有限时间内）验证。<ul><li>检查在猜测阶段产生的y是否是合适的形式，如果不是，则算法停下来并得到no；</li><li>如果y是合适的形式，则验证它是否是问题的解，如果是，则算法停下来并得到yes，否则算法停下来并得到no。它是验证所猜测的解的正确性。</li></ul></li></ul><p>&nbsp;</p><h3 id="规约-约化"><a href="#规约-约化" class="headerlink" title="规约/约化"></a>规约/约化</h3><p>&emsp;&emsp;问题A可以约化为问题B，称为“问题A可规约为问题B”，可以理解为问题B的解一定就是问题A的解，因此解决A不会难于解决B。由此可知问题B的时间复杂度一定大于等于问题A。</p><p>&emsp;&emsp;从规约的定义中我们看到，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断规约，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。</p><p>&nbsp;</p><h3 id="P-NP-NPC-NP-Hard问题"><a href="#P-NP-NPC-NP-Hard问题" class="headerlink" title="P/NP/NPC/NP-Hard问题"></a>P/NP/NPC/NP-Hard问题</h3><h4 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h4><p>&emsp;&emsp;能在多项式时间内可解的问题</p><h4 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h4><p>&emsp;&emsp;在多项式时间内”可验证“的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。</p><h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p>&emsp;&emsp;存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：</p><ul><li>是一个NP问题</li><li>所有NO问题都能规约到它</li></ul><h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>&emsp;&emsp;满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130636.png" alt="image-20211227130636049" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="启发式算法（Heuristic-algorithm）"><a href="#启发式算法（Heuristic-algorithm）" class="headerlink" title="启发式算法（Heuristic algorithm）"></a>启发式算法（Heuristic algorithm）</h2><p>&emsp;&emsp;实际工程中有许多优化问题是NP-Hard问题，其最优算法通常因为复杂度过高而效率低下，或者就是没有最优化算法可以用。启发式算法是相对于最优化算法提出的基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解（次优解），该可行解与最优解的偏离程度一般不能被预计。</p><ul><li>无法保证得到某优化问题的全局最优解</li><li>为了快速地求解那些不存在或者暂时未找到多项式时间内算法的问题而提出</li></ul><p><strong>元启发式算法（Metaheuristic algorithm）</strong></p><p>&emsp;&emsp;元启发式算法主要指一类通用型的启发式算法，这类算法的优化机理不过分依赖于算法的组织结构信息（不依赖特定问题，而是具有通用性的策略），可以广泛的应用到函数的组合优化和函数计算中。</p><p><strong>超启发算法（Hyper-heuristic algorithm）</strong></p><p>&emsp;&emsp;超启发式算法提供了某种高层策略（High-Level Strategy，HLS），通过操纵或管理一组低层启发式算法（Low-Level Heuristics, LLH），以获得新启发式算法。这些新启发式算法则被运用于求解各类NP-难解问题。</p><p>&nbsp;</p><h3 id="常用的启发式算法"><a href="#常用的启发式算法" class="headerlink" title="常用的启发式算法"></a>常用的启发式算法</h3><h4 id="模拟退火算法（SA）"><a href="#模拟退火算法（SA）" class="headerlink" title="模拟退火算法（SA）"></a>模拟退火算法（SA）</h4><p>&emsp;&emsp;模拟退火算法(Simulated Annealing, SA)的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化温度T(充分大)，温度下限Tmin(充分小)，初始解X，每个T值迭代次数L</span><br><span class="line"></span><br><span class="line">2. 随机生成临域解x_new;</span><br><span class="line"></span><br><span class="line">3. 设f(x)函数来计算用来计算解得好坏，计算出f(x_new)-f(x);</span><br><span class="line"></span><br><span class="line">4. 如果f(x_new)-f(x)&gt;0，说明新解比原来的解好，则无条件接受，如果f(x_new)-f(x)&lt;0，则说明旧解比新解好，则以概率exp((f(xnew)-f(x))/k*T)接受x_new作为解。</span><br><span class="line"></span><br><span class="line">5. 如果当前温度&lt;Tmin时，则退出循环，输出当前结果，否则减少当前温度，回到第2步继续循环，常用的降温方法为T= a*T (0&lt;a&lt;1)，一般a取接近1的值</span><br></pre></td></tr></table></figure><p>实例：求解函数最小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130659.png" alt="image-20211227130659835" style="zoom: 67%;" /><p>其中-100&lt;=x&lt;=100，给定任意y值，求x为多少时，F(x)最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">2000</span>;        <span class="comment">// 初始化温度</span></span><br><span class="line"><span class="keyword">double</span> Tmin = <span class="number">1</span>;     <span class="comment">// 温度的下界</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">100</span>;         <span class="comment">// 迭代的次数</span></span><br><span class="line"><span class="keyword">double</span> delta = <span class="number">0.98</span>; <span class="comment">// 温度的下降率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x取值范围 0~100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span>) / <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评价函数的值,即对应上文中的f(x)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x目标函数中的一个参数</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的另一个参数</span></span><br><span class="line"><span class="comment"> * @return函数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getFuncResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">5</span> * <span class="built_in">pow</span>(x, <span class="number">2</span>) - <span class="built_in">cos</span>(<span class="number">2</span> * x) * y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟退火算法的过程</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的指定的参数</span></span><br><span class="line"><span class="comment"> * @return最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSA</span><span class="params">(<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x_min = <span class="number">0</span>; <span class="comment">// 初始化最优值点</span></span><br><span class="line">    <span class="keyword">double</span> f_x = <span class="number">0</span>;   <span class="comment">// 初始化函数值</span></span><br><span class="line">    <span class="keyword">double</span> *x = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) * k);</span><br><span class="line">    <span class="comment">// 初始化初始解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代的过程</span></span><br><span class="line">    <span class="keyword">while</span> (T &gt; Tmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算此时的函数结果</span></span><br><span class="line">            <span class="keyword">double</span> funTmp = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">            <span class="comment">// 在邻域内产生新的解</span></span><br><span class="line">            <span class="keyword">double</span> x_new = x[i] + (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span> - <span class="number">5000</span>) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 判断新的x不能超出界</span></span><br><span class="line">            <span class="keyword">if</span> (x_new &gt;= <span class="number">-100</span> &amp;&amp; x_new &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug x=%f\n&quot;</span>, x_new);</span><br><span class="line">                <span class="keyword">double</span> funTmp_new = <span class="built_in">getFuncResult</span>(x_new, y);</span><br><span class="line">                <span class="keyword">if</span> (funTmp_new - funTmp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 替换</span></span><br><span class="line">                    x[i] = x_new;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 以概率替换</span></span><br><span class="line">                    <span class="keyword">double</span> p = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-(funTmp_new - funTmp) / T));</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">rand</span>() % <span class="number">100</span>) / <span class="number">100</span> &lt; p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x[i] = x_new;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T = T * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f_x &gt; <span class="built_in">getFuncResult</span>(x[i], y))</span><br><span class="line">        &#123;</span><br><span class="line">            x_min = x[i];</span><br><span class="line">            f_x = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置y的值</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="built_in">getSA</span>(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%4.2f时，有f(x)最小值为 %5.3f\n&quot;</span>, x, <span class="built_in">getFuncResult</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="遗传算法（GA）"><a href="#遗传算法（GA）" class="headerlink" title="遗传算法（GA）"></a>遗传算法（GA）</h4><p>&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 对潜在问题进行编码，初始化基因组，并根据基因组随机初始化种群，并指定繁衍代数。</span><br><span class="line"></span><br><span class="line">2. 计算种群中每个个体的适应度，选择一定数目的留下，其余淘汰。</span><br><span class="line"></span><br><span class="line">3. 在留下的个体中，随机繁衍，对分母基因进行交叉（极小概率变异），产生下一代。</span><br><span class="line"></span><br><span class="line">4. 回到第2步进行循环。直到达到指定的繁衍代数</span><br></pre></td></tr></table></figure><p><strong>相关术语</strong></p><p>编码(coding)：将物体的表现型用编码的方式转为程序可控的基因型</p><blockquote><p>比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给 它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津-&gt;新疆-&gt;北京-&gt;广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。<br>（1）二进制编码，基因用0或1表示（常用于解决01背包问题）</p><p>如：基因A：00100011010 (代表一个个体的染色体)</p><p>（2）互换编码（用于解决排序问题，如旅行商问题和调度问题）</p><p>如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。</p></blockquote><p>解码(decoding)：基因型到表现型的映射</p><p>基因型(genotype)：参数的因子</p><p>表现型(phenotype)：根据不同因子最终展现的形态</p><p>适应度(fitness)：度量某个结果的好坏</p><p>进化(evolution)：不断剔除差的结果，最终逐步留下好的结果</p><p>选择(selection)：以一定的概率从种群中选择若干个个体留下，并繁殖。选择过程是一种基于适应度的优胜劣汰的过程</p><p>复制(reproduction)：将父本、母本的基因复制，以便产生下一代</p><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交</p><blockquote><p>（1）单交叉点法 （用于二进制编码）</p><p>选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。</p><p>如：交叉前：</p><p>00000|01110000000010000</p><p>11100|00000111111000101</p><p>交叉后：</p><p>00000|00000111111000101</p><p>11100|01110000000010000</p><p>（2）双交叉点法 （用于二进制编码）</p><p>选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.</p><p>如：交叉前：</p><p>01 |0010| 11</p><p>11 |0111| 01</p><p>交叉后：</p><p>11 |0010| 01</p><p>01 |0111| 11</p><p>（3）基于“ 与/或 ”交叉法 （用于二进制编码）</p><p>对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .</p><p>如：交叉前：</p><p>01001011</p><p>11011101</p><p>交叉后：</p><p>01001001</p><p>11011111</p><p>（4）单交叉点法 （用于互换编码）</p><p>选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。</p><p>如：交叉前：</p><p>87213 | 09546</p><p>98356 | 71420</p><p>交叉后：</p><p>87213 | 95640</p><p>98356 | 72104</p><p>（5）部分匹配交叉（PMX）法（用于互换编码）</p><p>先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。</p><p>父代A：872 | 130 | 9546</p><p>父代B：983 | 567 | 1420    变为：</p><p>TEMP A: 872 | 567 | 9546</p><p>TEMP B: 983 | 130 | 1420</p><p>对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1&lt;——&gt;５　３&lt;——&gt;６　７&lt;——&gt;０</p><p>子代Ａ：802 | 567 | 9143</p><p>子代Ｂ：986 | 130 | 5427</p><p>（6）顺序交叉法(OX) （用于互换编码）</p><p>从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。</p><p>父代A: 872 | 139 | 0546</p><p>父代B: 983 | 567 | 1420</p><p>交叉后：</p><p>子代A: 856 | 139 | 7420</p><p>子代B: 821 | 567 | 3904</p><p>（7）循环交叉（CX）（用于互换编码）</p><p>CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。</p><p>父代A：1 2 3 4 5 6 7 8 9</p><p>父代B：5 4 6 9 2 3 7 8 1</p><p>可得循环基因：1-&gt;5-&gt;2-&gt;4-&gt;3-&gt;6-&gt;9-&gt;7-&gt;8</p><p>子代Ｂ的编码同理。（循环基因 5-&gt;1-&gt;4-&gt;2-&gt;6-&gt;3-&gt;9-&gt;7-&gt;8）</p></blockquote><p>变异(mutation)：交叉后可能（很小的概率）对染色体进行更改，来防止算法过早收敛而陷入局部最优解中</p><blockquote><p>变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。</p><p>（1）基本位变异算子（用于二进制编码）</p><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。</p><p>变异前：</p><p>000001110000000010000</p><p>变异后：</p><p>000001110001000010000</p><p>（2）逆转变异算子（用于互换编码）（源代码中使用类似此方法）</p><p>在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。</p><p>变异前：</p><p>1346798205</p><p>变异后：</p><p>1246798305</p></blockquote><p>个体（individual）：指染色体带有特征的实体</p><p>种群（population）：个体的集合，该集合内个体数称为种群的大小</p><p>&nbsp;</p><h4 id="蚁群算法（ACO）"><a href="#蚁群算法（ACO）" class="headerlink" title="蚁群算法（ACO）"></a>蚁群算法（ACO）</h4><p>&emsp;&emsp;蚁群优化算法（Ant Colony Optimization, ACO）来源于自然界觅食的最短路径原理。根据昆虫学家的观察，蚂蚁可以在没有任何提示的情况下找到从食物源到巢穴的最短路径，并且能在环境发生变化(如原有路径上有了障碍物)后，自适应地搜索新的最佳路径。这样由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化蚂蚁数量、可行路段、每条路段距离、每条路段的初始信息素大小等信息</span><br><span class="line"></span><br><span class="line">2. 设定蚂蚁的起点、终点。</span><br><span class="line"></span><br><span class="line">3. 蚂蚁从起点出发根据信息素浓度，有一定的概率性选择路段，浓度越高，概率越大，逐步回到终点。</span><br><span class="line"></span><br><span class="line">4. 在蚂蚁走过的路径上，根据每条路段的长度按比例释放信息素，短的路段释放的信息素多，长的路段释放的信息素少。</span><br><span class="line"></span><br><span class="line">5. 对所有路段的信息素进行挥发。</span><br><span class="line"></span><br><span class="line">6. 回到第二步进行循环，直到蚂蚁数量迭代完。</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="粒子群算法（PSO）"><a href="#粒子群算法（PSO）" class="headerlink" title="粒子群算法（PSO）"></a>粒子群算法（PSO）</h4><p>&emsp;&emsp;粒子群优化算法(PSO：Particle swarm optimization) 来源于对鸟群捕食的行为研究。通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化离子的速度和位置</span><br><span class="line"></span><br><span class="line">2. 计算粒子适应度</span><br><span class="line"></span><br><span class="line">3. 获取粒子个体的最优值</span><br><span class="line"></span><br><span class="line">4. 获取全体的历史最优值</span><br><span class="line"></span><br><span class="line">5. 更新速度和位置</span><br><span class="line"></span><br><span class="line">6. 若不满足结束条件，则重复2~5</span><br></pre></td></tr></table></figure><p><strong>参数设定</strong></p><ul><li>种群数量：粒子群算法的最大特点就是速度快，因此初始种群取50-1000都是可以的，虽然初始种群越大收敛性会更好，不过太大了也会影响速度；</li><li>迭代次数：一般取100~4000，太少解不稳定，太多浪费时间。对于复杂问题，进化代数可以相应地提高；</li><li>惯性权重：该参数反映了个体历史成绩对现在的影响，一般取0.5~1；</li><li>学习因子：一般取0~4，此处要根据自变量的取值范围来定，并且学习因子分为个体和群体两种；</li><li>空间维数：粒子搜索的空间维数即为自变量的个数。</li><li>位置限制：限制粒子搜索的空间，即自变量的取值范围，对于无约束问题此处可以省略。</li><li>速度限制：如果粒子飞行速度过快，很可能直接飞过最优解位置，但是如果飞行速度过慢，会使得收敛速度变慢，因此设置合理的速度限制就很有必要了<br>&nbsp;</li></ul><p>实例：求解函数最大值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202937.png" alt="image-20211227130748742" style="zoom:67%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line"><span class="comment">%% 初始化种群</span></span><br><span class="line">f= @(x)x .* <span class="built_in">sin</span>(x) .* <span class="built_in">cos</span>(<span class="number">2</span> * x) - <span class="number">2</span> * x .* <span class="built_in">sin</span>(<span class="number">3</span> * x); <span class="comment">% 函数表达式</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);ezplot(f,[<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">20</span>]);</span><br><span class="line">N = <span class="number">50</span>;                         <span class="comment">% 初始种群个数</span></span><br><span class="line">d = <span class="number">1</span>;                          <span class="comment">% 空间维数</span></span><br><span class="line">ger = <span class="number">100</span>;                      <span class="comment">% 最大迭代次数     </span></span><br><span class="line">limit = [<span class="number">0</span>, <span class="number">20</span>];                <span class="comment">% 设置位置参数限制</span></span><br><span class="line">vlimit = [<span class="number">-1</span>, <span class="number">1</span>];               <span class="comment">% 设置速度限制</span></span><br><span class="line">w = <span class="number">0.8</span>;                        <span class="comment">% 惯性权重</span></span><br><span class="line">c1 = <span class="number">0.5</span>;                       <span class="comment">% 自我学习因子</span></span><br><span class="line">c2 = <span class="number">0.5</span>;                       <span class="comment">% 群体学习因子 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:d</span><br><span class="line">    x = limit(<span class="built_in">i</span>, <span class="number">1</span>) + (limit(<span class="built_in">i</span>, <span class="number">2</span>) - limit(<span class="built_in">i</span>, <span class="number">1</span>)) * <span class="built_in">rand</span>(N, d);<span class="comment">%初始种群的位置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">v = <span class="built_in">rand</span>(N, d);                  <span class="comment">% 初始种群的速度</span></span><br><span class="line">xm = x;                          <span class="comment">% 每个个体的历史最佳位置</span></span><br><span class="line">ym = <span class="built_in">zeros</span>(<span class="number">1</span>, d);                <span class="comment">% 种群的历史最佳位置</span></span><br><span class="line">fxm = <span class="built_in">zeros</span>(N, <span class="number">1</span>);               <span class="comment">% 每个个体的历史最佳适应度</span></span><br><span class="line">fym = -<span class="built_in">inf</span>;                      <span class="comment">% 种群历史最佳适应度</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(xm, f(xm), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;初始状态图&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">%% 群体更新</span></span><br><span class="line">iter = <span class="number">1</span>;</span><br><span class="line">record = <span class="built_in">zeros</span>(ger, <span class="number">1</span>);          <span class="comment">% 记录器</span></span><br><span class="line"><span class="keyword">while</span> iter &lt;= ger</span><br><span class="line">     fx = f(x) ; <span class="comment">% 个体当前适应度   </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N      </span><br><span class="line">        <span class="keyword">if</span> fxm(<span class="built_in">i</span>) &lt; fx(<span class="built_in">i</span>)</span><br><span class="line">            fxm(<span class="built_in">i</span>) = fx(<span class="built_in">i</span>);     <span class="comment">% 更新个体历史最佳适应度</span></span><br><span class="line">            xm(<span class="built_in">i</span>,:) = x(<span class="built_in">i</span>,:);   <span class="comment">% 更新个体历史最佳位置</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> fym &lt; <span class="built_in">max</span>(fxm)</span><br><span class="line">        [fym, nmax] = <span class="built_in">max</span>(fxm);   <span class="comment">% 更新群体历史最佳适应度</span></span><br><span class="line">        ym = xm(nmax, :);      <span class="comment">% 更新群体历史最佳位置</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    v = v * w + c1 * <span class="built_in">rand</span> * (xm - x) + c2 * <span class="built_in">rand</span> * (<span class="built_in">repmat</span>(ym, N, <span class="number">1</span>) - x);<span class="comment">% 速度更新</span></span><br><span class="line">    <span class="comment">% 边界速度处理</span></span><br><span class="line">    v(v &gt; vlimit(<span class="number">2</span>)) = vlimit(<span class="number">2</span>);</span><br><span class="line">    v(v &lt; vlimit(<span class="number">1</span>)) = vlimit(<span class="number">1</span>);</span><br><span class="line">    x = x + v;<span class="comment">% 位置更新</span></span><br><span class="line">    <span class="comment">% 边界位置处理</span></span><br><span class="line">    x(x &gt; limit(<span class="number">2</span>)) = limit(<span class="number">2</span>);</span><br><span class="line">    x(x &lt; limit(<span class="number">1</span>)) = limit(<span class="number">1</span>);</span><br><span class="line">    record(iter) = fym;<span class="comment">%最大值记录</span></span><br><span class="line">     x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;状态位置变化&#x27;</span>)</span><br><span class="line">     pause(<span class="number">0.1</span>)</span><br><span class="line">    iter = iter+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);<span class="built_in">plot</span>(record);title(<span class="string">&#x27;收敛过程&#x27;</span>)</span><br><span class="line">x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);<span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;最终状态位置&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最大值：&#x27;</span>,num2str(fym)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;变量取值：&#x27;</span>,num2str(ym)]);</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;启发式算法其实是一种试探法，相对于梯度下降法等类似方法而言，它更体现了随机性；相对于盲目搜索算法而言，它又具有一定的方向性。</p><p><strong>5个基本要素</strong></p><ul><li>随机初始化可行解</li><li>评价函数或目标函数的确定</li><li>新解的产生机制</li><li>新解的接受机制</li><li>终止准则</li></ul><p><strong>本质</strong></p><p>&emsp;&emsp;试探法的本质是并行、随机、有一定方向的搜索方法。综合试探法的要素和本质可以看出，试探法中新解的产生机制和接受机制对于算法的全局收敛能力十分重要，有助于克服局部最优问题。</p><blockquote><p>并行性的体现：</p><ul><li>遗传算法中每代种群具备一定数量</li><li>蚁群算法中蚂蚁的数量</li><li>模拟退火算法中内循环的体现（要求降温过程足够缓慢）</li><li>粒子群算法中粒子的数量</li></ul><p>随机性的体现：</p><ul><li>遗传算法中新解的产生机制（交叉和变异）</li><li>蚁群算法中新解的产生机制（释放信息素）</li><li>模拟退火算法中新解的产生机制</li><li>粒子群算法中新解的产生机制（自身经验和他人信息前面的随机系数r1和r2）</li></ul><p>方向性的体现（逐渐向最优解逼近）：</p><ul><li>遗传算法中新解的接受机制（精英保留策略、轮盘赌）</li><li>蚁群算法中新解的接受机制（新解的产生来自于所有蚂蚁留下信息素的引导）</li><li>模拟退火算法中新解的接受机制（Metropolis准则：绝对接受更优解，以一定概率接受较差的解，且随着温度的降低，接受较差解的概率降低，即开始降温过程搜索空间大，增强全局收敛能力，接近稳定状态，更不易接受较差解，使局部搜索更为精确）</li><li>粒子群算法中新解的产生机制（新解的产生来自于粒子本身最优解和所有粒子最优解的引导）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 优化问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G网络切片资源分配文献综述</title>
      <link href="/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/"/>
      <url>/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;随着网络需求的快速持续增长，5G网络需要为传统网络运营商、垂直行业、OTT、第三方满足不同服务质量 (QoS)、服务水平协议 (SLA) 和关键绩效指标 (KPI)的要求，在这种情况下，第四代 (4G) 电信网络的“一刀切”和“一网通”类型不再适用。</p><p>&emsp;&emsp;网络切片是一种很有前途的技术，它可以建立包含专用和共享资源的定制端到端逻辑网络，通过利用 SDN 和 NFV，可以定制与资源相关的网络切片，以满足不同的 QoS 和 SLA。网络切片的资源分配在负载均衡、资源利用率和网络性能方面起着举足轻重的作用。</p><p><strong>主要内容</strong></p><ul><li>SDN 和 NFV 的原理及其对网络切片的影响</li><li>网络切片的基本管理和编排（MO）架构</li><li>RAN和CN切片中的资源类型和相应的隔离级别</li><li>5G 网络切片资源分配算法的原理和数学模型</li><li>提出网络切片的几个开放问题以及潜在的解决方案</li></ul><p><strong>原文</strong></p><p><a href="Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models.pdf" target="_blank">Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models.pdf</a></p><span id="more"></span><p>&nbsp;</p><h2 id="网络切片"><a href="#网络切片" class="headerlink" title="网络切片"></a>网络切片</h2><p>&emsp;&emsp;作为 5G 中很有前途的技术之一，网络切片在电信网络基础设施上创建了端到端（即从无线电接入网络 (RAN) 到核心网络 (CN)）逻辑上独立的网络。每个逻辑上独立的网络称为网络切片，是为特定需求而设计的，由从底层通信和网络资源中抽象出来的若干网络功能和资源组成。网络切片的基本思想与云计算中的基础设施（即服务 IaaS） 的基本思想密切相关。 IaaS 在不同租户之间共享计算、存储和网络资源，并提供由软件定义网络 (SDN) 和网络功能虚拟化 (NFV) 支持的全功能虚拟网络。事实上，SDN和NFV被认为是5G背景下网络切片的关键技术。 SDN依靠控制平面和数据平面的分离来增强数据转发效率和网络可编程性，NFV 使虚拟网络功能 (VNF) 能够在通用硬件上运行以降低部署成本。网络切片作为多个 VNF 的组合，不仅可以提供灵活、可扩展和可编程的网络服务，还可以通过高效编排和管理 VNF 来降低资本支出 (CAPEX) 和运营支出 (OPEX)</p><p>&emsp;&emsp;作为5G电信网络的一个主要问题，网络切片的资源分配面临隔离、定制、弹性、端到端协调等诸多挑战。具体而言，在资源隔离方面，由于通信环境的变化，网络切片的共享和隔离资源并不简单。例如，无线电资源的严格隔离可能导致低复用增益。定制化实现网络切片的高效资源利用，满足特定的网络服务需求。如何将网络服务需求有效地转化为所需的网络资源，需要在不同层面进行更多的考虑，包括控制层面、数据平面层面、网络层面。例如，在时变数据流量下无法直接获得具有相应计算、存储和网络资源的虚拟机（VM）的确切数量。共享资源的动态分配可能会影响网络切片的网络性能。端到端资源分配必须跨越不同的域，例如 CN、RAN 和传输网络 (TN)。在不同网络层的异构技术之间实现新的协调并不容易。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="SDN-amp-NFV"><a href="#SDN-amp-NFV" class="headerlink" title="SDN &amp; NFV"></a>SDN &amp; NFV</h2><h4 id="software-defined-networking"><a href="#software-defined-networking" class="headerlink" title="software defined networking"></a>software defined networking</h4><p>&emsp;&emsp;在SDN的框架中，控制平面与数据平面完全分离，数据平面移动到一个由SDN控制器（Controller）实现的集中位置。 SDN控制器根据手头应用的需求，在链路探索、拓扑管理、策略部署、流表下发等方面生成不同的规则并发送给数据平面。数据平面中的转发设备，例如交换机和路由器，只需应用并执行这些规则。</p><h4 id="Network-Function-Virtualization"><a href="#Network-Function-Virtualization" class="headerlink" title="Network Function Virtualization"></a>Network Function Virtualization</h4><p>&emsp;&emsp;与传统电信设备中网络功能和专有硬件之间的紧密耦合不同，NFV 使网络功能能够以软件设备的形式在通用服务器上运行。为了在电信网络中高效灵活地利用虚拟资源和管理 VNF，欧洲电信标准协会 (ETSI) 提出了 NFV 管理和编排器 NFV-MANO，它由 NFV 编排 (NFVO)、VNF管理器 (VNFM) 和虚拟化基础设施管理器 (VIM)组成。 NFV-MANO 通过 VNFM 和 VIM 管理 VNF 的生命周期。 NFVO 负责编排与外部运营/业务支持系统 (BSS/OSS) 相结合的网络服务。</p><p>&emsp;&emsp;由于其可编程性、可扩展性和灵活性，SDN 和 NFV 被认为是网络切片的关键推动因素。例如，受SDN启发，演进分组核心（EPC）实现了控制面和用户面的分离，从而实现了网络功能的灵活部署。此外，因为 NFV-MANO 管理 VM 或容器对网络功能的创建、更新和终止，网络切片可以以低成本进行初始化和修改。 NFVO 可以在不同的网络环境中调整 VNF 与 VNFM 和 VIM 的资源分配，例如数据流量的波动、网络切片中用户的变化等。此外，当某些 VNF 发生故障时，SDN 数据平面中的路由器和交换机可以根据 SDN 控制器配置的流表或调度策略重新路由数据流量。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="MO架构"><a href="#MO架构" class="headerlink" title="MO架构"></a>MO架构</h2><p>&emsp;&emsp;Management and Orchestration Architecture of Network Slicing</p><p>&emsp;&emsp;网络切片的基本问题包括网络切片需求的描述和网络切片的部署及其生命周期管理。为了解决这些问题，第三代合作伙伴计划 (3GPP) 提出了具有相应网络功能的基本 MO 架构，包括通信服务管理功能 (CSMF)、网络切片管理功能 (NSMF) 和网络切片子网管理功能 (NSSMF) ，每个子网都有一个 NSSMF，例如：RAN、CN。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226105342.png" alt="image-20211226105335500" style="zoom: 50%;" /><p>&emsp;&emsp;在这种架构下，特定网络服务的需求由CMSF转换为网络切片的需求（即网络切片需求描述），传递给NSMF。然后，NSMF 将网络切片的需求分解为不同子网的需求。不同子网中的 NSSMF 管理和编排相应子网中的网络切片。例如，CN 中的 NSSMF 可以根据从 NSMF 接收到的网络服务的需求，求解出计算、存储和网络资源（即 VM 的资源）相关联的 VNF 的数量。然后，基本的 VNF 由 NFV-MANO 初始化，如图左侧所示。资源分配依赖于带有NFV-MANO的NSSMF，可以根据网络服务的需求计算所需的资源。此外，带有 NFV-MANO 的 NSSMF 可以通过升级或扩展网络功能来动态调整资源分配，这些功能由流量波动或网络切片需求的变化触发。在网络切片的 MO 架构下，隔离级别和数学模型在资源分配中扮演着重要的角色。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Resouce-Type-and-Isolation"><a href="#Resouce-Type-and-Isolation" class="headerlink" title="Resouce Type and Isolation"></a>Resouce Type and Isolation</h2><h4 id="RAN-Slicing"><a href="#RAN-Slicing" class="headerlink" title="RAN Slicing"></a>RAN Slicing</h4><p>&emsp;&emsp;频谱是 RAN 切片的基本无线资源，在长期演进 (4G LTE) 系统中，频谱资源被提取为资源块 (RB) 或物理资源块 (PRB)。具有专用 PRB 的网络切片严格确保所需的 QoS/SLA，而公共媒体访问控制 (MAC) 调度程序可以分配和管理共享 PRB 以适应弹性流量、变化的信道条件和 QoS 要求，从而增强资源弹性和复用增益。除了频谱资源以外，其他基本物理资源还有：包括传输功率和基站（BS）的缓存空间等。</p><p>&emsp;&emsp;基于 PRB 隔离，数据包调度作为一种高级隔离，负责决定使用空闲 PRB 处理数据流量的时间。最高级别的资源隔离是<strong>准入控制</strong>，它通过估计网络资源使用状态来确定是否在用户和 CN（即无线接入承载）之间建立数据传送服务。更一般地，准入控制还包括确定是否允许用户访问网络或是否接受网络切片请求。此外，<strong>用户关联</strong>是RAN切片中资源分配的重要步骤，它决定了用户是否与特定的BS相关联。用户关联发生在数据传输之前和用户准入控制之后。很难为用户关联确定不同的隔离级别，但值得注意的是它在负载平衡、无线电频谱效率和网络效率方面起着关键作用。</p><p>&emsp;&emsp;与传统的RAN架构相比，Cloud-RAN（C-RAN）将基带过程和远程无线接入分离。集中式基带单元 (BBU) 池、分布式多个远程射频头 (RRH)、通过光链路连接 BBU 池和 RRH 的前传网络以及将 BBU 池连接到 CN 的回程网络是 C-RAN的四个基本部分。 BBU池用于基带处理，建立在具有虚拟化技术的高性能通用硬件上，可以运行在虚拟机或容器上，以提高物理资源（如计算、存储、网络资源）的利用率。由于部署成本低，分布式 RRH 通过天线为用户提供无线接入，以低 CAPEX 和 OPEX 覆盖大面积区域。在设计资源分配算法时，BBU 池和具有前传带宽的 RRH 的容量是重要因素。此外，用户关联和回程容量也会影响资源分配。下图左侧总结了与 RAN 切片的资源类型相关的隔离级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226123601.png" alt="image-20211226123601454" style="zoom:67%;" /><h4 id="CN-Slicing"><a href="#CN-Slicing" class="headerlink" title="CN Slicing"></a>CN Slicing</h4><p>&emsp;&emsp;与4G中的EPC相比，5G核心网采用更加模块化的架构，将网络划分为更细粒度的网络功能。每个网络功能都可以以VM或容器的方式部署在虚拟平台上，由SDN和NFV进行管理和编排，提供灵活、可扩展、可编程的网络服务。CN 切片中的高级资源隔离可以是 VM 或容器，这意味着网络运营商利用 VM 或容器粒度的扩展/扩展操作来初始化或调整资源分配。</p><p>&emsp;&emsp;在NFV-MANO的框架下，一个CN切片由多个VNF组成，形成一个运行在底层网络上的虚拟网络。在这种情况下，CN 切片的资源分配被转换为虚拟网络嵌入 (VNE) 问题。VNE 提出了两个问题：将虚拟节点映射到物理节点，将连接虚拟节点的虚拟链路映射到连接物理节点的路径。物理节点和路径代表计算、存储和网络资源。在我们看来，VNE 可用于对 CN 切片以及 C-RAN 切片的某些部分（例如，BBU 容量的虚拟化）中的资源分配问题进行建模。 </p><p>CN 切片中的隔离级别和资源类型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135025.png" alt="CN 切片中的隔离级别和资源类型" style="zoom: 67%;" /><p>无线资源管理、VNE和网络切片的资源分配之间的关系：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135101.png" alt="image-20211226135101482" style="zoom:50%;" /><p>&nbsp;</p><h2 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h2><h4 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h4><p>&emsp;&emsp;很自然地将网络切片的资源分配问题表述为线性规划 (LP) 问题或非线性规划 (NLP) 问题，优化目标包括网络切片的吞吐量、资源利用率、下一次分配的剩余物理资源等。一般的约束是基站的传输功率、基于服务合同的每个网络切片的最小PRB数量、不同网络切片之间的分配公平性等，这些可能会因网络环境的变化和网络切片的多样化需求而变得复杂。因此，一些一般的优化问题很难在<strong>多项式时间</strong>内解决。采用结合多个隔离级别的<strong>启发式方法</strong>来推导出具有低计算复杂性的近乎最优的解决方案。</p><h5 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h5><blockquote><p>Dynamic Network Slicing for Multitenant Heterogeneous Cloud Radio Access Networks</p><p>“ This paper proposes a dynamic network slicing scheme for multitenant H-CRANs, which takes into account tenants’ priority, baseband resources, fronthaul and backhaul capacities, quality of service (QoS) and interference. The framework of the network slicing scheme consists of an upper-level, which manages admission control, user association and baseband resource allocation; and a lower-level, which performs radio resource allocation among users. ”</p></blockquote><p>如前所述，C-RAN 通过 BBU 池集中基带处理能力，BBU 池通过前传网络连接到多个 RRH，并通过回程网络连接到 CN。因此，BBU 池和前传/回传网络的容量作为新的约束，被用于 C-RAN 切片的一般优化问题的框架中。此文中的作者提出了一种分层资源分配方案，以最大化 C-RAN中所有网络切片的网络吞吐量。分层方案包括准入控制、用户关联、虚拟BBU容量分配作为上层分配，以及相应网络切片中每个用户的PRB和传输功率分配作为下层分配。当上层分配的最佳结果用于下层分配时，计算负担和大的信令开销会显着减轻。</p><p>&nbsp;</p><h5 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h5><blockquote><p>A Service-Oriented Deployment Policy of End-to-End  Network  Slicing  Based  on  Complex  Network  Theory</p><p>“  In this paper, a mathematical model is used to construct network slice requests and map them to the infrastructure network. The mapping process consists of two steps: the placement of virtual network functions and the selection of link paths chaining them. To efficiently utilize the limited physical resources, we pay attention to the service-oriented deployment by offering different deployment policies for three typical slices: eMBB slices, mMTC slices, and uRLLC slices. Furthermore, we adopt complex network theory to obtain the topological information of slices and infrastructure network. With the topological information, we define a node importance metric to rank the nodes in node mapping. To evaluate the performance of deployment policy we proposed, extensive simulations have been conducted.  ”</p></blockquote><p>此文中利用通用数学模型探索了端到端网络切片的资源分配。 RAN、传输网络(TN) 和CN 中的资源被抽象为计算和带宽资源。然后，将资源分配问题转化为VNE问题，根据不同的网络切片类型有不同的目标。例如，优化目标是最小化超可靠和低延迟通信 (uRLLC) 网络切片的数据包延迟。在为海量机器类型通信（mMTC）网络切片分配资源时，应最大化当前网络切片部署后剩余的物理链路数量。</p><p>&nbsp;</p><h4 id="博弈论经济模型"><a href="#博弈论经济模型" class="headerlink" title="博弈论经济模型"></a>博弈论经济模型</h4><blockquote><p>价格差异化是一种基于经济和博弈模型的简单方法，它根据不同的网络切片的特点，如流量模型、资源容量、所需资源数量、网络切片优先级等，为不同的网络切片分配不同的价格。一个典型的优化目标是基础设施提供商的收入。</p></blockquote><p>&emsp;&emsp;网络切片为传统网络运营商、垂直行业和第三方提供了新的商业机会。在5G网络切片的场景中，典型的参与者有3个：网络运营商、网络切片的租户、网络切片的用户。网络运营商（例如基础设施提供商）提供包括物理资源和虚拟资源在内的网络基础设施，并建立网络切片以满足网络服务的要求;网络切片的租户（即网络服务提供商）向网络运营商提出网络服务需求，并为用户提供网络服务;用户（例如，用户设备UE）使用网络切片提供的网络服务。与上面讨论的一般模型相比，经济模型和博弈模型提供了复杂而有效的方法来描述这三个参与者之间的关系，可以制定优化问题，例如网络资源分配的公平性、网络的利润最大化。网络切片的运营商或租户，以及网络切片用户的成本最小化。例如，预算、成本、收入、利润和价格等经济因素对这些玩家在游戏过程中的资源分配有显着影响。经济和博弈模型可以在不牺牲资源分配公平性的前提下，为基础设施提供商的收入或利润最大化提供可行的解决方案。</p><h5 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h5><blockquote><p>Optimising 5G infrastructure markets: The business of network slicing</p><p>“ In this paper, we address this issue by designing an algorithm for the admission and allocation of network slices requests that (i) maximises the infrastructure provider’s revenue and (ii) ensures that the service guarantees provided to tenants are satisfied. Our key contributions include: (i) an analytical model for the admissibility region of a network slicing-capable 5G Network, (ii) the analysis of the system (modelled as a Semi-Markov Decision Process) and the optimisation of the infrastructure provider’s revenue, and (iii) the design of an adaptive algorithm <strong>(based on Q-learning)</strong> that achieves close to optimal performance. ”</p></blockquote><p>网络切片根据其流量模型定价不同，包括<strong>弹性</strong>和<strong>非弹性</strong>数据流量模型 。本文进一步推导出弹性网络切片和非弹性网络切片数量之间的关系，该关系在最大接纳非弹性网络切片数量和非弹性网络切片和弹性网络切片的固定总和的限制下。基于关系和价格差异，提出了一种结合半马尔可夫决策过程（SMDP）的价值迭代算法来搜索网络切片请求的最佳准入控制，以最大化基础设施提供商的收入。</p><p>&nbsp;</p><h5 id="example-4"><a href="#example-4" class="headerlink" title="example 4"></a>example 4</h5><blockquote><p>Network Slicing Games: Enabling Customization in Multi-Tenant Mobile Networks</p><p>“ This paper provides an analysis of a well-known model for resource sharing, the share-constrained proportional allocation mechanism, to realize network slicing. This mechanism enables tenants to reap the performance benefits of sharing, while retaining the ability to customize their own users’ allocation. This results in a network slicing game in which each tenant reacts to the user allocations of the other tenants so as to maximize its own utility. We show that, for elastic traffic, the game associated with such strategic behavior converges to a Nash equilibrium. At the Nash equilibrium, a tenant always achieves the same or better performance than that of a static partitioning of resources, thus providing the same level of protection as static partitioning. We further analyze the efficiency and fairness of the resulting allocations, providing tight bounds for the price of anarchy and envy-freeness. Our analysis and extensive simulation results confirm that the mechanism provides a comprehensive practical solution to realize network slicing. Our theoretical results also fills a gap in the analysis of this resource allocation model under strategic players. ”</p></blockquote><p>费雪（Fisher）市场作为一种著名的经济模型，被用来研究用户和网络切片之间的公平性。 Fisher 市场中预算固定的购买者映射成共享网络资源的网络切片租户、买家的出价被映射成网络切片租户的偏好。在 5G 网络切片场景中，网络切片的租户可以根据资源拥塞情况动态调整其偏好，以最大化自身效用。在这种情况下，资源分配问题转化为如何通过<strong>非合作博弈</strong>共同考虑网络切片的偏好和用户公平性来为网络切片分配资源。</p><p>&nbsp;</p><h5 id="example-5"><a href="#example-5" class="headerlink" title="example 5"></a>example 5</h5><blockquote><p>Coalitional Game for the Creation of Efficient Virtual Core Network Slices in 5G Mobile Systems</p><p>“ Our contribution in this paper is twofold. First, we devise an algorithm that derives the optimal number of virtual instances of 4G (MME, SGW, and PGW) or 5G (AMF, SMF, and AUSF) core network elements to meet the requirements of a specific mobile traffic. Second, we propose an algorithm for the placement of these virtual instances over a federated cloud. While the first algorithm is based on mixed integer linear programming, the second is based on coalition formation game, wherein the aim is to build coalitions of cloud networks to host the virtual instances of the vEPC/5G core elements. ”</p></blockquote><p>与预测和分析非合作博弈中每个玩家的行为不同，<strong>合作博弈</strong>调查由单个玩家或外部强制（例如合同规则）形成的玩家之间的联盟。联盟的组成、联盟产生时的联合行动、联盟已经形成时的集体收益是合作博弈的研究兴趣。以CN切片为例。 VNF放置问题在合作博弈的框架下通过两步解决。首先，在同一个云网络中，制定了一个优化问题，旨在通过调整 VNF 的数量来最小化 VNF 的创建成本。然后讨论如何将这些 VNF 放置在不同的云网络中，以保证 QoS/SLA 并最大化每个云网络的利润。事实上，部署了 VNF 的不同云网络可以形成不同的联盟。</p><p>&nbsp;</p><h4 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h4><p>&emsp;&emsp;预测模型用于根据经验知识或历史信息预测适当或最佳的资源数量。预测对象包括:用户到达率、网络切片中的数据流量、网络切片请求等。简单的预测方法直接使用经验数据或一些众所周知的概率模型。</p><h5 id="example-6"><a href="#example-6" class="headerlink" title="example 6"></a>example 6</h5><blockquote><p>Conformal Mapping  for  Optimal  Network  Slice  Planning  Based  on  Canonical   Domains</p><p>“ This paper addresses this issue by mapping the non-uniform distribution of signaling messages in the physical domain to a new uniform environment (i.e., canonical domain) whereby the placement of core functions is more feasible and efficient by means of Schwartz-Christoffel conformal mappings. The experimentation results, compared to some baseline approaches, have proven the efficiency of the conformal mapping based placement in allocating the virtual resources (i.e., virtual CPU and virtual storage) with regard to the optimal end-to-end delay, cost and activated virtual machines. Another interesting contribution is that all placement decisions are based on a realistic spatio-temporal user-centric model, which defines both the mobility of user equipments and the underlying service usage. “</p></blockquote><p>与使用合作博弈的 VNF 放置不同，VNF 的位置由会话请求到达率的<strong>概率分布</strong>决定。假设会话请求的到达率在物理域中遵循非均匀分布，通过 Schwarz-Christoffel 映射将其转换为规范域中的均匀分布。然后根据会话请求的数量和会话请求的到达率，很容易推导出规范域中 VNF 的最佳数量和位置。而VNFs在物理域中的对应位置可以通过逆空间变换函数得到。</p><p>&nbsp;</p><h5 id="example-7"><a href="#example-7" class="headerlink" title="example 7"></a>example 7</h5><blockquote><p>Mobile Traffic Forecasting for Maximizing 5G Network Slicing Resource Utilization</p><p>“ This paper focuses on the design of three key network slicing building blocks responsible for (i) traffic analysis and prediction per network slice, (ii) admission control decisions for network slice requests, and (iii) adaptive correction of the forecasted load based on measured deviations. Our results show very substantial potential gains in terms of system utilization as well as a trade-off between conservative forecasting configurations versus more aggressive ones (higher gains, SLA risk). ”</p></blockquote><p>基于时间序列的预测模型作为回归预测，根据过去的观察以及<strong>时间序列预测</strong>网络切片中的统计特征。与经验知识相比，基于时间序列的预测模型更实用，适用于不同的网络环境。 Holt-Winters (HW) 模型优于基本模型和双指数平滑模型，作为一种复杂的时间序列模型，不仅可以捕捉数据趋势，还可以捕捉数据季节性。在本文中，当用户数量固定时，HW模型用于分析网络切片中未来的流量请求。此外，当用户在多蜂窝环境中移动时，网络切片的流量模型也由 HW 模型预测。值得注意的是，每个被接纳的网络切片都设计了反馈机制，以提高硬件模型的预测精度。</p><p>&nbsp;</p><h5 id="example-8"><a href="#example-8" class="headerlink" title="example 8"></a>example 8</h5><blockquote><p>Information Prediction and Dynamic Programming Based RAN Slicing for Mobile Edge Computing</p><p>“ In this letter, the work is focused on the RAN slicing between MEC services and traditional services. An information prediction and dynamic programming based RAN slicing algorithm is proposed. It guarantees the inter-slice isolation and realizes the intra-slice customization. Furthermore, it can optimize the network utility with high fairness in polynomial time complexity. ”</p></blockquote><p>机器学习根据历史数据和决策生成最优或次优策略，适用于没有统一概率分布的场景。例如，支持向量回归（SVR）作为机器学习中的典型分类算法，用于预测时分双工(FDD)-OFDMA无线网络中网络切片的统计特征值。更具体地说，本文中的作者针对不同的上行/下行配置实现了移动边缘计算（MEC）和传统网络服务的RAN切片的资源分配。该配置被表述为具有网络切片统计特征的封闭式表达式，包括能量开销、运行时开销以及上下行链路的流量和数据速率。MEC 和传统网络服务的最佳配置是从封闭形式的表达式中导出的，其中包含 SVG 预测的统计特征值。</p><p>&nbsp;</p><h4 id="鲁棒性和故障恢复模型"><a href="#鲁棒性和故障恢复模型" class="headerlink" title="鲁棒性和故障恢复模型"></a>鲁棒性和故障恢复模型</h4><p>&emsp;&emsp;网络切片的资源分配算法不仅要提高资源利用效率，还要处理不可预测的网络事件，以实现电信网络的高可用性。不可预知的网络事件包括网络拥塞（由大量数据流量引起）或网络功能故障（由软件或硬件意外故障引起）。冗余资源预留和网络功能重新映射是两种有效的方法。</p><h5 id="example-9"><a href="#example-9" class="headerlink" title="example 9"></a>example 9</h5><blockquote><p>Optimisation  Models  for  Robust  and Survivable Network Slice Design: A Comparative Analysis</p><p>“ In this work, we first outline a mathematical model for the general network slice design problem and extend it to cope with traffic uncertainties. We employ the Γ-robust uncertainty set [1], [2] to model the uncertainties in the traffic demands. Furthermore, we add survivability aspects to our model by protecting the network slice against single substrate network element (node/link) failures. Finally, both survivability and traffic robustness approaches are considered simultaneously and we present two different optimisation models. A performance evaluation is carried out comparing the different robust and survivable models with their non-robust non-survivable counterpart using network topology examples from SNDlib. ”</p></blockquote><p>冗余资源预留为网络切片提供额外资源，例如多个 VNF 实例，以避免网络功能故障。网络切片的不确定流量由机会约束模型 [14] 表示为对称和随机变量。该变量作为保护级别，分别加入到虚拟节点和虚拟链路的容量约束中，以保证网络切片的鲁棒性。网络功能的重新映射通过将失败的 VNF 映射到好的 VNF 并重新路由失败的虚拟链接来恢复网络服务。</p><p>&nbsp;</p><h5 id="example-10"><a href="#example-10" class="headerlink" title="example 10"></a>example 10</h5><blockquote><p>Protocol Function Block Mapping of Software Defined Protocol for 5G Mobile Networks</p><p>“ In this paper, we propose software-defined protocol (SDP) technique to facilitate flexible service-oriented protocol stack deployment for providing high-throughput, low-latency and elastic mobile services based on platform virtualization and functionality modularization. We first elaborate the principle of SDP and then address one of the most important issues in SDP, namely SDP request mapping (SDPM), where an SDP request is fulfilled by mapping a set of required SDP function blocks and virtual links onto underlying SDP servers. We formulate the SDPM problem as a mixed integer programming (MIP). To address the NP-hardness and scalability of SDPM problem, we propose a decomposition algorithm which breaks down the SDPM problem into inter-block link and block mapping problems to accomplish the upper bound (UB) and lower bound (LB) of the MIP solution, respectively. The optimality can be achieved when the UB and the LB converges by using iterations. We employ LTE Layer-2 data-plane processing as a benchmark for validating the effectiveness of the SDP technique and evaluate the performance of SDPM algorithm. Numerical results show that SDP is effective to provide elastic low-latency mobile services and the proposed SDPM algorithm significantly outperforms the benchmark in stack processing delay, mapping cost, and resource utilization. “</p></blockquote><p>优化目标是在重新映射期间最小化总带宽消耗。</p><p>&nbsp;</p><h3 id="4种模型对比"><a href="#4种模型对比" class="headerlink" title="4种模型对比"></a>4种模型对比</h3><p>图中说明了四种数学模型之间的关系，每个饼图中每种方法的比例代表了相应的研究潜力：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161345.png" alt="image-20211226161345382" style="zoom: 33%;" /><p>表中根据目标、资源类型、场景和关键描述总结了所讨论的算法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161507.png" alt="image-20211226161507843" style="zoom:50%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="网络切片潜力研究方向"><a href="#网络切片潜力研究方向" class="headerlink" title="网络切片潜力研究方向"></a>网络切片潜力研究方向</h3><h4 id="资源分配的更新周期"><a href="#资源分配的更新周期" class="headerlink" title="资源分配的更新周期"></a>资源分配的更新周期</h4><p>&emsp;&emsp;为了尽可能降低资源分配算法的计算复杂度，前面提出了启发式方法以提供具有低计算复杂度的次优解决方案。而<strong>多级资源分配</strong>则是另一种方式，包括准入控制、用户关联等。然而，很少有研究报告或出版物讨论资源分配算法的更新周期。合适的更新间隔不仅可以提高资源利用率，还可以减少信令开销和计算负担。在example1中，作者指出分配PRB的周期不能短于信道条件报告的周期。较长的更新周期在慢变通道中是可行的解决方案，但在快变通道中可能无法实现高性能。此外，在设计资源分配更新周期时，可以综合考虑用户数量的变化、数据流量的波动以及网络功能故障的平均周期。</p><p>&nbsp;</p><h4 id="无线电接入技术-RATs-的异质性"><a href="#无线电接入技术-RATs-的异质性" class="headerlink" title="无线电接入技术 (RATs) 的异质性"></a>无线电接入技术 (RATs) 的异质性</h4><p>&emsp;&emsp;5G 预计将跨越和聚合多种异构 RAT，例如 3G、4G、LTE 和 WiFi。 5G网络切片中不同RAT的协作变得尤为重要，应满足网络切片的多样化需求。例如，车联网 (V2X) 网络切片中的车载信息娱乐应用依赖 LTE 和 WiFi 来提高网络吞吐量。在 mMTC 网络切片上运行的窄带物联网 (NB-IoT) 应用可能需要多种 RAT 来增强网络连接。当前的算法侧重于密集的异构无线网络，并研究宏蜂窝和小蜂窝之间的合作，对于不同的网络切片，可以在无缝切换、流量隔离和网络切片公平性等方面进一步研究多制式的资源分配，以增强用户体验，提高资源利用率。</p><p>&nbsp;</p><h4 id="端到端网络切片的资源分配"><a href="#端到端网络切片的资源分配" class="headerlink" title="端到端网络切片的资源分配"></a>端到端网络切片的资源分配</h4><p>&emsp;&emsp;大多数当前的资源分配算法都集中在单个子网，例如 RAN 或 CN。除了example2中的解决方案，很少有研究人员考虑端到端的网络切片。无线电和虚拟机的资源分别抽象为带宽和计算资源，在为特定的网络切片类型设计资源分配方案时只考虑其中之一。事实上，SLA 分解和多子网协调是端到端网络切片资源分配的主要挑战。由于缺乏基本的通信知识，网络切片的租户可能只向 NSMF 提供端到端的 SLA，而不需要每个子网。因此，如何将端到端的 SLA 分解为各个子网的需求是资源分配的必然步骤。SLA分解不仅要考虑端到端的容量，还要考虑每个子网的容量。多个子网之间的协调也很重要，尤其是在更新资源分配时。每个子网应定期通过 NSSMF 向 NSMF 报告其剩余容量，NSMF 可以实现资源分配的适当调整，以适应不断变化的网络环境。例如，如果某些子网过载，则应向 NSMF 报告，然后允许剩余的子网获得更多资源以保证所需的端到端 SLA。潜在的数学模型应该基于多运营商核心网（MOCN）和网关核心网（GWCN）精心设计，这是不同子网之间资源共享的两种基本架构。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每月歌单</title>
      <link href="/2021/12/09/test/"/>
      <url>/2021/12/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分享每月歌单</p><span id="more"></span><h5 id="2021-12"><a href="#2021-12" class="headerlink" title="2021-12"></a>2021-12</h5><p># 歌曲模板</p>    <div id="aplayer-UJjTjXIA" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p># 歌单模板</p>    <div id="aplayer-LEDaNTaw" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于令牌桶算法的LTE下行链路调度器设计</title>
      <link href="/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/"/>
      <url>/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;LTE网络支持共享无线接入和核心网络资源的不同类型的服务，包括：尽力而为、延迟敏感和实时（RT）服务。每种服务在比特率、延迟和分组丢失方面都有不同的QoS要求。</p><p>&emsp;&emsp;基站eNB的第一个目标是为UE提供高频谱效率，使更多的活跃用户可以在网络中接收服务。第二个目标是用户对接收的服务质量（QoS）的满意度。为了实现这些目标，eNB中的资源分配必须知道信道条件、UE请求的服务类型和其他参数。</p><p>&emsp;&emsp;eNB将一个小区中的可用无线电资源分配给活动用户（Active UE）。因此需要设计合适的调度算法来支持具有不同QoS要求的业务，尤其是RT业务。</p><p><strong>原文</strong></p><p><a href="A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems.pdf" target="_blank">A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems</a></p><span id="more"></span><p>&nbsp;</p><h3 id="现有调度算法研究"><a href="#现有调度算法研究" class="headerlink" title="现有调度算法研究"></a>现有调度算法研究</h3><ol><li><p>LTE下行链路中指数/比例公平（EXP/PF）和改进的最大加权延迟优先（M-LDWF）</p><p>都只在一个域中执行调度过程</p><p>带宽为5MHz的系统中，M-LDWF比EXP/PF提供了更多的吞吐量，但是EXP/PF满足了更多用户的QoS要求（RT用户所需的带宽因素所导致）</p><p>建议在低负载网络中使用M-LDWF，在网络负载增加时使用EXP/PF[2]</p></li><li><p>利用CQI反馈发送来自用户的空闲缓冲区值的报告以及实时和非实时服务的QoS需求，比PF具有更高的吞吐量，并且降低了丢包概率。[3]</p></li><li><p>VOIP流量调度的一些算法满足了该服务的QoS要求，并防止了由于优先考虑网络中的VOIP服务引起的不良影响。它通过分组丢弃来调整给予VOIP的优先级的持续时间。[4]</p></li><li><p>有的算法使用了时域和频域两级调度器，在用户之间保证了公平性，时域（TD）调度器提供用户所需的QoS参数，而频域（FD）调度器根据TD调度器给定的输入实现最高的频谱效率。[8]</p><p>该论文的另一个结论是，TD-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></li><li><p>另一个算法也是时域和频域两级调度器，在时域中使用PF算法来实现用户之间的公平性，而在FD中比较不同的算法。结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。[9]</p></li><li><p>还有一个算法也是时域和频域两级调度器，将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。[12]</p></li></ol><p>&emsp;&emsp;在之前的工作中，与GBR相关的流量通常在eNB中处理的优先级最高。虽然保障了GBR业务的时延性能，但是会导致小区的整体性能降低。</p><p>&emsp;&emsp;本论文提出了一种QoS感知的调度方法，包含时域和频域。先使用经典的五元组将不同的流映射到不同的载波。将VOIP和video流量分为GBR类、FTP和HTTP分为nGBR类。在GBR类中利用令牌桶算法来阻止其使用所有资源。这种不仅保证了两个类间资源分配的公平性，还提高了系统的总吞吐量。</p><p>&nbsp;</p><h3 id="LTE下行链路调度器"><a href="#LTE下行链路调度器" class="headerlink" title="LTE下行链路调度器"></a>LTE下行链路调度器</h3><p>&emsp;&emsp;正交频分多址（OFDMA）将分布在整个频谱中的一组子载波专用于用户。带宽被划分为180kHz的子信道，包括12个连续的子载波。时间/频率无线电资源扩展到时域中的两个时隙和频域中的一个子信道上，称为资源块（RB），是LTE中用于资源分配的最小单元。RBs的数量取决于系统带宽，例如，对于5 MHz系统，RBs数量为25，而在10 MHz系统中，RBs数量为50。</p><p>&emsp;&emsp;eNB使用信道状态信息获取每个用户链路上的信息。用户在每个TTI中向eNB报告其下行链路流状态。数据包优先级由eNB的调度器根据数据包延迟、下行链路状态、缓冲区状态、流量类型等参数确定。而特定数据包流的专用RB数量取决于调度器中使用的资源分配算法。以前大多数工作中的数据包调度器有两个阶段。先是时域调度器基于调度算法（自行设计）的输入参数选出请求服务的用户，然后频域调度器按照算法（自行设计）将资源分配给时域中选择出的用户。分组调度器使用CQI获取所有rb中的每个信道的质量信息。</p><p>&nbsp;</p><h3 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h3><h5 id="业务分类"><a href="#业务分类" class="headerlink" title="业务分类"></a>业务分类</h5><p>&emsp;&emsp;VOIP、Conversational Video 归为 GBR业务</p><p>&emsp;&emsp;FTP、HTTP 归为 nGBR业务</p><h5 id="时域调度"><a href="#时域调度" class="headerlink" title="时域调度"></a>时域调度</h5><p>&emsp;&emsp;TD调度器最重要的功能是根据QoS参数和信道的当前状态选择请求资源的活动用户（Activate UE）。</p><p>&emsp;&emsp;在没有资源分配给用户的第一阶段，TD调度器确定不同类别的活动Bearer（activate bearers），并根据不同的需求对它们进行优先级排序。由于TD调度器没有关于分配给每个用户的RBs的信息，因此利用所有RBs上的用户cqi的平均值来比较用户的信道条件，获取最大度量值的用户具有最高优先级。TD调度器创建用户和活动Bearer，分为GBR组和nGBR组并按优先级排序，并向FD调度器发送这两个单独的列表。</p><h6 id="GBR"><a href="#GBR" class="headerlink" title="GBR"></a>GBR</h6><p>&emsp;&emsp;GBR Bearer必须保证数据速率，与对延迟敏感的应用相关。本算法中GBR Bearer的QoS参数计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080439.png" alt="image-20211201173407839" style="zoom:50%;" /><p>&emsp;&emsp;注意，在eNB缓冲区中花费更多时间的数据包具有更高的服务交付优先级。</p><h6 id="nGBR"><a href="#nGBR" class="headerlink" title="nGBR"></a>nGBR</h6><p>&emsp;&emsp;nGBR Bearer通常包括尽力而为的服务，对延迟不敏感。nGBR类的不同活动Bearer根据不同的条件进行优先级排序。优先级排序使用nGBR的优先级因子完成，其行为类似于WPF算法，做了一些轻微的修改。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184317.png" alt="image-20211201184317270" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184346.png" alt="image-20211201184346056" style="zoom:50%;" /><p>&emsp;&emsp;参数 r 较大的nGBR用户在资源分配中优先于其他用户。</p><p>&nbsp;</p><h5 id="频域调度"><a href="#频域调度" class="headerlink" title="频域调度"></a>频域调度</h5><p>&emsp;&emsp;FD调度器负责将RBs分配给不同的持有人。FD调度器根据TD调度器发来的候选列表来确定在特定TTI中必须服务哪些Bearer。FD调度器优先服务于GBR Bearer，然后服务于nGBR Bearer。通过令牌桶算法确定允许分配资源的GBR Bearer，然后使用改进的LWDF、M-LWDFS对这些Bearer进行调度。<strong>（这里与流程图不符，流程图是PF算法调度）</strong></p><p>&emsp;&emsp;当GBR流量或相关令牌分配完后，FD调度器开始将资源分配给nGBR用户。采用了PF算法，在用户公平性和小区整体性能之间取得了较好的平衡。该算法计算用户信道的当前状态和先前接收的服务但是却不考虑QoS，因此PF适合非RT流量而不适合RT流量。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201185426.png" alt="image-20211201185425952" style="zoom:50%;" /><p>&emsp;&emsp;FD完整流程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201191306.png" alt="image-20211201191306507" style="zoom:50%;" /><p>&nbsp;</p><h3 id="仿真比较结果"><a href="#仿真比较结果" class="headerlink" title="仿真比较结果"></a>仿真比较结果</h3><p>&emsp;&emsp;为了研究提出的调度器在RT流量情况下对资源分配系统的影响，文章还模拟了TD-PF/FD-PF算法以及无令牌桶的情况。TD-PF/FD-PF算法虽然依据信道状态和服务质量，但是却并不考虑QoS，因此在RT流量业务的表现不佳。无令牌桶调度虽然考虑了QoS性能，但是由于GBR Bearer的优先级高于nGBR Bearer的优先级，而没有令牌桶对流量进行限制，因此当BGR业务需求较高时，nBGR业务无法顾及导致小区整体吞吐量降低。含令牌桶的调度是二者的折中，即维护了小区整体的吞吐量，又对RT流量业务的时延性能有所保证。</p><h6 id="三种业务情景"><a href="#三种业务情景" class="headerlink" title="三种业务情景"></a>三种业务情景</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192306.png" alt="image-20211201192305975" style="zoom:50%;" /><h6 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080440.png" alt="image-20211201192342289" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192359.png" alt="image-20211201192359425" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192413.png" alt="image-20211201192413873" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192430.png" alt="image-20211201192430785" style="zoom:50%;" /><p>&nbsp;</p><h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>&emsp;&emsp;其实这个令牌桶算法没有什么精巧的地方，无非是限制了对GBR业务资源分配，这样就能发论文，虽然是很多年前的了，但是一下让我觉得发论文也不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab音频滤波</title>
      <link href="/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Matlab-音频信号处理"><a href="#Matlab-音频信号处理" class="headerlink" title="Matlab 音频信号处理"></a>Matlab 音频信号处理</h2><p>&emsp;&emsp;现有原始音频文件<code>SunshineSquare.wav</code>，后半段音频被人为加上了多频段的噪音，使用matlab工具对其进行分析并消除噪音还原出无噪音频文件。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><span id="more"></span><p>&nbsp;</p><h3 id="Step1：分析原始音频文件"><a href="#Step1：分析原始音频文件" class="headerlink" title="Step1：分析原始音频文件"></a>Step1：分析原始音频文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[audio_data, fs] = audioread(<span class="string">&#x27;../../SunshineSquare.wav&#x27;</span>);</span><br><span class="line">L = <span class="built_in">length</span>(audio_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一听该音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br></pre></td></tr></table></figure><h4 id="绘制时域图"><a href="#绘制时域图" class="headerlink" title="绘制时域图"></a>绘制时域图</h4><p>&emsp;&emsp;从下面时域图中可以看出，源音频文件时长11秒左右，从第8秒左右开始为一段强噪声。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Original&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = (<span class="number">1</span> : L) * <span class="number">1</span>/fs;</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="built_in">plot</span>(tt, audio_data);grid;</span><br><span class="line">title(<span class="string">&#x27;Time Domain&#x27;</span>);xlabel(<span class="string">&#x27;时间（s）&#x27;</span>);ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><h4 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h4><p>&emsp;&emsp;使用快速傅里叶变换FFT对时域信号进行频谱分析，绘制的频域图反映出有四段噪声频段，后续消除噪声工作就是对这四个频段进行滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="number">2</span>^<span class="built_in">nextpow2</span>(L); <span class="comment">% 先从原始信号长度确定下一个 2 次幂的新长度,用尾随零填充信号以改善 fft 的性能</span></span><br><span class="line">Spectrum = fft(audio_data,L); <span class="comment">% 快速傅里叶变换，转换为频域</span></span><br><span class="line">f_x = fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L; <span class="comment">% 定义频域，即变换横坐标量纲为频率</span></span><br><span class="line">mag_FFT_audio_data = <span class="built_in">abs</span>(Spectrum / L); <span class="comment">% 取幅值，并归一化</span></span><br><span class="line">ang_FFT_audio_data = <span class="built_in">angle</span>(Spectrum)*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="built_in">plot</span>(f_x,mag_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="built_in">plot</span>(f_x,ang_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;ang&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143455.png" alt="image-20211128143455368"></p><h4 id="绘制声谱图"><a href="#绘制声谱图" class="headerlink" title="绘制声谱图"></a>绘制声谱图</h4><p>&emsp;&emsp;声谱图能够以颜色反映各频段信号强度随时间的变化和分布情况，如图所示，从第8秒左右开始有4个频段的强度持续较高，这就是上面频域分析出的4个噪声频段。但需要注意到，在噪声的开始和结束时刻，所有频段的强度都很高，在图中显示为两条垂直的黄线，这两条线仅靠滤波无法消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">spectrogram(audio_data,hann(<span class="number">256</span>),<span class="number">250</span>,<span class="number">256</span>,fs,<span class="string">&#x27;yaxis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143558.png" alt="image-20211128143558882"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step2：滤波"><a href="#Step2：滤波" class="headerlink" title="Step2：滤波"></a>Step2：滤波</h3><h4 id="滤波法1——手动衰减"><a href="#滤波法1——手动衰减" class="headerlink" title="滤波法1——手动衰减"></a>滤波法1——手动衰减</h4><p>&emsp;&emsp;手动衰减各个噪声频段的幅度，注意FFT变换后的频谱图为偶对称，所以共有4对（8个）频段，逐一消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第一个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第二个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第三个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第四个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第五个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第六个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第七个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第八个噪声频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆fft获得处理后的音频</span></span><br><span class="line">ifft_data = <span class="built_in">real</span>(ifft(Spectrum, L));</span><br><span class="line">audio_data = ifft_data(<span class="number">1</span>:<span class="built_in">length</span>(audio_data));</span><br></pre></td></tr></table></figure><h5 id="滤波效果"><a href="#滤波效果" class="headerlink" title="滤波效果"></a>滤波效果</h5><p>&emsp;&emsp;绘制滤波后音频信号的时域图、频域图、声谱图，可看见时域图上噪声被消除，频谱图上4个频段的信号全部被消除，声谱图有四条水平的消磨痕迹。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211130213111.png" alt="image-20211130213111056"></p><p>&nbsp;</p><h4 id="滤波法2——数字滤波器"><a href="#滤波法2——数字滤波器" class="headerlink" title="滤波法2——数字滤波器"></a>滤波法2——数字滤波器</h4><p>&emsp;&emsp;设计梳状滤波器，因为有4个噪声频段，所以设计4个带阻滤波器逐一滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%h1[n] = [1,-2,1];</span></span><br><span class="line">h1 = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>];</span><br><span class="line">h2 = [<span class="number">1</span>,<span class="number">-1.24698</span>,<span class="number">1</span>];</span><br><span class="line">h3 = [<span class="number">1</span>,<span class="number">0.44504</span>,<span class="number">1</span>];</span><br><span class="line">h4 = [<span class="number">1</span>,<span class="number">1.80194</span>,<span class="number">1</span>];</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波过程</span></span><br><span class="line">audio_data_h1 = filter(h1,a,audio_data);</span><br><span class="line">audio_data_h2 = filter(h2,a,audio_data_h1);</span><br><span class="line">audio_data_h3 = filter(h3,a,audio_data_h2);</span><br><span class="line">audio_data_h4 = filter(h4,a,audio_data_h3);</span><br><span class="line"></span><br><span class="line">audio_data = audio_data_h4;</span><br></pre></td></tr></table></figure><h6 id="滤波器分析"><a href="#滤波器分析" class="headerlink" title="滤波器分析"></a>滤波器分析</h6><p>&emsp;&emsp;绘制4个滤波器的幅频、相频、衰减及每次滤波后的信号时域图。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145815.png" alt="image-20211128145815600" style="zoom: 25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145835.png" alt="image-20211128145835590" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128153455.png" alt="image-20211128145856791" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145920.png" alt="image-20211128145920683" style="zoom:25%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step3：后续处理"><a href="#Step3：后续处理" class="headerlink" title="Step3：后续处理"></a>Step3：后续处理</h3><p>&emsp;&emsp;上面已分析，在噪声开始和结束时刻都有全频段的高强度信号，不是滤波能消除的，这里采用时域衰减，即在时域采用同第一种滤波方法相同的思想，手动衰减这两个时刻的信号强度。随后输出处理过的音频文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第一个高音时段</span></span><br><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第二个高音频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一下处理后的音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出音频文件</span></span><br><span class="line">audiowrite(<span class="string">&#x27;SunshineSquare_Processed.wav&#x27;</span>,audio_data,fs); </span><br></pre></td></tr></table></figure><p>使用滤波法2的最终输出信号的分析如下：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128150059.png" alt="image-20211128150059309"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="对数字信号处理的认识"><a href="#对数字信号处理的认识" class="headerlink" title="对数字信号处理的认识"></a>对数字信号处理的认识</h2><p>&emsp;&emsp;《数字信号处理》这门课我觉得其实是两大主题，第一是信号分析，第二是信号处理。</p><p>&emsp;&emsp;信号分析在《信号与线性系统》中有所讲解，但是那时所研究的是连续时间信号的傅里叶级数或傅里叶变换，离散时间信号的傅里叶变换，它们的特点都是：信号无限长，导致计算机无法处理。而为了使用计算机工具帮助对信号进行分析，《数字信号处理》这门课引入了采样、增/减采样和离散傅里叶变换DFT的概念。后续考虑到DFT算法的时间复杂度太高，因此又提出快速傅里叶变换FFT来代替之。</p><p>&emsp;&emsp;信号处理在这门课中主要指滤波。低通、高通、带通、带阻、全通，《信号与线性系统》中共提出过五种模拟滤波器，如何根据所需指标将其转化为对应的数字滤波器来在计算机上使用，是这门课的第二个重点。</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>&emsp;&emsp;模拟信号经过采样、抽取（减采样）后成为计算机可以处理的有限长离散信号。采样后，仍是连续时间信号，但频域上是原始模拟信号频域的周期延拓和幅度放缩。抽取后，变为有限长离散信号，频域点数和时域相同，但横坐标频率被按比例压缩在 0~2pi 范围内，幅值和采样后的一样。</p><h5 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h5><p>&emsp;&emsp;在傅里叶变换中，离散/连续 和 周期/非周期 相对偶，离散周期序列的傅里叶变换仍是离散周期序列。因为计算机容量有限，其处理的信号长度有限，因此从离散周期信号中取一个周期来代替整个信号分析是一种行之有效的方法。DFT也正是在这种思想下被引出，重点在于循环卷积、旋转因子、各种变换性质。</p><p>&emsp;&emsp;但是，用定义计算DFT的时间复杂度太高，计算机效率低。借助公式中“旋转因子”的周期性，长序列的DFT可以不断分解至一组组两点DFT的组合，大大减少了计算量，这就是FFT算法。</p><h5 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h5><p>&emsp;&emsp;数字滤波器有很多值得关注的地方，首先是截止频率、纹波幅度等性能指标，然后是幅频特性、相频特性，还有系统函数的极零点、信号流图等。根据冲激响应长度可分为有限脉冲响应滤波器FIR和无限脉冲响应滤波器IIR。从模拟滤波器转换为数字滤波器的方法有冲激响应不变法、双线性变换法。常用的滤波器有巴特沃斯滤波器、切比雪夫滤波器、椭圆滤波器等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大二一年</title>
      <link href="/2021/12/02/%E3%80%90%E6%97%A5%E5%B8%B8%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/"/>
      <url>/2021/12/02/%E3%80%90%E6%97%A5%E5%B8%B8%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在华科度过了两年时间里，我看过东九楼前路边的银杏一夜间被北风吹去满树黄叶，也曾在凌晨五点的晨雾中从百景园自习区一路徒步走回韵苑。回想大一大二的时光，涌上我心头的并不是特别的成就感，亦不是其他大喜大悲，而是平淡与坦然。如果要用一句话概括这一年，我想用大物老师曾提到过的——看山不是山。</p><span id="more"></span><p>&emsp;&emsp;现在看来，大一一年里我只做了两件对现在仍有影响的事，一是熟悉了大学的学习方式，把加权拉得很高；二是认识到，每天都在自习室度过，这样和高中没太大区别，我不喜欢只是这样的大学生活。大二开学那阵，我因为加权高并且也有一些课外的成绩所以拿到了国奖，有些自傲，那是心里总觉得大学生活怎么和高中没什么区别呀，无非是可以用iPad记笔记、带手机上课罢了。禅宗里描述有三种境界，“看山是山，看山不是山，看山还是山。”第一次听到这句话是在大物老师的课上，我发觉自己对华科这所学校和大学本身的认识也只是在“看山是山”的层面上，我还没有发现它真正的精彩。</p><p>&emsp;&emsp;大一下学期因为疫情所以一学期都在家，期间不能出门，所以从高中坚持到大学的夜跑习惯也丢掉了，但是也恰好喜欢上了室内健身，大二来到学校后，在一位朋友的影响下去了一学期的健身房，每周会有三四天专门去锻炼。一整天没课时会和这位朋友专门去主图自习，中午步行穿过青年园到百景园或西边小吃城用餐，吃完回来会在图书馆外草地边讨论一些很有意思的话题，时间似乎都变得慢了下来。大一的每天是做不完的事情，时间匆匆流过，却总觉得自己什么都没做，而大二上就这样以一种比较悠闲的节奏度过，虽然加权没有大一时那么高，但那相差的那几点几分换来了我对大学、对自己的另一种认识。</p><p>&emsp;&emsp;大二上的国奖答辩期间认识了不少优秀的同学，寒假我和其中两位同学组队参加了美赛，比赛期间我们异地合作，每天都连麦从天还没亮肝到晚上凌晨，最后一晚通宵修改论文，没有人是在划水摸鱼。对比其他许多队伍我发现，能够遇到值得信任的靠谱队友是多么重要。我们虽然都是第一次接触数模，但是扎实的功底和高效的合作帮助我们出乎意料地最终取得了特等奖提名，其实奖项只是次要的，弥足珍贵的是经历和友谊。</p><p>&emsp;&emsp;大二下在两位队友的建议下，我加入了电信学院大名鼎鼎的科创团队——Dian团队。其实大一就知道Dian团队，但是当时一心只读圣贤书，两耳不闻东九窗外事，没有想过加入这样的团队，算是一个小小的遗憾。不过悟已往之不谏，知来者之可追，加入团队的半年里认识了许多优秀的同学，也学到了好玩并实用的项目知识和技能。在智慧交通项目组我接触到了计算机视觉与实际应用的结合，我们组与萍乡市警方合作设计了用于重点车辆检测的软件，申请到了国家版权局的软件著作权。虽然到了大二下期末，我的总成绩从半年前刚分完专业时的专业第一掉到了第二，学年成绩更是滑落不少，但想象中的懊悔与失落并没有如期而至，倒不如说是现在的我看开了，有些东西和成绩一样重要。</p><p>&emsp;&emsp;代表大二学年尾声的暑假对我而言也是一段不平凡的记忆。七月基本上是在团队中度过的，原本AI组的项目已经结题了，我转到团队与Intel亚太研发有限公司合作的项目中，一直在补习无线通信方面的知识。七月末我本着走入社会、感悟基层的初衷，又一次参与到了暑期社会实践当中，我们到河南洛阳的一家养老院展开调研，却碰上了百年难得一遇的暴雨，火车高铁停运，我也被困回不到郑州的家或学校。后续终于返校，但是因为河南疫情爆发，我被学校组织隔离了28天。被放出来后的第一件事就是去当疫苗接种志愿者，毕竟自己是一名预备党员，只是可惜没能给涝疫同至的家乡献一份力。</p><p>&emsp;&emsp;最后一个比较有意义的事就是去火车站迎新了，以前高中课上老师激励我们说，每年开学期间各个城市的大学都会在火车站设迎新点，越是有名的大学迎新点也越大。虽然最后一句在我当时来到武汉站看见华科的迎新点后就不信了，但是它带给我的归属感却一直萦绕在我心头，所以今年我也要把这种关怀传承下去。</p><p>&emsp;&emsp;其实大二这一年还经历过好多事情，我心里明白自己和一年前不一样了。再一次走向国奖答辩的讲台，我已不再是一年前那患得患失、喜忧参半的心态。既然我的成绩支持我站在这里，那么我所走过的路、感悟到的事情足够让我自信地向台下展示出自己。因为没有刻意把国奖当作目标，也不需要用它来证明什么，毕竟身边有许多同样如此的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> 心得感悟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Love actually is all around</title>
      <link href="/2021/12/01/hello-world/"/>
      <url>/2021/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hello World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
