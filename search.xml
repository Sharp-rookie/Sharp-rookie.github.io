<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【机器学习】距离 &amp; 相似度</title>
      <link href="/2022/03/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E8%B7%9D%E7%A6%BB%20&amp;%20%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
      <url>/2022/03/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E8%B7%9D%E7%A6%BB%20&amp;%20%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在机器学习和数据挖掘中，经常需要知道个体间差异的大小，进而评价个体的相似性和类别。最常见的是数据分析中的相关分析，数据挖掘中的分类和聚类算法，如 K 最近邻（KNN）和 K 均值（K-Means）等等。根据数据特性的不同，可以采用不同的度量方法，一般而言，是定义一个特定的距离函数 d(x,y)，本文记录机器学习和数据挖掘中一些常见的距离公式</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303083222.png" alt="image-20220303083222508" style="zoom:45%;" /><span id="more"></span><p>&nbsp;</p><h3 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h3><p>欧式距离即日常生活中的空间距离</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302232158.png" alt="image-20220302232151083" style="zoom:70%;" /><ul><li><p>二维平面上点 a(x1,y1) 与 b(x2,y2) 间的欧氏距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081801.png" alt="image-20220303081801343" style="zoom: 67%;" /></li><li><p>三维空间点 a(x1,y1,z1) 与 b(x2,y2,z2) 间的欧氏距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081816.png" alt="image-20220303081816766" style="zoom:67%;" /></li><li><p>n维空间点 a(x11,x12,…,x1n) 与 b(x21,x22,…,x2n) 间的欧氏距离（两个n维向量）：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081827.png" alt="image-20220303081827097" style="zoom:67%;" /></li></ul><p>Matlab计算距离使用pdist函数。若X是一个m×n的矩阵，则pdist(X)将X矩阵每一行作为一个n维行向量，然后计算这m个向量两两间的距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line"><span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">4.2426</span>    <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">1.4142</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h3><p>顾名思义，在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是“曼哈顿距离”。曼哈顿距离也称为“城市街区距离” (City Block distance)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302232533.png" alt="image-20220302232533329" style="zoom:40%;" /><ul><li><p>二维平面上点 a(x1,y1) 与 b(x2,y2) 间的欧氏距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081842.png" alt="image-20220303081842713" style="zoom:67%;" /></li><li><p>n维空间点 a(x11,x12,…,x1n) 与 b(x21,x22,…,x2n) 间的欧氏距离（两个n维向量）：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081853.png" alt="image-20220303081853235" style="zoom:67%;" /></li></ul><p>Matlab计算曼哈顿距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;cityblock&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">2</span>     <span class="number">4</span>     <span class="number">6</span>     <span class="number">2</span>     <span class="number">4</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h3><p>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻8个方格中的任意一个。国王从格子 (x1,y1) 走到格子 (x2,y2) 最少需要多少步？这个距离就叫切比雪夫距离</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302232751.png" alt="image-20220302232751660" style="zoom:23%;" /><ul><li><p>二维平面上点 a(x1,y1) 与 b(x2,y2) 间的欧氏距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081907.png" alt="image-20220303081907899" style="zoom:67%;" /></li><li><p>n维空间点 a(x11,x12,…,x1n) 与 b(x21,x22,…,x2n) 间的欧氏距离（两个n维向量）：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081920.png" alt="image-20220303081920002" style="zoom:67%;" /></li></ul><p>Matlab计算切比雪夫距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;chebychev&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h3><p>闵氏距离不是一种特定的距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。</p><p>两个n维变量 a(x11,x12,…,x1n) 与 b(x21,x22,…,x2n) 间的闵可夫斯基距离定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303081937.png" alt="image-20220303081937321" style="zoom:67%;" /><p>p是一个变参数：</p><ul><li>当p=1时，就是曼哈顿距离</li><li>当p=2时，就是欧氏距离</li><li>当p→∞时，就是切比雪夫距离</li></ul><p>因此，根据变参数的不同，闵氏距离可以表示某一类/种的距离。</p><p>matlab计算闵氏距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;minkowski&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">4.2426</span>    <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">1.4142</span></span><br></pre></td></tr></table></figure><p>闵氏距离的缺点：</p><ol><li>将各个分量的量纲 (scale)，也就是“单位”相同的看待了</li><li>未考虑各个分量的分布（期望，方差等）可能是不同的</li></ol><p>&nbsp;</p><h3 id="标准化欧式距离"><a href="#标准化欧式距离" class="headerlink" title="标准化欧式距离"></a>标准化欧式距离</h3><p>标准化欧氏距离是针对欧氏距离的缺点而作的一种改进。</p><p>标准欧氏距离的思路：既然数据各维分量的分布不一样，那先将各个分量都“标准化”到均值、方差相等。</p><p>设样本集X的均值 (mean)为 m，标准差 (standard deviation)为 s，X的“标准化变量”表示为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082041.png" alt="image-20220303082041005" style="zoom:67%;" /><p>标准化欧式距离：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082050.png" alt="image-20220303082050799" style="zoom:67%;" /><p>如果将方差的倒数看成一个权重，也可称之为加权欧氏距离 (Weighted Euclidean distance)</p><p>Matlab计算标准化欧氏距离（假设两个分量的标准差分别为0.5和1）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">4</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;seuclidean&#x27;</span>,[<span class="number">0.5</span>,<span class="number">1</span>])</span><br><span class="line">d=</span><br><span class="line">    <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">6.7082</span>    <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">2.2361</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="马氏距离"><a href="#马氏距离" class="headerlink" title="马氏距离"></a>马氏距离</h3><p><strong>引出</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302233935.png" alt="image-20220302233935470" style="zoom:80%;" /><p>上图有两个正态分布的总体，它们的均值分别为 a 和 b，但方差不一样，则图中的 A 点离哪个总体更近？或者说 A 有更大的概率属于谁？显然，A 离左边的更近，A 属于左边总体的概率更大，尽管 A 与 a 的欧式距离远一些。这就是马氏距离的直观解释</p><p><strong>概念</strong></p><p>马氏距离是基于样本分布的一种距离，物理意义就是：在规范化的主成分空间中的欧氏距离。</p><p>所谓规范化的主成分空间就是利用主成分分析对一些数据进行主成分分解，再对所有主成分分解轴做归一化，形成新的坐标轴，由这些坐标轴张成的空间就是规范化的主成分空间</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302234213.png" alt="image-20220302234212975" style="zoom:45%;" /><p><strong>定义</strong></p><p>马氏距离（Mahalanobis Distance）是由马哈拉诺比斯（P. C. Mahalanobis）提出的，表示数据的协方差距离。它是一种有效的计算两个未知样本集的相似度的方法。与欧氏距离不同的是它考虑到各种特性之间的联系（例如：一条关于身高的信息会带来一条关于体重的信息，因为两者是有关联的）并且是尺度无关的（scale-invariant），即独立于测量尺度</p><ul><li><p>有 M 个样本向量 X1~Xm，协方差矩阵记为 S，均值记为向量 μ，则其中样本向量 X 到 μ 的马氏距离表示为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082004.png" alt="image-20220303082004123" style="zoom:67%;" /></li><li><p>向量 Xi 与 Xj 之间的马氏距离定义为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082012.png" alt="image-20220303082012812" style="zoom:67%;" /></li><li><p>若协方差矩阵是单位矩阵（各个样本向量之间独立同分布），则 Xi 与 Xj 之间的马氏距离等于他们的欧氏距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082023.png" alt="image-20220303082023020" style="zoom:67%;" /></li><li><p>若协方差矩阵是对角矩阵，则就是标准化欧氏距离</p></li></ul><p><strong>特点</strong></p><ul><li>不受量纲的影响</li><li>排除变量之间的相关性的干扰</li><li>建立在总体样本的基础上的，如果拿同样的两个样本，放入两个不同的总体中，最后计算得出的两个样本间的马氏距离通常是不相同的，除非这两个总体的协方差矩阵碰巧相同</li><li>计算过程中要求总体样本数大于样本的维数，否则得到的总体样本协方差矩阵逆矩阵不存在，这种情况下，用欧式距离计算即可</li></ul><p>Matlab计算马氏距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">2</span>;<span class="number">1</span> <span class="number">3</span>;<span class="number">2</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;mahal&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">2.3452</span>    <span class="number">2.0000</span>    <span class="number">2.3452</span>    <span class="number">1.2247</span>    <span class="number">2.4495</span>    <span class="number">1.2247</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="余弦距离——向量的间距"><a href="#余弦距离——向量的间距" class="headerlink" title="余弦距离——向量的间距"></a>余弦距离——向量的间距</h3><p>几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异</p><ul><li><p>二维空间中向量 A(x1,y1) 与向量 B(x2,y2) 的夹角余弦公式：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303075315.png" alt="image-20220303075315707" style="zoom:80%;" /></li><li><p>两个n维样本点 a(x11,x12,…,x1n) 和 b(x21,x22,…,x2n) 的夹角余弦为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303075329.png" alt="image-20220303075329300" style="zoom:80%;" /><p>  即：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303075347.png" alt="image-20220303075347630" style="zoom: 80%;" /></li></ul><p>夹角余弦取值范围为[-1,1]。余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大。当两个向量的方向重合时余弦取最大值1，当两个向量的方向完全相反余弦取最小值-1</p><p>Matlab计算夹角余弦（Matlab中的pdist(X, ‘cosine’)得到的是1减夹角余弦的值）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">2</span>;<span class="number">2</span> <span class="number">5</span>;<span class="number">1</span> <span class="number">-4</span>];</span><br><span class="line">d=<span class="number">1</span>-pdist(X,<span class="string">&#x27;cosine&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">0.9487</span>    <span class="number">0.9191</span>   <span class="number">-0.5145</span>    <span class="number">0.9965</span>   <span class="number">-0.7593</span>   <span class="number">-0.8107</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="汉明距离——分类数据点的间距"><a href="#汉明距离——分类数据点的间距" class="headerlink" title="汉明距离——分类数据点的间距"></a>汉明距离——分类数据点的间距</h3><ul><li><p>定义：</p><p>  两个等长字符串 s1 与 s2 的汉明距离为：将其中一个变为另外一个所需要作的最小字符替换次数。例如：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303075601.png" alt="image-20220303075601695" style="zoom:80%;" /></li><li><p>汉明重量：</p><p>  是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是 1 的个数，所以 11101 的汉明重量是 4。因此，向量空间中的元素 a 和 b 之间的汉明距离等于它们汉明重量的差 a-b</p></li><li><p>应用：</p><p>  汉明重量分析在包括信息论、编码理论、密码学等领域都有应用。比如在信息编码过程中，为了增强容错性，应使得编码间的最小汉明距离尽可能大。但是，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离等算法</p></li></ul><p>Matlab计算汉明距离（Matlab中2个向量之间的汉明距离的定义为2个向量不同的分量所占的百分比）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">2</span>;<span class="number">1</span> <span class="number">5</span> <span class="number">2</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;hamming&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">0.6667</span>    <span class="number">1.0000</span>    <span class="number">0.3333</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="编辑距离——字符串序列的间距"><a href="#编辑距离——字符串序列的间距" class="headerlink" title="编辑距离——字符串序列的间距"></a>编辑距离——字符串序列的间距</h3><p>汉明距离可以度量两个长度相同的字符串之间的相似度，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离（Edit distance, Levenshtein distance）等算法</p><p>通俗地来讲，编辑距离指的是在两个单词 w1、w2 之间，由其中一个单词 w1 转换为另一个单词 w2 所需要的最少单字符编辑操作次数，在这里定义的单字符编辑操作有且仅有三种：</p><ul><li>插入（Insertion）</li><li>删除（Deletion）</li><li>替换（Substitution）</li></ul><p>定义函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303084348.png" alt="image-20220303084347947" style="zoom:60%;" /><center>动态规划递归求解</center><p>则字符串 a、b 的编辑距离定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303084403.png" alt="image-20220303084402998" style="zoom:67%;" /><p>&nbsp;</p><h3 id="DTW距离——时间序列的间距"><a href="#DTW距离——时间序列的间距" class="headerlink" title="DTW距离——时间序列的间距"></a>DTW距离——时间序列的间距</h3><p><strong>引入</strong></p><p>在时间序列中，需要比较相似性的两段时间序列的长度可能并不相等，在语音识别领域表现为不同人的语速不同。Dynamic Time Warping（DTW）是一种衡量两个时间序列之间的相似度的方法，通过把时间序列进行延伸和缩短，来计算两个时间序列性之间的相似性，主要应用在语音识别领域来识别两段语音是否表示同一个单词。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303085133.png" alt="image-20220303085133638" style="zoom:45%;" /><p>如上图所示，上下两条实线代表两个时间序列，时间序列之间的虚线代表两个时间序列之间的相似的点。DTW使用所有这些相似点之间的距离的和，称之为<strong>归整路径距离</strong>(Warp Path Distance)来衡量两个时间序列之间的相似性</p><p><strong>计算</strong></p><ul><li><p>令要计算相似度的两个时间序列为 X 和 Y，长度分别为|X|和|Y|</p></li><li><p>归整路径 (Warp Path)，形式为 W=w1,w2,…,wK，其中 Max(|X|,|Y|)&lt;=K&lt;=|X|+|Y|</p></li><li><p>wk 的形式为 (i,j)，其中 i 表示的是 X 中的 i 坐标，j 表示的是 Y 中的 j 坐标</p></li><li><p>归整路径 W 必须从 w1=(1,1) 开始，到 wK=(|X|,|Y|) 结尾，以保证 X 和 Y 中的每个坐标都在 W 中出现</p></li><li><p>另外，W 中 w(i,j) 的 i 和 j 必须是单调增加的，以保证上图中的虚线不会相交，所谓单调增加是指：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303091737.png" alt="image-20220303091737757" style="zoom:60%;" /></li><li><p>最后得到的归整路径是距离最短的一个归整路径：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303091809.png" alt="image-20220303091809145" style="zoom:50%;" />  <center>动态规划递归求解</center></li></ul><p>&nbsp;</p><h3 id="KL散度——概率分布的间距"><a href="#KL散度——概率分布的间距" class="headerlink" title="KL散度——概率分布的间距"></a>KL散度——概率分布的间距</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303091916.png" alt="image-20220303091916229" style="zoom:25%;" /><p>考虑某个未知的分布 p(x)，假定用一个近似的分布 q(x) 对它进行建模。如果使用 q(x) 来建立一个编码体系，用来把 x 的值传给接收者，那么由于使用了 q(x) 而不是真实分布 p(x)，平均编码长度比用真实分布 p(x) 进行编码增加的信息量(单位是 nat )为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303092025.png" alt="image-20220303092025879" style="zoom:50%;" /><p>即为：分布 p(x) 和分布 q(x) 之间的<strong>相对熵</strong>(relative entropy) 或者 <strong>KL 散度</strong>( Kullback-Leibler divergence )</p><p>&nbsp;</p><h3 id="杰卡德距离——集合的间距"><a href="#杰卡德距离——集合的间距" class="headerlink" title="杰卡德距离——集合的间距"></a>杰卡德距离——集合的间距</h3><ul><li><p>杰卡德相似系数 (Jaccard similarity coefficient)：</p><p>  两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号 J(A,B) 表示：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082108.png" alt="image-20220303082108630" style="zoom:67%;" /></li><li><p>杰卡德距离(Jaccard Distance)：</p><p>  与杰卡德相似系数相反，用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082124.png" alt="image-20220303082124806" style="zoom:50%;" /></li></ul><p>Matlab计算杰卡德距离（Matlab中将杰卡德距离定义为不同的维度的个数占“非全零维度”的比例）：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>;<span class="number">-1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">d=pdist(X,<span class="string">&#x27;jaccard&#x27;</span>)</span><br><span class="line">d=</span><br><span class="line">    <span class="number">0.5000</span>    <span class="number">0.5000</span>    <span class="number">1.0000</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="相关距离——散点的间距"><a href="#相关距离——散点的间距" class="headerlink" title="相关距离——散点的间距"></a>相关距离——散点的间距</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303080149.png" alt="image-20220303080149153" style="zoom:65%;" /><ul><li><p>相关系数：</p><p>  是衡量随机变量 X 与 Y 相关程度的一种方法，相关系数的取值范围是 [-1,1]。相关系数的绝对值越大，则表明 X 与 Y 相关度越高。当 X 与 Y 线性相关时，相关系数取值为1（正线性相关）或-1（负线性相关）：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303080236.png" alt="image-20220303080236058" style="zoom:80%;" /></li><li><p>相关距离：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303080254.png" alt="image-20220303080254906" style="zoom:80%;" /></li></ul><p>Matlab计算相关系数与相关距离：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">3</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span>];</span><br><span class="line">c=corrcoef(X&#x27;) <span class="comment">%返回相关系数矩阵</span></span><br><span class="line">d=pdist(X,<span class="string">&#x27;correlation&#x27;</span>) <span class="comment">%返回相关距离</span></span><br><span class="line">c=</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">0.4781</span></span><br><span class="line">    <span class="number">0.4781</span>    <span class="number">1.0000</span></span><br><span class="line">d=</span><br><span class="line">    <span class="number">0.5219</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="信息熵——系统的分散度"><a href="#信息熵——系统的分散度" class="headerlink" title="信息熵——系统的分散度"></a>信息熵——系统的分散度</h3><p>以上的距离度量方法度量的皆为两个样本（向量）之间的距离，而信息熵描述的是整个系统内部样本之间的一个距离，或者称之为系统内样本分布的集中程度（一致程度）、分散程度、混乱程度（不一致程度）。系统内样本分布越分散(或者说分布越平均)，信息熵就越大。分布越有序（或者说分布越集中），信息熵就越小</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303080702.png" alt="image-20220303080702844" style="zoom:60%;" /><p>设 n 为样本集 X 的分类数、pi 为 X 中第 i 类元素出现的概率，则样本集的信息熵为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303080734.png" alt="image-20220303080734015" style="zoom:80%;" /><p>信息熵越大表明样本集S的分布越分散（分布均衡），信息熵越小则表明样本集X的分布越集中（分布不均衡）</p><ul><li>当S中n个分类出现的概率一样大时（都是1/n），信息熵取最大值log2(n)</li><li>当X只有一个分类时，信息熵取最小值0</li></ul><p>&nbsp;</p><h3 id="巴氏距离——概率分布的间距"><a href="#巴氏距离——概率分布的间距" class="headerlink" title="巴氏距离——概率分布的间距"></a>巴氏距离——概率分布的间距</h3><ul><li><p>巴氏距离：</p><p>  在统计学中，巴氏距离（巴塔恰里雅距离Bhattacharyya distance）用于测量两离散概率分布。它常在分类中测量类之间的可分离性</p></li><li><p>巴氏系数：</p><p>  两个统计样本之间的重叠量的近似测量，可以被用于确定被考虑的两个样本的相对接近</p></li></ul><ul><li><p>对于离散概率分布 p和q在同一域 X，巴氏距离定义为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082309.png" alt="image-20220303082309895" style="zoom:67%;" /></li><li><p>对于离散型概率分布，巴氏系数定义为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082320.png" alt="image-20220303082320863" style="zoom:67%;" /></li><li><p>对于连续型概率分布，巴氏系数定义为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220303082333.png" alt="image-20220303082333660" style="zoom:67%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】解析、生成、合并、编辑 PDF文档</title>
      <link href="/2022/03/02/%E3%80%90Python%E3%80%91%E8%A7%A3%E6%9E%90%E3%80%81%E7%94%9F%E6%88%90%E3%80%81%E5%90%88%E5%B9%B6%E3%80%81%E7%BC%96%E8%BE%91PDF%E6%96%87%E6%A1%A3/"/>
      <url>/2022/03/02/%E3%80%90Python%E3%80%91%E8%A7%A3%E6%9E%90%E3%80%81%E7%94%9F%E6%88%90%E3%80%81%E5%90%88%E5%B9%B6%E3%80%81%E7%BC%96%E8%BE%91PDF%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;事情是这样的，本来我在调研一个东西，总结成了一个PDF文档，打算加上水印（很强的版权意识），但是上网搜免费PDF加水印工具时发现，这些“免费”工具要么得注册会员、要么说我免费时长不够，一个个挂羊头卖狗肉。。。</p><p>&emsp;&emsp;不过想想看，给PDF加水印不就相当于用一个有内容的PDF和一个只有水印的空白PDF合成吗，干脆用Python来做算了，正好学用一下PyPDF2库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302105123.png" alt="image-20220302105123069" style="zoom:60%;" /><span id="more"></span><p>&nbsp;</p><h2 id="PyPDF2"><a href="#PyPDF2" class="headerlink" title="PyPDF2"></a>PyPDF2</h2><blockquote><p>PyPDF2是作为PDF工具包构建的python库，能够:</p><ul><li>提取文档信息（标题，作者，…）</li><li>按页拆分文档</li><li>逐页合并文档</li><li>裁剪、旋转、缩放页面</li><li>合并多个页面到一个页</li><li>对pdf文档进行加密解密</li></ul><p>实现这些功能，主要依靠 PyPDF 提供的一些对象，下面一一介绍</p></blockquote><h3 id="PdfFileReader"><a href="#PdfFileReader" class="headerlink" title="PdfFileReader"></a>PdfFileReader</h3><p><strong>构造</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyPDF2.PdfFileReader(stream,strict = <span class="literal">True</span>,warndest = <span class="literal">None</span>, overwriteWarnings = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>初始化一个 PdfFileReader 对象，此操作可能需要一些时间，因为 PDF 流的交叉引用表被读入内存</p><p>参数：</p><ul><li>stream：File 对象或支持与 File 对象类似的标准读取和查找方法的对象，也可以是表示 PDF 文件路径的字符串</li><li>strict(bool)： 确定是否应该警告用户所用的问题，也导致一些可纠正的问题是致命的，默认是 True</li><li>warndest：记录警告的目标(默认是 sys.stderr)</li><li>overwriteWarnings(bool)：确定是否 warnings.py 用自定义实现覆盖 Python 模块（默认为 True）</li></ul><p><strong>方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getDestinationPageNumber(destination)</td><td>检索给定目标对象的页码</td></tr><tr><td>getDocumentInfo()</td><td>检索 PDF 文件的文档信息字典</td></tr><tr><td>getFields(tree = None,retval = None,fileObj= None)</td><td>如果此 PDF 包含交互式表单字段，则提取字段数据</td></tr><tr><td>getFormTextFields()</td><td>从文档中检索带有文本数据（输入，下拉列表）的表单域</td></tr><tr><td>getNameDestinations(tree = None,retval= None)</td><td>检索文档中的指定目标</td></tr><tr><td>getNumPages()</td><td>计算此 PDF 文件中的页数</td></tr><tr><td>getOutlines(node = None,outline = None,)</td><td>检索文档中出现的文档大纲</td></tr><tr><td>getPage(pageNumber)</td><td>从这个 PDF 文件中检索指定编号的页面</td></tr><tr><td>getPageLayout()</td><td>获取页面布局</td></tr><tr><td>getPageMode()</td><td>获取页面模式</td></tr><tr><td>getPageNumber(pageObject)</td><td>检索给定 pageObject 处于的页码</td></tr><tr><td>getXmpMetadata()</td><td>从 PDF 文档根目录中检索 XMP 数据</td></tr><tr><td>decrypt(password)</td><td>检测输入的PDF密码是否正确</td></tr></tbody></table><p>每个方法返回值类型不同，有的返回的是 PdfFileReader 的其他类，比如：<code>DocumentInformation</code>、<code> XmpInformation</code>，可详见：<a href="https://pythonhosted.org/PyPDF2/PdfFileReader.html">The PdfFileReader Class — PyPDF2 1.26.0</a></p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader</span><br><span class="line"></span><br><span class="line">PDFpath = <span class="string">&quot;O-RAN.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Read</span>(<span class="params">PDFpath</span>):</span></span><br><span class="line">    <span class="comment"># 获取PdfFileReader对象</span></span><br><span class="line">    pdfReader = PdfFileReader(PDFpath)</span><br><span class="line">    <span class="comment"># 获取PDF文件的文档信息</span></span><br><span class="line">    documentInfo = pdfReader.getDocumentInfo()</span><br><span class="line">    txt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    -----documentInfo-----</span></span><br><span class="line"><span class="string">    Information about <span class="subst">&#123;PDFpath&#125;</span>:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Author: <span class="subst">&#123;documentInfo.author&#125;</span></span></span><br><span class="line"><span class="string">    Creator: <span class="subst">&#123;documentInfo.creator&#125;</span></span></span><br><span class="line"><span class="string">    Producer: <span class="subst">&#123;documentInfo.producer&#125;</span></span></span><br><span class="line"><span class="string">    Subject: <span class="subst">&#123;documentInfo.subject&#125;</span></span></span><br><span class="line"><span class="string">    Title: <span class="subst">&#123;documentInfo.title&#125;</span></span></span><br><span class="line"><span class="string">    Number of pages: <span class="subst">&#123;pdfReader.getNumPages()&#125;</span></span></span><br><span class="line"><span class="string">    PageLayout: <span class="subst">&#123;pdfReader.getPageLayout()&#125;</span></span></span><br><span class="line"><span class="string">    PageMode: <span class="subst">&#123;pdfReader.getPageMode()&#125;</span></span></span><br><span class="line"><span class="string">    xmpMetadata： <span class="subst">&#123;pdfReader.getXmpMetadata()&#125;</span></span></span><br><span class="line"><span class="string">    ----------------------</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(txt)</span><br><span class="line">    <span class="comment"># 获取每一页信息</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pageCount):</span><br><span class="line">        <span class="comment"># 获取指定页数的pageObject</span></span><br><span class="line">        pageObj = pdfReader.getPage(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index = %d , pageObj = %s&quot;</span> % (i, <span class="built_in">type</span>(pageObj)))</span><br><span class="line">        <span class="comment"># 获取 pageObject 在 PDF 文档中处于的页码</span></span><br><span class="line">        pageNumber = pdfReader.getPageNumber(pageObj)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;page = %s &quot;</span> % pageNumber)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Read(PDFpath)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302100022.png" alt="image-20220302095925585" style="zoom:50%;" /><center>这个pdf是typora生成的</center><p>&nbsp;</p><h3 id="PdfFileWriter"><a href="#PdfFileWriter" class="headerlink" title="PdfFileWriter"></a>PdfFileWriter</h3><p><strong>方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>addAttachment(fname,fdata)</td><td>在 PDF 中嵌入文件</td></tr><tr><td>addBlankPage(width= None,height=None)</td><td>追加一个空白页面到这个 PDF 文件并返回它</td></tr><tr><td>addBookmark(title,pagenum,parent=None,<br/>color=None,bold=False,italic=False,fit=’/fit,args’)</td><td>向此 PDF 文件添加书签</td></tr><tr><td>addJS(javascript)</td><td>添加将在打开此 PDF 是启动的 javascript</td></tr><tr><td>addLink(pagenum,pagedest,rect,border=None,fit=’/fit’,*args)</td><td>从一个矩形区域添加一个内部链接到指定的页面</td></tr><tr><td>addPage(page)</td><td>添加一个页面到这个PDF 文件，该页面通常从 PdfFileReader 实例获取</td></tr><tr><td>encrypt(user_pwd, owner_pwd=None, use_128bit=True)</td><td>加密此 PDF 文件</td></tr><tr><td>getNumpages()</td><td>页数</td></tr><tr><td>getPage(pageNumber)</td><td>从这个 PDF 文件中检索一个编号的页面</td></tr><tr><td>insertBlankPage(width=None,height=None,index=0)</td><td>插入一个空白页面到这个 PDF 文件并返回它，如果没有指定页面大小，就使用最后一页的大小</td></tr><tr><td>insertPage(page,index=0)</td><td>在这个 PDF 文件中插入一个页面，该页面通常从 PdfFileReader 实例获取</td></tr><tr><td>removeLinks()</td><td>从次数出中删除连接盒注释</td></tr><tr><td>removeText(ignoreByteStringObject = False)</td><td>从这个输出中删除图像</td></tr><tr><td>write(stream)</td><td>将添加到此对象的页面集合写入 PDF 文件</td></tr></tbody></table><p>详见：<a href="https://pythonhosted.org/PyPDF2/PdfFileWriter.html">The PdfFileWriter Class — PyPDF2 1.26.0</a></p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader, PdfFileWriter</span><br><span class="line"></span><br><span class="line">PDFpath = <span class="string">&quot;O-RAN.pdf&quot;</span></span><br><span class="line">OUTpath = <span class="string">&quot;out.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Write</span>(<span class="params">PDFpath, OUTpath</span>):</span></span><br><span class="line">    Writer = PdfFileWriter()</span><br><span class="line">    <span class="comment"># 获取PdfFileReader对象</span></span><br><span class="line">    pdfReader = PdfFileReader(PDFpath)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">i</span>):</span></span><br><span class="line">        <span class="comment"># 读取源pdf文件第i页的信息</span></span><br><span class="line">        pageObj = pdfReader.getPage(i)</span><br><span class="line">        <span class="comment"># 写入到新pdf对象中</span></span><br><span class="line">        Writer.addPage(pageObj)</span><br><span class="line">        <span class="comment"># 进而写入到目标文件中</span></span><br><span class="line">        Writer.write(<span class="built_in">open</span>(OUTpath, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    <span class="comment"># 把源pdf文件每隔5页写入到目标文件中</span></span><br><span class="line">    [write(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pdfReader.getNumPages()) <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 在文件的最后一页写入一个空白页,保存至文件中</span></span><br><span class="line">    Writer.addBlankPage()</span><br><span class="line">    Writer.write(<span class="built_in">open</span>(OUTpath, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Write(PDFpath, OUTpath)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302090815.png" alt="image-20220302090815546" style="zoom:50%;" /><center>使用Reader查看新生成的pdf信息</center><p>&nbsp;</p><h3 id="PageObject"><a href="#PageObject" class="headerlink" title="PageObject"></a>PageObject</h3><p><strong>构造</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageObject(pdf=<span class="literal">None</span>,indirectRef=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>此类表示 PDF 文件中的单个页面，通常这个对象是通过访问 PdfFileReader 对象的 getPage() 方法来得到的，也可以使用 createBlankPage() 静态方法创建一个空的页面</p><p>参数：</p><ul><li>pdf : 页面所属的 PDF 文件</li><li>indirectRef：将源对象的原始间接引用存储在其源 PDF 中</li></ul><p><strong>方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>static createBlankPage(pdf=None,width=None,height=None)</td><td>返回一个新的空白页面</td></tr><tr><td>extractText()</td><td>找到所有文本绘图命令，按照他们在内容流中提供的顺序，并提取文本</td></tr><tr><td>getContents()</td><td>访问页面内容，返回 Contents 对象或 None</td></tr><tr><td>rotateClockwise(angle)</td><td>顺时针旋转 angle 度，angle必须是90的倍数</td></tr><tr><td>scale(sx,sy)</td><td>按x、y比例缩放页面大小</td></tr><tr><td>compressContentStreams()</td><td>通过 FlateDecode 过滤器压缩页面大小</td></tr><tr><td>mergePage(page2)</td><td>将两个页面的内容流合并为一个</td></tr><tr><td>mergeRotatedScaledTranslatedPage(page2, rotation, scale,tx, ty,expand=False)</td><td>先经过旋转、缩放、平移，然后再合并</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader</span><br><span class="line"></span><br><span class="line">PDFpath = <span class="string">&quot;O-RAN.pdf&quot;</span></span><br><span class="line">OUTpath = <span class="string">&quot;out.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PageContent</span>(<span class="params">PDFpath</span>):</span></span><br><span class="line">    pdf = PdfFileReader(PDFpath)</span><br><span class="line">    content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pdf.getNumPages()):</span><br><span class="line">        pageObj = pdf.getPage(i)</span><br><span class="line">        content += pageObj.extractText() + <span class="string">&#x27;  &#x27;</span></span><br><span class="line">    <span class="keyword">return</span> content.encode(<span class="string">&quot;ascii&quot;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(PageContent(PDFpath))</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220302094813.png" alt="image-20220302094813165" style="zoom:50%;" /><center>其实我也不知道这些字符什么意思</center><p>&nbsp;</p><h3 id="PdfFileMerger"><a href="#PdfFileMerger" class="headerlink" title="PdfFileMerger"></a>PdfFileMerger</h3><p>详见：<a href="https://pythonhosted.org/PyPDF2/PdfFileMerger.html">The PdfFileMerger Class — PyPDF2 1.26.0</a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="PDF常用操作"><a href="#PDF常用操作" class="headerlink" title="PDF常用操作"></a>PDF常用操作</h2><h3 id="拆分PDF"><a href="#拆分PDF" class="headerlink" title="拆分PDF"></a>拆分PDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">PDFpath, OUTpath, PageNum</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function: 旋转pdf文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PDFpath: 源文件路径</span></span><br><span class="line"><span class="string">    OUTpath: 目标路径</span></span><br><span class="line"><span class="string">    PageNum: 划分间隔页数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    pdf = PdfFileReader(PDFpath)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pdf.getNumPages()):</span><br><span class="line">        <span class="keyword">if</span> i % PageNum == <span class="number">0</span>:</span><br><span class="line">            pdf_writer = PdfFileWriter()</span><br><span class="line">            [pdf_writer.addPage(pdf.getPage(j)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(</span><br><span class="line">                i, <span class="built_in">min</span>(PageNum+i, pdf.getNumPages()))]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;OUTpath[:-<span class="number">4</span>]&#125;</span><span class="subst">&#123;<span class="built_in">int</span>(i/PageNum)&#125;</span>.pdf&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> output_pdf:</span><br><span class="line">                pdf_writer.write(output_pdf)</span><br></pre></td></tr></table></figure><h3 id="旋转页面"><a href="#旋转页面" class="headerlink" title="旋转页面"></a>旋转页面</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_pdf</span>(<span class="params">PDFpath, OUTpath, direction=<span class="number">0</span>, rotate=<span class="number">90</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function: 旋转pdf文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PDFpath: 源文件路径</span></span><br><span class="line"><span class="string">    OUTpath: 目标路径</span></span><br><span class="line"><span class="string">    direction: 旋转方向, 默认——右、1——左</span></span><br><span class="line"><span class="string">    rotate: 旋转角度,必须是90及其倍数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> rotate % <span class="number">90</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong! Rotate must set as Integer mutliple of 90!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    pdf_writer = PdfFileWriter()</span><br><span class="line">    pdf_reader = PdfFileReader(PDFpath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pdf_reader.getNumPages()):</span><br><span class="line">            <span class="comment"># 向右旋转rotate度</span></span><br><span class="line">            page = pdf_reader.getPage(i).rotateClockwise(rotate)</span><br><span class="line">            pdf_writer.addPage(page)</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pdf_reader.getNumPages()):</span><br><span class="line">            <span class="comment"># 向右旋转rotate度</span></span><br><span class="line">            page = pdf_reader.getPage(i).rotateCounterClockwise(rotate)</span><br><span class="line">            pdf_writer.addPage(page)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong dirtection!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(OUTpath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pdf_writer.write(f)</span><br></pre></td></tr></table></figure><h3 id="加水印"><a href="#加水印" class="headerlink" title="加水印"></a>加水印</h3><p>加水印本质就是合并两个PDF文件，一个是源文件，一个是水印的文件</p><p>需要先用Word生成自己需要的水印文件 <code>Watermark.pdf</code>，记得把页眉关掉，影响美观</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_watermark</span>(<span class="params">OriginalFile, Watermark, Result</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Function：把水印添加到pdf中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    OriginalFile: 源pdf文件路径</span></span><br><span class="line"><span class="string">    Watermark: 水印pdf文件路径</span></span><br><span class="line"><span class="string">    Result: 生成文件路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pdf_output = PdfFileWriter()</span><br><span class="line">    pdf_input = PdfFileReader(OriginalFile)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取PDF文件的页数</span></span><br><span class="line">    pageNum = pdf_input.getNumPages()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读入水印底板pdf文件</span></span><br><span class="line">    pdf_watermark = PdfFileReader(Watermark)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给每一页打水印</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pageNum):</span><br><span class="line">        page = pdf_input.getPage(i)</span><br><span class="line">        page.mergePage(pdf_watermark.getPage(<span class="number">0</span>))</span><br><span class="line">        page.compressContentStreams()  <span class="comment"># 压缩内容</span></span><br><span class="line">        pdf_output.addPage(page)</span><br><span class="line">    pdf_output.write(<span class="built_in">open</span>(Result, <span class="string">&#x27;wb&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_encryption</span>(<span class="params">PDFpath, OUTpath, password=<span class="string">&#x27;123456&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function: 加密pdf文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PDFpath: 源文件路径</span></span><br><span class="line"><span class="string">    OUTpath: 目标路径</span></span><br><span class="line"><span class="string">    password: 密码</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    pdf_writer = PdfFileWriter()</span><br><span class="line">    pdf_reader = PdfFileReader(PDFpath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(pdf_reader.getNumPages()):</span><br><span class="line">        pdf_writer.addPage(pdf_reader.getPage(page))</span><br><span class="line"></span><br><span class="line">    pdf_writer.encrypt(user_pwd=password, owner_pwd=<span class="literal">None</span>,</span><br><span class="line">                       use_128bit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(OUTpath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">        pdf_writer.write(fh)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>除了 <code>PyPDF</code> 以外，Python处理 PDF 的库还有 <code>Pdfplumber</code>、<code>PDFminer</code>，以后用到了再学</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高效工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>O-RAN联盟 &amp; RIC智能控制</title>
      <link href="/2022/02/25/%E3%80%90%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E3%80%91O-RAN/"/>
      <url>/2022/02/25/%E3%80%90%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E3%80%91O-RAN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;O-RAN 联盟是一个由全世界多家大型运营商发起的，旨在将无线接入网络行业转变为开放、智能、虚拟化和完全可互操作的 RAN的国际化联盟，目前已有国内外许多大型通信硬件、软件供应商和企业加盟</p><p>&emsp;&emsp;O-RAN 架构在5G 3GPP 的 RAN 基础上，新引入了 RIC 智能控制逻辑网元，希望通过人工智能优化无线接入网，例如：无线资源控制、负载均衡等</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225213631.png" alt="image-20220225213631496" style="zoom:35%;" /><span id="more"></span><p>&nbsp;</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="无线接入网（Radio-Access-Network）"><a href="#无线接入网（Radio-Access-Network）" class="headerlink" title="无线接入网（Radio Access Network）"></a>无线接入网（Radio Access Network）</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225100910.png" alt="image-20220225100910059" style="zoom:50%;" /><p>广义上讲，能够把无线终端连接通过无线的方式连接到网络中的设备组成的网络，都称为无线接入网RAN。</p><p><strong>划分一</strong></p><ul><li>专用无线接入网：特定的行业或部门面向内部服务而建立的无线接入网。如：公安、军队、企业</li><li>公众无线接入网：由电信运营商面向公共服务而建立起来的无线接入网，如：2G/3G/4G/5G</li></ul><p><strong>划分二</strong></p><ul><li>利用免费的无线频谱接入：如WiFi，蓝牙</li><li>使用授权的无线频谱接入：如2G/3G/4G/5G</li></ul><p>无线接入RAN只为无线终端通过无线电磁波的方式连接到网络提供了手段，但如果终端要想相互间通信，还需要上图中的核心网。当然，核心网除了确保无线终端之间能够相互通信，还提供了计费、移动管理、与其通信网络互通、与互联网互通等功能。核心网和无线接入网共同组成公众移动/无线通信网</p><p>&nbsp;</p><h3 id="封闭-amp-开放"><a href="#封闭-amp-开放" class="headerlink" title="封闭 &amp; 开放"></a>封闭 &amp; 开放</h3><h4 id="封闭"><a href="#封闭" class="headerlink" title="封闭"></a>封闭</h4><p>要了解O-RAN所代表的开放式无线接入网，首先要明白什么是封闭的无线接入网</p><ul><li>接入网设备的<strong>硬件</strong>是设备供应商设计的专有硬件设备</li><li>接入网设备的<strong>软件</strong>（底层软件、操作系统、基站应用软件等）也是由对应硬件设备厂家提供</li><li>接入网设备，如：4G的网管+BBU+RRU+天线、5G的网管+CU+DU+AAU，通常由<strong>单一</strong>设备商提供，比如华为提供自己的RAN系统设备、诺基亚提供自己的RAN系统设备</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225101419.png" alt="image-20220225101419272" style="zoom:35%;" /><h4 id="开放"><a href="#开放" class="headerlink" title="开放"></a>开放</h4><ul><li>接入网的非实时性应用软件与专用硬件分离，如网管，CU，脱离专用硬件，在通用的X86的Linux服务器上运行</li><li>接入网的实时性要求高的软件与硬件依然强绑定，如DU或AAU，但需要提供可定制化的配置接口，便于第三方软件或设备可以配置专用软硬件设备的功能</li><li>让更多的第三方软件和硬件厂家参与进来，大家遵循统一的接口标准，让无线接入网中的不同软件实体，能够实现互联互通，打破单一设备厂家的垄断</li></ul><p>&nbsp;</p><h3 id="走向开放的-RAN"><a href="#走向开放的-RAN" class="headerlink" title="走向开放的 RAN"></a>走向开放的 RAN</h3><p><strong>5G网络总体上朝着开放、智能的架构演进</strong></p><p>&emsp;&emsp;传统的网络架构相对封闭、复杂而僵硬，不但网络建设成本较高、而且对新业务的支撑上也不够灵活和智能。而无线接入网一直是网络建设中资本开支最高的地方，尤其在5G时代，移动通信使用了更高频率甚至是毫米波来建设基站，同时，流量密度相对4G提升了100倍，连接密度提升了10倍，需要部署更多的基站以满足不断增长的需求。</p><p>&emsp;&emsp;5G开放性的技术体系、分布式的架构设计，以及系统模块之间高度的标准化，都提高了5G相关设备之间的可替换性。一方面，5G是未来更多是面向企业客户的，传统的技术驱动模式和产品化思维只能解决共性的问题，很难支持复杂性高、专业化强、个性化的企业解决方案；另一方面，由于5G时代的业务特性多样化，以及网络切片对于无线网络有更多新要求，传统网络架构难以满足需求，云化、智能化是必然选择。</p><p>&emsp;&emsp;5G的开放之路包括：能力开放，构建网络能力开放平台，赋能社会数字化转型；架构开放，推动网络功能软硬件解耦，打造积木式开放网络架构；网建开放，倡导共建共享，集合社会力量做大做强5G网络。</p><p>&nbsp;</p><h3 id="区分三个词：Open-RAN、OpenRAN、O-RAN"><a href="#区分三个词：Open-RAN、OpenRAN、O-RAN" class="headerlink" title="区分三个词：Open RAN、OpenRAN、O-RAN"></a>区分三个词：Open RAN、OpenRAN、O-RAN</h3><ul><li><p><strong>Open RAN</strong> </p><p>  开放式无线电接入网 (Open Radio Access Network)，是一个基于 RAN 元素的互操作性和标准化的概念，包括针对不同供应商的白盒硬件和开源软件元素的<strong>统一互连标准</strong>。</p></li><li><p><strong>OpenRAN</strong> </p><p>  电信基础设施项目 (TIP) 于 2017 年发起的一个<strong>项目组</strong></p></li><li><p><strong>O-RAN</strong> </p><p>  本应该是上面Open RAN的缩写，但是因为一个同名的联盟太有名了，所以O-RAN更多是指O-RAN <strong>联盟</strong>，它由世界几大运营商联合成立</p></li></ul><p>开放式 RAN 生态系统的前景推动了协同项目、联盟和工作组的形成，它们各自都有不同的任务和重点领域。这些工作都有一个共同的目标，那就是通过标准化的元件和接口来实现一个开放的 RAN 环境。</p><h4 id="Open-RAN"><a href="#Open-RAN" class="headerlink" title="Open RAN"></a>Open RAN</h4><p>开放式无线接入网 (Open Radio Access Network or O-RAN) 的使命是搭建一个开放、虚拟化和智能的无线接入网 (RAN) 体系结构，从而创造一个包含多家厂商、各家厂商的产品之间 可以互操作且具有竞争力的生态系统</p><ul><li>将模块化基站软件堆栈集成在现成的硬件上，允许来自分立供应商的基带和无线电单元组件无缝地一起运行</li><li>通过高效、智能和通用性的共同属性，强调了精简的 5G RAN 性能目标</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225082637.png" alt="image-20220225082637188" style="zoom:40%;" /><h4 id="OpenRAN"><a href="#OpenRAN" class="headerlink" title="OpenRAN"></a>OpenRAN</h4><p>&emsp;&emsp;2016年Facebook联合部分电信运营商发起了面向电信基础设施的开源项目TIP（Telecom Infrastructure Project），TIP项目涵盖了接入网、传送网和核心业务网三大领域，目前TIP已有超过500家成员，包括运营商、设备商、系统集成商以及创新技术提供商等。TIP于2017年发起OpenRAN项目，致力于<strong>白盒化基站</strong>研发，希望通过模块化方式在提升网络灵活性同时实现无线接入网的低成本建设和运营，许多IT厂商和无线技术创新公司参与到该项目的研发和软硬件提供。TIP又于2018年启动OpenRAN 5G NR重点项目，切入5G基站领域。</p><p>&emsp;&emsp;OpenRAN项目组的既定目标是基于通用、供应商中立的硬件和软件定义的技术来定义和构建 2G、3G 和 4G RAN 解决方案。这包括创建基于通用处理平台 (GPPP) 的可编程虚拟化 RAN 解决方案，以及加速创新步伐的分散软件。</p><p>&emsp;&emsp;为了使 O-RAN 联盟的精神和愿望与 TIP OpenRAN 一致，并尽量减少工作重复，两个组织之间已经建立了联络协议。尽管 TIP 对 O-RAN 规范仍不确定，但联络协议促进了更多的合作和协作解决方案，整合了每个项目组的优势。O-RAN 联盟技术指导委员会对规范开发的坚定承诺，使 OpenRAN 项目组能够继续关注在各种环境中对分散的电信基础设施的实际部署策略。</p><h4 id="O-RAN联盟"><a href="#O-RAN联盟" class="headerlink" title="O-RAN联盟"></a>O-RAN联盟</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225082729.png" alt="image-20220225082729716" style="zoom:40%;" /><center>记住这个美丽的 logo</center><p><strong>一句话简介</strong>：O-RAN联盟是一个由移动服务供应商和技术供应商组成的全球社区，是本文的主角</p><p><strong>参与方</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225105643.png" alt="image-20220225105643402" style="zoom:40%;" /><ul><li>运营商：<ul><li>最初发起：美国AT&amp;T、中国移动、德国电信、日本NTT DOCOMO、法国Orange</li><li>后来加入：印度Bharti Airtel、中国电信、韩国SKT和KT、新加坡Singtel、西班牙Telefonica、澳大利亚Telstra等</li></ul></li><li>设备供应商：爱立信、诺基亚、中兴通讯等（目前华为并没有参与）</li><li>芯片制造商：ARM，ADT, BROADCOM，ANALOG DEVICES，Qualcomm、Samsung， XILINX等</li><li>软件供应商：Microsoft等</li></ul><p><strong>成立动机</strong></p><ul><li><p>商业动机</p><ul><li>电信运营商不想被一俩家设备厂绑架垄断想出的招数，应对通信设备厂商涨价（运营商摆脱供应商）</li><li>通过非实时软件的“云化”，降低整个RAN系统的运营成本OPEX</li></ul></li><li><p>技术动机</p><ul><li>通过实现RAN系统中各个网元的网络功能虚拟化NFV，非常方便的重构已有的网络部署</li></ul></li><li><p>政治动机</p><ul><li><p>目前全球主流的5G系统设备供应商就剩下仅存的几家：华为、爱立信、诺基亚、中兴等，其中两家中国、两家欧洲小国的，其他两家还都是与中国建立的合资公司，在5G时代，美国没有能够提供5G成套系统设备的公司</p><p>  随着美国对华为公司以及整个中国的全方位打击升级，O-RAN的技术方案也成为美国政府试图打破中国通信公司在5G技术上绝对领先地位的一种政治手段，O-RAN背后的主要推动力量是美国政府</p></li></ul></li></ul><p><strong>目标</strong></p><ol><li><strong>硬件白盒化</strong>：白盒是相对于黑盒而言的，就是开放和标准化网元硬件内部的功能模块以及硬件模块之间的接口，引入更多的厂家参与硬件的开发与生产，逐渐把专用硬件演变通用硬件，而直接使用现有的通用硬件是实现硬件白盒化最快捷的途径之一</li><li><strong>软件开源化</strong>：通过开源软件的方式实现网络功能</li><li><strong>接口开放化</strong>：所有的逻辑网元的的接口都进行开放，不同厂家的逻辑网元能够方便、轻松的进行对接</li><li><strong>网络功能的虚拟化</strong>：将网络节点的功能，分割成几个功能区块，分别以软件方式实现，不再拘限于特定的硬件架构</li><li><strong>网络的智能化</strong>：结合人工技术和大数据分析技术，对网络进行自动化部署、运营、维护、管理和优化以及宏观调控</li></ol><p><strong>工作内容</strong></p><ul><li>在全球范围内发展无线电接入网，通过向虚拟网络元素、白盒硬件和开放式 RAN 接口过渡来实现</li><li>同制定规范、参考架构以及定义 O-RAN 的各个子组件之间的接口</li><li>推动RAN的重组，以提高开放性、虚拟化和智能，从而提升多供应商网络设备之间的互操作性</li><li>倡议着重于整合人工智能 (AI)，指定接口和 API 以推动适当的标准化，并建立必要的供应链基础设施</li></ul><p><strong>核心原则</strong></p><ul><li>开放性<ul><li>所有RAN网元的<strong>接口</strong>开放</li><li>RAN网元的<strong>硬件参考设计</strong>开源</li><li>RAN<strong>软件代码</strong>开源</li></ul></li><li>智能性<ul><li>网络操作管理的<strong>自驱动</strong>：O-RAN应该能够利用新的<strong>基于学习</strong>的技术来<strong>自动化</strong>操作网络功能并减少运营成本</li><li>全面的<strong>网元级</strong>智能：利用新兴的<strong>深度学习</strong>技术，将智能嵌入RAN体系结构的每一层</li><li>全面的<strong>嵌入式</strong>智能：智能应用于嵌入式设备内部的组件级和网络级，实现<strong>动态</strong>的<strong>本地</strong>无线资源分配，优化网络范围的效率</li></ul></li><li>互操作性<ul><li>最大限度地使用通用的、现成的硬件和软件平台，最大限度地减少专有硬件</li><li>指定开放的API和接口，推动标准化组织酌情采纳它们，并在适当的地方探索开源</li><li>O-RAN的架构和接口规范应尽可能与3GPP架构和接口规范一致</li></ul></li></ul><p><strong>对比 OpenRAN</strong></p><p>Open RAN（美国主导）项目侧重软硬件设备的研制实操，而O-RAN联盟（中国主导）侧重架构标准化和接口开放工作</p><p><strong>面临的挑战</strong></p><p>&emsp;&emsp;有关ORAN的优劣问题，使用专用软硬件还是选择通用软硬件问题，业界已有很多讨论。从目前看，运营商希望通过ORAN实现产业更加开放竞争，实现自动化运维，降低成本；通过RAN开源软件获取灵活性，提升商业竞争力。但与此同时也面临一些风险和挑战：</p><ol><li><p>可能更加依赖于国外</p><blockquote><p>ORAN在通用服务器的芯片，可以选择英特尔X86，还有ARM，目前X86在生态等层面十分强大，而ARM相对弱一些，ARM生态还处于培育期。两者直接展开对抗，X86存量优势明显。所以白盒化基站可能更加依赖于美国的通信芯片。</p></blockquote></li><li><p>白盒基站的性能不如专用基站，功耗更高</p><blockquote><p>5G设备专用芯片在实际使用性能表现方面，比通用芯片性能更优。这也是为何目前OPEN RAN设备主要是小基站设备，或是只用在农村人少地区的通信设备，无法替代性能要求高的5G宏站</p><p>无线接入网是电信网络中最昂贵的部分之一，也是要求最严格的部分之一。云核心网和数据中心可以通过大规模集中的通用资源池高效配合来达到专用硬件的性能，但无线接入网的基站是广泛分布式的，且对业务处理的实时性要求更高。通用芯片并非专门设计用于实时信号处理，延迟高，抖动大，全采用通用芯片的白盒设备是无法满足5G业务需求</p><p>通用芯片特点是“软硬件分离”，可通过外部编程来实现各种功能，它的优点是产量大、成本低、灵活性高，但针对基站实时性业务处理效率低，功耗最高。基站对设备功耗、体积、稳定性和散热等指标要求极高。传统基站大量采用ASIC、DSP或SoC等，性能更有保障</p></blockquote></li><li><p>对运营商集成和运营能力要求高</p></li></ol><p><strong>注解</strong></p><ul><li>要对现有封闭的无线接入网进行全面的开放、开源有相当大的阻力和难度</li><li>从技术标准来看，O-RAN并非是革命，并非要推翻3GPP, 而是对3GPP标准尝试性的探索和引导</li></ul><p>&nbsp;</p><h3 id="O-RAN-与-5G-的关系"><a href="#O-RAN-与-5G-的关系" class="headerlink" title="O-RAN 与 5G 的关系"></a>O-RAN 与 5G 的关系</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225103625.png" alt="image-20220225103625807" style="zoom:40%;" /><ul><li>由于原先2G/3G/4G的接入网是封闭，且网络已经建成，对现有的网络改造是相当困难的，因此ORAN不会在2G/3G/4G的现有网络上实施</li><li>5G网络处于建网的初期，因此ORAN首要的实施部署的目标是5G RAN系统中的各个网元：网管、CU、DU和AAU</li><li>ORAN是在5G 3GPP已有的各个网元接口协议基础之上进行了<strong>扩展</strong>，以支持新的开放性的要求，ORAN协议包括两部分：（1）4G/5G的3GPP协议；（2）ORAN为 开放性和自能性目标新增加的协议和规范</li></ul><p>&nbsp;</p><h3 id="O-RAN-与-4G-的关系"><a href="#O-RAN-与-4G-的关系" class="headerlink" title="O-RAN 与 4G 的关系"></a>O-RAN 与 4G 的关系</h3><ul><li>O-RAN 并不打算在纯4G的网络上实施，但考虑到在 5G 实施和部署的过程中，在较长的一段时间内是 4G+5G 的混合组网，即 NSA。因此，O-RAN  要想在 5G 上实施，是无法完全绕开 4G 的</li><li>O-RAN 也 4G 进行适当的扩展。与 5G 扩展的区别在于，5G RAN 的所有网元是全面的开放，而对于4G, 只开放了BBU</li></ul><hr><p>以上是理解O-RAN是什么的基础背景知识，而Intel组的工作又是基于O-RAN架构开展的，因此有必要了解O-RAN架构的关键内容</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="O-RAN架构"><a href="#O-RAN架构" class="headerlink" title="O-RAN架构"></a>O-RAN架构</h2><h3 id="模块间架构"><a href="#模块间架构" class="headerlink" title="模块间架构"></a>模块间架构</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225140715.png" alt="20200615090019264" style="zoom:80%;" /><p><strong>自下而上</strong>三个部分：O-RAN 运行平台、O-RAN 网络功能、O-RAN 智能管理平台</p><h4 id="O-RAN-运行平台：O-Cloud"><a href="#O-RAN-运行平台：O-Cloud" class="headerlink" title="O-RAN 运行平台：O-Cloud"></a>O-RAN 运行平台：O-Cloud</h4><p>&emsp;&emsp;开放的云基础设施平台是一个云计算平台，用于运行O-RAN系统中各个逻辑网元实体的软硬件功能，底层由满足O-RAN要求的物理基础设施节点（如通用的计算机或专用硬件平台）和云平台软件、O-RAN相关的管理和编排功能三部分组成：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225141010.png" alt="20200614114557930" style="zoom:65%;" /><ul><li><p><strong>物理基础设施节点</strong></p><ul><li><p><strong>专有</strong>软/硬件平台</p><blockquote><p>这里指：传统的无线接入网RAN原有的专有硬件和专有软件的平台。</p><p>即使在O-RAN中，在短时间内，也很难做到全部的硬件、软件都通用化，部分功能，如射频处理和新增的实时基带处理等还将运行在专有的软、硬件平台RU之上。</p><p>但基于专有硬件和Linux操作系统的嵌入式软件的部分“虚拟化”已经实现了；RU的虚拟化是未来进一步研究的方向之一</p></blockquote></li><li><p><strong>通用</strong>软/硬件平台</p><blockquote><p>通用硬件主要指基于X86的通用计算机硬件，通用软件主要指Linux这样的通用操作系统</p><p>O-RAN一个重要的目标，就是尽可能的把现有RAN的功能从专有的硬件和专有的嵌入式操作系统平台上剥离，迁移到通用的硬件、通用操作系统、通用的云平台上，并尝试开放软件接口，甚至软件开源</p></blockquote></li></ul></li><li><p><strong>统一云平台软件</strong></p><p>  包括虚拟机操作系统、虚拟机监视器、容器等</p></li><li><p><strong>O-RAN相关的管理和编排功能</strong></p><ul><li><p>O-RAN网络节点的管理：</p><p>  提供诸如O-RAN基础设施节点的发现、注册、软件生命周期管理、工作负载生命周期管理、故障管理、性能管理和配置管理等功能</p></li><li><p>硬件加速器管理</p></li><li><p>O-RAN云架构部署</p><p>  承载（host）和运行O-RAN网络功能相关的软件实体。</p></li></ul></li></ul><h4 id="O-RAN-网络功能：逻辑网元"><a href="#O-RAN-网络功能：逻辑网元" class="headerlink" title="O-RAN 网络功能：逻辑网元"></a>O-RAN 网络功能：逻辑网元</h4><ul><li><p>5G 三大子系统之<strong>接入网 RAN</strong></p><p>  是 O-RAN 的核心，O-RAN 的主体与核心功能都是在这里实现的，是在已有的 5G RAN 功能基础之上的扩展，包括 Near-RT RIC、O-CU-CP、O-CU-UP、O-DU 和 O-RU（细节见下面 <a href="#%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E7%BD%91%E5%85%83%E6%9E%B6%E6%9E%84">内部逻辑网元架构</a> ）</p></li><li><p>5G 三大子系统之<strong>核心网 Core</strong></p><p>  核心网络完成移动终端的接续、计费，移动性管理、相互通信，以及与网外设备进行通信（如互联网和固定电话网等）。不过在O-RAN标准中，并没有对5G的核心网进行扩展</p></li></ul><h4 id="O-RAN-智能平台：服务和编排-SMO"><a href="#O-RAN-智能平台：服务和编排-SMO" class="headerlink" title="O-RAN 智能平台：服务和编排 SMO"></a>O-RAN 智能平台：服务和编排 SMO</h4><p>&emsp;&emsp;SMO的功能相当于传统的封闭的RAN接入网设备的网络运营和管理子系统 <strong>OAM</strong> 或 NMS，即网管，包括如下三大功能：</p><ol><li>云基础实施 OAM：云基础实施的操作、维护、管理</li><li>RAN OAM：无线接入网的操作、维护、管理</li><li>非实时的RAN智能控制器（Non-RT RIC）：结合人工智能技术，大数据分析技术，通过A1接口实施对O-RAN无线资源的非实时性的宏观调控和干预</li></ol><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225163038.png" alt="image-20220225163038706" style="zoom:55%;" /><center>O-RAN SMO 与 3GPP OAM 的映射关系</center><ul><li><p>在传统 RAN OAM 方面</p><p>  O-RAN完全采用了3GPP的规范。由于AM计费是核心网的功能，安全SM是传输的功能，因此在OAM架构，没有把他们包含进来</p></li><li><p>在“云”平台和虚拟网络功能方面</p><p>  3GPP没有既定的规范，O-RAN借用了ETSI欧洲电信标准化协会的标准</p></li><li><p>在人工智能和大数据分析方面</p><p>  3GPP侧重于采集大量的无线通信网中的数据，并通过机器学习和大数据分析，对采集到的数据进行分析，并给出预测报告，以供OAM人员进行决策</p><p>  O-RAN在3GPP的基础之上，更近了一步，期望通过人工智能算法和新定义的 <strong>Non RT RIC</strong> 和 <strong>Near RT RIC</strong> 这两个智能控制器，基于全网的实时分析的宏观数据分析，对 RAN 系统进行自动动态优化和动态宏观控制，而不是依赖网优人员来进行人工的优化和控制</p></li></ul><p>&emsp;&emsp;为了体现O-RAN系统的网管与传统的封闭式网管的不同，体现O-RAN运营的高度智能化、网络功能的服务化和可定制化, 给它取了一个新的名称：服务管理和编排（SMO）框架</p><p>&emsp;&emsp;O-RAN系统的智能化管理框架 SMO，在思想层面、设计层面上都与传统电信设备商的现有网管系统的有着重大的区别：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225152006.png" alt="image-20220225152006613" style="zoom: 60%;" /><p>&nbsp;</p><h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225152715.png" alt="image-20220225152715746" style="zoom: 60%;" /><h4 id="NG"><a href="#NG" class="headerlink" title="NG"></a>NG</h4><ul><li>  核心网&lt;——&gt;控制面、数据面</li></ul><h4 id="O1"><a href="#O1" class="headerlink" title="O1"></a>O1</h4><ul><li>SMO&lt;——&gt;O-RAN内部网元</li><li>用于SMO对O-RAN内部的逻辑网元进行智能化的管理和运营，如O-CU-CP、O-CU-UP、O-DU、O-RU</li></ul><h4 id="O2"><a href="#O2" class="headerlink" title="O2"></a>O2</h4><ul><li>SMO&lt;——&gt;O-Cloud</li><li>用于SMO对云平台O-Cloud之上运行的各个O-RAN网络服务节点进行智能化管理与运营</li></ul><h4 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h4><ul><li><p>无线接入网&lt;——&gt;Non-RT RIC</p></li><li><p>用于SMO对O-RAN内部的无线资源进行智能和动态的细粒度的控制</p></li><li><p>是SMO对O-RAN内部<strong>控制平面</strong>实施的动态的、智能的<strong>控制性</strong>干预</p></li><li><p>原先的无线接入网，更多关注的是每个基站内部无线资源的微观的调控，而O-RAN中的SMO，更多是对整个无线接入网中所有无线资源进行的宏观调控。</p><p>  而能够做到这一点的关键是：无线资源功能的云化和虚拟化</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225153630.png" alt="image-20220225153630589" style="zoom:65%;" /></li></ul><p>&nbsp;</p><h3 id="内部逻辑网元架构"><a href="#内部逻辑网元架构" class="headerlink" title="内部逻辑网元架构"></a>内部逻辑网元架构</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220228140700.png" alt="image-20220228140700479" style="zoom:50%;" /><h4 id="Near-RT-RIC"><a href="#Near-RT-RIC" class="headerlink" title="Near-RT RIC"></a>Near-RT RIC</h4><p>&emsp;&emsp;是O-RAN新引入的，细节见下面 <a href="#RIC">RIC</a></p><h4 id="O-eNB"><a href="#O-eNB" class="headerlink" title="O-eNB"></a>O-eNB</h4><p>&emsp;&emsp;因为在很长的一段时间内，5G 不是独立组网 SA，而是 4G+5G 的混合组网NSA，因此 O-RAN 无法把 4G LTE eNB 排除在外，但考虑到 LTE 已经是成熟部署的网络，因此 O-RAN 没有对 LTE eNB 再进行进一步的切分，而是把 eNB 作为一个整体无线资源对其进行了扩展：</p><ul><li>O1接口：用于对 O-eNB 进行智能化的配置和管理</li><li>E2 接口：用于对 O-eNB 的无线资源进行控制</li></ul><h4 id="一系列5G网元"><a href="#一系列5G网元" class="headerlink" title="一系列5G网元"></a>一系列5G网元</h4><p>&emsp;&emsp;CU-CP、CP-UP、DU、RU 这些都是 5G 系统定义标准的网元</p><p>&emsp;&emsp;O-RAN对这些标准网元进行了开放性的扩展，以支持通过 SMO 对其进行智能化管理：O-RU（开放-无线单元）、O-DU（开放-分布式单元）、O-CU-CP（开放-集中单元-控制平面）、O-CP-UP（开放-集中单元-数据平面）</p><ul><li>O1接口：用于对O-RAN内部网元进行智能化的配置和管理</li><li>E2 接口：用于对O-RAN内部网元的无线资源进行控制</li></ul><p>&nbsp;</p><h3 id="功能模块角度"><a href="#功能模块角度" class="headerlink" title="功能模块角度"></a>功能模块角度</h3><p>与上面不同，这一节从功能模块角度来看O-RAN的架构（其实是另一篇文章的行文逻辑🤣）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225083129.png" alt="image-20220225083129297" style="zoom:50%;" /><ul><li>Orchestration/NMS layer with Non Real Time RAN Intelligent Controller（具有non-RT RIC的编排/NMS 层）</li><li>RAN Intelligent Controller (RIC) near-Real Time（near-RT RIC）</li><li>Multi-RAT CU protocol stack Function（具有协议栈功能的多 RAT）</li><li>DU and RRU Function（DU和RRU功能）</li></ul><p>&emsp;&emsp;围绕着这些主要特征和功能模块，27个全球 MNO 和 180 多个生态系统贡献者组成 O-RAN 联盟，共同制定规范、参考架构以及定义 O-RAN 的各个子组件之间的接口的组织。O-RAN 联盟的核心原则是开放性，智能性，虚拟化和互操作性。</p><h4 id="Orchestration-NMS-layer-with-Non-RT-RAN-Intelligent-Controller"><a href="#Orchestration-NMS-layer-with-Non-RT-RAN-Intelligent-Controller" class="headerlink" title="Orchestration/NMS layer with Non-RT RAN Intelligent Controller"></a>Orchestration/NMS layer with Non-RT RAN Intelligent Controller</h4><p>&emsp;&emsp;<strong>non-RT RIC</strong> (&gt; 1s) 和 <strong>near-RT RIC</strong> (&lt;1s) 在 RIC 中解耦。non-RT 功能包括<strong>服务和策略管理</strong>、<strong>RAN 分析</strong>和 <strong>near-RT</strong> RAN 功能的<strong>模型训练</strong>。在 <strong>non-RT RIC</strong> 中生成的训练模型和实时控制功能被分发到 <strong>near-RT RIC</strong> 以供运行时执行。</p><ul><li>O-RAN 规范定义了 Orchestration/NMS 层（含 non-RT RIC） 和 eNB/gNB（含near-RT RIC） 之间的 A1 接口</li><li>non-RT RIC 中的网络管理应用程序通过 A1 接口以标准化格式接收来自模块化控制单元 (CU) 和分布式单元 (DU) 的高度可靠数据并对其进行操作</li><li>支持 AI 的策略和基于 ML 的模型在 non-RT RIC 中生成消息并传送到 near-RT RIC</li><li>non-RT RIC 的核心算法由网络运营商拥有和部署，该算法提供了通过部署针对各个运营商策略和优化目标优化的不同模型来修改 RAN 行为的能力</li></ul><h4 id="RAN-Intelligent-Controller-RIC-near-Real-Time-function-layer"><a href="#RAN-Intelligent-Controller-RIC-near-Real-Time-function-layer" class="headerlink" title="RAN Intelligent Controller (RIC) near-Real Time function layer"></a>RAN Intelligent Controller (RIC) near-Real Time function layer</h4><p>&emsp;&emsp;O-RAN 参考架构的 <strong>near-RT RIC</strong> 功能层内为下一代 RRM 提供嵌入式智能，同时完全兼容传统 RRM。<strong>near-RT RIC</strong> 的设计旨在增强一些具有挑战性的操作功能，例如：具体到每个UE的负载平衡、RB 管理、干扰检测和缓解等。</p><p><strong>near-RT RIC</strong> 层功能如下：</p><ul><li>提供了利用嵌入式智能的新功能，例如 QoS 管理、连接管理和无缝切换控制</li><li>提供了一个强大、安全且可扩展的平台，允许灵活地加入第三方控制应用程序</li><li>利用了称为无线电网络信息库 (R-NIB) 的数据库，该数据库捕获底层网络的近实时状态</li><li><strong>将各种 RAN 测量数据馈送到近 RT RIC 以促进无线电资源管理</strong>（Intel-NS RRM）</li><li>向 CU/DU 提供启动配置命令</li><li><strong>near-RT RIC</strong> 可由传统 TEMs 或 第三方提供</li><li><strong>near-RT RIC</strong> 从 <strong>non-RT RIC</strong> 接收 AI 模型并执行它以改变网络的功能行为</li></ul><p><strong>near-RT RIC</strong> 层接口：</p><ul><li>A1，<strong>non-RT RIC</strong> 和包含 <strong>near-RT RIC</strong> 的模块化 CU 之间的接口</li><li>E2，O-RAN 架构背景下的 <strong>near-RT RIC</strong> 和 CU/DU 之间的标准接口</li></ul><h4 id="Multi-RAT-CU-protocol-stack-Function"><a href="#Multi-RAT-CU-protocol-stack-Function" class="headerlink" title="Multi-RAT CU protocol stack Function"></a>Multi-RAT CU protocol stack Function</h4><ul><li>Multi-RAT协议栈的功能支持4G、5G等协议处理</li><li>协议栈的基本功能是根据 Near-RT RIC 模块下发的控制命令来实现的，例如：交接</li><li>Multi-RAT CU功能应该部署在虚拟化平台</li><li>这种虚拟化为 CU 和 Near-RT RIC 提供了一个高效的执行环境，具有跨多个网络元素分配容量的能力，具有安全隔离、虚拟资源分配、加速器资源封装等优势</li><li>当前架构使用 3GPP 提供的 F1/E1/X2/Xn 现有接口定义，增强此接口以支持多供应商之间的互操作</li></ul><h4 id="DU-and-RRU-Function"><a href="#DU-and-RRU-Function" class="headerlink" title="DU and RRU Function"></a>DU and RRU Function</h4><ul><li>DU和RRU功能包括：实时L2功能、基带处理和射频处理</li><li>DU和RRU之间的接口提供标准的功能分割，包括DU-RRU下层拆分接口（Open front-haul Interface）和 CU-DU上层拆分接口（F1），保证不同系统之间的互操作性</li></ul><p>&nbsp;</p><h3 id="O-RAN-对-3GPP-架构的影响"><a href="#O-RAN-对-3GPP-架构的影响" class="headerlink" title="O-RAN 对 3GPP 架构的影响"></a>O-RAN 对 3GPP 架构的影响</h3><p><strong>逻辑网元</strong></p><p>&emsp;&emsp;O-RAN并没有对5G 3GPP定义的RU、DU、CU-CP、CU-UP、eNB(4G) 这些逻辑网元进行更改，而是在这些既有的网元的基础上，增加了两个新的逻辑网元：</p><ul><li>Non RT RIC（RAN智能控制器）：位于RAN接入网之外，RAN网络管理子系统SMO之内</li><li>Near RT RIC（RAN智能控制器）：位于RAN接入网之内</li></ul><p><strong>接口</strong></p><p>&emsp;&emsp;除了与网管子系统的接口之外，O-RAN并没有对5G 3GPP定义F1, E1, X2, Xn，NG这些既有的逻辑网元的接口进行更改，只在此基础之上增加了新的接口：O1、O2、A1、E2</p><hr><p>&emsp;&emsp;以上是 O-RAN 架构的大致内容，而Intel-NS方向的工作属于Near-RT RIC中的智能无线资源管理部分，因此下面研究一下O-RAN中提出两个的新逻辑网元：Non-RT RIC 和 Near-RT RIC</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="RIC（RAN-Intelligent-Controller）"><a href="#RIC（RAN-Intelligent-Controller）" class="headerlink" title="RIC（RAN Intelligent Controller）"></a>RIC（RAN Intelligent Controller）</h2><p>&emsp;&emsp;为了实现软件定义的 RAN 体系结构，O-RAN 对 RAN 进行分解，旨在建立一个开放的、与特定的设备供应商无关的 RAN 环境。无线智能控制器 RIC 就是在这样的大背景下被提出来的一个概念，或者说，在 5G 的网络架构中的网元之外，提出的一个新的逻辑网元，这部分探讨一下 RIC 这个新逻辑网元的总体架构与主要的功能模块</p><h3 id="RIC-的位置与使命"><a href="#RIC-的位置与使命" class="headerlink" title="RIC 的位置与使命"></a>RIC 的位置与使命</h3><p>&emsp;&emsp;RIC 是对传统的无线资源管理 RRM 的拆分与重新汇聚， 它综合了无线资源管理 RRM、切片管理、服务水平协议 SLA 与 Qos、机器学习与预测、微服务架构、云部署+Paas+Sass、移动边缘云计算 MEC 的协同等技术, 从而实现对 5G 无线接入网提供近实时的智能控制。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226151145.png" alt="image-20220226151138053" style="zoom:60%;" /><p>&emsp;&emsp;RIC 是 O-RAN 提出的一个新的逻辑网元，处于封闭 RAN 的最边缘，通常与 O-CU 一起部署在云端。与 RAN 传统的其他网元不同，RIC 诞生在“云”之上，拥有“云原生”很多属性和特点，同时又承担这对封闭 RAN 智能控制的职责，注定这是一个新与旧的融合体，注定这里会涌现出新的想象空间，注定这里会诞生新的机会。</p><p>&emsp;&emsp;部分传统的电信设备商正在与运营商联手，以 RIC 作为切入点，试图建立一个更加开放的、更加智能的无线接入网；并通过试图引入大量的第三方 xApp 微服务提供商，建议一个新的 O-RAN 的生态环境。</p><p>&nbsp;</p><h3 id="RIC-的前世：4G-5G非O-RAN网络架构下的无线资源管理-RRM"><a href="#RIC-的前世：4G-5G非O-RAN网络架构下的无线资源管理-RRM" class="headerlink" title="RIC 的前世：4G/5G非O-RAN网络架构下的无线资源管理 RRM"></a>RIC 的前世：4G/5G非O-RAN网络架构下的无线资源管理 RRM</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225191633.png" alt="image-20220225191633049" style="zoom:70%;" /><ul><li><p>L1、L2、L3</p><p>  完成了无线接入网4G/5G分层协议<strong>控制面</strong>的功能</p></li><li><p>RRM无线资源管理</p><p>  是 O-RAN 中 <strong>Rear RT RIC</strong> 的 <strong>A1</strong> 功能的<strong>前身</strong></p><p>  对移动通信系统的空中接口资源进行规划和调度，包括访问控制、信道分配控制、功率控制、负荷管理、移动性管理、小区间干扰协调、无线承载控制、切换控制等</p><p>  RRM能够跨越不同的协议层，完成对无线资源的<strong>信息收集</strong>、<strong>配置管理</strong>和<strong>优化控制</strong></p></li><li><p>OAM</p><p>  是 O-RAN 中 <strong>Rear RT RIC</strong> 的 <strong>O1</strong> 接口功能的<strong>前身</strong></p><p>  负责单一gNB本地的操作维护管理，并与操作维护管理中心的网管系统NMS进行通信</p></li><li><p>NMS</p><p>  是 O-RAN 中 <strong>SMO</strong> 的前身</p><p>  网络管理系统，负责RAN系统中<strong>所有</strong>的gNB的操作维护管理</p></li><li><p>SON</p><p>  是O-RAN系统中 <strong>Non RT RIC</strong> 功能的<strong>前身</strong></p><p>  是NMS系统的一个子模块，其主要思路是实现无线网络的一些自主功能，减少人工参与，降低运营成本</p></li></ul><p>&nbsp;</p><h3 id="4G-5G-RRM-的今生：O-RAN-架构下的-Rear-Time-RIC"><a href="#4G-5G-RRM-的今生：O-RAN-架构下的-Rear-Time-RIC" class="headerlink" title="4G/5G RRM 的今生：O-RAN 架构下的 Rear Time RIC"></a>4G/5G RRM 的今生：O-RAN 架构下的 Rear Time RIC</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225193701.png" alt="image-20220225193701060" style="zoom:75%;" /><p><strong>Near RT RIC</strong> (RAN Intelligent Controller)：近实时无线接入网智能控制器</p><p>它完成类似 4G/5G 系统中的无线资源管理 RRM 的功能，但在原先的 RRM 能力的基础之上，进行了增强：</p><ol><li>把 NMS中 SON 的功能剥离出来，成为SMO中的 None RT RIC</li><li>把 gNB 中无线资源控制 RRM 的功能中剥离出来，成为一个具有独立功能逻辑网元实体 Real RT RIC</li><li>把 RRM 原先与 NMS/OAM 的接口独立出来，变成了 RIC 的 A1 接口</li><li>把 RRM 原先与 L1、L2、L3 的接口独立出来，变成了 RIC 的 E2 接口</li><li>虽然 RIC 在实际部署时，可以与 O-CU 部署在一起, 但逻辑上讲，RIC 是一个独立的网元，独立于单个的CU、DU，因此可以在更宏观的层面, 综合全网的 CU、DU 进行“宏观”的调控</li><li>RIC 增加了人工智能技术，使得 RIC 更加的 ，如利用机器学习的学习和预测功能</li></ol><p>&nbsp;</p><h3 id="Near-RT-RIC-功能模块"><a href="#Near-RT-RIC-功能模块" class="headerlink" title="Near-RT RIC 功能模块"></a>Near-RT RIC 功能模块</h3><p>&emsp;&emsp;<strong>Near-RT RIC</strong> 内部架构采用经典的、基于web的、服务器应用程序的三层的架构模型：数据层、逻辑业务层和表示层</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225195555.png" alt="image-20220225195555053" style="zoom:60%;" /><h4 id="第一层：数据层"><a href="#第一层：数据层" class="headerlink" title="第一层：数据层"></a>第一层：数据层</h4><ul><li><p><strong>Database</strong> 分布式数据库</p><p>  数据库，用于存放UE上下文相关的信息、无线资源控制相关的信息</p><p>  分布式，是指数据库的存储与Near RT RIC不一定在同一个服务器上，数据库可基于云基础架构而部署</p></li><li><p><strong>Shared Data Layer</strong> 共享数据层 SDL</p><p>  是对底层数据库的封装，简化了上层应用对数据库的访问</p></li></ul><h4 id="第二层：业务逻辑层"><a href="#第二层：业务逻辑层" class="headerlink" title="第二层：业务逻辑层"></a>第二层：业务逻辑层</h4><ul><li><p><strong>xAPP Subscription Management</strong> 订阅管理</p><p>  xApp 与 E2 的节点（ CU、DU、RU）通信采用的是订阅机制</p><p>  订阅管理通过注册/订阅和访问控制管理微服务 xAPP，xAPP 只有向 E2 的节点订阅成功后，才能收到 E2节点发送的信息，xAPP 才能访问和控制E2节点</p></li><li><p><strong>Conflict Mitigation</strong> 冲突缓解</p><p>  无线资源管理的控制对象可能是小区、UE或承载。而无线资源控制的功能包括接入控制、承载控制、切换控制、QoS控制、资源分配，这些功能是通过修改控制对象的一个或多个参数来完成的。因此多个微服务应用程序调整的参数之间可能会发生冲突，甚至可能是反向的参数配置</p><p>  这就需要对冲突进行控制和管理，以避免CU、DU、RU这些节点无所适从，行为混乱</p></li><li><p><strong>Management Services</strong> 管理服务（O1接口）</p><p>  xApp生命周期管理</p><p>  FCAPS：故障、配置、计费（不需要）、性能和安全管理</p></li><li><p><strong>Security</strong> 安全</p><p>  防止恶意的xAPP滥用无线网络信息，增加网络的安全性</p></li><li><p><strong>xApp</strong> 微服务应用程序</p><p>  在 Near-RT RIC 架构中，xAPP可以由第三方公司提供，O-RAN为 xAPP 规定的的标准接口使得第三方开发的 xAPP 非常容易的集成到 Near-RT RIC 系统中。xApp的引入为RIC打开了一扇对外开放的窗，为第三方公司参与到O-RAN的生态中来提供了技术上可能性</p></li></ul><h4 id="第三层：表示层"><a href="#第三层：表示层" class="headerlink" title="第三层：表示层"></a>第三层：表示层</h4><p>如果把RIC作为一个系统，表示层就是O1 termination和 A1 termination，它们用来终止SMO Non RT的数据Http请求，然后分发到内部的各个xApp服务上</p><p>如果把O-RAN作为一个系统，表示层就是SMO Non RT，而IE浏览器就是客户端</p><p>&nbsp;</p><h3 id="Near-RT-RIC-对外接口"><a href="#Near-RT-RIC-对外接口" class="headerlink" title="Near-RT RIC  对外接口"></a>Near-RT RIC  对外接口</h3><ul><li><strong>E2</strong>：通过该接口，Non-RT RIC 实现对多个 O-CU-CP、O-CU-UP、DU、O-eNB 的无线资源的监控、配置、管理和控制</li><li><strong>O1</strong>：通过该接口，Non-RT RIC 实现对多个 RT RIC 的无线资源的配置、管理</li><li><strong>A1</strong>：通过该接口， Non-RT RIC 实现对多个 RT RIC 的无线资源的监控和控制</li></ul><p>&nbsp;</p><h3 id="为-xApp-开放的接口"><a href="#为-xApp-开放的接口" class="headerlink" title="为 xApp 开放的接口"></a>为 xApp 开放的接口</h3><p>目前互联网常用的微服务架构如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220225210423.png" alt="image-20220225210423824" style="zoom:60%;" /><p>&emsp;&emsp;微服务架构是新的软件架构，在互联网中得到了普遍的应用，而电信设备商的软件架构基本还停留在最初的单体程序架构上，因此电信设备商要想大幅度减少软件的发布周期，提升软件从开发到发布再到部署的整体效率，不仅仅需要组织架构的革新、软件开发流程的革新、IT基础设施的革新、管理人员和开发人员（劳动者）思维方式的变革、还包括目标系统（劳动对象）软件系统架构的革新</p><p>&emsp;&emsp;在此背景下，RIC 提供了一个开发平台，便于能够提供<strong>特定场景下的无线资源智能控制的算法和服务</strong>的第三方 xAPP 公司，方便和轻松得把他们的 xAPP 服务集成到 RIC 系统中</p><p>RIC 为 xApp 开放，用于从 RIC 平台获取信息，并对O-RAN进行控制的内部接口：</p><ul><li><p><strong>A1</strong> 相关的接口</p><p>  xApps 根据 non-RT-RIC 通过 A1 接口传输的策略或丰富信息或两者提供增值服务</p><p>  通过此接口与 A1 信息交互</p></li><li><p><strong>E2</strong> 相关的接口</p><p>  通过此接口与E2 信息交互</p></li><li><p><strong>Management</strong> 相关的接口</p><ol><li>xApp生命周期的管理</li><li>机器学习模型的部署请求、更新请求、卸载请求等接口</li><li>常规的配置管理、故障管理等</li></ol></li><li><p>共享数据访问层 <strong>SDL</strong> 接口</p><ol><li>该接口提供了一种简单而灵活的存储和检索数据的方法，同时隐藏了数据库的类型和位置、数据库层的管理操作（如高可用性、可伸缩性、负载平衡）等细节</li><li>该接口还允许多个xApp相互独立地访问数据</li></ol></li><li><p><strong>Control</strong> 接口</p><p>  该接口提供了xApp与负责控制功能的实体（如冲突缓解、xApp订阅管理）之间交换与控制相关的信息。例如，来自 xApp 的分析结果、决策或请求，可以通过接口进行传输，以缓解冲突、xApp订阅管理或其他必要的功能</p></li></ul><hr><p>&emsp;&emsp;虽然 O-RAN 定义了RAN的开发标准，但要实现 RAN 的完全的开放，还有很长的路要走。RIC 为 RAN 的开放打开了一扇窗，RIC 在 RAN 一时无法完全开放的情况下，为 RAN 的开放迈出了实质性和关键线性的一步。</p><p>&emsp;&emsp;RIC 把 RAN 开放到什么程度的控制权利留给 RAN 的设备供应商，允许 RAN 的设备供应商有条件、有步骤的、灵活的开放其内部无线资源。同时提供了一种开放的平台，允许第三方 xApp 公司，基于RAN设备开放的功能，开发特定业务场景下的无线资源智能制的应用程序。</p><p>&emsp;&emsp;而我们 NSRRM 做的就是利用机器学习得到智能的无线资源管理 RRM 的算法，作为一个 xApp 部署到 O-RAN 框架中</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Dian-Intel-NS-的工作"><a href="#Dian-Intel-NS-的工作" class="headerlink" title="Dian Intel-NS 的工作"></a>Dian Intel-NS 的工作</h2><blockquote><h3 id="5G复杂的资源分配的技术特点"><a href="#5G复杂的资源分配的技术特点" class="headerlink" title="5G复杂的资源分配的技术特点"></a>5G复杂的资源分配的技术特点</h3><p>相对于4G LTE, 5G引入了很多新的技术特征，如超高速、超大容量、超低延时、切片化资源管理、宽广的应用场景等；</p><p>从人与人的通信，演变成人与物的通信，再演变成物与物的通信，真正的万物互联极有可能在5G时代得以实现，但同时也使得5G系统的设计、运维比4G要复杂很多很多。</p><p>RIC的智能化、自动化的运维，正是辅助RAN系统中的其他网元，一起解决这一复杂性的重要的技术手段之一。</p><h3 id="RIC在客观上保护了设备厂家的封闭性和技术壁垒"><a href="#RIC在客观上保护了设备厂家的封闭性和技术壁垒" class="headerlink" title="RIC在客观上保护了设备厂家的封闭性和技术壁垒"></a>RIC在客观上保护了设备厂家的封闭性和技术壁垒</h3><p>RIC不强制要求开放RAN系统内部的结构，只要求开放资源调度的接口、并把资源调度开放的程度的权限留给了RAN设备厂家，客观上保护RAN系统的封闭性和技术壁垒。</p><p>正是因为RIC的存在，人工智能技术，特别是机器学习技术，可以轻松的应用到RAN系统中，而不需要对RAN现有的系统进行大量的改造或重新定义，只需要对RAN系统进行少量的适配性的修改。这就意味着O-RAN并没有给现有的RAN系统增加太多修改负担，同时却又能带来显著的收益，客观成为设备商参与O-RAN的另一个主要的推动力之一。</p><h3 id="探索-RIC-能否带来-RAN-运行效率的提升"><a href="#探索-RIC-能否带来-RAN-运行效率的提升" class="headerlink" title="探索 RIC 能否带来 RAN 运行效率的提升"></a>探索 RIC 能否带来 RAN 运行效率的提升</h3><p>当前，RAN系统的蜂窝小区的频谱效率、能效（功耗）还有最终用户的体验的能力，完全是取决于不同设备厂家的软硬件设计人员的事前设计以及网优人员的事后分析与优化。</p><p>这种完全靠人工的方式，不但效率低下，而且设备的性能，极大程度上依赖技术人员的技术水平、开发效率等因素。</p><p>人工智能技术、自动化技术、“云”计算等技术手段的采用，可以弥补上述的缺陷，极大的提升了对RAN自动化和智能化控制与优化的水平，提升了设备厂家自身的RAN系统的频谱效率、能效（功耗）还有最终用户的体验。这是设备上参与O-RAN的主要的内在动机之一。</p></blockquote><p>&nbsp;</p><p><strong>本文参考资料：</strong></p><p><a href="https://blog.csdn.net/HiWangWenBing/article/details/110390895">O-RAN专题系列-0：文火冰糖</a></p><p><a href="https://www.o-ran.org/">O-RAN官方：O-RAN ALLIANCE</a></p><p><a href="https://baijiahao.baidu.com/s?id=1669110942975163377&wfr=spider&for=pc">O-RAN系列：什么是开放无线接入网O-RAN </a></p><p><a href="https://www.techplayon.com/open-ran-o-ran-reference-architecture/">Open RAN (O-RAN) Reference Architecture</a></p><p><a href="https://www.viavisolutions.com/zh-cn/solutions/o-ran">开放式 RAN 是什么？ | O-RAN 架构、5G 和测试解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> O-RAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数字图像处理】图像的本质：纸片人老婆的数据格式</title>
      <link href="/2022/02/23/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/02/23/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;图像格式即图像文件存放的格式，通常有JPEG、BMP、GIF、TIFF、RAW、PNG等。由于数码相机拍下的图像文件很大，储存容量却有限，因此图像通常都会经过压缩再储存。不同格式的图片文件对像素信息的存储方式和处理方法都有所不同，所以各有特点和使用场景，在进行机器学习数据预处理时也需要格外关注图像的格式后缀。</p><p>&emsp;&emsp;近些年随着二次元文化的发展，越来越多人开始称呼纸片人为老婆，那么今天就让我来看看这些纸片人老婆”真实“的样子~😆</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220227110526.png" alt="image-20220227110526189" style="zoom:60%;" /><span id="more"></span><p>&nbsp;</p><h2 id="JPEG格式"><a href="#JPEG格式" class="headerlink" title="JPEG格式"></a>JPEG格式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;JPEG（联合图像专家组，Joint Photographic Experts Group）是JPEG标准的产物，正式名为：信息技术连续色调静止图像的数字压缩编码，该标准由国际标准化组织（ISO）制订，是面向连续色调静止图像的一种压缩标准。JPEG格式是最常用的图像文件格式，后缀名为 <code>.jpg</code> 或 <code>.jpeg</code></p><p>&emsp;&emsp;JPEG主要采用预测编码（DPCM）、离散余弦变换（DCT）以及熵编码的联合编码方式，以去除冗余的图像和彩色数据，属于有损压缩格式。它能够将图像压缩到很小的存储空间，压缩比例通常在 <code>10:1</code> 到 <code>40:1</code> ，同一幅图，JPEG格式存储的文件是其他类型文件的不到十分之一，但这会在一定程度上造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量降低，如果追求高品质图像，则不宜采用过高的压缩比例。</p><p>JPEG格式分为3种：</p><ul><li><p>标准JPEG：</p><p>  在网页下载时只能由上而下依序显示图像，直到图像资料全部下载完毕，才能看到图像全貌</p></li><li><p>渐进式JPEG：</p><p>  在网页下载时，先呈现出图像的粗略外观后，再慢慢地呈现出完整的内容；并且存成渐进式JPG格式的文档比存成标准JPG格式的文档要来得小，所以如果要在网页上使用图像，可以多用这种格式</p></li><li><p>JPEG2000：</p><p>  是新一代的影像压缩法，压缩品质更高，并可改善在无线传输时，常因信号不稳造成马赛克现象及位置错乱的情况，改善传输的品质</p></li></ul><h3 id="压缩标准"><a href="#压缩标准" class="headerlink" title="压缩标准"></a>压缩标准</h3><p><strong>JPEG标准</strong></p><ul><li><p>基于DPCM无损压缩</p><p>  采用预测法、哈夫曼编码，从而保证重建图像与原图像完全相同</p></li><li><p>基于DCT的顺序编码</p><p>  根据DCT变换原理，按从上到下、从左到右的顺序对图像数据进行压缩编码。当信息传送到接收端时，首先按照上述规律进行解码，从而还原图像。在此过程中存在信息丢失，因此这是一种有损图像压缩编码</p></li><li><p>基于DCT的累进编码</p><p>  也以DCT变换为基础的，但是其扫描过程不同。它通过多次扫描的方法来对一幅图像进行数据压缩。其描述过程采取由粗到细逐步累加的方式进行。图像还原时，在屏幕上首先看到的是图像的大致情况，而后逐步地细化，直到全部还原出来为止</p></li><li><p>基于DCT的分层编码</p><p>  以图像分辨率为基准进行图像编码，首先是从低分辨率开始，逐步提高分辨率，直至与原图像的分辨率相同为止。图像重建时也是如此。可见其效果与基于DCT累进编码模式相似，但其处理起来更复杂，所获得的压缩比也更高一些</p></li></ul><p><strong>JPEG 2000标准</strong></p><p>&emsp;&emsp;JPEG采用离散余弦变换将图像压缩为8×8的小块，然后依次放入文件中，这种算法靠丢弃频率信息实现压缩，因而图像的压缩率越高，频率信息被丢弃的越多。在极端情况下，JFEG图像只保留了反映图貌的基本信息，精细的图像细节都损失了，为此，JPEG制定了新一代静止图像压缩标准 JPEG2000。</p><p>&emsp;&emsp;JPEG 2000放弃了JPEG所采用的以离散余弦变换（DCT）为主的区块编码方式，而采用以小波变换为主的多解析编码方式，其主要目的是要将影像的频率成分抽取出来。小波转换将一幅图像作为一个整行变换和编码，很好地保存了图像信息中的相关性，达到了更好的压缩编码效果。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当用质量与比特率之比来衡量时，JPEG的性能相当优越，其优点在于：</p><ul><li>支持极高的压缩率，JPEG图像的下载速度很快</li><li>能够处理16.8M的颜色，可以很好地再现全彩的图像</li><li>对图像压缩处理时，JPEG允许自由地在最小文件尺寸和最大文件尺寸之间选择</li><li>文件尺寸相对较小，有利于在带宽并不富裕的情况下传输</li></ul><p>JPEG的缺点：</p><ul><li>不是所有浏览器都支持各种JPEG图像插入网页</li><li>压缩时，可能使图像的质量受到损失，故不适宜用于显示高清晰度图像</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>  JPEG格式的压缩率是目前各种图像文件格式中最高的，压缩的主要是高频信息，对色彩的信息保留较好，适合应用于互联网；它可减少图像的传输时间，支持24位真彩色；也普遍应用于需要连续色调的图像中。</p><h3 id="Matlab观察像素矩阵"><a href="#Matlab观察像素矩阵" class="headerlink" title="Matlab观察像素矩阵"></a>Matlab观察像素矩阵</h3><p><strong>原图像</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224112020.jpg" alt="芭芭拉" style="zoom: 25%;" /><center>芭芭拉.jpg</center><p><strong>代码</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">clear all;clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%读取一张图片，并显示</span></span><br><span class="line">original_picture=imread(<span class="string">&#x27;派蒙.jpg&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(original_picture);</span><br><span class="line">title(<span class="string">&#x27;Original Picture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%分别读取R、G、B的值，1代表R，2代表G，3代表B</span></span><br><span class="line">image_r=original_picture(:,:,<span class="number">1</span>);</span><br><span class="line">image_g=original_picture(:,:,<span class="number">2</span>);</span><br><span class="line">image_b=original_picture(:,:,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">222</span>)</span><br><span class="line">imshow(image_r);</span><br><span class="line">title(<span class="string">&#x27;R  Part&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">223</span>)</span><br><span class="line">imshow(image_g);</span><br><span class="line">title(<span class="string">&#x27;G  Part&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">224</span>)</span><br><span class="line">imshow(image_b);</span><br><span class="line">title(<span class="string">&#x27;B  Part&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>R、G、B灰度图</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224111952.png" alt="image-20220224111945350" style="zoom:60%;" /><p><strong>像素矩阵</strong>（以G通道为例）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224112227.png" alt="image-20220224112227515" style="zoom:50%;" /><p>&nbsp;</p><h2 id="BMP格式"><a href="#BMP格式" class="headerlink" title="BMP格式"></a>BMP格式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>BMP（全称Bitmap）是Window操作系统中的标准图像文件格式，能够被多种Windows应用程序所支持</p><p>BMP采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此BMP文件所占用的空间很大</p><p>BMP文件的图像深度可选：1bit、4bit、8bit、24bit</p><p>BMP图像的扫描方式是按从左到右、从下到上的顺序</p><p>由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>BMP格式文件从头到尾依次是：</p><ul><li>位图文件头（bmp file header）：14 bytes</li><li>位图信息头（bitmap information）：40 bytes</li><li>调色板（color palette）：可选</li><li>位图数据</li></ul><p>最常见的就是24位图，即一个像素的颜色信息用24位来表示，对于三原色BRG，每一个颜色都用以字节（8）位来表示。除了24位图，还有1位（单色），2位（4色，CGA），4位（16色，VGA），8位（256色），16位（增强色），24位（真彩色）和32位等。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>用 NotePad++ 的Hex插件打开bmp图片：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223150236.bmp" alt="派蒙" style="zoom:50%;" /><center>派蒙.bmp</center><p>截取部分数据如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223105608.png" alt="image-20220223105608563" style="zoom:40%;" /><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>文件头包含文件格式、大小等信息</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223105932.png" alt="image-20220223105932926" style="zoom:50%;" /><p>前14字节为bmp图像的文件头信息，其中：</p><table><thead><tr><th>字节</th><th>位名</th><th>含义</th><th>示例取值</th><th>说明</th></tr></thead><tbody><tr><td>0~1</td><td>bfType</td><td>文件类型</td><td>4d 42</td><td>0x424d = “BM”，即 bmp 文件</td></tr><tr><td>2~5</td><td>bfSize</td><td>文件大小</td><td>00 04 a1 ae</td><td>0x4a1ae = 303534 bits</td></tr><tr><td>6~7</td><td>bfReserved1</td><td>保留位</td><td>00 00</td><td>固定值：0</td></tr><tr><td>8~9</td><td>bfReserved2</td><td>保留位</td><td>00 00</td><td>固定值：0</td></tr><tr><td>a~d</td><td>bfOffBits</td><td>文件开头到图片数据的偏移量</td><td>00 00 00 36</td><td>0x36 = 54 bytes</td></tr></tbody></table><p>（注意，数据存储采用<strong>小字节序</strong>，高位值存在高位地址）</p><h4 id="信息头"><a href="#信息头" class="headerlink" title="信息头"></a>信息头</h4><p>信息头包含图像数据尺寸、位平面数、压缩方式、颜色索引等信息</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223131502.png" alt="1" style="zoom:50%;" /><p>第14~53字节为bmp图像的信息头分析，其中：</p><table><thead><tr><th>字节</th><th>位名</th><th>含义</th><th>示例取值</th><th>说明</th></tr></thead><tbody><tr><td>0e~11</td><td>biSize</td><td>信息头大小</td><td>00 00 00 28</td><td>0x28 = 40 bits</td></tr><tr><td>12~15</td><td>biWidth</td><td>位图宽度</td><td>00 00 01 67</td><td>0x167 = 359 像素</td></tr><tr><td>16~19</td><td>biHeight</td><td>位图高度</td><td>00 00 01 19</td><td>0x119 = 281 像素</td></tr><tr><td>1a~1b</td><td>biPlanes</td><td>平面数</td><td>00 01</td><td>0x1 = 1</td></tr><tr><td>1c~1d</td><td>biBitCount</td><td>颜色深度位数</td><td>00 18</td><td>0x18 = 24 bit/像素</td></tr><tr><td>1e~21</td><td>biCompression</td><td>压缩类型</td><td>00 00 00 00</td><td>0—不压缩，即BI_RGB格式</td></tr><tr><td>22~25</td><td>biSizeImage</td><td>图像大小 = 宽×高×色深</td><td>00 00 00 00</td><td>(按理说不应该是359×281×24吗 ? )</td></tr><tr><td>26~29</td><td>biXPelsPerMeter</td><td>水平分辨率（像素/米）</td><td>00 00 0e c3</td><td>0xec2 = 3779 像素</td></tr><tr><td>2a~2d</td><td>biYPelsPerMeter</td><td>垂直分辨率</td><td>00 00 0e c3</td><td>0xec2 = 3779 像素</td></tr><tr><td>2e~31</td><td>biClrUsed</td><td>调色板中颜色索引数</td><td>00 00 00 00</td><td>0—表示无调色板</td></tr><tr><td>32~35</td><td>biClrImportant</td><td>重要影响的颜色索引数</td><td>00 00 00 00</td><td>0—表示都重要</td></tr></tbody></table><h4 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h4><p>本例中，biBitCount=24、biClrUsed = 0，说明是24位真彩图，无调色板也无需调色板（4、8bit色深的才需要），位图信息头后面接的就是图像数据了；文件头14bytes、信息头40bytes，恰对应bfOddBites=54</p><hr><p>如果色深不是24bit而是4bit、8bit，无论4bit还是8bit都不能反映R、G、B共8bits×3=24bits的颜色信息，因此必须使用调色板。调色板中的数据每4bytes一组代表一种颜色，分别表示蓝、绿、红、保留值Alpha（表示透明度，在24位RGB位图中恒定为0），例如：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223134558.png" alt="image-20220223134558279" style="zoom:35%;" /><p>而每个像素具体使用调色板中哪个颜色，取决于颜色位值（以颜色位值作为调色板的数组索引来选择颜色）</p><ul><li><p>4bit色深</p><p>  4 bits/像素，说明一个像素有16种可能的颜色值而调色板中一种颜色对应 一组4bytes 数据，因此8bit色深图像的调色板大小为 16×4bytes = 64bytes</p></li><li><p>8bit色深</p><p>  8 bits/像素，说明一个像素有256种可能的颜色值，而调色板中一种颜色对应 一组4bytes 数据，因此8bit色深图像的调色板大小为 256×4bytes = 1024bytes</p></li><li><p>16比特色深</p><p>  这种格式叫作高彩色，或叫增强型16位色，或64K色；它的情况比较复杂：</p><p>  当biCompression成员的值是BI_RGB时没有调色板，16位中，最低的5位表示蓝色分量，中间的5位表示绿色分量，高的5位表示红色分量，一共占用了15位，最高的一位保留为0</p><p>  当biCompression成员的值是BI_BITFIELDS时，情况就复杂了，原来调色板的位置被三个DWORD变量占据，称为红、绿、蓝掩码。分别用于描述红、绿、蓝分量在16位中所占的位置</p></li></ul><h4 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h4><p>由于此图像是24位真彩图，没有调色板，所以信息头后直接就是图像数据</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223135634.png" alt="2" style="zoom:50%;" /><p>真彩图片每个像素都有24bits，即3bytes（R、G、B各1byte）；由于图片宽度为359像素，故每行有 359×3=1077bytes</p><p>但是要注意，Windows默认的扫描的最小单位是4字节，如果数据对齐满足这个值的话对于数据的获取速度等都是有很大的增益的。因此，BMP图像顺应了这个要求，要求每行的数据的长度必须是4的倍数，如果不够需要进行比特填充（以0填充），这样可以达到按行的快速存取。这样的话，位图数据的大小就不一定是宽x高x每像素字节数了，因为每行还可能有0填充</p><p>因此这张图片每行的大小应该是：1077 + 3 = 1080bytes（能被4整除）</p><h3 id="代码解析BMP位图信息"><a href="#代码解析BMP位图信息" class="headerlink" title="代码解析BMP位图信息"></a>代码解析BMP位图信息</h3><p>目前仅适用于24色真彩bmp图像的解析，4bit、8bit色深的图片反正同理，加一个调色板部分即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string message[<span class="number">15</span>] = &#123;<span class="string">&quot;type&quot;</span>, <span class="string">&quot;imgsize&quot;</span>, <span class="string">&quot;bfReserved1&amp;2&quot;</span>, <span class="string">&quot;bfOffBits&quot;</span>, <span class="string">&quot;biSize&quot;</span>, <span class="string">&quot;biWidth&quot;</span>, <span class="string">&quot;biHeight&quot;</span>, <span class="string">&quot;biPlanes&quot;</span>, <span class="string">&quot;biBitCount&quot;</span>, <span class="string">&quot;biCompression&quot;</span>, <span class="string">&quot;biSizeImage&quot;</span>, <span class="string">&quot;biXPelsPerMeter&quot;</span>, <span class="string">&quot;biYPelsPerMeter&quot;</span>, <span class="string">&quot;biClrUsed&quot;</span>, <span class="string">&quot;biClrImportant&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bmp_analysis</span><span class="params">(string filename, <span class="keyword">int</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">access</span>(filename.<span class="built_in">c_str</span>(), F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s not exist!\n&quot;</span>, filename.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *bmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bmp = <span class="built_in">fopen</span>(filename.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Something wrong when read %s!\n&quot;</span>, filename.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">0</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">2</span>, bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">1</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">2</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">3</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">4</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">5</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">6</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">7</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">short</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">8</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">short</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">9</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">10</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">11</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">12</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">13</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;result[<span class="number">14</span>], <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), bmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(bmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">    filename = <span class="string">&quot;派蒙.bmp&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">15</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">bmp_analysis</span>(filename, result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: %x\n&quot;</span>, message[i].<span class="built_in">c_str</span>(), result[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, message[i].<span class="built_in">c_str</span>(), result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上图测试输出为：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220223150412.png" alt="image-20220223150412147"></p><p>完全符合NotePad++中观察的结果</p><p>&nbsp;</p><h2 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>GIF格式的名称是Graphics Interchange Format的缩写，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的，可以被 PC 和 Mactiontosh 等多种平台上被支持。</p><p>GIF采用Lempel-Zev-Welch（LZW）压缩算法，最高支持256种颜色，因此适用于色彩较少的图片，比如卡通造型、公司标志等。如果碰到需要用真彩色的场合，那么GIF的表现力就有限了。</p><p>GIF通常会自带一个调色板，里面存放需要用到的各种颜色。在Web运用中，图像的文件量的大小将会明显地影响到下载的速度，因此可以根据GIF带调色板的特性来优化调色板，减少图像使用的颜色数（有些图像用不到的颜色可以舍去）而不影响图片质量。</p><p>GIF格式和其他图像格式的最大区别在于，它完全是作为一种公用标准而设计的，由于Compu Serve网络的流行，许多平台都支持GIF格式。</p><h3 id="文件结构-1"><a href="#文件结构-1" class="headerlink" title="文件结构"></a>文件结构</h3><p><a href="https://link.jianshu.com/?t=http://giflib.sourceforge.net/index.html">http://giflib.sourceforge.net/index.html</a>（科学.上网）是一个比较完整详细的GIF格式参考资料，其中有一张介绍GIF文件内部组成的图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224081432.png" alt="image-20220224081425494" style="zoom: 30%;" /><p>其中共有11个模块，有8块是GIF图像必备的：</p><ul><li><code>Header</code>：头</li><li><code>Logical Screen Descriptor</code>：逻辑屏幕描述符</li><li><code>Image Descriptor</code>：图像描述符</li><li><code>Image Data</code>：图像数据流</li><li><code>Plain Text Extension</code>：文本拓展</li><li><code>Application Extension</code>：应用拓展</li><li><code>Comment Extension</code>：注释拓展</li><li><code>Trailer</code>：尾部标记</li></ul><p>另外3个是可选块：</p><ul><li><code>Global Color Table</code>：全局颜色表</li><li><code>Graphic Control Extension</code>：图形控制拓展</li><li><code>Local Color Table</code>：本地颜色表</li></ul><p>传统GIF解码器正是通过上述模块来对GIF文件进行解析的</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>用 NotePad++ 的Hex插件打开 gif 图片：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224134302.gif" alt="小亮_zip" style="zoom:55%;" /><center>小亮.gif</center><p>截取部分数据如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224091520.png" alt="image-20220224091520240" style="zoom:40%;" /><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>GIF文件以Header开头，共包含6字节：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224092309.png" alt="image-20220224092309600" style="zoom: 50%;" /><ul><li>前三字节对应ASCII码中的：GIF 字符</li><li>后三字节对应版本号，目前有87a、89a两个</li></ul><hr><p>上例中为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224094909.png" alt="image-20220224094909721" style="zoom:50%;" /><p>对应 GIF_89a 版本</p><h4 id="Logical-Screen-Descriptor"><a href="#Logical-Screen-Descriptor" class="headerlink" title="Logical Screen Descriptor"></a>Logical Screen Descriptor</h4><p>逻辑描述符通常跟在Header后面，告知解码器此GIF图像的分辨率、背景色和Global Color Table等信息，组成如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224092753.png" alt="image-20220224092753640" style="zoom: 50%;" /><ul><li><code>Canvas Width</code>：GIF 图像的宽度（单位：像素）</li><li><code>Canvas Height</code>：GIF 图像的高度（单位：像素）</li><li><code>Packed Field</code>：包装字段，内部的不同 bit 各自含义如下<ol><li><code>Global Color Table Flag</code>（1bit）：1—有、0—无</li><li><code>Color Resolution</code>（3bit）：颜色位深度，Global Color Table 中的 颜色数 = <code>2^(Color Resolution + 1)</code>个，颜色位深度 = <code>Color Resolution + 1</code></li><li><code>Sort Flag</code>（1bit）：1—Global Color Table 按照出现频率降序排列、0—不排序</li><li><code>Size of Global Color Table</code>：Global Color Table 的颜色数，等于  <code>2^(Color Resolution + 1)</code></li></ol></li><li><code>Background Color Index</code>：GIF 背景色在 <code>Global Color Table</code> 中的索引</li><li><code>Pixel Aspect Retio</code>：表示用于计算原始图像中像素宽高比的近似因子，一般情况为 0</li></ul><hr><p>上例中为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224095014.png" alt="image-20220224095014732" style="zoom:50%;" /><p><code>Canvas Width</code> = 0x01b0 = 432 像素</p><p><code>Canvas Height</code> = 0x01b0 = 432 像素</p><p><code>Packed Field</code> = 0xf6 = 11110110</p><ul><li><code>Global Color Table Flag</code> = 1，说明存在 Global Color Table</li><li><code>Color Resolution</code> = 0b111 = 7，说明是 7+1 = 8 bit色深</li><li><code>Sort Flag</code> = 0，说明未排序</li><li><code>Size of Global Color Table</code> = 0b110 = 6，说明有2^(6+1) = 128</li></ul><p><code>Background Color Index</code> = 0，说明此 GIF 的背景色为 Global Color Table 中的第一个颜色</p><p><code>Pixel Aspect Ratio</code> = 0，忽略</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224100219.png" alt="image-20220224100219822" style="zoom:60%;" /><h4 id="Global-Color-Table"><a href="#Global-Color-Table" class="headerlink" title="Global Color Table"></a>Global Color Table</h4><p>如果 Global Color Table 存在，则会跟在 Logical Screen Descriptor 块后面。其块中的字节格式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224102424.png" alt="image-20220224102424444" style="zoom: 50%;" /><p>RGB三通道色彩的表示中，一种颜色由R、G、B三个部分组成，每个通道1byte，所以描述一个颜色需要 3×1=3 bytes。</p><p>上例中，由上面 <strong>Logical Screen Descriptor</strong> 中的信息可知有128种颜色，所以 <strong>Global Color Table</strong> 部分的长度为 128×3 = 384 bytes，对应下图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224105225.png" alt="image-20220224105225478" style="zoom:50%;" /><h4 id="Graphic-Control-Extension"><a href="#Graphic-Control-Extension" class="headerlink" title="Graphic Control Extension"></a>Graphic Control Extension</h4><p>看见 <strong>Global Color Table</strong> 后面紧跟的那个字节，从示例中可以看到的<code>21</code>，<code>21</code> 在 GIF 格式中是有特殊意义的，它表示 Extension Introducer（扩展入口），即接下来的一段数据为某一种扩展</p><p><code>21</code> 后的下一个字节是 <code>f9</code>，这也是一个标识符，代表这个拓展是 <strong>Graphics Control Extension</strong></p><p><strong>Graphics Control Extension</strong> 算上 <code>21</code> 和 <code>F9</code> 一共有8个字节，其结构如下图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224103752.png" alt="image-20220224103752657" style="zoom:45%;" /><ul><li><code>Byte Size</code>：表示接下来的有效数据字节数（不带结束位）</li><li><code>Packed Field</code>：包装字段，内部不同位的意义不同<ol><li>Reserved for Future Use（3bit）：保留位，暂无用处</li><li>Display Method（3bit）：表示逐帧渲染时，前一帧留下的图像作何处理：<ul><li>0：不做任何处理</li><li>1：保留前一帧图像，在此基础上进行渲染</li><li>2：渲染前将图像置为背景色</li><li>3：将被下一帧覆盖的图像重置</li></ul></li><li>User Input Flag（1bit）：表示是否需要在得到用户的输入时才进行下一帧的输入（具体用户输入指什么视应用而定）<ul><li>0——无需输入</li><li>1——需要输入</li></ul></li><li>Transparent Color Flag（1bit）：1—— Transparent Color Index 指定的颜色当做透明色处理、0 ——不做处理</li></ol></li><li><code>Delay Time</code>：表示 GIF 动图每一帧之间的间隔，单位为百分之一秒；为 0 时，间隔由解码器管理</li><li><code>Transparent Color Index</code>：为1时有效，此索引在 Global Color Table 中对应的颜色将当做透明色处理</li><li><code>Block Terminator</code>：Extension 的结束位</li></ul><hr><p>上例中为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224105155.png" alt="image-20220224105155048" style="zoom:50%;" /><ul><li><code>21 f9</code> 表示这是一个 Graphic Control Extension 模块</li><li><code>Bytes Size</code> = 4，有效长度为 4 bytes</li><li><code>Packed Field</code> = 00000100<ol><li><code>Reserved for Future Use</code> = 0</li><li><code>Display Method</code> = 1，表示逐帧渲染时，保留前一帧图像，在此基础上进行渲染</li><li><code>User Input Flag</code> = 0，下一帧的输入不需要得到用户的输入</li><li><code>Transparent Color Flag</code> = 0，Transparent Color Index 指定的颜色不做处理</li></ol></li><li><code>Delay Time</code> = 0x000a = 10ms</li><li><code>Transparent Color Index</code> = 0xff = 255，无效，没有需要做透明处理的颜色值</li><li><code>Block Terminator</code> = 00，结束位</li></ul><h4 id="Image-Descriptor"><a href="#Image-Descriptor" class="headerlink" title="Image Descriptor"></a>Image Descriptor</h4><p><strong>Image Descriptor</strong> 的标识符（Image Seperator）是 <code>2c</code>，内部字节结构为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224110217.png" alt="image-20220224110217363" style="zoom:45%;" /><ul><li><code>Image Left</code>：下一帧图像渲染位置离画布左边的距离（从 0 开始）</li><li><code>Image Top</code>：下一帧图像渲染位置离画布上边的距离（从 0 开始）</li><li><code>Image Width</code>：下一帧图像的宽度</li><li><code>Image Height</code>：下一帧图像的高度</li><li><code>Packed Field</code>：包装字段，内部不同位的意义不同<ol><li><code>Local Color Table Flag</code>（1bit）：下一帧图像是否需要一个独立的颜色表，1—需要、0—不需要</li><li><code>Interlace Flag</code>（1bit）：是否需要隔行扫描，1—需要，0—不需要</li><li><code>Sort Flag</code>（1bit）：如果需要 Local Color Table 的话，这个字段表示其排列顺序</li><li><code>Reserved For Future Use</code>（2bit）：保留位，不用管</li><li><code>Size of Local Color Table</code>（3bit）：同 Global Color Table 中的该位。如需要本地颜色表，则该数有效</li></ol></li></ul><hr><p>上例中为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224140502.png" alt="image-20220224140502887" style="zoom:50%;" /><ul><li><code>2c</code> 为标志位，表示这是一个 Image Descriptor 模块</li><li><code>Image Left</code> = 0</li><li><code>Image Top</code> = 0</li><li><code>Image Width</code> = 0x01b0 = 432</li><li><code>Image Height</code> = 0x01b0 = 432</li><li><code>Packed Field</code> = 0b0000_0000</li></ul><p>以上参数说明渲染的一帧大小为 432*432 像素，正好与 GIF 图的分辨率一致。打包字段都为零，表示下一帧不需要 Local Color Table，也不需要进行隔行扫描</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224100219.png" alt="image-20220224100219822" style="zoom:60%;" /><h4 id="Local-Color-Table"><a href="#Local-Color-Table" class="headerlink" title="Local Color Table"></a>Local Color Table</h4><p>同 Global Color Table 处理类似，上例中未使用</p><h4 id="Image-Data"><a href="#Image-Data" class="headerlink" title="Image Data"></a>Image Data</h4><p>如果存在 <strong>Local Color Table</strong>，<strong>Image Data</strong> 就紧跟其后。如若不存在，则紧跟在 <strong>Image Descriptor</strong> 后。<strong>Image Data</strong> 的内部字节组成如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224141058.png" alt="image-20220224141058449" style="zoom:50%;" /><ul><li><code>LZW Minimum Code Size</code>：GIF 在对每一帧的像素颜色在 Color Table 所对应的索引进行 LZW 压缩，这里的 LZW Minimum Code Size 是 LZW 压缩中很关键的一个值</li><li><code>Number of bytes of data in sun-blocks</code>：后面的有效字节的个数，范围为 01-FF。为 0则表示 Image Data 到此为止。由于其最大值为 FF，但图像像素数可能会大于这个值，所以从图上也能知道这个 Data sub-Blocks有可能接连出现很多个</li><li><code>Data Sub-Block(s)</code>：有效的字节块</li><li><code>Block Terminator</code>：结束符</li></ul><hr><p>上例中为：（部分截图）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224142409.png" alt="image-20220224142409004" style="zoom:50%;" /><ul><li><code>LZW Minimum Code Size</code> = 0x07</li><li><code>Number of bytes of data in sun-blocks</code> = 0xff，显然这里数据量很大</li></ul><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>GIF图像的结束符是 <code>3b</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220224143410.png" alt="image-20220224143410679" style="zoom:50%;" /><p>后面就是 <strong>Plain Text Extension</strong>、<strong>Application Extension</strong> 和 <strong>Comment Extension</strong> 可选三种拓展</p><h3 id="GIF-压缩"><a href="#GIF-压缩" class="headerlink" title="GIF 压缩"></a>GIF 压缩</h3><p>方法一：在线工具 <a href="https://docsmall.com/gif-compress">docsmall</a></p><p>方法二：自己写个脚本（通过抽帧实现）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> filename</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;小亮.gif&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AnalysisGif</span>(<span class="params">gifPath</span>):</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(gifPath)</span><br><span class="line">    pngDir = gifPath[:-<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(pngDir):</span><br><span class="line">        files = os.listdir(pngDir)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            file = pngDir + <span class="string">&quot;/&quot;</span> + file</span><br><span class="line">            os.remove(file)</span><br><span class="line">        os.rmdir(pngDir)</span><br><span class="line"></span><br><span class="line">    os.mkdir(pngDir)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            current = image.tell()</span><br><span class="line">            pngPath = pngDir+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(current)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">            image.save(pngPath, quality=<span class="number">100</span>)</span><br><span class="line">            image.seek(current+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="built_in">print</span>(EOFError)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Combine2Gif</span>(<span class="params">folderPath, gifFilePath</span>):</span></span><br><span class="line">    files = os.listdir(folderPath)</span><br><span class="line">    pngFiles = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(files), <span class="number">5</span>):</span><br><span class="line">        pngFiles.append(folderPath + <span class="string">&quot;/&quot;</span> + (<span class="string">&#x27;%d.png&#x27;</span> % i))</span><br><span class="line"></span><br><span class="line">    GenerateGif(<span class="number">0.15</span>, gifFilePath, pngFiles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenerateGif</span>(<span class="params">step, gifPath, filterPngs</span>):</span></span><br><span class="line">    images = []</span><br><span class="line">    <span class="keyword">for</span> filePath <span class="keyword">in</span> filterPngs:</span><br><span class="line">        images.append(imageio.imread(filePath))</span><br><span class="line">    imageio.mimsave(gifPath, images, duration=step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    gifPath = filename</span><br><span class="line">    AnalysisGif(gifPath)</span><br><span class="line">    Combine2Gif(gifPath[:-<span class="number">4</span>], gifPath[:-<span class="number">4</span>]+<span class="string">&quot;_zip.gif&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;== finished ==&quot;</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="TIFF格式"><a href="#TIFF格式" class="headerlink" title="TIFF格式"></a>TIFF格式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>TIFF （Tagged Image File Format）一种灵活的位图格式，主要用来存储包括照片和艺术图在内的图像。TIFF 与其他文件格式最大的不同在于，除了图像数据，它还可以记录图像的很多其他信息。理论上，任何其他格式的图像都能为 TIFF 所用，嵌入到 TIFF 中。</p><h3 id="文件结构-2"><a href="#文件结构-2" class="headerlink" title="文件结构"></a>文件结构</h3><p>TIFF 文件由4部分组成：图像文件头Image File Header（IFH）、图像文件目录Image File Directory（IFD）、目录项Directory Entry（DE）、图像数据Image Data。</p><p>每一幅图像都是以8字节的 IFH 开始的，IFH 指向第一个 IFD，IFD 包含了图像的各种信息，同时也包含了一个指向实际图像数据的指针。</p><h4 id="IFH"><a href="#IFH" class="headerlink" title="IFH"></a>IFH</h4><table><thead><tr><th>名称</th><th>字节数</th><th>数据类型</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>Byteorder</td><td>2</td><td>short</td><td>TIF 标记</td><td>4D4D—大字节序<br/>4949—小字节序</td></tr><tr><td>Version</td><td>2</td><td>short</td><td>版本号</td><td>恒为：2A00或002A</td></tr><tr><td>Offset to first IFD</td><td>4</td><td>int</td><td>第一个 IFD 的偏移量</td><td>IFD常位于图像数据的后面，<br/>所以需要记录IFH到第一个IFD的偏移量<br/>但必须在一个word的边界，即4的整数倍</td></tr></tbody></table><h4 id="IFD"><a href="#IFD" class="headerlink" title="IFD"></a>IFD</h4><table><thead><tr><th>名称</th><th>字节数</th><th>数据类型</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>Directory Entry Count</td><td>2</td><td>short</td><td>此 IFD 中 DE 的数量</td><td>——</td></tr><tr><td>Directory Entry (1)</td><td>12</td><td>——</td><td>目录项</td><td>具体结构见下面</td></tr><tr><td>Directory Entry (2)</td><td>12</td><td>——</td><td>……</td><td>……</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>Directory Entry (n)</td><td>12</td><td>——</td><td>……</td><td>……</td></tr><tr><td>Offset to next IFD</td><td>4</td><td>int</td><td>距离下一个 IFD 的偏移量</td><td>类似于链表中的下一指针</td></tr></tbody></table><h4 id="DE"><a href="#DE" class="headerlink" title="DE"></a>DE</h4><p>DE 的 TagID 代表此项的含义，valueOffset是此项实际值在文件中的偏移量（即此 TagID 项的内容并未保存在 DE 中，必须通过 DE 中的偏移量在文件中寻找）</p><table><thead><tr><th>名称</th><th>字节数</th><th>数据类型</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>TagID</td><td>2</td><td>short</td><td>本属性的标签编号</td><td>按照升序排列的（但不一定是连续的）<br/>详见 [TagID 说明](#TagID 说明)</td></tr><tr><td>type</td><td>2</td><td>short</td><td>本属性值的数据类型</td><td>官方指定的有5种数据类型<br/>( 但也有说12种数据类型的 )<br/>详见 [type 说明](#type 说明)</td></tr><tr><td>length</td><td>4</td><td>int</td><td>该类型数据的数量</td><td>注意数量<strong>不是长度</strong></td></tr><tr><td>valueOffset</td><td>4</td><td>int</td><td>属性值的存放偏移量</td><td>tagID 代表的变量值相对文件开始处的偏移量</td></tr></tbody></table><h5 id="TagID-说明"><a href="#TagID-说明" class="headerlink" title="TagID 说明"></a>TagID 说明</h5><table><thead><tr><th>TagID</th><th>属性名称</th><th>type</th><th>说明</th></tr></thead><tbody><tr><td>0100</td><td>图像宽</td><td>0003</td><td>——</td></tr><tr><td>0101</td><td>图像高</td><td>0003</td><td>——</td></tr><tr><td>0102</td><td>颜色深度</td><td>0003</td><td>值＝1为单色、＝4为16色、＝8为256色<br/>如果该类型数据个数＞2个，说明是真彩图像</td></tr><tr><td>0103</td><td>是否压缩</td><td>0003</td><td>值＝05表示压缩</td></tr><tr><td>0106</td><td>是否采用反色显示</td><td>0003</td><td>值＝01表示反色，否则表示不反色</td></tr><tr><td>0111</td><td>图像扫描线偏移量</td><td>0004</td><td>图像数据起始字节相对于文件开始处的位置</td></tr><tr><td>0116</td><td>图像扫描线的数量</td><td>0004</td><td>表示图像有几行扫描线，实际上等于图像高度</td></tr><tr><td>0117</td><td>图像数据字节总数</td><td>0003</td><td>如果不是偶数，那么实际存放时会在后面加0</td></tr><tr><td>011A</td><td>水平分辩率偏移量</td><td>0005</td><td>常用计量单位是：像素/英寸</td></tr><tr><td>011B</td><td>垂直分辩率偏移量</td><td>0005</td><td>常用计量单位是：像素/英寸</td></tr><tr><td>0131</td><td>生成该图像的软件名</td><td>0002</td><td>文本类型</td></tr><tr><td>0132</td><td>生成该图像的时间</td><td>0002</td><td>文本类型</td></tr><tr><td>0140</td><td>调色板偏移量</td><td>0003</td><td>256色和16色图像才有此属性，而且有连续2个<br/>调色板，但属性的length值只表示出1个调色板</td></tr></tbody></table><p>完整说明见：<a href="https://www.awaresystems.be/imaging/tiff/tifftags/baseline.html">Baseline TIFF Tags</a></p><h5 id="type-说明"><a href="#type-说明" class="headerlink" title="type 说明"></a>type 说明</h5><table><thead><tr><th>type值</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>0001</td><td>Byte</td><td>——</td></tr><tr><td>0002</td><td>Ascii</td><td>文本类型，7位Ascii码加1位二进制0</td></tr><tr><td>0003</td><td>Integer</td><td>——</td></tr><tr><td>0004</td><td>Long</td><td>——</td></tr><tr><td>0005</td><td>RATIONAL</td><td>分数类型，由两个Long组成，第1个是分子，第2个是分母</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>用 NotePad++ 的Hex插件打开 tif 图片：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226161825.png" alt="image-20220226161825837" style="zoom: 35%;" /><center>温迪.tif</center><p>截取部分数据如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226162145.png" alt="image-20220226162145096" style="zoom:40%;" /><h4 id="IFH-1"><a href="#IFH-1" class="headerlink" title="IFH"></a>IFH</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226162352.png" alt="image-20220226162352057" style="zoom:50%;" /><table><thead><tr><th>名称</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td>Byteorder</td><td>0x4949</td><td>存储方式为小字节序</td></tr><tr><td>Version</td><td>0x002a</td><td>版本号</td></tr><tr><td>Offset to first IFD</td><td>0x0006f4d0 =</td><td>第一个IFD的偏移量为455888</td></tr></tbody></table><h4 id="IFD-1"><a href="#IFD-1" class="headerlink" title="IFD"></a>IFD</h4><p>第一个 IFD：（0006f4d0开始）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226164530.png" alt="image-20220226164530189" style="zoom:50%;" /><p>从第一位可知，此 IFD 包含 0x10 = 16 个DE，而每个 DE 长度为 12，故一共长 12×16=172。加上Directory Entry Count占用的2字节，再加上Offset to next IFD占用的4字节，此 IFD一共长为 1+172+2+4=179</p><table><thead><tr><th>名称</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td>Directory Entry Count</td><td>0x10 = 16</td><td>此IFD含16个DE</td></tr><tr><td>Directory Entry (1)</td><td>——</td><td>——</td></tr><tr><td>Directory Entry (2)</td><td>——</td><td>——</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>Directory Entry (16)</td><td>——</td><td>——</td></tr><tr><td>Offset to next IFD0</td><td>00000000</td><td>此图像文件只有1个IFD</td></tr></tbody></table><h4 id="DE-1"><a href="#DE-1" class="headerlink" title="DE"></a>DE</h4><table><thead><tr><th>序号</th><th>偏移量</th><th>取值</th><th>TagID</th><th>Type</th><th>length</th><th>valueOffset</th><th>按偏移量查询为：</th></tr></thead><tbody><tr><td>1</td><td>0006f4d2</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170611.png" alt="image-20220226170611614"></td><td>0x00fe<br/>(NewSubfileType)</td><td>long</td><td>0x1</td><td>0</td><td></td></tr><tr><td>2</td><td>0006f4de</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170702.png" alt="image-20220226170702215"></td><td>0x0100<br/>(图像宽)</td><td>long</td><td>0x1</td><td>0x01dd</td><td>224</td></tr><tr><td>3</td><td>0006f4ea</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170720.png" alt="image-20220226170720041"></td><td>0x0101<br/>(图像高)</td><td>long</td><td>0x1</td><td>0x01d7</td><td>184</td></tr><tr><td>4</td><td>0006f4f6</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170735.png" alt="image-20220226170735417"></td><td>0x0102<br/>(颜色深度)</td><td>int</td><td>0x4</td><td>0x6f596</td><td>下略</td></tr><tr><td>5</td><td>0006f502</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170752.png" alt="image-20220226170752786"></td><td>0x0103<br/>(是否压缩)</td><td>int</td><td>0x1</td><td>0x5</td><td></td></tr><tr><td>6</td><td>0006f50e</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226170900.png" alt="image-20220226170900430"></td><td>0x0106<br/>(是否采用反色)</td><td>int</td><td>0x1</td><td>0x2</td><td></td></tr><tr><td>7</td><td>0006f51a</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171830.png" alt="image-20220226171830444"></td><td>0x0111<br/>(扫描线偏移量)</td><td>long</td><td>0x4f</td><td>0x159e</td><td></td></tr><tr><td>8</td><td>0006f526</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171843.png" alt="image-20220226171843586"></td><td>0x0115<br/>(每像素样本数)</td><td>int</td><td>0x1</td><td>0x4</td><td></td></tr><tr><td>9</td><td>0006f532</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171855.png" alt="image-20220226171855427"></td><td>0x0116<br/>(扫描线数量)</td><td>long</td><td>0x1</td><td>0x6</td><td></td></tr><tr><td>10</td><td>0006f53e</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171907.png" alt="image-20220226171907173"></td><td>0x0117<br/>(图像数据字节数)</td><td>long</td><td>0x4f</td><td>0x6f6da</td><td></td></tr><tr><td>11</td><td>0006f54a</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171920.png" alt="image-20220226171920413"></td><td>0x011a<br/>(水平分辨率偏移量)</td><td>RATIONAL</td><td>0x1</td><td>0x6f816</td><td></td></tr><tr><td>12</td><td>0006f556</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171939.png" alt="image-20220226171939044"></td><td>0x011b<br/>(垂直分辨率偏移量)</td><td>RATIONAL</td><td>0x1</td><td>0x6f81e</td><td></td></tr><tr><td>13</td><td>0006f562</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226171954.png" alt="image-20220226171954724"></td><td>0x011c<br/>(平面配置)</td><td>int</td><td>0x1</td><td>0x1</td><td></td></tr><tr><td>14</td><td>0006f56e</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226172005.png" alt="image-20220226172005765"></td><td>0x0128<br/>(分辨率单位)</td><td>int</td><td>0x1</td><td>0x2</td><td></td></tr><tr><td>15</td><td>0006f57a</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226172016.png" alt="image-20220226172016469"></td><td>0x013d<br/>(不知道)</td><td>int</td><td>0x1</td><td>0x2</td><td></td></tr><tr><td>16</td><td>0006f586</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220226172027.png" alt="image-20220226172027469"></td><td>0x0152<br/>(额外成分)</td><td>int</td><td>0x1</td><td>0x2</td><td></td></tr></tbody></table><p>&nbsp;</p><h2 id="RAW格式"><a href="#RAW格式" class="headerlink" title="RAW格式"></a>RAW格式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>RAW 图像就是 CMOS 或者 CCD 图像感应器 sensor 将捕捉到的光源信号转化为数字信号的原始数据，表示sensor接受 到的各种光的强度。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如 ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>RAW文件几乎是未经过处理而直接从CCD或CMOS上得到的信息，通过后期处理，摄影师能够最大限度地发挥自己的艺术才华</li><li>RAW文件并没有白平衡设置，但是真实的数据也没有被改变，就是说作者可以任意的调整色温和白平衡，并且是不会有图像质量损失的</li><li>虽然RAW文件附有饱和度、对比度等标记信息，但是其真实的图像数据并没有改变。用户可以自由地对某一张图片进行个性化的调整，而不必基于一、两种预先设定好的模式</li><li>RAW最大的优点就是可以将其转化为16位的图像，也就是有65536个层次可以被调整，这在需要对阴影区或高光区进行重要调整的时候非常有用</li></ul><h3 id="格式解析"><a href="#格式解析" class="headerlink" title="格式解析"></a>格式解析</h3><p>Raw 格式是 sensor 的输出格式，是未经处理过的数据，表示sensor接受到的各种光的强度；<br>Raw 数据在输出的时候是有一定的顺序的，一般为以下四种：</p><ul><li>00：GR/BG</li><li>01：RG/GB</li><li>10：BG/GR</li><li>11：GB/RG</li></ul><p>每种情况里都有两个 G 分量，因为人眼对绿色敏感，所以增加了对绿色的采样。其中每个分量代表一个piexl。所以 GR/BG 就代表四个 piexl，在物理 sensor 上就表示4个晶体管，一个晶体管只采样一个颜色分量，然后通过插值计算得到每个 piexl，这样做的主要目的是降低功耗。<br>sensor 输出的数据一般要送到 ISP 中处理才会得到一个好的效果，这就需要 ISP 知道 sensor 输出的 raw 数据的顺序与大小，其中顺序一般通过配置 ISP 的 pattern 寄存器来实现，大小一般配置在 ISP 的输入格式控制寄存器中。</p><p><strong>RAW 的常用格式</strong></p><ul><li>RAW8</li></ul><p>​    用 8bits 表示 G/R/B/G 中的一个分量，而不是使用 8bits 表示 RG/GB 四个分量。在 sensor 中，为了降低功耗，使用一个晶体来表示一种颜色，然后利用差值计算出相邻像素的值。</p><ul><li>Raw10</li></ul><p>​    使用 10bit 表示上述的一个 G/R/B/G，但是数据中是16bit 的，高6位没用。</p><ul><li>Raw12</li></ul><p>​    使用 12bit 表示上述的一个 G/R/B/G，但是数据中是 16bit 的，高4位没用。</p><h3 id="不同相机的RAW格式拓展名"><a href="#不同相机的RAW格式拓展名" class="headerlink" title="不同相机的RAW格式拓展名"></a>不同相机的RAW格式拓展名</h3><p>不同的相机产生的RAW文件的扩展名一般不同：</p><table><thead><tr><th>品牌</th><th>拓展名</th></tr></thead><tbody><tr><td>富士</td><td>*.raf</td></tr><tr><td>佳能</td><td><em>.crw，</em>.cr2,*.cr3</td></tr><tr><td>柯达</td><td>*.kdc</td></tr><tr><td>美能达</td><td>*.mrw</td></tr><tr><td>尼康</td><td>*.nef</td></tr><tr><td>奥林巴斯</td><td>*.orf</td></tr><tr><td>adobe</td><td>*.dng</td></tr><tr><td>宾得</td><td><em>.ptx，</em>.pef</td></tr><tr><td>索尼</td><td>*.arw</td></tr><tr><td>适马</td><td>*.x3f</td></tr><tr><td>松下</td><td>*.rw2</td></tr></tbody></table><p>&nbsp;</p><h2 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>PNG 是20世纪90年代中期开始开发的图像文件存储格式，其目的是替代 GIF 和 TIFF 文件格式，同时增加一些 GIF 文件格式所不具备的特性。流式网络图形格式 (Portable Network Graphic Format，PNG) 名称来源于非官方的“PNG’s Not GIF”，是一种位图文件 (bitmap file) 存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的 α 通道数据。PNG 使用从 LZ77 派生的<strong>无损</strong>数据压缩算法。（说白了这就是一种方便的、适于网络传播的轻便图片文件格式）</p><p><strong>特性</strong></p><ol><li>使用调色板技术可支持256种颜色的彩色图像（必须的）</li><li>流式读/写性(streamability)：图像文件格式允许连续读出和写入图像数据（因此适于网络传播）</li><li>逐次逼近显示(progressive display)：这种特性可使在通信链路上传输图像文件的同时就在终端上显示图像，把整个轮廓显示出来之后逐步显示图像的细节，也就是先用低分辨率显示图像，然后逐步提高它的分辨率（类似马赛克逐渐消除的过程）</li><li>透明性(transparency)：这个性能可使图像中某些部分不显示出来，用来创建一些有特色的图像</li><li>辅助信息(ancillary information)：这个特性可用来在图像文件中存储一些文本注释信息（就是可以说一些废话）</li><li>独立于计算机软硬件环境</li><li>使用无损压缩（无损！）</li><li>可在一个文件中存储多幅图像</li></ol><h3 id="文件结构-3"><a href="#文件结构-3" class="headerlink" title="文件结构"></a>文件结构</h3><p>PNG 文件由文件署名域（8字节）和最少3个数据块（Chunk）按照特定的顺序排列而成</p><p>数据块分为两类：</p><ul><li>关键数据块（Critical Chunk）：必须包含的数据块。一个有效的PNG文件必须包含一个IHDR块、至少一个IDAT块和一个IEND块</li><li>辅助数据块（Ancillary Chunk）：可选的数据块。也就是说，编码器并不必须写入辅助数据块，解码器也可以选择忽略它们，但鼓励编码器在有相关数据时写入标准的辅助数据块、解码器在可行的条件下对这些内容进行解码</li></ul><p>数据快组成如下：</p><table><thead><tr><th>名称</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>Length</td><td>4</td><td>指定数据块中数据域的长度，其长度不超过(231−1)(231−1)字节</td></tr><tr><td>Chunk Type Code（类型码）</td><td>4</td><td>数据块类型码由ASCII字母(A-Z和a-z)组成</td></tr><tr><td>Chunk Data（数据块实际内容）</td><td>可变</td><td>存储按照Chunk Type Code指定的数据</td></tr><tr><td>CRC（循环冗余校验）</td><td>4</td><td>存储用来检测是否有错误的循环冗余码</td></tr></tbody></table><h4 id="文件署名域"><a href="#文件署名域" class="headerlink" title="文件署名域"></a>文件署名域</h4><p>PNG 文件开头8个字节是其署名域，代表其文件类型，通常是：<code>89 50 4E 47 0D 0A 1A 0A</code></p><p>事实上，大部分格式的文件都是通过头部的文件头标识（十六进制）来识别的，靠拓展名有时未必可靠，常见文件头有：</p><table><thead><tr><th>拓展名</th><th>文件头标识</th></tr></thead><tbody><tr><td>7z</td><td>37 7A BC AF 27 1C</td></tr><tr><td>avi</td><td>41 56 49 20</td></tr><tr><td>bmp</td><td>42 4D</td></tr><tr><td>doc</td><td>0D 44 4F 43 (doc的文件头标识不唯一)</td></tr><tr><td>gif</td><td>47 49 46 38 37 61</td></tr><tr><td>html</td><td>68 74 6D 6C 3E</td></tr><tr><td>img</td><td>00 01 00 08 00 01 00 01 01</td></tr><tr><td>jpg</td><td>FF D8 FF</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><h4 id="关键数据块"><a href="#关键数据块" class="headerlink" title="关键数据块"></a>关键数据块</h4><p>关键数据块中包含4个标准数据块：IHDR、PLTE、IDAT、IEND</p><p><strong>文件头数据块 IHDR chunk</strong></p><p>包含 PNG 文件中存储的图像数据的基本信息，并要作为第一个数据块出现在 PNG 数据流中，一个 PNG 数据流中只能有一个文件头数据块。Chunk Data部分共13字节，组成结构如下：</p><table><thead><tr><th>域的名称</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>Width</td><td>4</td><td>图像宽度，以像素为单位</td></tr><tr><td>Height</td><td>4</td><td>图像高度，以像素为单位</td></tr><tr><td>Bit depth</td><td>1</td><td>图像深度：表示每个采样点占用的bit数<br/>索引彩色图像：1，2，4，8<br/>灰度图像：1，2，4，8，16 <br/>真彩色图像：8，16</td></tr><tr><td>ColorType</td><td>1</td><td>颜色类型：<br/>0：灰度图像，深度为：1，2，4，8，16<br/>2：真彩色图像，深度为：8，16<br/>3：索引彩色图像，深度为：1，2，4，8<br/>4：带α通道数据的灰度图像，深度为：8，16<br/>6：带α通道数据的真彩色图像，深度为：8，16</td></tr><tr><td>Compression method</td><td>1</td><td>压缩方法：<br/>0：LZ77派生算法（目前仅定义了0）<br/>其他值：无效；为未来扩展的压缩方法预留</td></tr><tr><td>Filter method</td><td>1</td><td>滤波器方法：<br/>0（目前仅定义了0）<br/>其他值：无效</td></tr><tr><td>Interlace method</td><td>1</td><td>隔行扫描方法：<br/>0——非隔行扫描<br/>1——Adam7 (由Adam M. Costello开发的7遍隔行扫描方法)</td></tr></tbody></table><p>带上Length、Chunk Type Code和最后的CRC部分，文件头数据块长度为：4+4+13+4 = 25 bytes</p><p><strong>调色板数据块 PLTE chunk</strong></p><p>调色板包含有与索引彩色图像 (indexed-color image) 相关的彩色变换数据，仅与索引彩色图像有关。位置在图像数据块 (image data chunk) 之前。真彩色的 PNG 数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。结构如下：</p><table><thead><tr><th>颜色</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>Red</td><td>1</td><td>0——黑，255——红</td></tr><tr><td>Green</td><td>1</td><td>0——黑，255——绿</td></tr><tr><td>Blue</td><td>1</td><td>0——黑，255——蓝</td></tr></tbody></table><p>调色板的作用在于，使得图像深度较小的图像，可以使用索引号来正确表示颜色</p><p>PLTE块还必需满足以下限制条件，否则会被判定为不合法：</p><ul><li><p>调色板的长度应为3的倍数，即PLTE块最大字节数为256 × 3 = 768 B</p></li><li><p>调色板信息的数量不能超过图像深度可以表示的范围（如对于4 bit深度的图像，最多有16条调色板信息，但允许少于16条）</p></li><li><p>对于Colour type 3的PNG图像（索引图像），PLTE块是必需的，此时调色板的颜色索引从0开始编号，然后是1，2……</p></li><li><p>对于Colour type为2和6的图像，PLTE块是可选的，此时调色板将提供一个1—256的建议颜色集，以便软件或屏幕不支持显示真彩色时量化真彩色图像</p></li><li><p>Colour type为0和4的图像中不能出现PLTE块</p></li></ul><p><strong>图像数据块 IDAT chunk</strong></p><p>IDAT块包含实际的图像数据。此外：</p><ul><li>允许编码器根据需要将压缩的数据流分为多个IDAT块，但它们必须连续出现</li><li>并不限定IDAT块的大小，但过短的IDAT块会浪费更多空间</li><li>IDAT块可以出现在压缩数据流的任何位置</li></ul><p><strong>图像结束数据 IEND chunk</strong></p><p>IEND块必需出现在文件的末尾，用来标志PNG数据流的结束，通常是：<code>00 00 00 00 49 45 4E 44 AE 42 60 82</code></p><h4 id="辅助数据块"><a href="#辅助数据块" class="headerlink" title="辅助数据块"></a>辅助数据块</h4><p>辅助数据块主要包含以下4类、14种：</p><ul><li><p>表示透明信息（Transparency information）的数据块：</p><ul><li>tRNS chunk（Transparency chunk，透明信息数据块）</li></ul></li><li><p>表示色彩空间信息（Colour space information）的数据块：</p><ul><li><p>gAMA chunk（Image gamma chunk，图像γ数据块）</p></li><li><p>cHRM chunk（Primary chromaticities chunk，基色和白色度数据块）</p></li><li><p>sRGB chunk（Standard RGB colour space chunk，标准RGB色彩空间数据块）</p></li><li><p>iCCP chunk（Embedded ICC profile chunk）</p></li></ul></li><li><p>表示文本信息（Textual information）的数据块：</p><ul><li>tEXt chunk（Textual data chunk，文本信息数据块）</li></ul></li></ul><pre><code>- zTXt chunk（Compressed textual data chunk，压缩文本数据块）- iTXt chunk（International textual data chunk）</code></pre><ul><li><p>表示其他信息（Miscellaneous information）的数据块：</p><ul><li><p>bKGD chunk（Background colour chunk，背景颜色数据块）</p></li><li><p>pHYs chunk（Physical pixel dimensions chunk，物理像素尺寸数据块）</p></li><li><p>sBIT chunk（Significant bits chunk，样本有效位数据块）</p></li><li><p>sPLT chunk（Suggested palette chunk）</p></li><li><p>hIST chunk（Palette histogram chunk，图像直方图数据块）</p></li><li><p>tIME chunk（Image last-modification time chunk，图像最后修改时间数据块）</p></li></ul></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>用 NotePad++ 的Hex插件打开 tif 图片：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301135042.png" alt="刻晴" style="zoom: 33%;" /><center>刻晴.png</center><p>截取部分数据如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301135026.png" alt="image-20220301135026697" style="zoom:40%;" /><h4 id="文件署名域-1"><a href="#文件署名域-1" class="headerlink" title="文件署名域"></a>文件署名域</h4><p>可以看见，就是 <code>89 50 4E 47 0D 0A 1A 0A</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301135153.png" alt="image-20220301135153394" style="zoom:50%;" /><h4 id="关键数据块-1"><a href="#关键数据块-1" class="headerlink" title="关键数据块"></a>关键数据块</h4><p><strong>IHDR</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301135623.png" alt="image-20220301135623598" style="zoom:50%;" /><ul><li>Length：0x0000000d = 13</li><li>Chunk type code：0x49484452（ASCII码：“IHDR”）</li><li>Chunk data<ul><li>Width：0x000001f2 = 498（像素）</li><li>Height：0x0000021a = 538（像素）</li><li>Bit depth：0x8，8bit色深</li><li>Color type：0x6，表示带α通道数据的真彩色图像</li><li>Compression method：0，LZ77派生算法</li><li>Filter method：0</li><li>Interlace method：0，非隔行扫描</li></ul></li><li>CRC：<code>db 6e cf a2</code></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301140002.png" alt="image-20220301140002869" style="zoom:50%;" /><p><strong>PLTE</strong></p><p>PLTE chunk 的 type code 是 <code>0x50 4C 54 45</code>，因为本例是 Color type=0x6 （真彩色图像，调色板可有可没有），这里没有PLTE</p><p><strong>IDAT</strong></p><p>略</p><p><strong>IEND</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220301142345.png" alt="image-20220301142345205" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于动态令牌桶的实时应用准入控制算法</title>
      <link href="/2022/02/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%9A%84%E5%AE%9E%E6%97%B6%E5%BA%94%E7%94%A8%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/02/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%9A%84%E5%AE%9E%E6%97%B6%E5%BA%94%E7%94%A8%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;现有分组交换网络（例如 Internet）的“尽力而为”服务质量（QoS）不能很好地支持来自交互式实时网络应用程序的数据连续传输。为了提供 QoS 支持，准入控制机制必须确保一个新的数据流能获得其请求的 QoS，同时不会影响其他已经存在于网络中的数据流的 QoS。</p><p>&emsp;&emsp;当前的准入控制方法通常是基于参数或基于测量的 [1]。基于参数的方法取决于先验的交通特征，缺点是无法预先准确地表征大量突发流量。基于测量的方法 [1-4] 侧重于为可以容忍某些 QoS 恶化的实时应用程序实现更高的资源利用率，基于实际交通量的测量值。因此，基于测量的准入控制过程能够更好地利用可用于实时流量的带宽。</p><p>&emsp;&emsp;文章提出了基于测量的准入控制方案，根据观察到的实时流量源的QoS 要求和其他性能指标的不同组合，调整 r 和 b 来处理网络条件的变化。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Adaptive%20resource%20negotiation%20based%20control%20for%20real%20time%20applications.pdf">Adaptive resource negotiation based control for real time applications</a></p><span id="more"></span><p>&nbsp;</p><h2 id="Token-Bucket-模型反映流量特征"><a href="#Token-Bucket-模型反映流量特征" class="headerlink" title="Token Bucket 模型反映流量特征"></a>Token Bucket 模型反映流量特征</h2><p>&emsp;&emsp;文章提出的准入控制算法中，每个数据源的流量特征用token bucket模型来描述，具体就是用参数 <code>(r ，b)</code> 来描述，其中 <code>r</code> 是令牌生成速率、<code>b</code> 是令牌桶大小（bits）。假设数据包长度随机，且进入网络传输的数据包必须完整不能拆分。所以令牌数量小于数据包大小时就不允许传输，必须进入等待队列，等令牌生成足够。此时该数据包就产生了<strong>排队时延</strong>。令牌桶的参数应该根据源的流量模式（Traffic Pattern）来选择，以便在这个队列中产生的延迟相当小。鉴于此，文章提出一种动态且灵活的机制来调整令牌桶的参数。</p><p>&emsp;&emsp;为了不产生排队时延，可以把队列长度设置为0。但这也会导致没有足够数量token的数据包会被截断并丢弃。流量源的<strong>截断率</strong>是反映其当前的令牌桶参数 <code>(r ，b)</code> 是否适合的重要指标。</p><p>&emsp;&emsp;在文章提出的方案中，考虑了两个应用程序类型，其中第 1 类应用程序的输入缓冲区队列设置为 0，第 2 类应用程序允许输入缓冲区的最坏情况排队延迟为 10 毫秒。这里最坏情况的排队延迟定义为 <code>Q/r</code>，<code>Q</code> 是输入缓冲区的大小。</p><h3 id="r、b-的上下限"><a href="#r、b-的上下限" class="headerlink" title="r、b 的上下限"></a>r、b 的上下限</h3><p>对于特定的流量源，假设在时间 <code>t0</code> 开始执行测量，测量间隔中有 <code>T</code> 个数据包到达。令 <code>tn</code> 为该间隔中大小为 <code>Pn</code> 的第 <code>n</code> 个数据包的到达时刻，令 <code>b0</code> 表示 <code>t0</code> 时刻令牌桶中的初始令牌数。直观地说，如果令牌生成率 <code>r</code> 太小，那么无论 <code>b</code> 的值如何，桶中都没有足够的令牌用于所有传入的数据包。假设 <code>b</code> 和 <code>r</code> 都设置得当，不会因为令牌桶溢出而丢失令牌，并且基本测量块是 <code>T</code> 个分组传输单元的测量窗口，满足无延迟要求的必要条件是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222151235.png" alt="image-20220222151235427" style="zoom:43%;" /><p>其中 <code>r</code> 定义如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222151312.png" alt="image-20220222151312918" style="zoom:43%;" /><p>其中 <code>t0</code> 是测量块开始的时刻，<code>tn</code> 是在 <code>t0</code> 之后到达的第 <code>n</code> 个数据包的到达时刻，<code>T</code> 是在测量间隔内到达的数据包总数。如果初始令牌计数设置为 0，则 <code>r_min</code> 恰为该流量模式的平均比特率。</p><hr><p><code>r</code> 的值可以取很高，但没必要太大，因为这样会由于令牌桶溢出而造成令牌浪费。最大 <code>r</code> 值满足在每个间隔期间生成的令牌数足够每个新数据包的发送即可，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222151809.png" alt="image-20220222151808963" style="zoom:43%;" /><p>如果初始令牌数设置为 0，则 <code>r_max</code> 恰为流量源的峰值比特率。</p><hr><p>由于系统只会将完整的数据包传入网络，因此令牌的最小数量必须大于数据包的大小。当 <code>r</code> 取最大值时，<code>b</code> 可以取最小值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222152031.png" alt="image-20220222152030992" style="zoom:43%;" /><p>其中 <code>M</code> 是最大数据包大小，在 IETF 集成服务规范 [5] 中有定义。</p><hr><p>令 <code>b(r)_n</code> 表示在数据包 <code>n</code> 到达之前累积的令牌数。假设令牌桶不会溢出，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222152208.png" alt="image-20220222152208908" style="zoom:43%;" /><p>因此，最大 <code>b</code> 值为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222152310.png" alt="image-20220222152310749" style="zoom:43%;" /><h3 id="在给定-r-和队列大小，求-b-的最优值"><a href="#在给定-r-和队列大小，求-b-的最优值" class="headerlink" title="在给定 r 和队列大小，求 b 的最优值"></a>在给定 r 和队列大小，求 b 的最优值</h3><p>令 <code>d_n = t_n-t_n-1</code> 表示数据包 <code>n</code> 和 <code>n-1</code> 之间的到达间隔时间，其中 <code>n=1,2,……,T</code>。令 <code>b(r)_n</code> 表示在数据包 <code>n</code> 到达之前的瞬间桶中的令牌数。由于 <code>b(r)_n</code> 不能超过令牌桶大小 <code>b</code>，有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153132.png" alt="image-20220222153132920" style="zoom:43%;" /><p>其中 <code>J_n</code> 是在 <code>t_n</code> 时刻数据包 <code>n</code> 到达之前已经传输的最后一个包的索引。</p><p>注意，如果<code>J_n = J_n-1</code>，则说明在 <code>dn</code> 中没有数据包传输，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153110.png" alt="image-20220222153110151" style="zoom:43%;" /><hr><p>如果缓冲队列大小为 <code>Q</code>，那么如要实现无丢包，<code>Q</code> 应该足够大以容纳仍在等待令牌的比特总数。因此有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153558.png" alt="image-20220222153558646" style="zoom:43%;" /><p>综上可得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153701.png" alt="image-20220222153701196" style="zoom:43%;" /><p>如要满足上不等式，则必须同时满足：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153751.png" alt="image-20220222153751645" style="zoom:43%;" /><p>和</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222153803.png" alt="image-20220222153803525" style="zoom:43%;" /><hr><p>对于<code>n = T, =T-1,T-2,……,1</code> 、令牌速率 <code>r</code>、队列长度 <code>Q</code>，满足数据包无损传输的 b 的最小值为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222154055.png" alt="image-20220222154055858" style="zoom:43%;" /><hr><p>如果缓冲队列长度为0，则：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222154127.png" alt="image-20220222154127454" style="zoom:43%;" /><hr><p>显然，<code>b_no_Q</code> &gt; <code>b_opt</code>，因为无队列令牌桶要保留比有队列令牌桶更多的资源。这也代表着在资源利用率和 QoS 性能之间的权衡。使用队列时，突发流量将被平滑，因此派生的令牌桶参数比无队列情况下的要求更低，并且更好地利用网络资源。</p><p>&nbsp;</p><h2 id="准入控制和资源再协调方案"><a href="#准入控制和资源再协调方案" class="headerlink" title="准入控制和资源再协调方案"></a>准入控制和资源再协调方案</h2><h3 id="准入控制决策"><a href="#准入控制决策" class="headerlink" title="准入控制决策"></a>准入控制决策</h3><p>&emsp;&emsp;文中假设网络流量由实时和非实时应用程序组成，只有实时应用程序需要明确的准入控制程序，而非实时应用程序继续使用传统的“尽力而为”服务。</p><p>&emsp;&emsp;基于测量的准入控制方案最适合具有高聚合度的链路，如果聚合水平较低，即使平均到达率相当高，测量的到达率也可能在很长一段时间内保持较低水平。如果发生这种情况，那么系统可能会接纳比应有的更多的新数据流。当到达率恢复到更正常的较高水平时，会产生后续问题。基于此，对于具有低聚合级别的链路，准入控制过程可以简单地基于准入流的峰值速率；而对于具有更高级别聚合的链路，基于测量的准入控制程序可能会带来很大的好处。</p><p>&emsp;&emsp;准入决定基于新数据流 <code>α</code> 的最坏情况流量，由令牌桶 <code>&#123;b_α, r_α&#125;</code> 建模。在 [7]中已经证明，如果为此数据流保留最小带宽是 <code>r_α</code>，那么最坏情况的排队延迟是 <code>b_α</code> / <code>r_α</code>。在最坏情况下，只要网络可以缓冲 <code>b_α</code> 大小的突发并提供至少与 <code>r_α</code> 相同的持续速率，就可以保证不丢失来自源的数据包。</p><hr><p>对于总容量为 C 的链路，以下条件指导准入决定：</p><ul><li><p>资源状况</p><p>  接纳新数据流后的总带宽使用量不能超过 mC，其中 m 是链路容量的选定部分。用 <code>ρ_i</code> 表示现有数据流的第 <code>i</code> 类的估计总流量速率，<code>ρ_α</code> 表示新数据流 <code>α</code> 的流量速率（注意：<code>ρ_α</code> = <code>r_α</code> ），则有：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222161807.png" alt="image-20220222161806959" style="zoom:43%;" /></li><li><p>QoS状况</p><p>  接纳新数据流不能影响相同优先级数据流的延迟限制。假设数据流 <code>α</code> 来自 <code>k</code> 类，那么最坏情况下估计 k 类的新延迟为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222162025.png" alt="image-20220222162025857" style="zoom:43%;" /><p>  其中：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222162043.png" alt="image-20220222162043365" style="zoom:43%;" /><p>  是在准入数据流 <code>α</code> 之前的聚合类 <code>k</code> 的延迟，可以通过测量现有流量的聚合速率来获得。在准入数据流 <code>α</code> 之后，聚合类 <code>k</code> 的延迟与 <code>b_α</code> 成线性关系</p></li></ul><hr><p>文章使用静态优先级方案来研究这种基于测量的准入控制方案。因此，新类 <code>k</code> 的准入也会影响优先级更低的类 <code>j</code> 的延迟。</p><p>有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222163220.png" alt="image-20220222163220080" style="zoom:43%;" /><p>其中 <code>Dj</code> 是准入数据流 <code>α</code> 之前的 j 类数据流的总延迟。注意，新数据流 <code>α</code> 不会影响优先级高于其类型的数据流的排队延迟。</p><h3 id="参数测量"><a href="#参数测量" class="headerlink" title="参数测量"></a>参数测量</h3><ol><li><p>时延</p><p> 测量变量 <code>Di</code> 跟踪 <code>I</code> 类数据流的估计最大排队延迟。使用 T 个数据包传输单元的测量窗口作为基本测量块。<code>Di</code> 的值在测量块结束时更新，以反映在测量块中看到的最大数据包延迟，即：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222163703.png" alt="image-20220222163703206" style="zoom:43%;" /><p> 其中 <code>dk</code> 是测量块中第 <code>k</code> 个传输单元的分组排队延迟</p></li><li><p>速率</p><p> 测量变量 <code>∑ρ</code> 跟踪第 <code>i</code> 类数据流的最高采样流量速率。通过计算 S 个传输单元的平均比特率，在大小为 S 个单元的平均周期结束时获得每个测量样本。大小为 T(=nS) 单位的测量块包含 n 个测量样本，表示为 <code>S1, S2, ……,Sn</code>。在测量块结束时，使用 S 中的 n 个平均周期的最高平均比特率更新 <code>∑ρ</code> ：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222164415.png" alt="image-20220222164415266" style="zoom:43%;" /> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222164428.png" alt="image-20220222164428514" style="zoom:43%;" /><p> 其中 <code>Pm</code> 是第 <code>m</code> 个数据包的数据包大小，<code>ts</code> 是大小为 <code>S</code> 个单位的平均周期内最后一个数据包的到达时间</p></li></ol><p>对于以下特殊情况，可以更快地更新估计值，以提高方案的响应能力：</p><ul><li><p>如果在测量块的中间准入了一个新的数据流，则先前估计的延迟和速率（即在前一个测量块结束时采用的那些）立即更新：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222164748.png" alt="image-20220222164748070" style="zoom: 43%;" />  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222164838.png" alt="image-20220222164838619" style="zoom:30%;" /></li><li><p>当测量块中的平均周期的一次测量超过目前的估计值时，则立即更新（一超过就更新）</p></li></ul><h3 id="资源再协调"><a href="#资源再协调" class="headerlink" title="资源再协调"></a>资源再协调</h3><p>当流量源的丢包率大于用户指定的丢包率 <code>L</code> 或 一段时间内没有发现丢包时，开启资源再协调过程。</p><hr><p>初始令牌速率 <code>r</code> 设置为 <code>rmax</code>（=峰值比特率，<code>P</code>），初始令牌大小设为 <code>bmin</code>（=最大数据包尺寸，M）。如前所述，令牌桶参数的这组值满足无丢失无延迟条件。随后进行资源再协调时，<code>r</code> 的值是实际测量的平均数据速率：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222165743.png" alt="image-20220222165743204" style="zoom:30%;" /><p><code>b</code> 的最佳值由上面的公式计算得出：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222154055.png" alt="image-20220222154055858" style="zoom:43%;" /><p>令牌桶参数的最优值也可以根据用户的QoS要求和实时流量情况进行调整。</p><hr><p>文章提出的用于主机系统和中间节点的自适应资源协调准入控制方案的流程图如图 1 和图 2 所示。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222170407.png" alt="image-20220222170407318" style="zoom:55%;" /><center>图1 for主机系统</center><p>最初，用户指定其 QoS 参数要求（例如L 和 D) 和应用参数（例如P 和 M）。数据源将初始令牌率和令牌大小值分别设置为 <code>rmax</code> 和 <code>bmin</code>。呼叫准入“请求包”将从源发送到目的地，“请求包”由令牌桶参数和QoS参数信息组成。当一个中间节点（例如路由器）从数据源或前一个节点接收到呼叫准入包，在做出准入决定时会考虑资源条件和QoS条件。只有当这两个条件都满足，呼叫准入请求包才会被中继到下一个路由器，否则会向源返回一个“拒绝包”。只有当路径上的所有网络节点都准入该数据流时，该请求才会被准入。在这种情况下，“请求数据包”最终会到达目的地，而目的地将向源发送一个“准入数据包”。当数据源接收到来自目标的“接受数据包”时，数据源将开始向目标发送数据包。随后，它将定期检测丢包率。只要丢包率超过用户指定的丢包率 <code>L</code>，或者在一定时间内没有丢包，就会启动资源再协调过程。将计算 <code>r</code> 和 <code>b</code> 的最佳值并将其用于资源再协调过程。资源再协调过程遵循与上述呼叫准入过程相同的过程。不过在资源再协调时，即使“请求包”被拒绝，数据源仍然可以使用其先前的参数继续发送数据包。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220222170458.png" alt="image-20220222170458869" style="zoom:55%;" /><center>图2 for中间节点</center>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
            <tag> Token Bucket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于令牌桶的802.16无线接入网呼叫准入控制和上行包调度算法</title>
      <link href="/2022/02/20/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Token%20bucket%20based%20CAC%20and%20packet%20scheduling%20for%20IEEE%20802.16%20broadband%20wireless%20access%20networks/"/>
      <url>/2022/02/20/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Token%20bucket%20based%20CAC%20and%20packet%20scheduling%20for%20IEEE%20802.16%20broadband%20wireless%20access%20networks/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;在802.11标准之后，又提出了一个针对WMAN的全新标准802.16。第一个 802.16 标准支持 QoS，它将所有流量根据应用类型分为四类，每类具有不同的优先级。 802.16 使用分组调度来实现 QoS 支持，但没有明确的算法定义或实现细节。 802.16 标准只定义了 QoS 参数和一些简单的原则，其他部分是留给供应商的开放问题</p><p>&emsp;&emsp;本文提出了对数据流请求建立连接的准入控制方法，并使用 token bucket 进行数据整形，给出了基于QoS需求和bucket size的token rate的计算方法</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Token%20bucket%20based%20CAC%20and%20packet%20scheduling%20for%20IEEE%20802.16%20broadband%20wireless%20access%20networks.pdf">Token bucket based CAC and packet scheduling for IEEE 802.16 broadband wireless access networks</a></p><span id="more"></span><p>&nbsp;</p><h2 id="IEEE-802-16标准"><a href="#IEEE-802-16标准" class="headerlink" title="IEEE 802.16标准"></a>IEEE 802.16标准</h2><ul><li><p>用户侧称为 SS（Subscriber Station）、服务侧称为 BS（Base Station）</p></li><li><p>定义了4种QoS类型：UGS、rtPS、nrtPS、BE</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220105622.png" alt="image-20220220105622096" style="zoom:35%;" />  <center>高低反映优先级</center></li><li><p>数据流 被视为 连接（connection），在传输前必须与BS建立连接</p></li><li><p>操作过程</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220110058.png" alt="image-20220220110058133" style="zoom:30%;" />  <center>虚线框是未定义的部分</center></li><li><p>将传输时间划分为超级帧，每个超级帧又可以分为下行子帧和上行子帧</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220110451.png" alt="image-20220220110451686" style="zoom:35%;" /></li><li><p>在 BS 接受一个新连接后将轮询这个新连接，并让它发送带宽需求，以从 BS 接受带宽授权。授权是 BS 上行链路分组调度的结果，将包含在下行链路子帧的上行链路 MAP (UL-MAP) 字段中。</p><p>  （文中使用 [4] 中的架构：连接将其队列长度作为 BW 请求发送）</p></li><li><p>带宽请求争用期是为较低优先级的类（例如 nrtPS 和 BE）在系统忙到无法轮询所有连接时，获得发送 BW 请求的机会</p></li></ul><p>&nbsp;</p><h2 id="呼叫准入控制（CAC）"><a href="#呼叫准入控制（CAC）" class="headerlink" title="呼叫准入控制（CAC）"></a>呼叫准入控制（CAC）</h2><p>&emsp;&emsp;在文章模型中，每个连接connection由两个参数控制：令牌生成速率 <code>ri</code> 和桶的大小 <code>bi</code>，当有数据流想要和BS建立连接时，需要向BS发送这两个指标并等待回复（本质是带宽申请）。如果是 rtPS 类型的数据流，则还需要额外发送一个指标：时延需求 <code>di</code></p><h3 id="rtPS-带宽需求分析"><a href="#rtPS-带宽需求分析" class="headerlink" title="rtPS 带宽需求分析"></a>rtPS 带宽需求分析</h3><p>假设一个超级帧时长为 <code>f</code>，一个 rtPS 类型数据流的需求参数包括：<code>ri</code>、<code>bi</code>、<code>di</code>，其中时延需求 <code>di</code> 必须是 <code>f</code> 的二倍，这里假设为 <code>3f ≤ di＜4f</code>，并进一步设 <code>di</code> = <code>3f</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220133944.png" alt="image-20220220133944202" style="zoom:40%;" /><p>如果该连接在 <code>[t, t+6f]</code> 期间有一段突发数据，每个帧要发的最大尺寸如图中灰色框所示。因为时延需求是 <code>3f</code>，因此  <code>[t, t+f]</code> 期间的数据必须至少在 <code>[t+f, t+2f]</code>、<code>[t+2f, t+3f]</code> 内完成发送。而一个令牌桶在时间t内能发送的理论最大数据量为 <code>ri*t+bi</code>，因此一个帧内发送的最大数据量为 <code>ri*f+bi</code>。生成数据的速度超过 <code>ri</code> 时就会开始消耗 <code>bi</code>，在极端情况下，<code>bi</code> 会被消耗完。上图中，<code>bi</code> 在 <code>[t+2f, t+3f]</code> 内被消耗，这意味着在 <code>[t+4f, t+5f]</code> 期间应该发出的最大尺寸为 <code>ri*t+bi</code></p><p>在上图中，<code>bi</code> 来自帧 <code>[t+2f, t+3f]</code>。所以只有帧 <code>[t+3f, t+4f]</code> 可以共享帧 <code>[t+4f, t+5f]</code> 的 <code>bi</code> 位。</p><p>设 <code>mi</code> = <code>di</code> = <code>3f</code>，则最多有 <code>mi-1</code>帧可以共享 <code>bi</code> 位。因此每帧的最大尺寸为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220135324.png" alt="image-20220220135324523" style="zoom:40%;" /><p>设 <code>rtPS</code> 类连接的数量为 <code>Nrtps</code>、最大需求为 <code>Cdemand</code> bits，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220205208.png" alt="image-20220220205208161" style="zoom:60%;" /><p>为避免其他类型业务资源匮乏，这里为每种类型设置一个阈值：<code>t_UGS</code>、<code>t_rtPS</code>、<code>r_nrtPS</code>、<code>r_BE</code>，满足 <code>t_UGS+t_rtPS+r_nrtPS+r_BE ≤ Cuplink</code>，其中 <code>Cuplink</code> 是上行总容量。哪种类型占用的容量超过其阈值，则降低其优先级。</p><h3 id="CAC-algorithm"><a href="#CAC-algorithm" class="headerlink" title="CAC algorithm"></a>CAC algorithm</h3><p>这里给出本文中，当有新的数据流 <code>[ri, bi, di]</code> 请求与BS建立连接时，呼叫准入控制的流程：</p><ol><li><p>计算当前剩余的上行容量 <code>Cremain</code> ：<code>Cremain = Cuplink - C_UGS - C_rtPS - C_nrtPS - C_BE</code>，其中 <code>C_UGS</code> 等 分别是四种业务当前所占用的容量</p></li><li><p>对比 <code>Cremain</code> 和新连接的带宽需求，rtPS 类型的带宽需求即为上面 <code>Cdemand</code> 公式计算得，其他类型的数据流带宽需求为 <code>ri</code>。若 <code>Cdemand</code> 不够用，则进入第3步；够用则呼叫准入，建立连接</p></li><li><p>先关注比当前连接所属类型更低优先级的类型下的已有连接，如果这些连接中，某些连接占用的容量超过该类型的阈值，则计算可以从该连接中抽取多少带宽 <code>Cl</code>。若<code>Cl</code>与<code>Cremain</code>之和大于 <code>Cdemand</code> ，则呼叫准入，建立连接。</p><p>否则，再关注当前连接所属的类型占用的容量是否达到阈值，如果达到了则拒接该连接请求；若未达到，则从比当前连接所属的类型优先级更高的类型下已有连接中抽取带宽<code>Cu</code>为其所用，方法和上面一样。若<code>Cl</code>、<code>Cu</code>、<code>Cremain</code>三者之和大于<code>Cdemand</code>，则呼叫准入，建立连接；否则拒绝连接</p></li></ol><p>&nbsp;</p><h2 id="上行链路数据包调度"><a href="#上行链路数据包调度" class="headerlink" title="上行链路数据包调度"></a>上行链路数据包调度</h2><ol><li>计算 rtPS 类型连接的所有到达数据包及其 deadline，采用 [4] 中的EDF机制。用一个数据库记录每个 rtPS 连接在每个帧中所需发送的数据包的数量</li><li>为所有 UGS 类连接授予容量，根据802.16协议，UGS 类型连接每个帧内要接收固定的带宽</li><li>根据 rtPS 数据库为 rtPS类连接授予容量</li><li>至于 nrtPS 和 BE 类连接，先分配其所需容量，然后有多余容量则按需为二者再分配</li><li>最后容量如果还有剩余，必要时按顺序将它们分配到 nrtPS 和 BE 的争用期</li></ol><p>&nbsp;</p><h2 id="token-rate-预估模型"><a href="#token-rate-预估模型" class="headerlink" title="token rate 预估模型"></a>token rate 预估模型</h2><p>假设 packet 的到达符合期望为 <code>λ</code> 的泊松分布Possion，且 packet 的 delay 要求为 <code>dq</code>，Bucket的 token rate 为 <code>ri</code>、大小为 <code>bi</code>，那么可以通过马尔可夫链预测出排队延迟：</p><ul><li><p><code>state(t, p)</code>：bucket 中有 t 个 token，队里中有 p 个packet </p></li><li><p>token 生成时间间隔为 <code>1/ri</code></p></li><li><p>时间 <code>1/ri</code> 内到达 n 个packet的概率为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220095203.png" alt="image-20220220095203834" style="zoom:40%;" /></li><li><p>马尔可夫链为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220095308.png" alt="image-20220220095308294" style="zoom:50%;" /></li><li><p>设 <code>state(t, p)</code> 表示为 <code>π(bi-t+p)</code>，且设：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220095459.png" alt="image-20220220095459544" style="zoom:45%;" /></li><li><p>马尔可夫链的一般状态（没理解）</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220103955.png" alt="image-20220220103955854" style="zoom:60%;" /></li></ul><h3 id="无限长队列"><a href="#无限长队列" class="headerlink" title="无限长队列"></a>无限长队列</h3><p>对于无限长队列，根据上述建模可得等式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220095652.png" alt="image-20220220095652684" style="zoom:45%;" /><center>式 1</center><p>当 n ≥ 1时，有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220102814.png" alt="image-20220220102813955" style="zoom:60%;" /><center>式 2</center><p>设 泊松分布概率密度P 和 马尔可夫过程π 的Z变换分别为：<code>Gp</code>、<code>Gπ</code>，对上式做Z变换得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220100317.png" alt="image-20220220100317915" style="zoom:65%;" /><center>式 3</center><p>因为 M+P(0)+P(1)=1，并把公式1带入公式 3得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220100634.png" alt="image-20220220100634023" style="zoom:45%;" /><center>式 4</center><p>又因为 z—&gt;1时，Gπ(z)—&gt;0，所以：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220100858.png" alt="image-20220220100858648" style="zoom:40%;" /><center>式 5</center><p>至此，通过公式1、2可以递推出完整马尔可夫过程：<code>[π(0), π(1), π(2)……]</code> 中的任一 <code>π(n)</code></p><p>平均排队延时为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220101423.png" alt="image-20220220101423481" style="zoom:65%;" /><center>式 6</center><p>其中：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220101717.png" alt="image-20220220101717082" style="zoom:65%;" /><center>式 7</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220101900.png" alt="image-20220220101900134" style="zoom:45%;" /><center>式 8</center><p>由公式6、7、8可以根据给定ri、bi计算出泊松过程packet在无限长队列中的排队时延</p><h3 id="有限长队列"><a href="#有限长队列" class="headerlink" title="有限长队列"></a>有限长队列</h3><p>在有限长队列情况下必须考虑丢包问题，设队列长队为 <code>q</code> 时，数据流的丢包率要求为 <code>lq</code> ；</p><p>此时仍使用马尔可夫过程，但是序列长度变得有限：<code>[π(0), π(1), ……, π(bi+q-1)]</code> ；</p><p>根据上述建模可得等式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220102455.png" alt="image-20220220102455668" style="zoom:45%;" /><center>式 9</center><p>对 1 ≤ n ≤ bi+q-2 有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220103005.png" alt="image-20220220103005766" style="zoom:65%;" /><center>式 10</center><p>根据公式9、10可以递推算出完整马尔可夫过程：<code>[π(0), π(0), ……, π(bi+q-1)]</code> 中的任一 <code>π(n)</code></p><p>平均排队延时为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220103224.png" alt="image-20220220103224629" style="zoom:50%;" /><center>式 11 （j=0时N=0.5，j>0时N=0）</center><p>平均丢包率为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220103413.png" alt="image-20220220103413017" style="zoom:50%;" /><center>式 12</center><p>同无限长队列情况类似，先递推计算出马尔可夫过程 <code>π(n)</code> ，然后根据给定ri、bi可以计算出泊松过程packet在长度为q的队列情况下的排队时延和丢包率</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
            <tag> Token Bucket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传拓扑神经网络 NEAT</title>
      <link href="/2022/02/20/%E3%80%90AI%E3%80%91%E9%81%97%E4%BC%A0%E6%8B%93%E6%89%91%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CNEAT/"/>
      <url>/2022/02/20/%E3%80%90AI%E3%80%91%E9%81%97%E4%BC%A0%E6%8B%93%E6%89%91%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CNEAT/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;遗传拓扑神经网络模型最早由2002年的一篇论文 <a href="https://lrk612.com/resources/Efficient%20Evolution%20of%20Neural%20Network%20Topologies.pdf">Efficient Evolution of Neural Network Topologies</a> 提出，同年的另一篇论文 <a href="https://lrk612.com/resources/Evolving%20Neural%20Networks%20through%20Augmenting%20Topologies.pdf">Evolving Neural Networks through Augmenting Topologies</a> 对其进行了详细地论述。NEAT对神经网络结构设计进行建模，并认为是一个NP问题，故引入遗传算法来优化网络结构设计，使得网络中神经元的组合逐渐向着满足尽可能高的适应度方向进化。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220220002540.png" alt="image-20220220002533169" style="zoom:45%;" /><span id="more"></span><p>&nbsp;</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般深度学习模型解决问题的思路是期望搭建一个深度神经网络来拟合一个从输入x到输出y之间的复杂映射关系。通过深度神经网络中丰富的神经元组合，以及一个个小的、拟合能力有限的功能组件，构成一个拥有复杂拟合能力的模型。网络越深，其VC维越高，高层特征的提取能力越强，网络能够学习的东西越多。</p><p>而NEAT的方法论与深度学习模型不同，它是神经网络和遗传算法的朴素结合。NEAT的优点主要有三点：</p><ol><li>拓扑连接简单</li><li>可解释性强</li><li>在一些场景中收敛很快</li></ol><p>在NEAT算法中的神经网络因为基因突变的存在，会导致网络内神经元的连接都不是很规则。而不规则、不对称的网络结构正是NEAT的一个特点。</p><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><h3 id="基因组"><a href="#基因组" class="headerlink" title="基因组"></a>基因组</h3><p>一个完整的基因组（Genome）中有两类节点描述，一是节点基因（Node Genes）、二是连接基因（Connect Genes）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219083434.png" alt="image-20220219083413316" style="zoom:40%;" /><p>重点是连接基因，一个连接基因携带的信息如下：</p><ul><li>输入节点：In</li><li>输出节点：Out</li><li>权重：Weight</li><li>有效性：Enable / DISAB(Disable)</li><li>序号：Innov</li></ul><p>用节点基因和连接基因的所有信息就可以完整且唯一地描述一个神经网络结构了，接下来的遗传选择工作也只需要对两种基因展开即可。</p><h3 id="变异和遗传"><a href="#变异和遗传" class="headerlink" title="变异和遗传"></a>变异和遗传</h3><p><strong>变异</strong></p><p>变异包含两种：</p><ul><li><p>添加连接变异（Mutate Add Connection）</p><p>  在已有节点基因间随即加入一个新的连接基因</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219084624.png" alt="image-20220219084624534" style="zoom:50%;" /></li><li><p>添加节点变异（Mutate Add Node）</p><p>  增加一个新的节点，并为该节点随机增加一些连接基因</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219084645.png" alt="image-20220219084645037" style="zoom:50%;" /></li></ul><p><strong>遗传</strong></p><p>首先对“双亲”的基因进行对齐操作，Innov序号从小到大一一对齐，如果双方都有该Innov，就保留该Innov对应的基因；如果Innov不匹配，则取适应度较高一方的基因。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219085025.png" alt="image-20220219085024986" style="zoom: 40%;" /><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>gym—cartpole</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> neat</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line">GAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">env = gym.make(GAME).unwrapped</span><br><span class="line"></span><br><span class="line">CONFIG = <span class="string">&quot;./config&quot;</span></span><br><span class="line">EP_STEP = <span class="number">300</span></span><br><span class="line">GENERATION_EP = <span class="number">30</span></span><br><span class="line">CHECKPOINT = <span class="number">29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_genomes</span>(<span class="params">genomes, config</span>):</span></span><br><span class="line">    <span class="keyword">for</span> genome_id, genome <span class="keyword">in</span> genomes:</span><br><span class="line">        net = neat.nn.FeedForwardNetwork.create(genome, config)</span><br><span class="line">        ep_r = []</span><br><span class="line">        <span class="keyword">for</span> ep <span class="keyword">in</span> <span class="built_in">range</span>(GENERATION_EP):</span><br><span class="line">            accumulative_r = <span class="number">0</span></span><br><span class="line">            observation = env.reset()</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(EP_STEP):</span><br><span class="line">                action_values = net.activate(observation)</span><br><span class="line">                action = np.argmax(action_values)</span><br><span class="line">                observation_, reward, done, _ = env.step(action)</span><br><span class="line">                accumulative_r += reward</span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                observation = observation_</span><br><span class="line">            ep_r.append(accumulative_r)</span><br><span class="line">        genome.fitness = np.<span class="built_in">min</span>(ep_r)/<span class="built_in">float</span>(EP_STEP)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    config = neat.Config(neat.DefaultGenome, neat.DefaultReproduction,</span><br><span class="line">                         neat.DefaultSpeciesSet, neat.DefaultStagnation, CONFIG)</span><br><span class="line">    pop = neat.Population(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recode history</span></span><br><span class="line">    stats = neat.StatisticsReporter()</span><br><span class="line">    pop.add_reporter(stats)</span><br><span class="line">    pop.add_reporter(neat.StdOutReporter(<span class="literal">True</span>))</span><br><span class="line">    pop.add_reporter(neat.Checkpointer(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    pop.run(eval_genomes, GENERATION_EP)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># visualize training</span></span><br><span class="line">    visualize.plot_stats(stats, ylog=<span class="literal">False</span>, view=<span class="literal">True</span>)</span><br><span class="line">    visualize.plot_species(stats, view=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluation</span>():</span></span><br><span class="line">    p = neat.Checkpointer.restore_checkpoint(<span class="string">&#x27;neat-checkpoint-%i&#x27;</span> % CHECKPOINT)</span><br><span class="line">    winner = p.run(eval_genomes, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># show winner net</span></span><br><span class="line">    node_names = &#123;-<span class="number">1</span>: <span class="string">&#x27;In0&#x27;</span>, -<span class="number">2</span>: <span class="string">&#x27;In1&#x27;</span>, -</span><br><span class="line">                  <span class="number">3</span>: <span class="string">&#x27;In3&#x27;</span>, -<span class="number">4</span>: <span class="string">&#x27;In4&#x27;</span>, <span class="number">0</span>: <span class="string">&#x27;act1&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;act2&#x27;</span>&#125;</span><br><span class="line">    visualize.draw_net(p.config, winner, <span class="literal">True</span>, node_names=node_names)</span><br><span class="line"></span><br><span class="line">    net = neat.nn.FeedForwardNetwork.create(winner, p.config)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = env.reset()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            env.render()</span><br><span class="line">            a = np.argmax(net.activate(s))</span><br><span class="line">            s, r, done, _ = env.step(a)</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Please input the option: TRAIN or EVAL&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    TRAINING = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> TRAINING == <span class="string">&#x27;TRAIN&#x27;</span>:</span><br><span class="line">        run()</span><br><span class="line">    <span class="keyword">elif</span> TRAINING == <span class="string">&#x27;EVAL&#x27;</span>:</span><br><span class="line">        evaluation()</span><br></pre></td></tr></table></figure><p>29轮生成的网络结构：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219151746.png" alt="image-20220219151738869" style="zoom: 35%;" /><p>代码仓库：<a href="https://github.com/Sharp-rookie/NEAT">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【启发式算法】遗传算法 GA</title>
      <link href="/2022/02/16/%E3%80%90%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E3%80%91%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%20GA/"/>
      <url>/2022/02/16/%E3%80%90%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E3%80%91%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%20GA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;由于遗传算法的整体搜索策略和优化搜索方法在计算时不依赖于梯度信息或其它辅助知识，而只需要影响搜索方向的目标函数和相应的适应度函数，所以遗传算法提供了一种求解复杂系统问题的通用框架，不依赖于问题的具体领域，对问题的种类有很强的鲁棒性，广泛应用于许多场景。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220216231227.png" alt="image-20220216231227178" style="zoom: 35%;" /><span id="more"></span><p>&nbsp;</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;遗传算法（Genetic Algorithm）是一类借鉴生物界的进化规律（遗传变异、优胜劣汰、适者生存）演化而来的随机化搜索方法。与其说遗传算法是一类算法，不如说是一种处理问题的思想。</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>&emsp;&emsp;在遗传算法的建模中，编码是关键。在遗传算法中，遗传空间的染色体或者个体建模为一系列bit位的0、1二进制数值串，也就是说需要把原问题的解空间<strong>一一映射</strong>且<strong>满射</strong>为二进制定长数值串，后续的遗传、基因重组、变异都是在数值串基础上进行的。</p><p>评估编码策略有以下3个规范：</p><ul><li>完备性(completeness)：问题解空间中的所有解都能被映射为GA空间中的某个点(染色体)</li><li>健全性(soundness)：GA空间中的染色体全都能对应问题解空间中的某个解</li><li>非冗余性(nonredundancy)：染色体和候选解一一对应</li></ul><h4 id="适应度"><a href="#适应度" class="headerlink" title="适应度"></a>适应度</h4><p>&emsp;&emsp;进化论中的适应度（fitness），是表示某一个体对环境的适应能力，也表示该个体繁殖后代的能力。那么遗传算法的适应度函数相应就是用来表示该个体实现问题目标的优劣程度，也叫评价函数，类似强化学习中的奖励函数。</p><p>&emsp;&emsp;遗传算法在搜索进化过程中一般不需要其他外部信息，仅用评估函数来评估个体或解的优劣，并作为以后遗传操作的依据。由于遗传算法中，适应度函数要比较排序并在此基础上计算选择概率，所以适应度函数的值要取<strong>正值</strong>，所以适应度函数必须是求最大值形式且非负的。适应度函数的设计主要满足以下条件：</p><ul><li><p>单值、连续、非负、最大化</p></li><li><p>合理、一致性</p></li><li><p>计算量小</p></li><li><p>通用性强</p></li></ul><p>在具体应用中，适应度函数的设计要结合求解问题本身的要求而定。适应度适应度函数设计直接影响到遗传过程的收敛和性能。</p><h4 id="初始种群"><a href="#初始种群" class="headerlink" title="初始种群"></a>初始种群</h4><p>遗传算法中初始群体中的个体是随机产生的。一般来讲，初始群体的设定可采取如下的策略:</p><ul><li>根据问题固有知识，设法把握最优解所占空间在整个问题空间中的分布范围，然后，在此分布范围内设定初始群体</li><li>先随机生成一定数目的个体，然后从中挑出最好的个体加到初始群体中。这种过程不断迭代，直到初始群体中个体数达到了预先确定的规模</li></ul><h4 id="遗传算子"><a href="#遗传算子" class="headerlink" title="遗传算子"></a>遗传算子</h4><p><strong>基因选择</strong></p><p>&emsp;&emsp;从群体中选择优胜的个体，淘汰劣质个体的操作叫选择。选择算子有时又称为再生算子（reproduction operator）。选择的目的是把优化的个体（或解）直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的，常用的选择算子有以下几种：适应度比例方法（常用）、随机遍历抽样法、局部选择法。</p><p><strong>基因重组</strong></p><p>&emsp;&emsp;在自然界生物进化过程中起核心作用的是生物遗传基因的重组（加上变异）。同样，遗传算法中起核心作用的是遗传操作的交叉算子。所谓交叉是指把被选择出来的两个父代个体的部分结构加以替换重组而生成新个体的操作，实际上是在解空间中较优解附近有“指向性地”进行探索。</p><p><strong>基因突变</strong></p><p>&emsp;&emsp;变异算子的基本内容是对群体中的个体随机基因上的基因值（二进制数值串随机bit位）作变动。遗传算法引入变异的目的有两个：</p><ol><li>使遗传算法具有局部的随机搜索能力，当遗传算法通过交叉算子已接近最优解邻域时，利用变异算子的这种局部随机搜索能力可以加速向最优解收敛。显然，此种情况下的变异概率应取较小值，否则接近最优解的积木块会因变异而遭到破坏</li><li>使遗传算法可维持群体多样性，以防止出现未成熟收敛现象。也就是说搜索的前期，突变概率应取较大值</li></ol><h4 id="中止条件"><a href="#中止条件" class="headerlink" title="中止条件"></a>中止条件</h4><p>&emsp;&emsp;当最优个体的适应度达到给定的阈值，或者最优个体的适应度和群体适应度不再上升时，或者迭代次数达到预设的代数时，算法收敛、终止。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>遗传算法重在思想，没有固定的算法流程，但是大体上都相似，只是细节处理不同，见下面两个例子。</p><p>&nbsp;</p><h2 id="示例一：背包问题"><a href="#示例一：背包问题" class="headerlink" title="示例一：背包问题"></a>示例一：背包问题</h2><p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，如何选择才能使得物品的总价格最高。</p><p>问题的名称来源于如何选择最合适的物品放置于给定背包中，相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。</p><p><strong>场景</strong></p><p>现在假设有一个承重80的包，还有6个物体：</p><table><thead><tr><th>物体</th><th>质量</th><th>价值</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>15</td></tr><tr><td>2</td><td>15</td><td>25</td></tr><tr><td>3</td><td>20</td><td>35</td></tr><tr><td>4</td><td>25</td><td>45</td></tr><tr><td>5</td><td>30</td><td>55</td></tr><tr><td>6</td><td>35</td><td>70</td></tr></tbody></table><p><strong>编码</strong></p><p>本场景编码使用六位二进制，每位的1、0分别表示物体的有无，类似独热向量</p><p><strong>初始种群</strong></p><p>任选4种组合（个体）：<code>100100、101010、010101、101011</code></p><p><strong>适性度</strong></p><p>定义为物体价值之和：<code>A1*W1+A2*W2+……+A6*w6</code>，其中 <code>A</code> 是每一位的值</p><p><strong>遗传</strong></p><p>计算出4种组合（个体）的适性度，以适性度比例为概率随机从4种组合（个体）中抽取出4个用于基因重组和突变。对依概率抽取出的4个两两配对进行重组得到新的4种组合（个体），然后随机对某种或某些组合（个体）的某个或某些bit位做突变（建议概率低一些）。</p><p>检测所以新组合（个体）的质量之和是否超过80，超过的直接淘汰。</p><table><thead><tr><th>初始种群</th><th>适性值</th><th>依概率选取</th><th>交叉点位置</th><th>重组结果</th></tr></thead><tbody><tr><td>100100</td><td>60</td><td>101010</td><td>3</td><td>101101</td></tr><tr><td>101010</td><td>105</td><td>010101</td><td>3</td><td>010010</td></tr><tr><td>010101</td><td>140</td><td>101010</td><td>4</td><td>101001</td></tr><tr><td>101011</td><td>质量超标，直接淘汰</td><td>010101</td><td>4</td><td>010110</td></tr></tbody></table><center>假设依概率选取出的4个组合是101010、010101各两个</center><p><strong>收敛条件</strong></p><p>这里定义收敛判定为：连续两代适性函数最大值不增加</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 背包问题</span></span><br><span class="line"><span class="comment"># 物品质量价格</span></span><br><span class="line">X = &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">10</span>, <span class="number">15</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">15</span>, <span class="number">25</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">20</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">25</span>, <span class="number">45</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">30</span>, <span class="number">55</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="number">35</span>, <span class="number">70</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止界限</span></span><br><span class="line">FINISHED_LIMIT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重量界限</span></span><br><span class="line">WEIGHT_LIMIT = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 染色体长度</span></span><br><span class="line">CHROMOSOME_SIZE = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遴选次数</span></span><br><span class="line">SELECT_NUMBER = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">max_last = <span class="number">0</span></span><br><span class="line">diff_last = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断退出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_finished</span>(<span class="params">fitnesses</span>):</span></span><br><span class="line">    <span class="keyword">global</span> max_last</span><br><span class="line">    <span class="keyword">global</span> diff_last</span><br><span class="line"></span><br><span class="line">    max_current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> fitnesses:</span><br><span class="line">        <span class="keyword">if</span> v[<span class="number">1</span>] &gt; max_current:</span><br><span class="line">            max_current = v[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    diff = max_current - max_last</span><br><span class="line">    <span class="keyword">if</span> diff &lt; FINISHED_LIMIT <span class="keyword">and</span> diff_last &lt; FINISHED_LIMIT:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        diff_last = diff</span><br><span class="line">        max_last = max_current</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始染色体样态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    chromosome_state1 = <span class="string">&#x27;100100&#x27;</span></span><br><span class="line">    chromosome_state2 = <span class="string">&#x27;101010&#x27;</span></span><br><span class="line">    chromosome_state3 = <span class="string">&#x27;010101&#x27;</span></span><br><span class="line">    chromosome_state4 = <span class="string">&#x27;101011&#x27;</span></span><br><span class="line">    chromosome_states = [chromosome_state1,</span><br><span class="line">                         chromosome_state2,</span><br><span class="line">                         chromosome_state3,</span><br><span class="line">                         chromosome_state4]</span><br><span class="line">    <span class="keyword">return</span> chromosome_states</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算适应度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span>(<span class="params">chromosome_states</span>):</span></span><br><span class="line">    fitnesses = []</span><br><span class="line">    <span class="keyword">for</span> chromosome_state <span class="keyword">in</span> chromosome_states:</span><br><span class="line">        value_sum = <span class="number">0</span></span><br><span class="line">        weight_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(chromosome_state):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(v) == <span class="number">1</span>:</span><br><span class="line">                weight_sum += X[i + <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                value_sum += X[i + <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        fitnesses.append([value_sum, weight_sum])</span><br><span class="line">    <span class="keyword">return</span> fitnesses</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">chromosome_states, fitnesses</span>):</span></span><br><span class="line">    <span class="comment"># 重量大于80的被淘汰</span></span><br><span class="line">    index = <span class="built_in">len</span>(fitnesses) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> fitnesses[index][<span class="number">1</span>] &gt; WEIGHT_LIMIT:</span><br><span class="line">            chromosome_states.pop(index)</span><br><span class="line">            fitnesses.pop(index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遴选</span></span><br><span class="line">    selected_index = [<span class="number">0</span>] * <span class="built_in">len</span>(chromosome_states)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(SELECT_NUMBER):</span><br><span class="line">        j = chromosome_states.index(random.choice(chromosome_states))</span><br><span class="line">        selected_index[j] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> selected_index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生下一代</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossover</span>(<span class="params">chromosome_states, selected_index</span>):</span></span><br><span class="line">    chromosome_states_new = []</span><br><span class="line">    index = <span class="built_in">len</span>(chromosome_states) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        chromosome_state = chromosome_states.pop(index)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(selected_index[index]):</span><br><span class="line">            chromosome_state_x = random.choice(chromosome_states)</span><br><span class="line">            pos = random.choice(<span class="built_in">range</span>(<span class="number">1</span>, CHROMOSOME_SIZE - <span class="number">1</span>))</span><br><span class="line">            chromosome_states_new.append(</span><br><span class="line">                chromosome_state[:pos] + chromosome_state_x[pos:])</span><br><span class="line">        chromosome_states.insert(index, chromosome_state)</span><br><span class="line">    <span class="keyword">return</span> chromosome_states_new</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 初始群体</span></span><br><span class="line">    chromosome_states = init()</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 适应度计算</span></span><br><span class="line">        fitnesses = fitness(chromosome_states)</span><br><span class="line">        <span class="keyword">if</span> is_finished(fitnesses):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;1:&#x27;</span>, fitnesses)</span><br><span class="line">        <span class="comment"># 遴选</span></span><br><span class="line">        selected_index = <span class="built_in">filter</span>(chromosome_states, fitnesses)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;2:&#x27;</span>, selected_index)</span><br><span class="line">        <span class="comment"># 产生下一代</span></span><br><span class="line">        chromosome_states = crossover(chromosome_states, selected_index)</span><br><span class="line">        <span class="comment"># print &#x27;3:&#x27;, chromosome_states</span></span><br><span class="line"></span><br><span class="line">    fitnesses = fitness(chromosome_states)</span><br><span class="line">    <span class="built_in">print</span>(chromosome_states)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[60, 35], [105, 60], [140, 75], [175, 95]]</span></span><br><span class="line"><span class="comment"># 2: [1, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[60, 35], [105, 60], [80, 45], [90, 50]]</span></span><br><span class="line"><span class="comment"># 2: [2, 1, 0, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[95, 55], [115, 65], [70, 40], [90, 50]]</span></span><br><span class="line"><span class="comment"># 2: [2, 0, 2, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[70, 40], [70, 40], [150, 85], [115, 65]]</span></span><br><span class="line"><span class="comment"># 2: [3, 0, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[115, 65], [115, 65], [115, 65], [70, 40]]</span></span><br><span class="line"><span class="comment"># 2: [2, 0, 0, 2]</span></span><br><span class="line"><span class="comment"># [&#x27;100110&#x27;, &#x27;100110&#x27;, &#x27;100110&#x27;, &#x27;100110&#x27;]</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="示例二：凸函数最大值"><a href="#示例二：凸函数最大值" class="headerlink" title="示例二：凸函数最大值"></a>示例二：凸函数最大值</h2><p>函数优化是遗传算法的经典应用领域，也是遗传算法进行性能评价的常用算例，许多人构造出了各种各样复杂形式的测试函数：连续函数和离散函数、凸函数和凹函数、低维函数和高维函数、单峰函数和多峰函数等。对于一些非线性、多模型、多目标的函数优化问题，用其它优化方法较难求解，而遗传算法可以方便的得到较好的结果。</p><p><strong>场景</strong></p><p>x∈[-10, 10], y∈[-10, 10]时，求二元函数 <code>z(x,y) = y*sin(x) + x*cos(y)</code> 的最大值点，使用matlab绘制图像如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-10</span>:<span class="number">0.01</span>:<span class="number">10</span>);</span><br><span class="line">z = y.*<span class="built_in">sin</span>(x)+x.*<span class="built_in">cos</span>(y);</span><br><span class="line">mesh(x,y,z),xlabel(<span class="string">&#x27;x&#x27;</span>),ylabel(<span class="string">&#x27;y&#x27;</span>),zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219083829.png" alt="image-20220219083829525" style="zoom: 20%;" /><p><strong>编码</strong></p><p>计算机无法处理连续值，为了确保准确性和离散性，对x、y的取值精确到3位小数，以0.001为最小粒度。因此x和y从-10.000变化到10.000各自总共20001个离散取值，因为<code>2^14 &lt; 20001 &lt; 2^15</code>，所以编码为15位二进制值。同时为了保证一一映射和满射，具体编码映射方式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220219083445.png" alt="image-20220217110053767" style="zoom:60%;" /><center>h为实际值，m为编码值</center><p>注意，这里的编码和上例不同，不再是独热向量。这就导致在基因重组和突变时，不同交叉点和突变位对个体产生的变化影响大小是不等的，越靠左的位影响越大。</p><p><strong>初始种群</strong></p><p>随机选取8个：</p><table><thead><tr><th>个体</th><th>X基因</th><th>Y基因</th></tr></thead><tbody><tr><td>1</td><td>000000100101001</td><td>101010101010101</td></tr><tr><td>2</td><td>011000100101100</td><td>001100110011001</td></tr><tr><td>3</td><td>001000100100101</td><td>101010101010101</td></tr><tr><td>4</td><td>000110100100100</td><td>110011001100110</td></tr><tr><td>5</td><td>100000100100101</td><td>101010101010101</td></tr><tr><td>6</td><td>101000100100100</td><td>111100001111000</td></tr><tr><td>7</td><td>101010100110100</td><td>101010101010101</td></tr><tr><td>8</td><td>100110101101000</td><td>000011110000111</td></tr></tbody></table><p>注意，因为这个场景中，可以看见函数图像里有很多凸点，会导致某部分个体集中在次优解，而少数个体在最优解的半山腰处反而不如次优解从而提前被淘汰。为了规避这种现象，可以增大种群初始规模（个体数量）和分布均匀度。</p><p><strong>适性度</strong></p><p>即：<code>z(x,y) = y*sin(x) + x*cos(y)</code></p><p><strong>遗传</strong></p><p>与上例不同，这里先基因重组，重组后再依照适性值随机选取。</p><table><thead><tr><th>个体</th><th>X基因</th><th>Y基因</th><th>重组后X</th><th>重组后Y</th></tr></thead><tbody><tr><td>1</td><td>000000100101001</td><td>101010101010101</td><td>000000100101100</td><td>101010110011001</td></tr><tr><td>2</td><td>011000100101100</td><td>001100110011001</td><td>011000100101001</td><td>001100101010101</td></tr></tbody></table><p>如上所示，8个个体两两配对，产生C8_2 = 56种子代个体，计算它们各自的适性值，然后选出8个进入下一轮遗传。</p><p><strong>迭代至收敛</strong></p><p>相隔两代的适性函数最大值相差小于1即判断为收敛</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 极大值问题</span></span><br><span class="line"><span class="comment"># 染色体 基因X 基因Y</span></span><br><span class="line">X = [</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&#x27;000000100101001&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">&#x27;011000100101100&#x27;</span>, <span class="string">&#x27;001100110011001&#x27;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">&#x27;001000100100101&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="string">&#x27;000110100100100&#x27;</span>, <span class="string">&#x27;110011001100110&#x27;</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="string">&#x27;100000100100101&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="string">&#x27;101000100100100&#x27;</span>, <span class="string">&#x27;111100001111000&#x27;</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="string">&#x27;101010100110100&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>],</span><br><span class="line">    [<span class="number">8</span>, <span class="string">&#x27;100110101101000&#x27;</span>, <span class="string">&#x27;000011110000111&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 染色体长度</span></span><br><span class="line">CHROMOSOME_SIZE = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断退出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_finished</span>(<span class="params">last_three</span>):</span></span><br><span class="line">    s = <span class="built_in">sorted</span>(last_three)</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">and</span> s[<span class="number">2</span>] - s[<span class="number">0</span>] &lt; <span class="number">0.01</span> * s[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始染色体样态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    chromosome_state1 = [<span class="string">&#x27;000000100101001&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>]</span><br><span class="line">    chromosome_state2 = [<span class="string">&#x27;011000100101100&#x27;</span>, <span class="string">&#x27;001100110011001&#x27;</span>]</span><br><span class="line">    chromosome_state3 = [<span class="string">&#x27;001000100100101&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>]</span><br><span class="line">    chromosome_state4 = [<span class="string">&#x27;000110100100100&#x27;</span>, <span class="string">&#x27;110011001100110&#x27;</span>]</span><br><span class="line">    chromosome_state5 = [<span class="string">&#x27;100000100100101&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>]</span><br><span class="line">    chromosome_state6 = [<span class="string">&#x27;101000100100100&#x27;</span>, <span class="string">&#x27;111100001111000&#x27;</span>]</span><br><span class="line">    chromosome_state7 = [<span class="string">&#x27;101010100110100&#x27;</span>, <span class="string">&#x27;101010101010101&#x27;</span>]</span><br><span class="line">    chromosome_state8 = [<span class="string">&#x27;100110101101000&#x27;</span>, <span class="string">&#x27;000011110000111&#x27;</span>]</span><br><span class="line">    chromosome_states = [chromosome_state1,</span><br><span class="line">                         chromosome_state2,</span><br><span class="line">                         chromosome_state3,</span><br><span class="line">                         chromosome_state4,</span><br><span class="line">                         chromosome_state5,</span><br><span class="line">                         chromosome_state6,</span><br><span class="line">                         chromosome_state7,</span><br><span class="line">                         chromosome_state8]</span><br><span class="line">    <span class="keyword">return</span> chromosome_states</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算适应度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span>(<span class="params">chromosome_states</span>):</span></span><br><span class="line">    fitnesses = []</span><br><span class="line">    <span class="keyword">for</span> chromosome_state <span class="keyword">in</span> chromosome_states:</span><br><span class="line">        <span class="keyword">if</span> chromosome_state[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            x = <span class="number">10</span> * (-<span class="built_in">float</span>(<span class="built_in">int</span>(chromosome_state[<span class="number">0</span>][<span class="number">1</span>:], <span class="number">2</span>) - <span class="number">1</span>)/<span class="number">16384</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = <span class="number">10</span> * (<span class="built_in">float</span>(<span class="built_in">int</span>(chromosome_state[<span class="number">0</span>], <span class="number">2</span>) + <span class="number">1</span>)/<span class="number">16384</span>)</span><br><span class="line">        <span class="keyword">if</span> chromosome_state[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            y = <span class="number">10</span> * (-<span class="built_in">float</span>(<span class="built_in">int</span>(chromosome_state[<span class="number">1</span>][<span class="number">1</span>:], <span class="number">2</span>) - <span class="number">1</span>)/<span class="number">16384</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = <span class="number">10</span> * (<span class="built_in">float</span>(<span class="built_in">int</span>(chromosome_state[<span class="number">1</span>], <span class="number">2</span>) + <span class="number">1</span>)/<span class="number">16384</span>)</span><br><span class="line">        z = y * math.sin(x) + x * math.cos(y)</span><br><span class="line">        <span class="built_in">print</span>(x, y, z)</span><br><span class="line">        fitnesses.append(z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fitnesses</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span>(<span class="params">chromosome_states, fitnesses</span>):</span></span><br><span class="line">    <span class="comment"># top 8 对应的索引值</span></span><br><span class="line">    chromosome_states_new = []</span><br><span class="line">    top1_fitness_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.argsort(fitnesses)[::-<span class="number">1</span>][:<span class="number">8</span>].tolist():</span><br><span class="line">        chromosome_states_new.append(chromosome_states[i])</span><br><span class="line">        top1_fitness_index = i</span><br><span class="line">    <span class="keyword">return</span> chromosome_states_new, top1_fitness_index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生下一代</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossover</span>(<span class="params">chromosome_states</span>):</span></span><br><span class="line">    chromosome_states_new = []</span><br><span class="line">    <span class="keyword">while</span> chromosome_states:</span><br><span class="line">        chromosome_state = chromosome_states.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> chromosome_states:</span><br><span class="line">            pos = random.choice(<span class="built_in">range</span>(<span class="number">8</span>, CHROMOSOME_SIZE - <span class="number">1</span>))</span><br><span class="line">            chromosome_states_new.append(</span><br><span class="line">                [chromosome_state[<span class="number">0</span>][:pos] + v[<span class="number">0</span>][pos:], chromosome_state[<span class="number">1</span>][:pos] + v[<span class="number">1</span>][pos:]])</span><br><span class="line">            chromosome_states_new.append(</span><br><span class="line">                [v[<span class="number">0</span>][:pos] + chromosome_state[<span class="number">1</span>][pos:], v[<span class="number">0</span>][:pos] + chromosome_state[<span class="number">1</span>][pos:]])</span><br><span class="line">    <span class="keyword">return</span> chromosome_states_new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基因突变</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutation</span>(<span class="params">chromosome_states</span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="number">5.0</span> / <span class="number">100</span> * <span class="built_in">len</span>(chromosome_states))</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        chromosome_state = random.choice(chromosome_states)</span><br><span class="line">        index = chromosome_states.index(chromosome_state)</span><br><span class="line">        pos = random.choice(<span class="built_in">range</span>(<span class="built_in">len</span>(chromosome_state)))</span><br><span class="line">        x = chromosome_state[<span class="number">0</span>][:pos] + \</span><br><span class="line">            <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="keyword">not</span> <span class="built_in">int</span>(chromosome_state[<span class="number">0</span>][pos]))</span><br><span class="line">                ) + chromosome_state[<span class="number">0</span>][pos+<span class="number">1</span>:]</span><br><span class="line">        y = chromosome_state[<span class="number">1</span>][:pos] + \</span><br><span class="line">            <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="keyword">not</span> <span class="built_in">int</span>(chromosome_state[<span class="number">1</span>][pos]))</span><br><span class="line">                ) + chromosome_state[<span class="number">1</span>][pos+<span class="number">1</span>:]</span><br><span class="line">        chromosome_states[index] = [x, y]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chromosome_states = init()</span><br><span class="line">    last_three = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">    last_num = <span class="number">0</span></span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        chromosome_states = crossover(chromosome_states)</span><br><span class="line">        mutation(chromosome_states)</span><br><span class="line">        fitnesses = fitness(chromosome_states)</span><br><span class="line">        chromosome_states, top1_fitness_index = <span class="built_in">filter</span>(</span><br><span class="line">            chromosome_states, fitnesses)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---------%d-----------&#x27;</span> % n)</span><br><span class="line">        <span class="built_in">print</span>(chromosome_states)</span><br><span class="line">        last_three[last_num] = fitnesses[top1_fitness_index]</span><br><span class="line">        <span class="built_in">print</span>(fitnesses[top1_fitness_index])</span><br><span class="line">        <span class="keyword">if</span> is_finished(last_three):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> last_num &gt;= <span class="number">2</span>:</span><br><span class="line">            last_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;100100&#x27;, &#x27;101010&#x27;, &#x27;010101&#x27;, &#x27;101011&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1: [[60, 35], [105, 60], [140, 75], [175, 95]]</span></span><br><span class="line"><span class="comment"># 2: [0, 2, 2]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1: [[60, 35], [60, 35], [80, 45], [125, 70]]</span></span><br><span class="line"><span class="comment"># 2: [3, 0, 1, 0]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1: [[80, 45], [60, 35], [60, 35], [140, 80]]</span></span><br><span class="line"><span class="comment"># 2: [1, 2, 0, 1]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1: [[70, 40], [70, 40], [70, 40], [85, 50]]</span></span><br><span class="line"><span class="comment"># 2: [3, 0, 0, 1]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1: [[70, 40], [70, 40], [70, 40], [95, 55]]</span></span><br><span class="line"><span class="comment"># 2: [4, 0, 0, 0]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1: [[70, 40], [70, 40], [70, 40], [70, 40]]</span></span><br><span class="line"><span class="comment"># 2: [4, 0, 0, 0]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [&#x27;100010&#x27;, &#x27;100010&#x27;, &#x27;100010&#x27;, &#x27;100010&#x27;]</span></span><br><span class="line"><span class="comment"># [[70, 40], [70, 40], [70, 40], [70, 40]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 优化问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于机器学习的5G网络切片资源调度算法</title>
      <link href="/2022/02/14/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%915G%20network%20slices%20resource%20orchestration%20using%20Machine%20Learning%20techniques/"/>
      <url>/2022/02/14/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%915G%20network%20slices%20resource%20orchestration%20using%20Machine%20Learning%20techniques/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;为了有效地满足数据速率、可靠性、延迟和移动性方面的异构需求，网络运营商必须优化其基础设施资源的利用率。在这种背景下，文章提出了一个框架，通过利用机器学习 (ML) 技术来协调 5G 网络的资源。</p><p>&emsp;&emsp;首先将资源需求分类为组，以便通过专用逻辑虚拟网络或网络切片 (NS) 充分服务它们。为了优化实现这些共享相同基础设施的异构 NS，文章开发了一种新的物理资源块 (PRB) 动态切片方法。首先提出了一种预测方法，以从有限的资源池中实现 PRB 的最佳切片决策。另一方面，文章设计了一个准入控制器和一个切片调度器，并将它们形式化为背包问题。最后利用深度强化学习 (DRL) 设计了一个自适应资源管理器。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214140053.png" alt="image-20220214103608117" style="zoom:50%;" /><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/5G%20network%20slices%20resource%20orchestration%20using%20Machine%20Learning%20techniques.pdf">5G network slices resource orchestration using Machine Learning techniques</a></p><span id="more"></span><p>&nbsp;</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;未来移动网络将提供三类服务：增强型移动宽带 (eMBB)、大规模机器类型通信 (mMTC) 和超可靠低延迟通信 (uRLLC) 。根据第三代合作伙伴项目 (3GPP) 的一份可行性研究技术报告，每个类别（eMBB、mMTC 和 URLLC）在吞吐量、移动性、可靠性、延迟、能源效率方面都有其独特的要求，此外还具有不同的连接性和流量密度。为了使成本保持在可承受范围内，移动网络运营商必须优化其资源以满足所有这些异构需求。但是资源具有自然稀缺性，无论是外部（频谱和电力）还是基础设施（计算、网络和存储）。通过两种支持技术：软件定义网络 (SDN) 和网络功能虚拟化 (NFV)，网络切片 (NS)成为了一种解决方案，即提供专用逻辑网络，以确保所需的服务质量（服务质量）。</p><h3 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h3><p>&emsp;&emsp;第一步是对请求进行分类。特别地，文章考虑了QCI来为使每种类型的流量与定制的 NS 支持的服务类别相关联。NS 是经过优化的微调切片，可在满足底层系统约束的同时最大限度地提高服务水平目标。文章通过切片比率表示无线接入网络 (RAN) 中物理资源块 (PRB) 的数量，这些块在实例化切片之间进行划分。为了提供端到端 (E2E) QoS 网络设计，文章的系统模型分为四个功能块，包括：</p><ul><li>需求分类</li><li>最佳切片比率预测</li><li>准入控制与调度相结合</li><li>适应性资源管理</li></ul><p>&emsp;&emsp;文章的目标是解决 5G 网络切片的资源编排问题。资源编排是关于有效地消耗可用的稀缺资源，将它们简化为功能，并利用这些功能通过优化的性能来创造附加值。文章提出的资源编排过程如下：</p><p>&emsp;&emsp;在需求分类之后，文章解决了从由底层系统容量限制的有限资源池中预测共享资源的几个 NS 的最佳切片比率。为此，文章首先建议采用机器学习技巧，特别是用于需求分类和切片比率预测的回归树 (RT)。因为RT 是使用分支方法来说明决策的每个可能结果的图。</p><p>&emsp;&emsp;然后，文章为自适应资源管理器提出了深度强化学习 (DRL) 实施方案，使用实验性 5G 原型 [4] 验证了此的提议，该原型被实现为基于 OpenAirInterface™(OAI) [5] 和 Docker [6] 容器的面向微服务的架构。具体来说，文章配置多个切片，生成一个数据集并对几个 ML 模型以及两个基线解决方案（即静态切片和不知情的随机切片决策）的性能进行基准测试。将真实情况与切片比率的预测值进行比较，并使用四个不同的指标分析资源编排的效果：上行链路 PRB 的数量、缓冲区状态报告 (BSR)、系统利用率和网络吞吐量。</p><p>论文的主要贡献主要包括：</p><ol><li>全面回顾了 5G 网络切片资源编排的最新技术</li><li>设计了一个由四个构建块组成的资源编排框架</li><li>提供公式、模型和算法来实现这些构建块：<ul><li>使用 ML 技术进行分类</li><li>基于 RT 预测切片比率</li><li>将准入控制和调度建模为背包优化问题</li><li>利用 DRL 进行自适应资源管理。 </li></ul></li><li>使用基于OAI 的5G 实验原型展示了模型的有效性，包括地面实况测量和其他指标，即UL PRB、BSR、系统中央处理器（CPU）利用率和网络吞吐量。</li></ol><h3 id="领域研究"><a href="#领域研究" class="headerlink" title="领域研究"></a>领域研究</h3><h4 id="分类和切片方法"><a href="#分类和切片方法" class="headerlink" title="分类和切片方法"></a>分类和切片方法</h4><table><thead><tr><th>论文</th><th>工作</th></tr></thead><tbody><tr><td>SDN/NFV, machine learning, and big data driven network slicing for 5G</td><td>提出了一个集成各种 ML 算法、SDN 和 NFV 的框架，使用流量分类模块和网络切片来实现自组织网络。但没有考虑准入控制和调度过程。</td></tr><tr><td>On multi-domain network slicing orchestration architecture and federated resource control</td><td>研究了一种包含 SDN 和 NFV 的管理和编排架构，用于实例化和管理联合网络切片。但没有解决在符合 3GPP 的测试平台中对此类架构的验证</td></tr><tr><td>Deep reinforcement learning for mobile 5G: Fundamentals, applications and challengs</td><td>使用基于 DRL 的方法来允许网络实体了解网络，旨在做出与 5G 中的网络切片相关的最佳决策。但没有提供实施细节。</td></tr><tr><td>M2EC: A multi-tenant resource orchestration in multi-access edge computing</td><td>提出了一种多访问边缘计算代理，用于在网络切片环境中满足异构租户需求和相关特权。设计了一种编排机制，能够在满足租户请求的同时避免违反服务水平协议 (SLA)。</td></tr></tbody></table><h4 id="流量和资源预测方法"><a href="#流量和资源预测方法" class="headerlink" title="流量和资源预测方法"></a>流量和资源预测方法</h4><table><thead><tr><th>论文</th><th>工作</th></tr></thead><tbody><tr><td>A supervised learning based QoS assurance architecture for 5G networks</td><td>提出了一种基于决策树 (DT) 的有监督 ML 模型，用于对 QoS 降级进行根本原因分析</td></tr><tr><td>Feature-Selection based data prioritization in traffic prediction using machine learning</td><td>使用基于特征选择的优先级来预测移动流量，用了大数据挑战中的开放数据集。但没有考虑服务器的自适应资源管理。</td></tr><tr><td>Modeling oscillation behavior of network traffic by nested hidden Markov model with variable state-duration</td><td>使用随机模型来表示时间序列数据，使用分层隐马尔可夫模型，该模型包括两个嵌套的隐马尔可夫链和一个可观察的过程。</td></tr><tr><td>Dynamic resource prediction and allocation for cloud data center using the multiobjective genetic algorithm</td><td>提出了一种多目标遗传算法来优化资源分配，同时最小化 CPU 和内存利用率以及能源消耗。根据历史时隙预测资源需求以及虚拟机 (VM) 的位置。</td></tr><tr><td>[16]~[22]</td><td>使用基于机器学习的方法进行时间序列预测：树、KNN、CART、随机森林、支持向量机、高斯回归</td></tr></tbody></table><h4 id="任务控制和调度优化方法"><a href="#任务控制和调度优化方法" class="headerlink" title="任务控制和调度优化方法"></a>任务控制和调度优化方法</h4><table><thead><tr><th>论文</th><th>工作</th></tr></thead><tbody><tr><td>OVNES: Demonstrating 5G network slicing overbooking on real deployments</td><td>提出了测试平台 OVNES（超额预订网络切片），收集网络统计数据，通过 ML 预测流量行为，并应用准入控制策略来选择请求以提高网络效率和调度。但没有提供这些模块的详细实施。</td></tr><tr><td>Overbooking network slices through yield-driven end-to-end orchestration</td><td>设计了一个分层控制平面来管理切片的 E2E 编排。将编排问题表述为随机收益管理问题，并提出了最优和启发式方法。</td></tr><tr><td>Intelligent resource scheduling for 5G radio access network slicing</td><td>提出了一种利用深度学习和强化学习的协作学习框架的 5G RAN 智能资源调度策略</td></tr><tr><td>A machine learning approach to 5G infrastructure market optimization</td><td>设计了一种网络切片准入控制算法，利用 ML 学习最佳接受策略，同时满足对租户的服务保证。提供了分析切片可否受理的模型，使用半马尔可夫决策过程分析系统，并使用实用的ML方法优化了优势。</td></tr><tr><td>Procuring spontaneous session-level resource guarantees for real-time applications: An auction approach</td><td>提出了一种使用多单元组合拍卖模型的准入控制算法，以确定快速获胜者，在使用性能保留时。他们开发了一种基于强化学习的实用性最大化策略，可在租户分发资源。</td></tr><tr><td>Deep reinforcement learning applicationfor network latency management in software defined networks</td><td>提出了一种基于DRL的方法，用于在SDN上下文中优化网络延迟。</td></tr></tbody></table><h4 id="自适应资源管理方法"><a href="#自适应资源管理方法" class="headerlink" title="自适应资源管理方法"></a>自适应资源管理方法</h4><table><thead><tr><th>论文</th><th>工作</th></tr></thead><tbody><tr><td>On the configuration of radio resource management in sliced RAN</td><td>提出了一种使用静态切片比例在切片RAN中配置无线电资源管理的框架。评估了不同类型切片的每个数据无线承载的阻塞速率和吞吐量。</td></tr><tr><td>Mobile traffic forecasting for maximizing 5G network slicing resource utilization</td><td>为网络切片设计了三个关键构建块，即预测模块、准入控制代理、调度程序，使用Holt-Winers方法进行流量预测。</td></tr><tr><td>Network traffic prediction and result analysis based on seasonal ARIMA and correlation coefficient</td><td>使用季节性自动回归移动平均（Sarima）进行预测，但在时间序列趋势中存在异常增长或放缓时效果不好。</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>&emsp;&emsp;网络切片编排器的系统设计如图1所示，包含3GPP技术规范的内联，详细说明了网络共享和管理架构的概念和要求[33]。</p><p>&emsp;&emsp;在守门人（GateKeeper）模块完成租户需求的分类之后，租户流量概况以及分类需求用于预测每个分类需求的适当切片比率。然后是准入控制、资源管理和调度过程。对于一个服务实例，首先获取其网络特性（例如频谱效率，延迟，可靠性和能效）方面对切片的要求[34]。使用监督学习ML进行分类[35]。决策者（Decision Maker）模块由两个子模块组成：基于ML回归的切片预测器、根据当前和预测的负载来授权或拒绝资源请求的准入控制器。准入控制器预计会有两种结果：授权的请求转发到切片调度器（Slice Scheduler）以在最近的时间窗口中提供服务；拒绝的请求将发送到自适应资源管理器（Resource Manager）以训练其资源管理能力。通过实现自动流量控制系统来使用DRL，从而有效实现高资源利用率并最大化吞吐量。切片调度程序为决策者提供了反馈，以关闭优化循环并提供推迟的请求。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214140053.png" alt="image-20220214103608117" style="zoom:50%;" /><center>图 1 5G网络切片资源编排系统框图</center><h3 id="守门人模型"><a href="#守门人模型" class="headerlink" title="守门人模型"></a>守门人模型</h3><p>&emsp;&emsp;如图1所示，设置了需求分类的初始阶段，用作编排器的输入。为每种用例量身定制网络切片以满足其要求是不切实际的。相反，一个简单的方法是聚合每个切片类型的流量。表1显示了蓝图和SLA [36]报告中对部分QoS流量的要求。例如，当流量类𝑙= 3时，QCI = 65具有保证比特率（GBR）承载类型，延迟预算= 10毫秒，丢包容差= 10^-2，以及0.7的优先级，由此可知<code>关键任务至关重要推动谈话服务</code>（MCPTT）适用此要求[36]。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214111002.png" alt="image-20220214111002434" style="zoom:60%;" /><center>表 1</center><p>&emsp;&emsp;租户 h 在时间 <code>(t)</code> 内对流量的需求用 <code>r_h(t)</code> 表示，过程中的每一个实例（或事件） <code>ξ</code> 定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214111456.png" alt="image-20220214111456621" style="zoom:40%;" /><p>，构成特征向量，其中 <code>δ</code> 表示狄拉克函数。</p><p>&emsp;&emsp;使用[37]中阐述的分类公式，用 <code>𝑘</code> 表示一个可能的类别，用 <code>𝛼𝑘</code> 表示相应权重向量的转置。权重向量是在训练阶段计算的一组参数，用以对训练集进行正确分类并最大化评价函数。这里的分类问题包括通过使用点积将实例的特征向量与其相关权重向量相乘，为每个可能的类别 𝑘 分配一个分数。所选择的类别将是通过将实例 ℎ 分配给类别 𝑘 而产生的具有最高效用的类别。效用函数定义如下</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214105948.png" alt="image-20220214105948677" style="zoom:40%;" /><p>该公式适用于多种分类技术，包括回归树。使用二进制递归分区建立回归树，是一个迭代过程，将数据拆分为分区或分支。然后，随着方法通过每个分支移动，继续将每个分区分成较小的组[17]。</p><h3 id="决策者模型"><a href="#决策者模型" class="headerlink" title="决策者模型"></a>决策者模型</h3><h4 id="预测感知切片器"><a href="#预测感知切片器" class="headerlink" title="预测感知切片器"></a>预测感知切片器</h4><p>&emsp;&emsp;流量配置文件是基于在分析时间窗口内收集的数据的网络流量图。可作为编排器的输入，用于决策制定过程。合并的流量配置文件作为决策者的输入，然后 预测感知切片器（forecast aware slicer）预测不同切片的最佳切片比率，以便为切片过程提供良好的起点。因此在这个模块中，从丰富的历史流量剖面中提取的多个预测变量，即：时间戳、星期几、计划事件存在和多云条件环境因素，来预测切片比率的最佳值。注意，多云条件和其他环境因素以两种方式影响切片预测。从技术角度来看：无线电传播通常会受到空气中水分含量的影响，因为水往往会吸收电磁波，从而降低无线系统的范围和带宽。从生态学的角度来看：多云条件通常伴随着流动性的下降。因此，用户倾向于更频繁地使用他们的数据连接。因此，对无线电资源的需求通常会增加。</p><p>&emsp;&emsp;为了选择最佳性能预测技术，文章评估了包括 RT 在内的几种方法。用 <code>𝑋 = (𝑥1,𝑥2,... ,𝑥𝑛)′ ∈ R𝑛</code> 表示，一个由 𝑛 维预测变量，用 <code>𝑦 ∈ R</code> 表示一个标量输出，表示响应变量；文章制定的回归模型如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214123050.png" alt="image-20220214123050531" style="zoom:40%;" /><p>其中 <code>𝑒</code> 是一个独立的随机噪声，涉及响应变量 <code>𝑦</code> 和预测变量 <code>𝑥𝑖</code> 之间的统计关系，允许非完美的确定性关系。参数 <code>𝛽 = (𝛽1,𝛽2,... ,𝛽𝑛)′</code> 是 𝑛 维未知向量，在训练期间基于所选回归模型通过最小化 <code>误差平方和 (𝑆)</code> 进行评估，即损失函数。具体到生成回归树的目标函数就是：最小化回归树 T 上所有叶子 𝑐 的误差平方和：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214123110.png" alt="image-20220214123110799" style="zoom:40%;" /><p>其中 <code>𝑚𝑐</code> 是对有nc个叶子节点的节点的预测值，这里与回归树算法中保持一致，都是取平均值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214124723.png" alt="image-20220214124723080" style="zoom: 40%;" /><h4 id="回归树的生成算法"><a href="#回归树的生成算法" class="headerlink" title="回归树的生成算法"></a>回归树的生成算法</h4><p>&emsp;&emsp;文章提出了一种简单而有效的算法来递归生成回归树。从包含所有 (M) 个点的当前节点开始，计算节点预测值 <code>𝑚𝑐</code> 和成本函数 <code>S</code> 。递归终止条件是当前节点内的样本类别全部相同。每次分叉的特征选择依据是能够减小分叉后的成本函数 <code>S</code> ，分叉的预剪枝要求：</p><ul><li>分叉后成本函数 <code>S</code> 变化值不大于 𝜀0，则不分叉</li><li>分叉后的叶子节点内样本数少于 𝑞个，则不分叉</li></ul><p>如此生成的回归树能够用来预测适当的切片比率，用作拆分 PRB 的起点。之后是准入控制器部分。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214123239.png" alt="image-20220214123239595" style="zoom:50%;" /><h3 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a>准入控制器</h3><p>&emsp;&emsp;准入控制器接收需要调度的请求。根据当前系统负载 (𝑙) 并结合 预测感知切片器 生成的数据支持，按优先级（见表1）决定批准还是拒绝每个单独的请求。</p><p>&emsp;&emsp;授权的请求会发送到切片调度器，同时将观测内容发给资源管理器，令其进行强化学习。因此，对于高优先级的资源请求，考虑到底层系统的能力和其他基础设施资源的可用性，可以进行池的重新划分以减少拒绝服务的机会。</p><h4 id="场景建模"><a href="#场景建模" class="headerlink" title="场景建模"></a>场景建模</h4><p>&emsp;&emsp;在时刻 <code>t</code>，假设 <code>𝑥𝑖𝑗</code> 表示一个二元决策变量（布尔值），表示请求 <code>𝑗</code> 是否由切片 <code>𝑖</code> 提供服务并允许进入系统。索引变量 <code>𝑛</code> 和 <code>𝑚</code> 分别表示请求数和切片数。对每个被授权的请求 𝑗 定义值 <code>𝑣𝑗</code> ，反映其个人收入 <code>𝑣𝑖</code> 对应的消耗资源量。假设切片租户支付与消耗的资源相对应的货币金额。简单起见，这里不讨论多租户环境的特定定价。</p><p>&emsp;&emsp;主要云服务提供商在线提供了几种模型，例如 Google Cloud Provider (GCP) [38] 或 Amazon Web Services (AWS) [39]。文章将准入控制器问题形式化为 <code>D维多项选择背包问题</code>，该问题受主机系统容量施加的 𝐷 约束。数学模型如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214130037.png" alt="image-20220214130037036" style="zoom:35%;" /><ul><li>(4a) 中的目标函数旨在最大化资源利用所产生的价值</li><li>(4b) 根据 𝐷 容量反映了与需求有关的基础设施计算资源的约束不等式</li><li>(4c) 是排他性的约束不等式。</li><li>(4d) 是对 <code>xij</code> 布尔性的约束。</li></ul><p>这个数学场景是 NP-hard 问题[40]，可以使用 [41] 中列出的多项式时间算法来求解：</p><h4 id="D-MCKP-算法"><a href="#D-MCKP-算法" class="headerlink" title="D-MCKP 算法"></a>D-MCKP 算法</h4><p>&emsp;&emsp;该过程首先对计算资源的约束进行排序，以识别瓶颈约束。瓶颈约束是指在解决映射问题时首先消耗的多项选择背包问题 (D-MCKP) 的 D 维度中最紧的维度，这种瓶颈的索引表示为 <code>𝑑∗</code>。拒绝任何无法满足要求的网络切片请求。然后计算每个请求的效率（效率定义为每个请求的网络资源利用率值 <code>𝑣</code> 与瓶颈约束值 <code>𝐶</code>（𝑑∗）之间的比率）。然后从效率最高的请求开始降序排序。重复此过程是为了包括满足资源限制的附加请求。一旦不再满足请求，算法就会停止，得到最终的网络资源利用率以及要服务的所选切片请求集。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214130125.png" alt="image-20220214130125369" style="zoom:50%;" /><h3 id="切片调度器"><a href="#切片调度器" class="headerlink" title="切片调度器"></a>切片调度器</h3><p>&emsp;&emsp;一旦准入控制器将需求映射到网络切片，该映射就会被发送给切片调度器，以在最短的时间内正确地满足相应的需求。用 <code>𝑝𝑗</code> 表示在 <code>𝑛</code> 请求中传输请求 <code>𝑗</code> 的处理时间，这样它的时间跨度是<code>𝑐_𝑗_𝑡</code>。注意，当考虑基于微服务的架构部署时，处理时间与处理节点的处理能力无关，因为每个微服务都是原子的，并且类似于它的任何副本[43]。这里的问题在于找到一个最小化总持续时间的时间表。定义一个二元决策变量 <code>𝑧_𝑗_𝑡</code> 来指示请求 <code>𝑗</code> 是否被安排在时间窗口（𝜏）中。由此，切片调度器可以形式化为如下优化问题：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214132802.png" alt="image-20220214132802822" style="zoom:35%;" /><p>假设实现切片的主机容量有限并且最多可以同时处理最多 <code>𝑁</code> 请求，约束 (5b) 规定在时间窗口 (𝜏) 期间，最多可以执行 𝑁 请求。约束 (5c) 确保每个请求只需要安排一次。最后，约束 (5d) 规定每个请求应在当前时间窗口 𝜏 中提供服务或推迟到下一个时间窗口。</p><p>注意，𝜏 必须与请求的服务质量配置文件（即表1）中延迟预算项的最低粒度一致。在文章的例子中取 𝜏 为 100 毫秒。</p><p>&emsp;&emsp;因为这里的模型和上面准入控制器相似，都是 NP-hard 问题[40] 并且对应于背包问题，是 D-MCKP 的一个特例。因此也可以用上面提出的算法，在多项式时间内求解此问题。这里 D 等于 1。</p><h3 id="资源管理器（没看懂）"><a href="#资源管理器（没看懂）" class="headerlink" title="资源管理器（没看懂）"></a>资源管理器（没看懂）</h3><p>来自准入控制器模块的拒绝请求被发送到自适应资源管理器，以训练其资源管理能力并减少未来拒绝服务的机会。</p><p>分别用 <code>𝑙𝑑</code> 和 <code>𝑙</code> 表示需求负载水平和实际系统负载。这些负载以 bit 表示，并反映在 vCPU 和内存方面的某些基础设施要求（如 [45] 中所述）。作为初始设置，这里既可以基于运行在另一个 VM/容器上的类似应用程序的实际读取值，也可以分配最小的可用 vCPU，这通常是一个单元。</p><p>目标是让资源管理器以最佳流量 <code>𝑓_set</code> 运行，以 bit/s 表示，同时保持安全负载裕度 <code>𝑙𝑔</code> 以解决需求和实际系统负载之间的差额。将流量定义为在给定时间段内通过资源管理器点的请求数量，通常以 个/秒 为单位表示。可以通过弹性控制资源管理器处理速率随时间的变化来实现这种最佳行为。这种弹性包括在资源方面扩大和扩大运营能力。使用基于微服务的架构，特别是 Docker 容器，可以无缝地进行这种自动扩展，正如在之前的一项工作中所展示的那样 [4]。请注意，利用预测感知切片器实现的预测通常喜欢较少的缩放命令。</p><p>由于持续不断地扩大/缩小效率不高，因此需要仔细分析两个问题。首先，假设我们使用特定的策略 𝛱，如何自动确定最佳流量 <code>𝑓_set</code>，以最大化资源管理器的性能？第二，如何确定这种理想的特定政策？因此，我们的资源管理器设计背后的基本原理是通过利用 DRL 充当自适应流控制系统。实际上，使用 DRL 可以捕获所获得知识的所有复杂细节，从而免除明确执行以下详细说明的特征工程过程。</p><h4 id="System-Model（没看懂）"><a href="#System-Model（没看懂）" class="headerlink" title="System Model（没看懂）"></a>System Model（没看懂）</h4><p>资源管理器应该根据从准入控制器接收到的二进制优先级 <code>𝜌𝑡</code> 来调整其可用资源。可能有两个主要动作：</p><ol><li>当𝜌𝑡 = 1 时增加/减少</li><li>当𝜌𝑡 = 0 时保持当前处理流量</li></ol><p>由此，资源管理器通过考虑资源需求的动态来调整其流量。为此考虑以下三个变量：</p><ol><li>流量随时间的变化（𝛾）代表加速/减速</li><li>每时间单位的流量（𝑓）</li><li>电流系统负载（𝑙）</li></ol><p>注意，𝛾 对云计算部署的成本有直接影响 [47]。理想情况下，𝛾应该遵循需求流（𝛾𝑑）的增加/减少变化。为了限制这种流量变化，文章定义了两个参数 𝛾min 和 𝛾max，分别表示随时间的最小和最大允许流量变化。</p><p>在正式确定问题模型之前，文章在汽车行业的背景下给出了一个说明性的例子。这里的资源管理器类似于用于自动设置车辆速度的巡航控制系统。在这种情况下，资源管理器可以根据环境因素的变化来决定加速、保持或减速，同时与需求保持安全距离。</p><p>在这种情况下，受车辆动力学的启发，将两辆车之间的安全距离映射到速度和两者之间的时间间隔，文章将需求和系统负载之间的负载差异表示为每时间单位流量的线性函数和时间差。</p><p>至此，开始形式化确定系统的参考流量（𝑓ref）的安全负载裕度（𝑙𝑔）。先考虑一个简单的模型，让流量成为所需系统负载和当前系统负载之间的距离。将 <code>𝑙𝑔</code> 公式化为 <code>𝑓</code> 的线性函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214134733.png" alt="image-20220214134733738" style="zoom:40%;" /><p>其中 <code>𝑙𝑔0</code> 是初始负载裕度，<code>𝑡𝑔𝑎𝑝</code> 是从当前系统状态转换到所需系统状态的时间间隔。</p><p>用相对负载裕度 <code>𝑙𝑟𝑒𝑙</code> 来表示需求负载 <code>𝑙𝑑</code> 和系统负载 <code>𝑙</code> 之间的差异：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214134800.png" alt="image-20220214134800426" style="zoom:40%;" /><p>系统保持一定的安全裕度来解释需求变化：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214134820.png" alt="image-20220214134820169" style="zoom:40%;" /><p>从环境中收集三个观察结果：</p><ol><li>流量误差 (𝑒𝑡)，定义为参考流量𝑓ref 和 𝑓 之间在每个时间步 𝑡 的差异</li><li>流量误差的积分 ∫ 𝑒𝑡 d𝑡 允许消除稳态误差</li><li>电流 (𝑓) 提供增强效果</li></ol><p>该机制类似于比例-积分-微分 (PID) 控制器，其中积分项旨在通过在误差的历史累积值上添加一些控制效果来消除残余误差。因此，当误差消除时，积分项将停止增长。当误差减小时，会导致比例效应减小，或通过积分效应增大来补偿这种误差。</p><p>最后，需求和资源管理器的负载和流量的初始条件分别表示为：<code>(𝑙𝑑0，𝑓𝑑0)</code> 和 <code>(𝑙0，𝑓0)</code>。</p><h4 id="场景建模-1"><a href="#场景建模-1" class="headerlink" title="场景建模"></a>场景建模</h4><p>目标是在上面约束条件下，最大限度地利用资源：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214141705.png" alt="image-20220214141705349" style="zoom:40%;" /><p>这是个 NP-Hard 问题，因为它具有非线性和条件约束。因此文章将模型分解，如图 2 所示，并使用 DRL 解决。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214141842.png" alt="image-20220214141842090" style="zoom:50%;" /><p>&emsp;&emsp;强化学习通过试错法动态学习以最大化结果。通过遵循策略 𝛱，系统遵循状态 𝑠 ∈ S、动作 𝑎 ∈ A 和奖励 𝑟 ∈ R 的样本路径（例如，𝑠0、𝑎0、𝑟0、𝑠1、𝑎1、𝑟1 等）。奖励𝑟𝑡定义如下，是控制输入 (𝑢𝑡)、流错误 (𝑒𝑡) 和二元偏差 (𝑏𝑡) 的函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214141913.png" alt="image-20220214141913246" style="zoom:40%;" /><p>其中，<code>𝑒𝑡</code> 是所需流量与前一次迭代的流量之间的流量误差； <code>𝑢𝑡-1</code> 表示来自前一个时间步的控制输入；<code>𝑏𝑡</code> 是反映流量误差最小幅度的二元变量，如果 <code>𝑒𝑡</code>^2 ≤ <code>𝜀</code>，则 <code>𝑏𝑡</code>=1，否则 <code>𝑏𝑡</code>=0，<code>𝜀</code> 是一个小的预设阈值。可以观察到，当误差的大小和先前的控制输入较小时，奖励值较大，反之亦然。此外，通过在平方误差项前面使用 10% 的系数进一步降低了误差的影响。这个乘数是任意选择的（小于 1），以确保只有一小部分错误会影响奖励值。</p><p>&emsp;&emsp;用 𝑝 表示从状态 𝑠 到另一个状态的转移概率，用 E 表示期望。首先需要找到使总奖励最大化的最优策略 𝛱∗，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214141949.png" alt="image-20220214141949278" style="zoom:35%;" /><p>其中 𝑡 是时间步长，𝛿 是 ≤ 1 的折扣因子。另一方面，将价值函数 𝑉 𝛱(𝑠) 定义为遵循策略 𝛱 的预期累积奖励，从状态 𝑠 开始：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142022.png" alt="image-20220214142022059" style="zoom:35%;" /><p>将质量 Q 值 <code>𝑄^𝛱(𝑠,𝑎)</code> 定义为在状态 𝑠 下采取行动 𝑎 并遵循政策 𝛱 的预期累积奖励：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142056.png" alt="image-20220214142056160" style="zoom:35%;" /><p>另一方面，基于系统模型中定义的动作，以及前面设计的即时奖励，可以将特定策略的 DRL 问题写成期望Q值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142135.png" alt="image-20220214142135262" style="zoom:35%;" /><p>基于贝尔曼方程[48]，上式的递归形式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142200.png" alt="image-20220214142200822" style="zoom:35%;" /><p>其中 <code>𝑄∗(𝑠′,𝑎′)</code> 是下一个时间步长Q值。使用值迭代求最优解：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142222.png" alt="image-20220214142222781" style="zoom:35%;" /><p>上式中，当 𝑖 →∞ 时 𝑄𝑖 会收敛到 𝑄∗。不过，这个问题是不可扩展的。因此，文章建议使用函数逼近器通过利用深度神经网络来估计𝑄(𝑠,𝑎)，见下节 DQN。同时为了得到连续动作，文章还考虑了DDPG。</p><h4 id="DQN算法"><a href="#DQN算法" class="headerlink" title="DQN算法"></a>DQN算法</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214142259.png" alt="image-20220214142259631" style="zoom:50%;" /><h4 id="DDPG算法"><a href="#DDPG算法" class="headerlink" title="DDPG算法"></a>DDPG算法</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220214143530.png" alt="image-20220214143530229" style="zoom:50%;" /><p><strong>感受</strong></p><p>和之前读的普通论文相比，Introduction部分废话少，介绍本文工作的逻辑层次很清晰分明；Related Work部分工作做的很全面详细，且和本文4部分模型都一一对应，并且时时强调别人论文中的不足以及本文比其更优的地方；在模型部分，文章每个子模型提出的算法都用正规格式打了出来，并分析了复杂度；</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Regression </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Classifier </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】UNREAL：磨刀不误砍柴工</title>
      <link href="/2022/02/13/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91UNREAL%EF%BC%9A%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/"/>
      <url>/2022/02/13/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91UNREAL%EF%BC%9A%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp; 2016年DeepMind 的一篇论文 <a href="https://lrk612.com/resources/Reinforcement%20Learning%20with%20Unsupervised%20Auxiliary%20tasks.pdf">Reinforcement Learning with Unsupervised Auxiliary tasks</a> 中提出了一种叫作 <code>UNsupervised REinforcement and Auxiliary Learning</code> 的模型，缩写为 <strong>UNREAL</strong>。论文篇幅14页，洋洋洒洒，论述精彩，其核心思想是在训练 A3C 的同时，训练多个辅助任务来改进算法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213160657.png" alt="image-20220213160612491" style="zoom: 30%;" /><span id="more"></span><p>&nbsp;</p><h2 id="UNREAL"><a href="#UNREAL" class="headerlink" title="UNREAL"></a>UNREAL</h2><p>&emsp;&emsp;UNREAL模型分为4部分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213160657.png" alt="image-20220213160612491" style="zoom: 50%;" /><p>&nbsp;</p><h3 id="主任务-A3C"><a href="#主任务-A3C" class="headerlink" title="主任务 A3C"></a>主任务 A3C</h3><p>&emsp;&emsp;如上图(a)部分所示，UNREAL的主任务是一个普通的基于 A3C 模型的 Agent，网络结构为 CNN-LSTM，也就是一个前半部分为卷积神经网络、后半部分为 LSTM 的网络结构。其训练方式和 A3C 模型没有本质区别，使用的损失函数也是 A3C 模型的，唯一值得一提的是 LSTM 部分，它带来的好处就是能记忆这一帧的前n帧内容对当前内容的影响。传统的DQN模型使用4个连续的帧组成了一个完整输入模型的 x，使用 LSTM 网络来实现记忆功能。</p><p>&emsp;&emsp;在图中，三角形代表卷积神经网络层，圆形代表 LSTM 网络层。最后一次 Feature Map 的后面有两个不同的后端网络：一个是V网络，用于拟合状态估值；另一个是π网络，用于学习策略。4张输入的图片是连续4帧按时间序列逐一输入网络的。在这个过程中收集的 Transition 信息放入 Replay Buffer中。</p><p>&nbsp;</p><h3 id="像素控制任务"><a href="#像素控制任务" class="headerlink" title="像素控制任务"></a>像素控制任务</h3><p>&emsp;&emsp;如上图(b)部分所示，UNREAL的像素控制任务（Pixel Control）要训练一个辅助策略网络 <code>Qaux</code>，希望能够通过训练把输入图片的不同区域的像素强度（Pixel Intensity）最大化。从形式上看，这部分就是对从 Replay Buffer 中取出的一帧图像进行<strong>反卷积</strong>（deconvolution）。</p><p>&emsp;&emsp;反卷积又称为转置卷积（Transposed Convolution），是一种升采样的手段。与深度学习中的降采样 Max Pooling、Average Pooling等手段目的相反，反卷积对数据进行升维。卷积运算可以视为是 <code>原始像素矩阵</code> 左乘一个 <code>卷积核构成的矩阵</code>，得到一个 <code>压缩尺寸的像素矩阵</code>；而反卷积就是把 <code>压缩尺寸的像素矩阵</code> 左乘 <code>卷积核矩阵的转置</code>，从而还原回 <code>原始像素矩阵的尺寸</code>，但是要注意，这样说只是在维度上进行解释，实际反卷积使用的矩阵元素值与卷积时的矩阵无关，通过梯度下降优化。</p><p>&emsp;&emsp;在这个任务中，网络的前半部分和主任务共享一套 CNN 和 LSTM，只是后半部分的反卷积神经网络是其独有的。最终输出一个 <code>Nact×n×n</code> 的矩阵，称为 <code>Qaux</code>。其中 <code>Nact</code> 表示动作空间的数量，n×n 表示像素快。矩阵 <code>Qaux(a, i, j)</code> 的含义是：执行动作a，下一帧画面变为 i×j 这个矩阵描述的内容。训练时使用 MSE Loss 计算两帧画面像素矩阵的差。</p><p>&nbsp;</p><h3 id="奖励值预测"><a href="#奖励值预测" class="headerlink" title="奖励值预测"></a>奖励值预测</h3><p>&emsp;&emsp;如上图(c)部分所示，奖励值预测是根据相邻的3帧图像 <code>τ-3</code>、<code>τ-2</code>、<code>τ-1</code> 预测下一帧图像 <code>τ</code> 的奖励值，是个典型的回归问题、监督学习场景。网络的前半部分也是用了主任务的 CNN，而后半部分负责从 CNN 提取后的特征中对Reward进行预测。论文中专门配了一幅图，左边表示机器人在迷宫中的视角，右边表示“上帝视角”。这幅图说明了一种非常典型的情况：如果吃到前面的苹果，可以得到+1的奖励值；如果还能吃到更远处的糖葫芦，可以得到+10奖励且游戏重新开始。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213182224.png" alt="image-20220213182224554" style="zoom:50%;" /><p>&nbsp;</p><h3 id="值函数回放"><a href="#值函数回放" class="headerlink" title="值函数回放"></a>值函数回放</h3><p>&emsp;&emsp;如上图(d)部分所示，是值函数回放（Value Function Replay）部分。论文里没有给出实现值函数回放的具体方案，不过说明了几个要点。首先对收集到的 Replay Memory 中的 Transition 信息做了分类：一类叫做“Rewarding Subset”，即：带有回报的 Transition；另一类叫做“Non-Rewarding Subset”，即：无回报的 Transition。因为游戏中并非苹果满地，所以有回报的 Transition 其实是小样本集合，很稀疏。文中对此采用了<strong>过采样</strong>（Oversampling）的方式来处理。</p><p>&emsp;&emsp;过采样是机器学习中面对分布较偏的样本的技巧。比如一个二分类数据集，样本A只占5%，其他95%都是样本B，那么可以通过把样本A复制18份，从而提高模型对样本B的“谨慎性”，即至少不会太过容易判断为B而取得高的准确率，但这样做会不可避免地导致对样本A的判断出现过拟合，因为单纯数量的增加并不能使样本集中蕴含的特征变得丰富。</p><p>&emsp;&emsp;为了应对上述情况，大牛们提出一种叫作 <strong>SMOTE</strong>（Synthetic Minority Oversampling Technique）的算法进一步增强过采样的效果。大致是插值的思想，即对小样本集做聚类分析，同一类下“距离”最近的两、三个样本按自定义的比例融合出一个新的样本，由此来自行制造补充稀缺样本。</p><p>&nbsp;</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;UNREAL模型期望通过一些辅助性质的工作来尽可能实现自动化的高效训练过程。主要体现为损失函数有很多因素组成，这些因素反映每个辅助工作的完成效果。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token Bucket的应用调研</title>
      <link href="/2022/02/13/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Token%20Bucket%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/02/13/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Token%20Bucket%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="调研目录"><a href="#调研目录" class="headerlink" title="调研目录"></a>调研目录</h2><ul><li>Performance Analysis of a Token Bucket Shaper for MPEG4 Video and Real Audio Signal</li><li>Cooperative Fair Bandwidth Scaling in Contention-based Wireless Networks using Time Token Bucket</li><li>Token Bucket Based Traffic Shaping and Monitoring for WLAN-based Control Systems</li><li>Dynamic Token Bucket (DTB): A Fair Bandwidth Allocation Algorithm for High-speed Networks</li></ul><span id="more"></span><p>&nbsp;</p><h2 id="论文一"><a href="#论文一" class="headerlink" title="论文一"></a>论文一</h2><blockquote><p>原文：<a href="https://lrk612.com/resources/Performance%20analysis%20of%20a%20Token%20Bucket%20Shaper%20for%20MPEG4%20video%20and%20Real%20Audio%20signal.pdf">Performance Analysis of a Token Bucket Shaper for MPEG4 Video and Real Audio Signal</a> </p><p>应用：</p><p>&emsp;&emsp;设计了Token Bucket整形器，改变发送流量的时间特征，对突发和随机数据进行整形，向网络提交符合要求的数据包，以提供QoS保证</p><p>背景：</p><p>&emsp;&emsp;流量整形处理使数据符合带宽，而流量监管用于检查数据是否符合网络参数。流量整形在用户端进行，流量监管在网络端进行，以确保用户没有违反服务水平协议。流量整形非常重要，因为它可以确保在网络端不会因为流量监管而丢弃任何数据包</p><p>内容：</p><ul><li>介绍了令牌桶整形器对真实世界数据（如 MPEG4 视频和真实音频信号）的性能分析</li><li>讨论了不同 Token Bucket Shaper 参数对其性能的影响</li></ul><p>对比论文：<a href="https://lrk612.com/resources/Correlated%20token%20bucket%20shapers%20for%20multiple%20traffic%20classes.pdf">Correlated token bucket shapers for multiple traffic classes</a></p></blockquote><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>&emsp;&emsp;文中使用的方法基于对每个流量类别使用多个独立令牌桶整形器。这种令牌桶整形器的优点是与多个相关的令牌桶整形器相比，其实现要简单得多。每个令牌桶整形器都有自己的流量生成器、令牌桶和数据包队列。用户能够改变桶大小、队列长度和令牌生成率的值。从用户端发送的MPEG4视频和真实音频信号数据由各自的令牌桶整形器独立整形。仅当令牌桶中存在足够的令牌时，数据才会发送到网络。一个桶中存在令牌不会对另一个流量类别的性能产生任何影响。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213101527.png" alt="image-20220211163734069" style="zoom: 67%;" /><p>&nbsp;</p><hr><p>&nbsp;</p><h2 id="论文二"><a href="#论文二" class="headerlink" title="论文二"></a>论文二</h2><blockquote><p>原文：<a href="https://lrk612.com/resources/Cooperative%20Fair%20Bandwidth%20Scaling%20in%20Contention-based%20Wireless%20Networks%20using%20Time%20Token%20Bucket.pdf">Cooperative Fair Bandwidth Scaling in Contention-based Wireless Networks using Time Token Bucket</a></p><p>应用：</p><p>&emsp;&emsp;提出了一种使用时间令牌桶方法进行动态协作带宽缩放的协作算法，以公平的方式提高了带宽利用率，动态响应拓扑变化，实现了参与节点的稳定带宽使用</p><p>背景：</p><p>&emsp;&emsp;IEEE 802.11 (WiFi) 等当今现成的无线标准不能很好地支持具有服务质量 (QoS) 要求的应用。指定一系列最低要求的基本 QoS 和首选 QoS，并在此范围内结合动态扩展会有助于支持 QoS，同时提高网络利用率。但是扩展通常以贪婪且不公平的方式发生，每个节点都试图最大化其吞吐量</p><p>内容：</p><p>&emsp;&emsp;文章首先定义了节点间的公平性，然后利用时间令牌桶算法分配带宽资源，又定义了节点等级 level，通过放缩 level 来改变节点的可分配资源量，从而实现整体公平的频谱资源调度策略</p><p>参考论文：<a href="https://lrk612.com/resources/Token%20Bucket%20Based%20Traffic%20Shaping%20and%20Monitoring%20for%20WLAN-based%20Control%20Systems.pdf">Token Bucket Based Traffic Shaping and Monitoring for WLAN-based Control Systems</a>（见下面）</p></blockquote><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><h4 id="QoS-公平性"><a href="#QoS-公平性" class="headerlink" title="QoS 公平性"></a>QoS 公平性</h4><p>文章不仅仅是以公平的方式扩展带宽使用，同时还是为了支持带宽需求。这意味着对公平的定义不仅仅是每个节点应该获得大约相同的带宽。相反，文章首先要求每个节点至少应该获得足够的带宽来满足其基本带宽要求。然后，扩展带宽应该在基本和首选带宽要求之间以公平的方式发生。</p><p>为了形式化对公平性的定义，首先定义节点 v 的带宽需求如下：</p><ul><li>requestBwBase ∈ [0, 1]，节点v的相对基本带宽</li><li>requestBwPref ∈ [0, 1]，节点v的相对首选带宽</li></ul><p>假设每个节点上的应用程序都有可以派生对以上值的要求。比如，应用程序可能必须每秒发送大小在 <code>base</code> 和 <code>preferred</code> 帧之间的帧。若数据速率为 <code>rate</code>，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213101528.png" alt="image-20220213085320943" style="zoom:60%;" /><p>假设所有节点都使用其基本带宽进行传输是可能的。在单跳网络中，这意味着所有节点 V 的相对请求带宽之和不得超过 1：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213085610.png" alt="image-20220213085610396" style="zoom:60%;" /><p>缩放应该发生在基本和首选带宽的范围内，即：动态带宽控制将带宽 <code>asignedBw</code> 分配给下面范围内的每个节点 v：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213085703.png" alt="image-20220213085703255" style="zoom:60%;" /><p>定义带宽的相对分配比例 <code>extraBw</code> 如下：：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213085730.png" alt="image-20220213085730345" style="zoom:60%;" /><p>由此可知，分配了基本带宽的节点的 <code>extraBw</code> = 0，而分配了首选带宽的节点的 <code>extraBw</code> = 1</p><p>接下来根据 [15] 中的公平指数概念，定义节点 v 之间带宽分配的 QoS 公平性。由于节点之间的绝对带宽相等并不是公平，分配比例<code>extraBwv</code> 的相等才是，所以公平指数通过 <code>extraBwv</code> 计算，而不是 <code>assignBw</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213085802.png" alt="image-20220213085802475" style="zoom:60%;" /><p>如果所有节点具有相同的 <code>extraBw</code>，则此公平指数为 1。特别地，如果所有节点都只分配了它们的基本带宽，则公平指数也为 1。但是这意味着所有节点的 <code>extraBw</code> = 0，此时分母为0。公平指数概念有一个缺点，即：可能发生所有节点的 <code>assignBw</code> = 0的情况，例如连接断开时。因此，文章假设 ∑|V | v=1 extraBwv2 = 0 的情况为完全公平，即公平指数为 1。不希望将更多带宽分配给没有完全使用它们已经分配的节点。因此认为这些节点是公平对待的，并且仅在分配时会使用更多带宽的节点之间计算公平指数。</p><h4 id="时间-Token-Bucket-算法"><a href="#时间-Token-Bucket-算法" class="headerlink" title="时间 Token Bucket 算法"></a>时间 Token Bucket 算法</h4><p>使用时间令牌桶算法 [14] 进行流量整形，即将节点 v 可以使用的带宽限制为 <code>assignmentBw</code>。如果节点 v 尝试使用超过 <code>assignmentBw</code>，令牌桶机制会延迟（或丢弃）帧。</p><p>文章中的时间令牌桶机制与标准令牌桶机制的工作原理类似：固定大小的令牌不断落入桶中，如下图所示。桶具有最大容量，如果桶满则令牌溢出。发送帧时，节点需要桶中有足够的令牌。这意味着帧可能会在帧到达队列中延迟，直到有足够的令牌放入桶中。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213091947.png" alt="image-20220213091947148" style="zoom:60%;" /><p>时间令牌桶与标准令牌桶算法的区别在于令牌代表什么的定义：在标准令牌桶算法中，令牌代表发送一定大小数据的权利。例如：令牌大小为 100 B，发送 1000 B 的帧将需要 10 个令牌。由于 IEEE 802.11 规定了不同的数据速率，发送 1000 B 可能需要 以 1 MB/s 发送 8 ms ，或 600 MB/s 发送 13 μs。因此如果使用标准令牌桶算法反而会导致允许慢速节点比快速节点使用介质更长的时间。而本场景希望以公平的方式共享介质使用时间，而不是传输数据，因此本文时间令牌桶中的一个令牌代表了在一个小时间片内使用介质的权利。发送帧时，必须收集足够的令牌才能以选定的数据速率传输帧。此外，MAC 层开销的时间，例如 IEEE 802.11 中所需的帧间空间，将被视为传输帧所需的时间。如果该帧是单播帧，并且很可能随后传输确认帧，则单播帧的发送者还必须收集发送确认帧所需的令牌。这意味着可以无延迟地发送确认帧，并且会消耗分配给发送方而不是接收方的带宽。</p><p>正如 [14] 中所解释的，令牌桶机制还允许派生一个称为 <em>不可用浪费带宽比</em> 的度量。它本质上测量节点尝试使用但由于介质繁忙而无法使用的带宽。在介质繁忙的情况下，帧被卡在帧发送队列中，而令牌桶慢慢填满并溢出。在这种情况下计算溢出的令牌，可以计算出不可用的浪费带宽。此外，如果存储桶溢出但队列为空，则会发生可用带宽浪费。通过计算溢出令牌的数量，可以计算分配但未使用的带宽量。</p><h4 id="带宽缩放"><a href="#带宽缩放" class="headerlink" title="带宽缩放"></a>带宽缩放</h4><p>为了在基本带宽和首选带宽之间进行缩放，分配的带宽 <code>assignmentBw</code> 会动态变化。在时间令牌桶中，通过相应地更改重新填充间隔来实现这一点。</p><p>首先将 <code>requestBwBase</code> 和 <code>requestBwPref</code> 之间的间隔拆分为等距离的级别。每个节点 v 根据其当前级别 <code>levelv</code> 计算其分配的带宽，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213093357.png" alt="image-20220213093357846" style="zoom:60%;" /><p>将 <code>extraBw</code> 表达式带入得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213093515.png" alt="image-20220213093515180" style="zoom:60%;" /><center>levels 代表level的最大值</center><p>很明显，随着 <code>levelv</code> 的增加 <code>extraBw</code> 会线性扩展。从 <code>levelv</code> = 0 开始，节点获得分配的基本带宽，即 extraBwv = 0；<code>levelv</code> 达到最大值时，节点分配得到其首选带宽，即extraBwv = 1。根据公平性定义，这意味着当所有节点处于同一级别时，相当于实现了完美的公平性。</p><p>为了使用时间令牌桶机制调整带宽使用，重新填充间隔是动态更改的。可以使用上面公式中的 <code>assignedBw</code> 推导出来，配置 <code>tokenSize</code> 如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213093853.png" alt="image-20220213093853483" style="zoom:60%;" /><h4 id="带宽缩放的条件"><a href="#带宽缩放的条件" class="headerlink" title="带宽缩放的条件"></a>带宽缩放的条件</h4><p>上面展示了如何根据级别扩展节点使用的带宽，接下来解释节点放大或缩小时的条件，即增加或减少其 <code>level</code>。</p><p>最初，每个节点从 <code>levelv</code> = 0 开始，即在其请求的基本带宽处。在常规控制间隔内，例如一秒，节点 v 都会检查它是否应该增加或减少其级别。</p><h5 id="上调条件"><a href="#上调条件" class="headerlink" title="上调条件"></a>上调条件</h5><p>如果满足以下所有条件，它将增加 1 级：</p><table><thead><tr><th>条件</th><th>说明</th></tr></thead><tbody><tr><td><code>level</code> 未达到最大值，即 <code>levelv</code> &lt; <code>levels</code></td><td>确保不超过首选带宽</td></tr><tr><td>不存在较低 <code>level</code> 的相邻节点</td><td>强制节点之间的公平性：一个节点需要等待它的邻居扩展到它当前使用的相同级别，然后才能被允许进一步扩展。</td></tr><tr><td>节点在最后一个控制间隔内完全使用了其分配的带宽</td><td>确保不存在因为介质过载而无法完全使用其当前分配的带宽；确保带宽资源不浪费</td></tr><tr><td>没有相邻节点因介质过载而无法完全使用其当前分配的带宽</td><td>强制节点之间的公平性：相邻节点实际可以用带宽不能差太多</td></tr><tr><td>没有在至少 <code>10 + random(0, 9)</code> 个控制间隔内增加其 <code>level</code></td><td>确保节点不会扩展得太快</td></tr></tbody></table><h5 id="下调条件"><a href="#下调条件" class="headerlink" title="下调条件"></a>下调条件</h5><p>如果满足以下所有条件，它将降低 1 级：</p><table><thead><tr><th>条件</th><th>说明</th></tr></thead><tbody><tr><td><code>level</code> &gt; 0</td><td>——</td></tr><tr><td>存在 level 比自己低2或以上的相邻节点，并其所有带宽都充分使用</td><td>强制节点之间的公平性</td></tr><tr><td>节点在最后一个控制间隔内没有完全使用其分配的带宽</td><td>因为介质过载而无法完全使用其当前分配的带宽；或者是造成了带宽资源的浪费</td></tr><tr><td>有相邻节点表示不能完全使用其分配的带宽</td><td>强制节点之间的公平性：相邻节点实际可以用带宽不能差太多</td></tr></tbody></table><p>对于缩减条件 2和 3，文章为节点由于介质争用而无法使用的带宽量设置了上限阈值，即 <em>不可用的浪费带宽比率</em>，例如最多 5% 的分配带宽可能无法使用。</p><p>总而言之，扩展条件确保节点以公平的方式扩展，并且尽可能优化整体吞吐量。</p><p>&nbsp;</p><hr><p>&nbsp;</p><h2 id="论文三"><a href="#论文三" class="headerlink" title="论文三"></a>论文三</h2><blockquote><p>原文：<a href="https://lrk612.com/resources/Token%20Bucket%20Based%20Traffic%20Shaping%20and%20Monitoring%20for%20WLAN-based%20Control%20Systems.pdf">Token Bucket Based Traffic Shaping and Monitoring for WLAN-based Control Systems</a></p><p>应用：</p><p>&emsp;&emsp;提出了一种应用令牌桶算法变体的流量整形方法，以及一种流量监控方法，以确定网络过载；引入并应用了不可用浪费带宽比，该指标源自不可用的浪费令牌的数量，用于检测本地网络过载</p><p>背景：</p><p>&emsp;&emsp;为了监测和控制工业环境中的生产过程，无线网络控制系统 (WNCS)用于灵活且经济的方式连接传感器、执行器和控制器，甚至可以支持移动对象。WNCS 的控制应用程序通常具有关于带宽、传输延迟和帧丢失率的服务质量 (QoS) 要求。一种基于反馈的闭环控制方法能够提供足够的QoS保证，但是这需要合适的流量监控方法，即感知当前网络负载和流量整形，例如延迟或丢弃帧。</p><p>内容：</p><p>&emsp;&emsp;文章首先对节点预留带宽进行规划，然后使用时间令牌桶模型对资源调度进行建模，给出了令牌通道各项参数指标。</p></blockquote><h3 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h3><h4 id="带宽预留"><a href="#带宽预留" class="headerlink" title="带宽预留"></a>带宽预留</h4><p>带宽预留由集中式带宽管理器 (CBM) 动态执行。除了分散式方法之外，该解决方案还可以精确控制分配的带宽。文章中，术语带宽表示允许节点使用介质进行传输的最大时间量或最大介质占用持续时间。为了有效地运行网络，文章只使用了无线网络 G 的总带宽的一定比例 <code>bwr_G_assgn</code> ∈ [0,1]，例如20%。选择该比率一是为了使介质争用保持足够小，二是取决于外部流量的影响。类似地，<code>bwr_v_avail</code> ∈ [0,1] 表示节点 v 的可用本地带宽。</p><p>假设每个节点 v ∈ Vi 有一个相对带宽要求 <code>bwr_v_required</code> ∈ [0,1]，从 CBM 请求。基于 <code>bwr_G_avail</code> 和当前分配的相对带宽 <code>bwr_G_assgn</code>，CBM 决定是否可以批准请求。如果批准，CBM 将 <code>bwr_v_required</code> 作为 <code>bwr_v_assgn</code> 返回，否则返回 0。更具体地说，CBM 必须强制执行以下约束：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213104328.png" alt="image-20220213104328033" style="zoom:40%;" /><p>在多跳网络中，带宽预留建立在用于自动链路检测的协议之上，提供用于路由目的的拓扑信息。</p><h4 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h4><p>流量整形的目的是监控节点v的本地带宽使用 <code>bwr_v_used</code> 是否符合分配的相对带宽 <code>bwr_v_assgn</code>，延迟或丢弃超过它的帧，并均匀分配流量以避免全局峰值和高争用情况</p><p>文章为流量整形设计了一种改进的令牌桶算法（图1）。与原始令牌桶算法一样，令牌以恒定的重新填充间隔放入桶中。在原始令牌桶算法中，每个令牌代表发送一定字节数的权利。在 WLAN 上，可以以许多不同的传输速率发送帧，因此传输一定数量字节的时间可能会有很大差异。考虑到这一点，文章使用等长的时间片作为标记。每个时间片代表对介质的短期访问权。为了调度帧进行传输，必须在桶中收集足以覆盖帧传输时间（包括开销）的令牌。当帧从到达队列移动到发送队列时，这些令牌会从存储桶中删除。当桶已经被填满时，进一步的重新填充尝试会导致溢出，即令牌丢失。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213105742.png" alt="image-20220213105742432" style="zoom:40%;" /><center>图 1</center><p>节点 v ∈ V i 的令牌桶由带宽配置文件 bpv 表征。要确定 bpv，除了 <code>bwr_v_required</code> 之外，CBM 还需要最大有效负载大小。节点 v 的带宽配置文件是一个元组 bpv：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213105138.png" alt="image-20220213105138694" style="zoom:40%;" /><p>其中：</p><ul><li><p><code>d_v_txMax</code> ∈ N0 [μs] 是节点 v 的最大介质占用持续时间或最大突发大小。为了最小化可能的突发并保证可以发送所有帧，文章将其设置为以最低传输速率传输最大可能帧所需的持续时间：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213105224.png" alt="image-20220213105224270" style="zoom:40%;" /><p>  其中，<code>bMLO</code> 表示 MAC 层开销（以字节为单位），dPLO 是 PHY 层开销的平均值（以微秒为单位），包括帧间距、平均退避间隔和 PHY 前导码。</p></li><li><p><code>d_v_refill</code> ∈ N0 [μs] 是在节点 v 的桶中收集的介质占用持续时间增加的再填充间隔。作为启发式，重新填充间隔应该足够小以避免不必要的延迟，平均每帧半个令牌。</p></li><li><p><code>bwr_v_assgn</code> ∈ [0,1]：<code>bwr_v_requested</code>，如果被批准；否则为 0。它是分配给节点 v 的带宽相对于网络带宽。</p></li></ul><p>与通用令牌桶 [4] 相比，<code>d_v_txMax</code> 和 <code>d_v_refill</code> 分别表示桶大小和令牌重新填充间隔。从 bpv 可以确定节点 v 的进一步桶参数如下：</p><ul><li><p><code>d_v_token</code> [μs] 表示令牌的大小：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110008.png" alt="image-20220213110008829" style="zoom:40%;" /></li><li><p><code>n_v_fillings</code> 表示完全填充桶所需的令牌总数：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110106.png" alt="image-20220213110106057" style="zoom:40%;" /></li><li><p><code>d_v_bucket</code> [μs] 表示完全填满空桶所需的最短时间：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110118.png" alt="image-20220213110118919" style="zoom:40%;" /></li></ul><p>接下来，文章讨论了一个根据应用需求计算桶参数的例子。考虑在节点 v 上运行的周期性应用程序 appX，其值如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110300.png" alt="image-20220213110300487" style="zoom:40%;" /><p>其中：</p><ul><li>b_appX_ payload ∈N0 是以字节为单位的有效载荷大小</li><li>d_appX_ period ∈N0 [μs] 是应用周期长度</li><li>n_appX_msg ∈ N0 是周期性应用程序在一个周期内发送的消息数</li></ul><p>代入上面公式可得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110642.png" style="zoom:40%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110736.png" alt="image-20220213110736058" style="zoom:40%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213110720.png" alt="image-20220213110720737" style="zoom:40%;" /><p>图 1 说明了改进的令牌桶算法的操作。要发送的帧被放入帧到达队列中。如果桶已满且帧发送队列为空，则可以安排下一帧进行传输，方法是将其放入发送队列并从桶中消耗所需数量的令牌。如果桶中没有足够的令牌或者帧发送队列仍然包含一个帧，那么下一帧会被延迟，直到两个条件都成立。令牌被放入存储桶中，由重新填充间隔确定。</p><p>请注意，通过将帧发送队列的大小限制为 1 并通过保持桶大小保持较小，可以限制传输突发。当一个帧被调度传输时，下一帧被延迟。因此，节点v的使用带宽比 <code>bwr_v_used</code> 被限制为 <code>bwr_v_assgn</code>。</p><h4 id="流量监测"><a href="#流量监测" class="headerlink" title="流量监测"></a>流量监测</h4><p>通过监控令牌桶来进行流量监控。当分配的带宽未被利用时，令牌桶会溢出，导致令牌浪费。这可能有两个原因：</p><ol><li>分配的带宽超过使用的带宽，即 <code>bwr_v_assgn</code> ≥ <code>bwr_v_used</code>。这里浪费的令牌称为<em>可用的浪费令牌</em>，因为应用程序可以使用它们，只是不需要</li><li>网络过载，即 <code>bwr_v_assgn</code> ≥ <code>bwr__vavail</code>。由于高竞争，帧在发送队列中停留的时间更长，因此到达队列中的帧不能使用重新填充的令牌，从而导致溢出。这样无法使用的token称为<em>不可用的浪费令牌</em>，因为过多的介质争用而无法使用它们。</li></ol><p>为了监控可用和不可用的浪费令牌，文章引入了两个计数器：</p><ol><li>计数器 <code>n_v_WT_usable(t)</code> 表示在时间 t 之前浪费的<em>可用令牌</em>。如果令牌桶已满，且帧发送队列和帧到达队列均为空时，则在生成令牌时递增</li><li>计数器 <code>nv_WT_unusable(t)</code> 表示在时间 t 之前浪费的<em>不可用令牌</em>。如果令牌桶已满，且帧发送队列或帧到达队列不为空，则在生成令牌时递增</li></ol><p>使用这些计数器并基于监控的传输活动，可以得出以下特征参数：</p><table><thead><tr><th>参数</th><th>含义</th><th>公式</th></tr></thead><tbody><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213142952.png" alt="image-20220213142952535" style="zoom:50%;" /></td><td>从实验开始到时间 t，节点 v 使用介质传输帧的总时间</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143016.png" alt="image-20220213143016580" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143321.png" alt="image-20220213143321820" style="zoom:50%;" /></td><td>从节点开始时间到时间 t，节点 v 使用的分配带宽的比率。</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143346.png" alt="image-20220213143346594" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143403.png" alt="image-20220213143403387" style="zoom:50%;" /></td><td>自开始以来，节点 v 在时间 t 的不可用浪费分配带宽的比率</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143426.png" alt="image-20220213143426615" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143444.png" alt="image-20220213143444428" style="zoom:50%;" /></td><td>自开始以来节点 v 在时间 t 的可用浪费分配带宽的比率</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143507.png" alt="image-20220213143507229" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143526.png" alt="image-20220213143526909" style="zoom:50%;" /></td><td>自开始以来，节点 v 在时间 t 浪费的分配带宽的比率</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143546.png" alt="image-20220213143546280" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143602.png" alt="image-20220213143602603" style="zoom:50%;" /></td><td>在时间 t 来自节点 v 的硬件寄存器的值 Channel Busy Time (CBT)</td><td></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143628.png" alt="image-20220213143628603" style="zoom:50%;" /></td><td>从开始到时间 t，节点 v 观察到介质繁忙的时间比率</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143649.png" alt="image-20220213143649739" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143717.png" alt="image-20220213143717099" style="zoom:50%;" /></td><td>节点v感知介质能量的时间量，不包括从开始到时间 t 的传输持续时间</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143801.png" alt="image-20220213143801843" style="zoom:40%;" /></td></tr><tr><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143818.png" alt="image-20220213143818871" style="zoom:50%;" /></td><td>从开始到时间 t，节点感知介质能量（不包括其传输持续时间）的时间比率</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213143835.png" alt="image-20220213143835843" style="zoom: 40%;" /></td></tr></tbody></table><p>注：第一行 Fv(t) 表示节点 v 在时间 t 之前发送的帧，b_f_payload 表示单个帧的有效载荷大小，r_f_tx 表示发送它的速率</p><p>&nbsp;</p><hr><p>&nbsp;</p><h2 id="论文四"><a href="#论文四" class="headerlink" title="论文四"></a>论文四</h2><blockquote><p>原文：<a href="https://lrk612.com/resources/Dynamic%20token%20bucket%20DTB%20a%20fair%20bandwidth%20allocation_algorithm%20for%20high-speed%20networks.pdf">Dynamic Token Bucket (DTB): A Fair Bandwidth Allocation Algorithm for High-speed Networks</a></p><p>应用：</p><p>&emsp;&emsp;提出了一种基于令牌桶监管的计算简单机制，以实现一组竞争流的几乎相等的带宽分配。可以动态调整令牌桶阈值并测量流的瞬时到达率。此框架可用于基于 Internet 和帧中继的虚拟专用网络 (VPN)。</p><p>背景：</p><p>&emsp;&emsp;FIFO 调度在公平带宽分配方面表现不佳；使用拥塞控制的 TCP 等协议也无法避免 FIFO 调度中固有的不公平性。路由器中的智能调度能够缓解公平性问题，但是这意味着维护每个流的信息并执行每个流的计算，复杂度太高。</p><p>内容：</p><p>&emsp;&emsp;在令牌桶的基础上，观测每个类型数据流对应令牌桶的活跃状态、数据总量和数据包到达率，然后根据每个bucket的流量情况引入概率丢包机制来削弱行为不端的类型</p></blockquote><h3 id="模型-3"><a href="#模型-3" class="headerlink" title="模型"></a>模型</h3><p>&emsp;&emsp;令牌桶流量整形是通过维护一个计数器来计算令牌和一个计时器来确定何时向计数器添加新令牌来实施的。当长度为 1（字节）的数据包到达缓冲区并且计数器中至少有 1 个令牌时，发送数据包并从计数器中删除 1 个令牌。如果令牌桶中的令牌少于 1，则数据包必须等待令牌滴入桶中，直到至少有 1 个令牌，此时才发送。令牌桶以每 T 秒 RT 个令牌的有效速率补充。令牌桶的优点是它的简单性和对典型的数据流量有限突发性的适应能力。T 的选择有一个权衡，较高的 T 值允许更好的突发性能，而较小的 T 值有助于防止流在非常小的时间间隔内发送大突发。每 T 秒重置一次的计时器会触发令牌桶的重新初始化。</p><p>&emsp;&emsp;本文 DTB 模型基于令牌桶算法并进行了一些修改。在 DTB 中，每个活动流都分配有一个令牌桶。令牌桶的容量等于瞬时公平率 F(t)。公平率取决于活动流的数量 N(t) 和链路容量 C：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213200743.png" alt="image-20220213200743183" style="zoom:40%;" /><p>对于以 <code>fi</code> 为索引的每个流，DTB 在路由器中维护以下变量：</p><ol><li><code>arrivals_i</code>：自上次补充令牌桶以来到达缓冲区的 <code>fi</code> 流的字节数</li><li><code>admitted_i</code>：自上次填充桶以来进入缓冲区的 <code>fi</code> 流的字节数</li><li><code>active_i</code>：一个布尔变量，指示流是否处于活动状态</li></ol><p>当一个流在定时器复位后发送它的第一个数据包时，它就被声明为活动的。如果在两次连续定时器重置之间的时间间隔内没有发送数据包，则活动流被声明为非活动流。</p><p>&emsp;&emsp;作为上述每个流状态变量的一部分，DTB 还维护了全局变量 <code>F(t)</code> 和 <code>N(t)</code>。将 MAXFLOWS 定义为一个常数，等于任何链路上支持的最大流数。对于 <code>fi</code> 的所有值，将 <code>active_i</code> 设置为零。当来自 <code>fi</code> 流的第一个数据包到达链路时，<code>active_i</code> 设置为 1 以指示该流处于活动状态。初始重置的 <code>N(t)</code> 增加 1，并计算并存储公平利率 <code>F(t)</code> 的相应值。此时，<code>arrivals_i</code> 和 <code>admitted_i</code> 设置为零，即初始化 <code>fi</code> 流的令牌桶。在初始化之后，每当属于 <code>fi</code> 流的数据包被允许进入缓冲区时，<code>admitted_i</code> 就会增加数据包的长度 <code>li</code> 。但是在时间 t 时，数据包被允许进入缓冲区的前提条件是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213200814.png" alt="image-20220213200814745" style="zoom:40%;" /><p>如果上式不成立，数据包立即被丢弃，不像基本的令牌桶方法，将它保存在缓冲区中，直到桶中有 <code>li</code> 个令牌后调度。这样做是为了避免按流缓冲开销，有利于简单的 FIFO 调度。就像在基本的令牌桶实现中一样，定时器每 T 秒关闭一次，此时所有活动流的 <code>admitted_i</code> 和 <code>arrivals_i</code> 都被清除。</p><p>在仿真实验中观察到单靠上面不等式无法实现公平：当多个流以不同的速率发送数据包时，可以观察到具有低传输速率的流实现了非常低的吞吐量（归一化为公平速率）。为了处理这个问题，文章为每个活动流定义了变量<code>arrivals_i</code>，在非活动流的第一个数据包到达缓冲区时初始化，并按相应流的每个到达数据包的长度递增。根据该变量值估计流的到达率，当一个属于 <code>fi</code> 流的数据包到达缓冲区并且有足够的令牌和缓冲区空间可用时，依概率决定是否接纳该数据包，如果（在时间 r）缓冲区级别高于预定义的阈值 <code>Cthresh</code> 并且有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213200853.png" alt="image-20220213200853664" style="zoom:40%;" /><p>其中 F(t) 是上面定义的瞬时公平率，Ri(t) 是到达率：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220213200907.png" alt="image-20220213200907013" style="zoom:40%;" /><center>这里还可以使用滑动平均、加权平均</center><p>其中 i 是计时器自上次到期以来的值。</p><p>选择 Clhresh 的值是为了通过概率性地丢弃行为不端流（以远高于公平速率传输的流）的数据包为弱流留出缓冲区空间。观察上面不等式，流到达率越大，数据包丢弃概率越大，从而帮助较弱的流有效地屏蔽了行为不端的流。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Resource Management </tag>
            
            <tag> Token Bucket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRL &amp; 随机森林对网络业务分类</title>
      <link href="/2022/02/12/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DRL&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%AF%B9%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E5%88%86%E7%B1%BB/"/>
      <url>/2022/02/12/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DRL&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%AF%B9%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;&emsp;蜂窝通信和5G 移动网络需要满足高可靠性标准、极低延迟、更高容量、更高安全性和高速用户连接。文中通过实施深度学习 (DL) 神经网络，利用网络内深度学习和预测来管理网络负载效率和网络可用性，开发了一个“DeepSlice”模型。用网络关键性能指标 (KPI) 训练模型以分析传入流量并预测未知设备类型的网络切片。智能资源分配保证有效地使用现有网络切片上的可用资源并提供负载平衡。DeepSlice 模型能够做出明智的决策并为数据包选择最合适的网络切片，包括网络故障的情况。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212152159.png" alt="image-20220212152136937" style="zoom:60%;" /><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/DeepSlice%20A%20Deep%20Learning%20Approach%20towards%20an%20Efficient%20and%20Reliable%20Network%20Slicing%20in%205G%20Networks.pdf">DeepSlice: A Deep Learning Approach towards an Efficient and Reliable Network Slicing in 5G Networks</a></p><span id="more"></span><p>&nbsp;</p><h2 id="问题导向及现有研究"><a href="#问题导向及现有研究" class="headerlink" title="问题导向及现有研究"></a>问题导向及现有研究</h2><p>&emsp;&emsp;在过去的二十年中，移动设备的数量呈指数级增长，不仅导致网络需要更高的容量和吞吐量，而且需要多种不同技术的紧密集成。许多新兴技术通过支持新的商业模式和为客户提供不同的体验，5G 网络将封装一些关键服务包括自动驾驶、企业商业模式、AR-VR 解决方案、工业自动化、远程监控、智能健康、智慧城市等等。第三代合作伙伴计划 (3GPP) 认为网络切片是 5G 的关键支持技术。切片将允许运营商在单个基础设施上有效地运行多个网络实例，从而以卓越的服务质量 (QoS) 为各种应用程序、用例和业务服务提供服务。</p><p>&emsp;&emsp;电信行业正在经历一场大规模的数字化转型，采用机器学习、人工智能、基于反馈的自动化和高级分析来处理下一代应用程序和服务。人工智能概念并不新鲜。机器学习和深度学习使用的算法目前正在各个行业和技术垂直领域实施。随着 5G 数据的不断增长和海量信息，主动、快速和准确地预测数据的能力至关重要。人工智能将通过优化网络性能和提高体验质量 (QoE) 使网络功能能够提供超低延迟、更高的吞吐量和可靠性。</p><p>&emsp;&emsp;本文模型的主要目标是</p><ul><li>为设备选择适当的网络切片</li><li>正确预测切片并根据流量预测为该切片分配足够的资源</li><li>在网络故障的情况下调整切片分配</li></ul><p>&emsp;&emsp;实现这些目标的关键工具是深度学习神经网络。文章利用 ML 和深度学习神经网络 (DLNN) 提出了DeepSlice 模型，来帮助为设备和服务选择最有效和优化的网络切片。同时还分析了整体流量模式并可以预测未来的流量，从而提前将资源分配给最合适的切片。</p><table><thead><tr><th>论文</th><th>相关内容</th></tr></thead><tbody><tr><td>[1]</td><td>MVNO 的容量受用户数量和传输功率的影响，5G 网络切片的多租户性质</td></tr><tr><td>[2]</td><td>定义基于 SDN 和 NFV 的 5G 核心网络架构</td></tr><tr><td>[3]</td><td>提出了一种特定于应用程序的移动网络深度学习架构，在 RAN 中应用特定于应用程序的无线电频谱调度</td></tr><tr><td>[4]</td><td>提出了一个框架，使用优先级管理 SDN 方法对智能城市的网络流量进行优先级排序</td></tr><tr><td>[5]</td><td>讨论了网络切片的标准化、网络切片选择、识别切片独立功能，提出了切片架构和 RRC 帧</td></tr><tr><td>[6]</td><td>对比基于衰落持续时间中断概率 (FDOP) 的切换要求和蜂窝系统中基于传统 SINR 的切换方法</td></tr><tr><td>[7]</td><td>展示了动态数据速率分配以及在 5G 新无线电空中接口上提供硬服务保证的能力</td></tr><tr><td>[9]</td><td>使用矩阵指数分布表示用于公共安全和紧急通信的切换</td></tr><tr><td>[10]</td><td>提出了 5G 网络中的网络生存性框架</td></tr><tr><td>[11]</td><td>服务相关的安全要求</td></tr><tr><td>[13]</td><td>提出的模型实现了网络切片的成本优化部署，允许移动网络运营商根据其用户的需求有效地分配底层资源</td></tr></tbody></table><p>&nbsp;</p><h2 id="系统模型：DeepSlice"><a href="#系统模型：DeepSlice" class="headerlink" title="系统模型：DeepSlice"></a>系统模型：DeepSlice</h2><p>&emsp;&emsp;文章先创建了一个随机森林和神经网络，用来对输入数据包的切片类型进行判断。切片类型分为4中：eMBB、mMTC、URLLC和Master Slice，其中Master Slice具有属于其他每个切片的网络功能的切片，始终可以作为备用切片，处于热备用状态，并将根据其他切片上的负载状态使用。然后提出“DeepSlice”模型用于管理网络负载、切片故障条件并为连接到网络的任何新的未知设备类型检测最合适的切片。其中随机森林和神经网络使用相同的数据集，包含超过 65,000 个独特的输入组合。</p><p>&emsp;&emsp;数据集包括来自网络和设备的最相关 KPI，包括用于连接的设备类型（智能手机、物联网设备、URLLC 设备等）、用户设备 (UE) 类别、QoS 类标识符 (QCI)、数据包延迟预算、最大丢包率、时间和星期几等。在 5G 中，数据包延迟预算和数据包丢失率是 5QI（5G QoS 标识符）的组成部分，这也包含在数据集中。 </p><p>&emsp;&emsp;模型考虑了多种不同类型的输入设备，包括智能手机、通用 IoT 设备、AR-VR 设备、工业 4.0 流量、e911 或公共安全通信、医疗保健、智慧城市或智能家居流量等，甚至是请求访问的未知设备或多项服务。每种输入设备都有定义的 UE 类别值和预定义的 QCI 值。上述所有信息都用于神经网络训练，以便在当前做出明智的决策并有效地预测未来的网络资源预留。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212152159.png" alt="image-20220212152136937" style="zoom:60%;" /><center>总架构</center><p>&emsp;&emsp;文章模型根据传入连接的先前信息预测每个网络切片上的网络负载，并跟踪哪个输出“网络切片”被使用最多。然后根据需要在所有切片之间有效地分配传入流量来将传入流量分配给网络。因为对于如何处理每种传入设备类型没有明确的规则集，所以用神经网络来处理非常合适。对于每一个新场景，与传统算法相比，智能网络都可以非常快速地学习和适应变化或新要求。下表展示了仿真模型的特点：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212164055.png" alt="image-20220212164055405" style="zoom:70%;" /><h4 id="PartⅠ-随机森林分类器"><a href="#PartⅠ-随机森林分类器" class="headerlink" title="PartⅠ 随机森林分类器"></a>PartⅠ 随机森林分类器</h4><p>&emsp;&emsp;当拥有具有多个属性结构的数据集时，推荐使用随机森林 (RF)。 RF 是一种监督学习模型，主要用于为分类和回归问题建立预测模型。文章的模型选择 RF 而不是 k-Nearest Neighbor、朴素贝叶斯或决策树的主要原因是因为数据集中有大约 65,000 个独特的输入，并且所有这些数据都结构良好，因此 RF 通过使用多个子树来降低过度拟合的风险。RF 有助于将输入数据快速分类为任何预定义的类别。 RF 在大型数据库上高效运行并产生准确的预测。最重要的是，它可以估计任何丢失的数据，即使在某些输入数据丢失的情况下也能保持准确性</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212164428.png" alt="image-20220212164428903" style="zoom: 60%;" /><p>&emsp;&emsp;下图是随机森林投票分类模型。输入数据集有大约 8 个不同的输入字符串，它们共同有助于模型做出决策。在现实世界的场景中很可能会发生 8 个输入中的一个或多个可能没有被接收到，而模型仍然必须预测一个输出的情况。在数据训练期间，RF 根据输入构建多个决策树，树的每个分支代表一个可能的事件或响应。文章使用 60% 的输入数据集来训练我们的模型，剩下的 40% 用于预测分类器的准确性。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212164443.png" alt="image-20220212164443517" style="zoom:55%;" /><h4 id="PartⅡ-神经网络分类器"><a href="#PartⅡ-神经网络分类器" class="headerlink" title="PartⅡ 神经网络分类器"></a>PartⅡ 神经网络分类器</h4><p>&emsp;&emsp;当数据非结构化且庞大的时，神经网络会比随机森林分类的效果更好。文章使用相同的数据集来训练神经网络的多个神经元，并根据来自 UE 信息的任何输入预测正确的网络切片。文章利用神经网络模型为未知设备类型选择正确的切片类型。在下图所示的DeepSlice 模型中，根据传入连接预测每个网络切片的网络负载，并跟踪哪个输出“网络切片”被使用最多，然后根据模型预测的负载和输出，通过在 eMBB、URLLC、mMTC 或主切片之间有效分配来将传入设备分配给切片。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212165139.png" alt="image-20220212165139106" style="zoom:55%;" /><p>&emsp;&emsp;在 24 小时模拟中产生了大约 25 万用户连接请求，其中 40% 是 eMBB、25% mMTC 和 35% URLLC。下图显示了运行 24 小时的模拟神经网络模型运行效果，给出了在一个实例中服务的用户数量。因为所有传入流量都有一个预定义的生存时间 (TTL)，因此每秒只有一小部分仍然有效。例如，在任何给定实例中，eMBB 活跃用户平均数为 275。与 eMBB 相比，为 URLLC 和 mMTC 用户分配了较短的 TTL，这就是为什么图中有更多用户使用宽带服务的原因。</p><p>&emsp;&emsp;DeepSlice 最终将学习和了解什么样的设备会进入哪个切片，并且随着时间的推移，它将能够预测未来需要特定服务或网络切片的连接。它可以通过提前适当分配资源来帮助网络为任何新连接做好准备；这将节省以后的任何延误。数据集中包括任何连接的日期和时间，这也可以帮助网络在任何给定时间预测未来的连接数量，并根据从过去的信息中学习了解这些连接需要或请求哪些网络切片。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212165445.png" alt="image-20220212165445873" style="zoom:55%;" /><p>&nbsp;</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p>在本节中，我们评估 DeepSlice 并验证它如何用于提供切片预测、负载平衡和网络可用性。在我们的第一个用例中，我们通过演示如何为请求连接到系统的任何未知设备类型准确选择切片来验证我们的方法。我们的第二个负载平衡用例涉及有效利用每个可用的网络切片。如果任何单个切片利用率超过其总可用资源的某个阈值，我们的模型将引导任何新连接到主切片，否则当切片利用率超过预定义阈值时需要承载设备。我们的第三个用例描述了一个切片故障场景，其中所有流量都将路由到主切片，并防止在切片故障期间出现任何服务丢失。 DeepSlice 将捕获任何连接失败的时间以及失败周围的一些属性；下次它可以尝试隔离问题并提前做好准备。</p><h4 id="实验一-Unknown-Device-Type"><a href="#实验一-Unknown-Device-Type" class="headerlink" title="实验一 Unknown Device Type"></a>实验一 Unknown Device Type</h4><p>使用DeepSlice 模型对未知设备类型进行切片分类，交叉验证准确率超过 90.62%，其中包括新输入场景的整个测试数据集，以及训练时未使用的那些。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212214537.png" alt="image-20220212214537501" style="zoom:55%;" /><p>下表显示了一些未知数以及如何仅使用一部分输入信息来正确确定要使用的网络切片。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212214714.png" alt="image-20220212214714302" style="zoom:55%;" /><h4 id="实验二-Load-Balancing-Scenario"><a href="#实验二-Load-Balancing-Scenario" class="headerlink" title="实验二 Load Balancing Scenario"></a>实验二 Load Balancing Scenario</h4><p>假设使用率阈值为90%，如果连接数超过阈值，则该切片定义为过度使用。下图显示了一个 eMBB 切片被检测到具有超过 90% 的利用率，其流量超过了设置的阈值时，Master切片充当任何新 eMBB 连接的备份：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212215050.png" alt="image-20220212215050386" style="zoom:55%;" /><p>DeepSlice 模型可以实现这种过载，并且准备下次重定向流量，从而不会导致特定切片过载。主切片接管多余的流量效果如图所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212215159.png" alt="image-20220212215159502" style="zoom:55%;" /><h4 id="实验三-Network-Slicing-Failure-Scenario"><a href="#实验三-Network-Slicing-Failure-Scenario" class="headerlink" title="实验三 Network Slicing Failure Scenario"></a>实验三 Network Slicing Failure Scenario</h4><p>假设指定切片完全失效，例如是 eMBB，如图所示。此时 DeepSlice 模型会将所有新的 eMBB 相关流量引导到Master切片，避免网络中的流量传输丢失：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212215347.png" alt="image-20220212215347359" style="zoom:55%;" /><p>但是，该切片上的任何正在进行的通信都会受到影响，并且所有现有连接都会由于切片突然故障而丢失。这由系统记录，例如日期和时间，并且下次将注意避免丢失所有正在进行的连接。</p><p>下图显示，模拟模型在 mMTC 切片上出现故障，从 3 小时到 5 小时，持续两个小时，在 eMBB 切片上，在 16 小时到 18 小时的另外两个小时内出现故障。Master切片被标识为备份，并用于在这些切片故障期间重定向此流量。就容量和处理速度而言，Master切片中为每个网络切片保留了大量资源。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220212215437.png" alt="image-20220212215437268" style="zoom:55%;" /><p>&nbsp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;我觉得这篇论文思路比较简单，就是用随机森林和一个简单的神经网络对数据包做了分类，然后加上了一些简单的切片资源调度策略，但是好在文章作者开源了代码和数据集。</p><p>仓库：<a href="https://github.com/adtmv7/DeepSlice">github</a></p><p>源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> plot_model</span><br><span class="line"></span><br><span class="line">seed = <span class="number">9</span></span><br><span class="line">numpy.random.seed(seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load datasets</span></span><br><span class="line"><span class="comment">#csv files were filtered based on the data.</span></span><br><span class="line">input_file = <span class="string">&quot;C:\\XXX...csv&quot;</span></span><br><span class="line">test_file = <span class="string">&quot;C:\\XXX.csv&quot;</span></span><br><span class="line"></span><br><span class="line">dataset = pd.read_csv(input_file).values</span><br><span class="line"></span><br><span class="line"><span class="comment"># read training data</span></span><br><span class="line">datasetTest = pd.read_csv(test_file).values</span><br><span class="line"></span><br><span class="line"><span class="comment"># split into input (X) and output (Y) variables</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">8</span>].astype(<span class="string">&quot;int32&quot;</span>)</span><br><span class="line">Y = dataset[:,<span class="number">8</span>]</span><br><span class="line">XT = datasetTest[:,<span class="number">0</span>:<span class="number">8</span>].astype(<span class="string">&quot;int32&quot;</span>)</span><br><span class="line"></span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">encoder.fit(Y)</span><br><span class="line">encoded_Y = encoder.transform(Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert integers to dummy variables (i.e. one hot encoded)</span></span><br><span class="line">dummy_y = np_utils.to_categorical(encoded_Y)</span><br><span class="line"></span><br><span class="line">(X_train, X_test, Y_train, Y_test) = train_test_split(X, dummy_y, test_size=<span class="number">0.001</span>, random_state=seed)</span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">8</span>, input_dim=<span class="number">8</span>, init=<span class="string">&#x27;normal&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">4</span>, init=<span class="string">&#x27;normal&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">3</span>, init=<span class="string">&#x27;normal&#x27;</span>, activation=<span class="string">&#x27;tanh&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">3</span>, init=<span class="string">&#x27;normal&#x27;</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(model.summary())</span><br><span class="line"><span class="comment"># Compile model</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, Y_train, validation_split=<span class="number">0.3</span>, epochs=<span class="number">16</span>, batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># evaluate the model</span></span><br><span class="line">scores = model.evaluate(X_test, Y_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n%s: %.2f%%&quot;</span> % (model.metrics_names[<span class="number">1</span>], scores[<span class="number">1</span>]*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">plot_model(model, to_file=<span class="string">&#x27;model.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot training &amp; validation accuracy values</span></span><br><span class="line">plt.plot(history.history[<span class="string">&#x27;acc&#x27;</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">&#x27;val_acc&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Model Accuracy&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Train&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>], loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot training &amp; validation loss values</span></span><br><span class="line">plt.plot(history.history[<span class="string">&#x27;loss&#x27;</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Model Loss&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Train&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#from sklearn.metrics import confusion_matrix</span></span><br><span class="line"><span class="comment">#y_pred_keras = model.predict_classes(XT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#csv = open(&quot;C:\\DeepSlice\\5G\\output.csv&quot;, &quot;w&quot;)</span></span><br><span class="line"><span class="comment">#&quot;w&quot; indicates that you&#x27;re writing strings to the file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pd.DataFrame(y_pred_keras).to_csv(&quot;C:\\DeepSlice\\5G\\output.csv&quot;)</span></span><br><span class="line"><span class="comment">#cm = confusion_matrix(Y_test, y_pred_keras, labels=[0, 1, 2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#csv = open(&quot;C:\\DeepSlice\\5G\\input.csv&quot;, &quot;w&quot;)</span></span><br><span class="line"><span class="comment">#&quot;w&quot; indicates that you&#x27;re writing strings to the file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pd.DataFrame(XT).to_csv(&quot;C:\\DeepSlice\\5G\\input.csv&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】A3C：多重影分身一起学习</title>
      <link href="/2022/02/09/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91A3C%EF%BC%9A%E5%A4%9A%E9%87%8D%E5%BD%B1%E5%88%86%E8%BA%AB%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/09/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91A3C%EF%BC%9A%E5%A4%9A%E9%87%8D%E5%BD%B1%E5%88%86%E8%BA%AB%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;如果我能有一个超能力，我希望能够使用火影忍者里鸣人的多重影分身之术，许多个分身同时学习，然后学到的东西汇总到我脑子里 ヾ(≧▽≦*)o~~</p><p>&emsp;&emsp;受益于计算机的多进程或多线程功能，A3C 理念帮助强化学习的 Agent 替我实现了这个梦想。不愧是DeepMind，轻易就做到了我做不到的事 ( •̀ ω •́ )✧</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209161905.png" alt="image-20220209161905574" style="zoom: 40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><p>&emsp;&emsp;A3C算法是DeepMind在2016年发表在ICML上的论文 <a href="https://lrk612.com/resources/Asynchronous%20Methods%20for%20Deep%20Reinforcement%20Learning.pdf">Asynchronous Methods for Deep Reinforcement Learning</a> 中提出的，其理念是通过多个进程或线程的Agent在不同策略的指导下不断与环境交互，然后收集动作和奖励，最终博采众长。</p><h3 id="异步训练框架"><a href="#异步训练框架" class="headerlink" title="异步训练框架"></a>异步训练框架</h3><p>&emsp;&emsp;上图中上部的Global Network就是共享的公共部分，主要是一个公共的神经网络模型，这个神经网络包括Actor网络和Critic网络两部分的功能。下面有n个worker线程，每个线程里有和公共的神经网络一样的网络结构，每个线程会独立的和环境进行交互得到经验数据，这些线程之间互不干扰，独立运行。</p><p>&emsp;&emsp;每个线程和环境交互到一定量的数据后，就计算在自己线程里的神经网络损失函数的梯度，但是这些梯度却并不更新自己线程里的神经网络，而是去更新公共的神经网络。也就是n个线程会独立的使用累积的梯度分别更新公共部分的神经网络模型参数。每隔一段时间，线程会将自己的神经网络的参数更新为公共神经网络的参数，进而指导后面的环境交互。</p><p>&emsp;&emsp;可见，公共部分的网络模型就是待训练的模型，而线程里的网络模型主要是用于和环境交互使用的，这些线程里的模型可以帮助线程更好的和环境交互，拿到高质量的数据帮助模型更快收敛。</p><p>&nbsp;</p><h2 id="A3C：DQN"><a href="#A3C：DQN" class="headerlink" title="A3C：DQN"></a>A3C：DQN</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>并行性</strong></p><p>&emsp;&emsp;A3C是第一个以显示方式表示可以使用并行化的强化学习算法，由此，在线学习可以成倍地提高样本手机效率，拿CPU计算资源换取时间效率。不过要注意，多线程异步并行Agent与环境的交互过程只能通过CPU来计算，GPU这时帮不上忙，GPU只在定期更新网络参数时起到加速的作用，因此CPU的处理速度和线程数量显得额外重要。</p><p><strong>异步更新</strong></p><p>&emsp;&emsp;A3C中有两处网络参数更新，一个是当前Q网络（估计Q值）更新，另一个是目标Q网络（计算目标Q值）。这两步都是周期更新，所有线程维护两个公共计数器，当计数器到达时，当前所处的线程就更新对应网络。由此可见两个网络的更新都是异步的，而由经验可知，异步的间隔越大，就越像离线学习，估值就越稳定、收敛越平稳，因此两个计数器的计数阈值的大小会影响Agent所表现出来的进步效率和收敛稳定性之间的平衡。一般建议这两个值设的大一些。</p><p><strong>取消Replay Memory</strong></p><p>&emsp;&emsp;在DQN算法族中大部分算法都是用经验回放来消除样本之间的关联性，从而帮助网络更好地收敛，但是在A3C算法中不再需要使用这个方法来消除关联性，因为本身多个Agent就是异步并行地对环境进行交互试探，得到的经验是不相关的，而网络的更新是各个Agent的经验按周期一同使用，所以数据的相关性通过这种并行性就已经消除了。关于这点，论文中也有给出专门的论述。</p><p>&emsp;&emsp;并且由于不再需要使用经验回放，计算机的内存资源也得到了释放，这使得在线学习算法的执行效率得到了提高。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125452.png" alt="image-20220113125452328" style="zoom:50%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络结构，对应参数位θ、w，全局共享的迭代轮数T，全局最大迭代次数Tmax，w更新周期Iw，θ更新周期Iθ，状态特征维度n, 动作集A，衰减因子γ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络参数θ、w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>更新时间序列 t=0</p></li><li><p>重置Actor和Critic的梯度更新量：<code>dθ=0</code></p></li><li><p><code>tstart = t</code>，初始化状态st</p></li><li><p>if ( T &lt;= Tmax )：</p><ul><li><p>基于策略 <code>π(at|st;θ)</code> 选择出动作at</p></li><li><p>执行动作at得到奖励 <code>rt</code> 和新状态 <code>st+1</code></p></li><li><p>计算目标Q值：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209182402.png" alt="image-20220209182402662" style="zoom: 33%;" /></li><li><p>累积需要更新的梯度：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209182501.png" alt="image-20220209182501797" style="zoom: 33%;" /></li><li><p>执行一步，进入状态 <code>st+1</code></p></li><li><p>t = t+1、T = T+1</p></li><li><p>if ( T % Iw == 0 )：</p><ul><li>复制更新目标Q网络的参数：w = θ</li></ul></li><li><p>if ( t % Iθ == 0 )：</p><ul><li>更新当前Q网络的参数：<ul><li>θ = θ - dθ</li><li>dθ = 0</li></ul></li></ul></li><li><p>进入步骤4</p></li></ul><p> else：算法结束，输出公共部分的A3C神经网络参数 θ、w</p></li></ol><p>注意：从第4步开始就是每个线程的Agent要做的内容，各个线程共享进程资源和变量，即：θ、w、dθ 是”全局“变量，线程共享。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;Gym 的 Pong-v0 游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> config.net <span class="keyword">import</span> AtariNet</span><br><span class="line"><span class="keyword">from</span> config.util <span class="keyword">import</span> preprocess</span><br><span class="line"></span><br><span class="line">LR = <span class="number">0.001</span></span><br><span class="line">EXPLORE = <span class="number">1000000</span></span><br><span class="line">GAMMA = <span class="number">0.99</span></span><br><span class="line">N_STEP = <span class="number">4</span></span><br><span class="line">ENV = <span class="string">&#x27;Pong-v0&#x27;</span></span><br><span class="line">ACTIONS_SIZE = gym.make(ENV).action_space.n</span><br><span class="line">PROCESSES = <span class="number">1</span></span><br><span class="line">SEED = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, action_size</span>):</span></span><br><span class="line">        self.action_size = action_size</span><br><span class="line">        self.EPSILON = <span class="number">1.0</span></span><br><span class="line">        self.network = AtariNet(action_size)</span><br><span class="line">        self.memory = deque()</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.network.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state, israndom</span>):</span></span><br><span class="line">        <span class="keyword">if</span> israndom <span class="keyword">and</span> random.random() &lt; self.EPSILON:</span><br><span class="line">            <span class="keyword">return</span> np.random.randint(<span class="number">0</span>, self.action_size)</span><br><span class="line">        state = torch.unsqueeze(torch.FloatTensor(state), <span class="number">0</span>)</span><br><span class="line">        actions_value = self.network.forward(state)</span><br><span class="line">        <span class="keyword">return</span> torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            self.memory.append((state, action, reward, next_state, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.memory.append((state, action, reward, next_state, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, shared_optimizer, shared_model</span>):</span></span><br><span class="line">        batch_size = <span class="built_in">len</span>(self.memory)</span><br><span class="line">        batch = random.sample(self.memory, batch_size)</span><br><span class="line">        state = torch.FloatTensor([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        action = torch.LongTensor([[x[<span class="number">1</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        reward = torch.FloatTensor([[x[<span class="number">2</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        next_state = torch.FloatTensor([x[<span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        done = torch.FloatTensor([[x[<span class="number">4</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line"></span><br><span class="line">        eval_q = self.network.forward(state).gather(<span class="number">1</span>, action)</span><br><span class="line">        next_q = self.network(next_state).detach()</span><br><span class="line">        target_q = reward + GAMMA * next_q.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(batch_size, <span class="number">1</span>) * done</span><br><span class="line">        loss = self.loss_func(eval_q, target_q)</span><br><span class="line"></span><br><span class="line">        shared_optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="keyword">for</span> param, shared_param <span class="keyword">in</span> <span class="built_in">zip</span>(self.network.parameters(), shared_model.parameters()):</span><br><span class="line">            <span class="keyword">if</span> shared_param.grad <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                shared_param._grad = param.grad</span><br><span class="line">        shared_optimizer.step()</span><br><span class="line"></span><br><span class="line">        self.memory = deque()</span><br><span class="line">        <span class="keyword">if</span> self.EPSILON &gt; <span class="number">0.1</span>:</span><br><span class="line">            self.EPSILON -= (<span class="number">1.0</span> - <span class="number">0.1</span>) / EXPLORE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedAdam</span>(<span class="params">torch.optim.Adam</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, params, lr=<span class="number">1e-3</span>, betas=(<span class="params"><span class="number">0.9</span>, <span class="number">0.999</span></span>), eps=<span class="number">1e-8</span>, weight_decay=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(SharedAdam, self).__init__(params, lr, betas, eps, weight_decay)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> self.param_groups:</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> group[<span class="string">&#x27;params&#x27;</span>]:</span><br><span class="line">                state = self.state[p]</span><br><span class="line">                state[<span class="string">&#x27;shared_steps&#x27;</span>], state[<span class="string">&#x27;step&#x27;</span>] = torch.zeros(</span><br><span class="line">                    <span class="number">1</span>).share_memory_(), <span class="number">0</span></span><br><span class="line">                state[<span class="string">&#x27;exp_avg&#x27;</span>] = p.data.new().resize_as_(</span><br><span class="line">                    p.data).zero_().share_memory_()</span><br><span class="line">                state[<span class="string">&#x27;exp_avg_sq&#x27;</span>] = p.data.new().resize_as_(</span><br><span class="line">                    p.data).zero_().share_memory_()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">shared_model, shared_optimizer, rank, info</span>):</span></span><br><span class="line">    env = gym.make(ENV)</span><br><span class="line">    env.seed(SEED + rank)</span><br><span class="line">    torch.manual_seed(SEED + rank)</span><br><span class="line">    agent = Agent(ACTIONS_SIZE)</span><br><span class="line"></span><br><span class="line">    start_time = last_disp_time = time.time()</span><br><span class="line">    episode_length, epr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    state = env.reset()</span><br><span class="line">    state = preprocess(state)</span><br><span class="line">    <span class="keyword">while</span> info[<span class="string">&#x27;frames&#x27;</span>][<span class="number">0</span>] &lt;= <span class="number">4e7</span>:</span><br><span class="line">        agent.network.load_state_dict(shared_model.state_dict())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N_STEP):</span><br><span class="line">            <span class="comment"># env.render()</span></span><br><span class="line">            episode_length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            action = agent.action(state, <span class="literal">True</span>)</span><br><span class="line">            next_state, reward, done, ext = env.step(action)</span><br><span class="line">            epr += reward</span><br><span class="line">            done = done <span class="keyword">or</span> episode_length &gt;= <span class="number">1e4</span></span><br><span class="line">            info[<span class="string">&#x27;frames&#x27;</span>].add_(<span class="number">1</span>)</span><br><span class="line">            num_frames = <span class="built_in">int</span>(info[<span class="string">&#x27;frames&#x27;</span>].item())</span><br><span class="line"></span><br><span class="line">            next_state = preprocess(next_state)</span><br><span class="line">            agent.add(state, action, reward, next_state, done)</span><br><span class="line"></span><br><span class="line">            state = next_state</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                info[<span class="string">&#x27;episodes&#x27;</span>] += <span class="number">1</span></span><br><span class="line">                interp = <span class="number">1</span> <span class="keyword">if</span> info[<span class="string">&#x27;episodes&#x27;</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.01</span></span><br><span class="line">                info[<span class="string">&#x27;run_epr&#x27;</span>].mul_(<span class="number">1</span> - interp).add_(interp * epr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rank == <span class="number">0</span> <span class="keyword">and</span> time.time() - last_disp_time &gt; <span class="number">60</span>:</span><br><span class="line">                elapsed = time.strftime(</span><br><span class="line">                    <span class="string">&quot;%Hh %Mm %Ss&quot;</span>, time.gmtime(time.time() - start_time))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;time &#123;&#125;, episodes &#123;:.0f&#125;, frames &#123;:.1f&#125;M, mean epr &#123;:.2f&#125;&#x27;</span></span><br><span class="line">                      .<span class="built_in">format</span>(elapsed, info[<span class="string">&#x27;episodes&#x27;</span>].item(), num_frames / <span class="number">1e6</span>,</span><br><span class="line">                              info[<span class="string">&#x27;run_epr&#x27;</span>].item()))</span><br><span class="line">                last_disp_time = time.time()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                episode_length, epr, eploss = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                state = env.reset()</span><br><span class="line">                state = preprocess(state)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        agent.learn(shared_optimizer, shared_model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.version_info[<span class="number">0</span>] &gt; <span class="number">2</span>:</span><br><span class="line">        mp.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.platform == <span class="string">&#x27;linux&#x27;</span> <span class="keyword">or</span> sys.platform == <span class="string">&#x27;linux2&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;Must be using Python 3 with linux! Or else you get a deadlock in conv2d&quot;</span></span><br><span class="line"></span><br><span class="line">    torch.manual_seed(SEED)</span><br><span class="line">    shared_model = AtariNet(ACTIONS_SIZE).share_memory()</span><br><span class="line">    shared_optimizer = SharedAdam(shared_model.parameters(), lr=LR)</span><br><span class="line"></span><br><span class="line">    info = &#123;k: torch.DoubleTensor([<span class="number">0</span>]).share_memory_()</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">&#x27;run_epr&#x27;</span>, <span class="string">&#x27;episodes&#x27;</span>, <span class="string">&#x27;frames&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="built_in">range</span>(PROCESSES):</span><br><span class="line">        p = mp.Process(target=worker, args=(</span><br><span class="line">            shared_model, shared_optimizer, rank, info))</span><br><span class="line">        p.start()</span><br><span class="line">        processes.append(p)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="A3C-DDPG"><a href="#A3C-DDPG" class="headerlink" title="A3C DDPG"></a>A3C DDPG</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;和上面A3C DQN算法略有不同，A3C DDPG算法中不仅有全局共享的网络参数 θ、w，同时每个线程都有独占的变量，即 θ‘、w’。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>网络结构优化</strong></p><p>&emsp;&emsp;A3C把两个网络放到了一起，即输入状态S，可以输出状态价值V和对应的策略π。不过仍然可以把Actor和Critic看做独立的两块，分别处理：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112094415.png" alt="image-20220112094415642" style="zoom: 25%;" /><p><strong>Critic选择的优化</strong></p><p>&emsp;&emsp;在A3C中Critic选择为优势函数的近似，省略<a href="extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=http%3A%2F%2Fproceedings.mlr.press%2Fv48%2Fmniha16.pdf">A3C论文</a>中的推导，直接给出其计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112095035.png" alt="image-20220112095035246" style="zoom:40%;" /><p><strong>损失函数优化</strong></p><p>&emsp;&emsp;在Actor的损失函数中加入了策略π的熵项，系数为c：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112095453.png" alt="image-20220112095453116" style="zoom:40%;" /><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209183724.png" alt="image-20220209183724280" style="zoom: 60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络结构，对应参数位θ、w，当前线程的A3C神经网络结构，对应参数θ′、w′，全局共享的迭代轮数T，全局最大迭代次数Tmax，线程内单次迭代时间序列最大长度tmax，状态特征维度n, 动作集A，步长α、β，熵系数c，衰减因子γ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络参数θ、w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>更新时间序列 t=1</p></li><li><p>if (T &lt;= Tmax )：</p><ul><li><p>重置Actor和Critic的梯度更新量：<code>dθ=0、dw=0</code></p></li><li><p>从公共部分的A3C神经网络同步参数到本线程的神经网络：<code>θ’=θ、w’=w</code></p></li><li><p><code>tstart = t</code>，初始化状态st</p></li><li><p>if ( st不是终止状态 且 t - tstart != tmax )：</p><ol><li>基于策略 <code>π(at|st;θ)</code> 选择出动作at</li><li>执行动作at得到奖励rt和新状态st+1</li><li>t = t+1、T = T+1</li><li>返回步骤 2.4</li></ol><p>  else：进入步骤 3</p></li></ul></li><li><p>计算最后一个时间序列位置st的Q(s,t)：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112101419.png" alt="image-20220112101419222" style="zoom:40%;" /> <center>注意，这里和DQN、DDOG都不一样，游戏结束的奖励是0</center></li><li><p>for i in [t-1, tstart]：</p><ul><li><p>计算每个时刻的Q(s, i)：<code>Q(s, i) = ri + γQ(s, i+1)</code></p></li><li><p>累计Actor网络的梯度更新：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112102319.png" alt="image-20220112102319176" style="zoom:40%;" /></li><li><p>累计Critic网络的梯度更新：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112102707.png" alt="image-20220112102707754" style="zoom:40%;" /></li></ul></li><li><p>更新全局神经网络的参数：<code>θ=θ-αdθ、w=w-βdw</code></p></li><li><p>if ( T&gt;Tmax )：算法结束，输出公共部分的A3C神经网络参数 θ、w；</p><p> else：进入步骤 2</p></li></ol><p>（可以看出，A3C DDPG中，每个线程的Agent会从头到尾”玩”一个episode，期间只更新本线程的网络参数θ‘、w’，一轮游戏结束后才将学到的所有东西更新到全局共享网络 θ、w 中，全局共享网络参数θ、w更新是以episode为周期进行的）</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">OUTPUT_GRAPH = <span class="literal">True</span></span><br><span class="line">LOG_DIR = <span class="string">&#x27;./log&#x27;</span></span><br><span class="line">N_WORKERS = <span class="number">3</span></span><br><span class="line">MAX_GLOBAL_EP = <span class="number">3000</span></span><br><span class="line">GLOBAL_NET_SCOPE = <span class="string">&#x27;Global_Net&#x27;</span></span><br><span class="line">UPDATE_GLOBAL_ITER = <span class="number">100</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">ENTROPY_BETA = <span class="number">0.001</span></span><br><span class="line">LR_A = <span class="number">0.001</span>    <span class="comment"># learning rate for actor</span></span><br><span class="line">LR_C = <span class="number">0.001</span>    <span class="comment"># learning rate for critic</span></span><br><span class="line">GLOBAL_RUNNING_R = []</span><br><span class="line">GLOBAL_EP = <span class="number">0</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line">env = gym.make(GAME)</span><br><span class="line">N_S = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">N_A = env.action_space.n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACNet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, scope, globalAC=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> scope == GLOBAL_NET_SCOPE:   <span class="comment"># get global network</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">                self.s = tf.placeholder(tf.float32, [<span class="literal">None</span>, N_S], <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                self.a_params, self.c_params = self._build_net(scope)[-<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># local net, calculate losses</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">                self.s = tf.placeholder(tf.float32, [<span class="literal">None</span>, N_S], <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                self.a_his = tf.placeholder(tf.int32, [<span class="literal">None</span>, ], <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                self.v_target = tf.placeholder(</span><br><span class="line">                    tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], <span class="string">&#x27;Vtarget&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                self.a_prob, self.v, self.a_params, self.c_params = self._build_net(</span><br><span class="line">                    scope)</span><br><span class="line"></span><br><span class="line">                td = tf.subtract(self.v_target, self.v, name=<span class="string">&#x27;TD_error&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;c_loss&#x27;</span>):</span><br><span class="line">                    self.c_loss = tf.reduce_mean(tf.square(td))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;a_loss&#x27;</span>):</span><br><span class="line">                    log_prob = tf.reduce_sum(tf.log(self.a_prob + <span class="number">1e-5</span>) * tf.one_hot(</span><br><span class="line">                        self.a_his, N_A, dtype=tf.float32), axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>)</span><br><span class="line">                    exp_v = log_prob * tf.stop_gradient(td)</span><br><span class="line">                    entropy = -tf.reduce_sum(self.a_prob * tf.log(self.a_prob + <span class="number">1e-5</span>),</span><br><span class="line">                                             axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>)  <span class="comment"># encourage exploration</span></span><br><span class="line">                    self.exp_v = ENTROPY_BETA * entropy + exp_v</span><br><span class="line">                    self.a_loss = tf.reduce_mean(-self.exp_v)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;local_grad&#x27;</span>):</span><br><span class="line">                    self.a_grads = tf.gradients(self.a_loss, self.a_params)</span><br><span class="line">                    self.c_grads = tf.gradients(self.c_loss, self.c_params)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;sync&#x27;</span>):</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;pull&#x27;</span>):</span><br><span class="line">                    self.pull_a_params_op = [l_p.assign(g_p) <span class="keyword">for</span> l_p, g_p <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                        self.a_params, globalAC.a_params)]</span><br><span class="line">                    self.pull_c_params_op = [l_p.assign(g_p) <span class="keyword">for</span> l_p, g_p <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                        self.c_params, globalAC.c_params)]</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;push&#x27;</span>):</span><br><span class="line">                    self.update_a_op = OPT_A.apply_gradients(</span><br><span class="line">                        <span class="built_in">zip</span>(self.a_grads, globalAC.a_params))</span><br><span class="line">                    self.update_c_op = OPT_C.apply_gradients(</span><br><span class="line">                        <span class="built_in">zip</span>(self.c_grads, globalAC.c_params))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_net</span>(<span class="params">self, scope</span>):</span></span><br><span class="line">        w_init = tf.random_normal_initializer(<span class="number">0.</span>, <span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;actor&#x27;</span>):</span><br><span class="line">            l_a = tf.layers.dense(self.s, <span class="number">200</span>, tf.nn.relu6,</span><br><span class="line">                                  kernel_initializer=w_init, name=<span class="string">&#x27;la&#x27;</span>)</span><br><span class="line">            a_prob = tf.layers.dense(</span><br><span class="line">                l_a, N_A, tf.nn.softmax, kernel_initializer=w_init, name=<span class="string">&#x27;ap&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;critic&#x27;</span>):</span><br><span class="line">            l_c = tf.layers.dense(self.s, <span class="number">100</span>, tf.nn.relu6,</span><br><span class="line">                                  kernel_initializer=w_init, name=<span class="string">&#x27;lc&#x27;</span>)</span><br><span class="line">            v = tf.layers.dense(</span><br><span class="line">                l_c, <span class="number">1</span>, kernel_initializer=w_init, name=<span class="string">&#x27;v&#x27;</span>)  <span class="comment"># state value</span></span><br><span class="line">        a_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.TRAINABLE_VARIABLES, scope=scope + <span class="string">&#x27;/actor&#x27;</span>)</span><br><span class="line">        c_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.TRAINABLE_VARIABLES, scope=scope + <span class="string">&#x27;/critic&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> a_prob, v, a_params, c_params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_global</span>(<span class="params">self, feed_dict</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        <span class="comment"># local grads applies to global net</span></span><br><span class="line">        SESS.run([self.update_a_op, self.update_c_op], feed_dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull_global</span>(<span class="params">self</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        SESS.run([self.pull_a_params_op, self.pull_c_params_op])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, s</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        prob_weights = SESS.run(self.a_prob, feed_dict=&#123;</span><br><span class="line">                                self.s: s[np.newaxis, :]&#125;)</span><br><span class="line">        action = np.random.choice(<span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]),</span><br><span class="line">                                  p=prob_weights.ravel())  <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, globalAC</span>):</span></span><br><span class="line">        self.env = gym.make(GAME).unwrapped</span><br><span class="line">        self.name = name</span><br><span class="line">        self.AC = ACNet(name, globalAC)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> GLOBAL_RUNNING_R, GLOBAL_EP</span><br><span class="line">        total_step = <span class="number">1</span></span><br><span class="line">        buffer_s, buffer_a, buffer_r = [], [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> COORD.should_stop() <span class="keyword">and</span> GLOBAL_EP &lt; MAX_GLOBAL_EP:</span><br><span class="line">            s = self.env.reset()</span><br><span class="line">            ep_r = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># if self.name == &#x27;W_0&#x27;:</span></span><br><span class="line">                <span class="comment">#     self.env.render()</span></span><br><span class="line">                a = self.AC.choose_action(s)</span><br><span class="line">                s_, r, done, info = self.env.step(a)</span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    r = -<span class="number">5</span></span><br><span class="line">                ep_r += r</span><br><span class="line">                buffer_s.append(s)</span><br><span class="line">                buffer_a.append(a)</span><br><span class="line">                buffer_r.append(r)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total_step % UPDATE_GLOBAL_ITER == <span class="number">0</span> <span class="keyword">or</span> done:   <span class="comment"># update global and assign to local net</span></span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        v_s_ = <span class="number">0</span>   <span class="comment"># terminal</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        v_s_ = SESS.run(</span><br><span class="line">                            self.AC.v, &#123;self.AC.s: s_[np.newaxis, :]&#125;)[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">                    buffer_v_target = []</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> buffer_r[::-<span class="number">1</span>]:    <span class="comment"># reverse buffer r</span></span><br><span class="line">                        v_s_ = r + GAMMA * v_s_</span><br><span class="line">                        buffer_v_target.append(v_s_)</span><br><span class="line">                    buffer_v_target.reverse()</span><br><span class="line"></span><br><span class="line">                    buffer_s, buffer_a, buffer_v_target = np.vstack(</span><br><span class="line">                        buffer_s), np.array(buffer_a), np.vstack(buffer_v_target)</span><br><span class="line">                    feed_dict = &#123;</span><br><span class="line">                        self.AC.s: buffer_s,</span><br><span class="line">                        self.AC.a_his: buffer_a,</span><br><span class="line">                        self.AC.v_target: buffer_v_target,</span><br><span class="line">                    &#125;</span><br><span class="line">                    self.AC.update_global(feed_dict)</span><br><span class="line"></span><br><span class="line">                    buffer_s, buffer_a, buffer_r = [], [], []</span><br><span class="line">                    self.AC.pull_global()</span><br><span class="line"></span><br><span class="line">                s = s_</span><br><span class="line">                total_step += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(GLOBAL_RUNNING_R) == <span class="number">0</span>:  <span class="comment"># record running episode reward</span></span><br><span class="line">                        GLOBAL_RUNNING_R.append(ep_r)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        GLOBAL_RUNNING_R.append(</span><br><span class="line">                            <span class="number">0.99</span> * GLOBAL_RUNNING_R[-<span class="number">1</span>] + <span class="number">0.01</span> * ep_r)</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        self.name,</span><br><span class="line">                        <span class="string">&quot;Ep:&quot;</span>, GLOBAL_EP,</span><br><span class="line">                        <span class="string">&quot;| Ep_r: %i&quot;</span> % GLOBAL_RUNNING_R[-<span class="number">1</span>],</span><br><span class="line">                    )</span><br><span class="line">                    GLOBAL_EP += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    SESS = tf.Session()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:0&quot;</span>):</span><br><span class="line">        OPT_A = tf.train.RMSPropOptimizer(LR_A, name=<span class="string">&#x27;RMSPropA&#x27;</span>)</span><br><span class="line">        OPT_C = tf.train.RMSPropOptimizer(LR_C, name=<span class="string">&#x27;RMSPropC&#x27;</span>)</span><br><span class="line">        GLOBAL_AC = ACNet(GLOBAL_NET_SCOPE)  <span class="comment"># we only need its params</span></span><br><span class="line">        workers = []</span><br><span class="line">        <span class="comment"># Create worker</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N_WORKERS):</span><br><span class="line">            i_name = <span class="string">&#x27;W_%i&#x27;</span> % i   <span class="comment"># worker name</span></span><br><span class="line">            workers.append(Worker(i_name, GLOBAL_AC))</span><br><span class="line"></span><br><span class="line">    COORD = tf.train.Coordinator()</span><br><span class="line">    SESS.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> OUTPUT_GRAPH:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(LOG_DIR):</span><br><span class="line">            shutil.rmtree(LOG_DIR)</span><br><span class="line">        tf.summary.FileWriter(LOG_DIR, SESS.graph)</span><br><span class="line"></span><br><span class="line">    worker_threads = []</span><br><span class="line">    <span class="keyword">for</span> worker <span class="keyword">in</span> workers:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">job</span>():</span> <span class="keyword">return</span> worker.work()</span><br><span class="line">        t = threading.Thread(target=job)</span><br><span class="line">        t.start()</span><br><span class="line">        worker_threads.append(t)</span><br><span class="line">    COORD.join(worker_threads)</span><br><span class="line"></span><br><span class="line">    testWorker = Worker(<span class="string">&quot;test&quot;</span>, GLOBAL_AC)</span><br><span class="line">    testWorker.AC.pull_global()</span><br><span class="line"></span><br><span class="line">    total_reward = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            env.render()</span><br><span class="line">            action = testWorker.AC.choose_action(</span><br><span class="line">                state)  <span class="comment"># direct action for test</span></span><br><span class="line">            state, reward, done, _ = env.step(action)</span><br><span class="line">            total_reward += reward</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    ave_reward = total_reward / TEST</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, GLOBAL_EP, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line">    plt.plot(np.arange(<span class="built_in">len</span>(GLOBAL_RUNNING_R)), GLOBAL_RUNNING_R)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;step&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Total moving reward&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118130134.png" alt="image-20220118105654323" style="zoom: 35%;" /><p>&nbsp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;A3C提供了一种通用的异步的并发的强化学习框架，就像是多个影分身同时学习，然后把学会的汇总在一起。A3C并发框架不光可以用于DQN、DDPG，还可以用于其他的强化学习算法，这是A3C最大的贡献。目前已经有基于GPU的A3C框架，这样A3C的框架训练速度就更快了。</p><p>&emsp;&emsp;但是有一点需要注意，多线程之间访问共享资源时不可避免地要考虑通信和同步问题，最简单的方法就是添加互斥锁，在Python中是通过GIL库来实现的。但是GIL库设计上存在缺陷，效率存在严重问题且属于历史遗留问题无法解决。因此在Python中使用A3C进行训练的话，最好使用多进程+多协程的方式。</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境配置 &amp; 问题记录</title>
      <link href="/2022/02/08/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/02/08/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;记录一下配置环境遇到的奇奇怪怪的bug，特别是软件版本前后不互相支持、官方文档不够全面的问题（痛苦面具＞﹏＜）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220216231526.png" alt="image-20220216231526246" style="zoom: 20%;" /><span id="more"></span><p>&nbsp;</p><h3 id="Gym安装正常，但atari游戏无法使用"><a href="#Gym安装正常，但atari游戏无法使用" class="headerlink" title="Gym安装正常，但atari游戏无法使用"></a>Gym安装正常，但atari游戏无法使用</h3><h4 id="Part1：安装"><a href="#Part1：安装" class="headerlink" title="Part1：安装"></a>Part1：安装</h4><p>（正确步骤总结在最后）</p><hr><p>按照官方文档安装gym：</p><p><code>pip install gym</code></p><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    env.render()</span><br><span class="line">    env.step(env.action_space.sample()) <span class="comment"># take a random action</span></span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure><p>代码运行正常</p><hr><p>跑强化学习代码，用gym作为环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&#x27;Pong-v0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>出现报错，提示gym库中没有挂载 <code>‘Pong-v0’</code> 这个游戏</p><hr><p>按照stackoverflow上帖子：<a href="https://stackoverflow.com/questions/69442971/error-in-importing-environment-openai-gym">Error in importing environment OpenAI Gym</a> 建议，操作如下：</p><p><code>pip install --upgrade gym==0.19.0</code></p><p><code>pip install gym[atari]</code></p><hr><p>此时跑强化学习程序，出现另一种报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileNotFoundError: Could <span class="keyword">not</span> find module <span class="string">&#x27;D:\anaconda3\lib\site-packages\atari_py\ale_interface\ale_c.dll&#x27;</span> (<span class="keyword">or</span> one of its dependencies). Try using </span><br><span class="line">the full path <span class="keyword">with</span> constructor syntax.</span><br></pre></td></tr></table></figure><p>提示位置没有 <code>ale_c.dll</code> 文件，故上网下载了一个（<a href="https://drive.google.com/file/d/1WQrEBliYbASwNDyyVIlPFSZHRwAa7sPp/view?usp=sharing">网址</a>），放到对应位置，但是依然报同样的错误</p><hr><p>按照 github 论坛 <a href="https://github.com/openai/gym/issues/1726">module could not be found’ when running gym.make for atari environment</a> 建议，操作如下：</p><ol><li><p><code>pip uninstall atari-py</code></p><p> <code>pip uninstall gym[atari]</code></p></li><li><p>下载 VS build tools：<a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16">网址</a> （科学上网）</p></li><li><p>安装VS build，注意选择 C++ build tools</p><p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110252.png" alt="68347704-afadcf80-00ac-11ea-8da0-446c390556f9"></p></li><li><p>重启电脑</p></li><li><p>安装 cmake, atari-py and gym<br> <code>pip install cmake</code><br> <code>pip install atari-py</code><br> <code>pip install gym[atari]</code></p></li><li><p>测试：<br> <code>import atari_py</code><br> <code>print(atari_py.list_games())</code></p></li><li><p>理论效果：</p><p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110358.png" alt="image-20220208110358251"></p><p> 实际效果：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110523.png" alt="image-20220208110523047" style="zoom:50%;" /></li></ol><hr><p>再运行强化学习程序，工作正常（喜</p><hr><p>经过在服务器和虚拟机的多次测试，安装gym的正确过程总结如下：</p><p><code>pip install cmake</code><br><code>pip install atari-py</code><br><code>pip install gym[atari]</code><br><code>pip install gym[accept-rom-license]</code></p><h4 id="Part2：判断版本"><a href="#Part2：判断版本" class="headerlink" title="Part2：判断版本"></a>Part2：判断版本</h4><p>本来按照上面安装好了，<code>Pong-v0</code> 游戏已经可以使用了，但是在我写一个ddpg算法中使用 <code>Pendulum-v0 </code>游戏时又出错了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) PS C:\Users\lrk\Desktop\Learn\DRL&gt; python .\ddpg.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 158, <span class="keyword">in</span> spec</span><br><span class="line">    <span class="built_in">return</span> self.env_specs[id]</span><br><span class="line">KeyError: <span class="string">&#x27;Pendulum-v0&#x27;</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;.\ddpg.py&quot;</span>, line 142, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    env = gym.make(args.env_name)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 235, <span class="keyword">in</span> make</span><br><span class="line">    <span class="built_in">return</span> registry.make(id, **kwargs)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 128, <span class="keyword">in</span> make</span><br><span class="line">    spec = self.spec(path)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 185, <span class="keyword">in</span> spec</span><br><span class="line">    raise error.DeprecatedEnv(</span><br><span class="line">gym.error.DeprecatedEnv: Env Pendulum-v0 not found (valid versions include [<span class="string">&#x27;Pendulum-v1&#x27;</span>])</span><br></pre></td></tr></table></figure><p>看样子又没找到这个游戏，不过似乎是版本的问题，于是按照网上帖子学会了gym内注册游戏的代码位置：</p><p><code>D:\anaconda3\lib\site-packages\gym\__init__.py</code>，注意这是目前我电脑上gym的安装目录，自己的目录位置可以通过报错内容来查看。</p><p>可以看见gym内注册的游戏都在这里（截出部分）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209154944.png" alt="image-20220209154944060" style="zoom:50%;" /><p>自行查看可以用版本即可。</p><p>&nbsp;</p><p>&nbsp;</p><hr><h3 id="Windows文件传到Linux后去除-M"><a href="#Windows文件传到Linux后去除-M" class="headerlink" title="Windows文件传到Linux后去除^M"></a>Windows文件传到Linux后去除^M</h3><p>在Windows环境下编辑的文件，上传到Linux后会在文件中产生 <code>^M</code>字符。尤其是对sh脚本的运行产生影响：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#!coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x = <span class="string">&quot;abc123&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x[<span class="number">2</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>WSL下的执行结果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220210212409.png" alt="image-20220210212409708" style="zoom: 67%;" /><p><strong>原因</strong></p><p>&emsp;&emsp;CRLF(\r\n)是Windows环境下的行尾结束符，LF(\n)Linux环境下的行尾结束符，在Linux环境下，无法识别Windows环境下文件的行尾结束符引起。</p><p><strong>处理</strong></p><p>查看方法：<code>cat -A &lt;filename&gt;</code></p><p>消除方法（4种）：</p><ul><li><code>sed -i &#39;s/^M$//g&#39; &lt;filename&gt;</code></li><li><code>cat &lt;filename1&gt; | tr -d &#39;\r&#39; &gt; &lt;filename&gt;</code></li><li><code>dos2unix &lt;filename&gt;</code></li><li><code>vim &lt;filename&gt; </code> + 输入 <code>: set ff=unix</code> + 输入 <code>:wq</code> 退出</li></ul><p>&nbsp;</p><p>&nbsp;</p><hr><h3 id="Typora图床图片-load-failed"><a href="#Typora图床图片-load-failed" class="headerlink" title="Typora图床图片 load failed"></a>Typora图床图片 load failed</h3><p>根据目前测试，大小超过1M就会加载不出来，压缩就好了</p><p>&nbsp;</p><p>&nbsp;</p><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】决策树&amp;随机森林——回归问题</title>
      <link href="/2022/02/06/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/06/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在监督学习中，分类问题通常是指预测离散类的标签，而回归问题则是预测连续类的值。分类并没有逼近的概念，最终正确结果只有一个，错误的就是错误的，不会有相近的概念；而回归则是使预测值不断逼近理论值，会存在误差。</p><p>&emsp;&emsp;本文记录如何使用决策树和随机森林求解回归问题。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206110710.png" alt="image-20220206110710194" style="zoom:40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><p>&emsp;&emsp;决策树模型既能用于解决分类问题，又能用于处理回归问题，在处理回归问题时，决策树就成为了回归树。不过要注意，回归树与分类时的决策树的不同之处在于，回归树对输入空间的划分采用一种启发式的方法，会遍历所有输入变量，找到最优的切分变量（特征）和最优的切分点（阈值）。在这一步中，回归树不使用熵或者Gini指数表示的不纯度来作为判断依据，而是改用类似损失函数的思想，对不同切分变量和切分点带来的模型误差进行定量计算，取带来最小误差损失的切分变量和切分点。</p><h3 id="回归树的建立"><a href="#回归树的建立" class="headerlink" title="回归树的建立"></a>回归树的建立</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>分叉特征的选择</strong></p><p>对特征空间的划分采用启发式方法，每次划分逐一考察当前集合中所有特征的所有取值，根据平方误差最小化准则选择其中最优的一个作为切分点，平方误差表达式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206105908.png" alt="image-20220205222348334" style="zoom: 67%;" /><p>其中，<code>f(xi)</code> 是每个划分单元的预测值，这个预测值是该单元内每个样本点的值的均值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220205222452.png" alt="image-20220205222452942" style="zoom:67%;" /><p>（这里将输入空间划分为M个单元：R1,R2,…,Rm）</p><p>也就是说，切分变量 <code>j</code> 及切分点 <code>s</code> 的选择必须满下式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102520.png" alt="image-20220206102520423" style="zoom: 60%;" /><p>其中，c1、c2为划分后两个区域内固定的输出值，方括号内的两个min意为使用的是最优值，而最优值对应就是两个区域内各自Y的平均值，故上式可写成：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102747.png" alt="image-20220206102746971" style="zoom:60%;" /><p>其中，c1、c2分别为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102838.png" alt="image-20220206102838239" style="zoom:67%;" /><p>找到最优的切分点(j,s)后，依次将输入空间划分为两个区域，接着对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成了一棵回归树，这样的回归树通常称为<strong>最小二乘回归树</strong>。</p><p><strong>输出值</strong></p><p>通过上面分叉过程，得到的最小二乘回归树的每个叶子节点对应一个分类，该节点内Y的平均值就是这个分类的样本的回归预测值，分叉使已经满足该预测值的最小二乘误差达到最低。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>输入：训练数据集 D</p><p>输出：回归树 f(x)</p><p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p><ol><li><p>选择最优切分变量 <code>j</code> 与切分点 <code>s</code>，求解</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102520.png" alt="image-20220206102520423" style="zoom: 60%;" /><p> 遍历变量 <code>j</code>，对固定的切分变量 <code>j</code> 扫描切分点 <code>s</code>，选出使上式取最小值的对 <code>(j,s)</code></p></li><li><p>用选定的对 <code>(j,s)</code> 划分区域并决定相应的输出值：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206103448.png" alt="image-20220206103448102" style="zoom: 67%;" /><p> 其中，R1、R2分别表示切分出的两个区间</p></li><li><p>继续对两个子区域调用步骤(1),(2)，直至满足停止条件</p></li><li><p>将输入空间划分为M个区域：R1、R2……Rm，生成决策树：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206103610.png" alt="image-20220206103610660" style="zoom:67%;" /><p> 其中 <code>I</code> 为指示函数</p></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>训练数据集如下，简单起见，特征向量只有一维。根据此数据表建立回归决策树：</p><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>y</td><td>5.56</td><td>5.7</td><td>5.91</td><td>6.4</td><td>6.8</td><td>7.05</td><td>8.9</td><td>8.7</td><td>9</td><td>9.05</td></tr></tbody></table><ol><li><p>选择最优切分变量 <code>j</code> 与最优切分点 <code>s</code>：</p><p> 在本数据集中，只有一个特征变量，最优切分变量自然是x。接下来考虑9个切分点：</p><ul><li><p>计算子区域输出值</p><p>  当s=1.5时，两个子区域：R1={1}、R2={2，3，4，5，6，7，8，9，10}</p><p>  对应子区域输出值：c1=5.56、 c2=7.5</p><p>  同理得其他切分点子区域的输出值如下：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>c1</td><td>5.56</td><td>5.63</td><td>5.72</td><td>5.89</td><td>6.07</td><td>6.24</td><td>6.62</td><td>6.88</td><td>7.11</td></tr><tr><td>c2</td><td>7.5</td><td>7.73</td><td>7.99</td><td>8.25</td><td>8.54</td><td>8.91</td><td>8.92</td><td>9.03</td><td>9.05</td></tr></tbody></table></li><li><p>计算最小二乘误差，找出最优切分点</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>L</td><td>15.72</td><td>12.07</td><td>8.36</td><td>5.78</td><td>3.91</td><td>1.93</td><td>8.01</td><td>11.73</td><td>15.74</td></tr></tbody></table><p>  显然，最有切分点为：s=6.5</p></li></ul></li><li><p>用选定的对 <code>(j,s)</code> 划分区域并决定相应的输出值：</p><p> 划分区域为：R1={1，2，3，4，5，6}、R2={7，8，9，10}</p><p> 对应输出值：c1=6.24、c2=8.91</p></li><li><p>调用步骤(1)、(2)，继续划分：</p><p> 对R1，取切分点{1.5，2.5，3.5，4.5，5.5}，对应输出值为：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th></tr></thead><tbody><tr><td>c1</td><td>5.56</td><td>5.63</td><td>5.72</td><td>5.89</td><td>6.07</td></tr><tr><td>c2</td><td>6.37</td><td>6.54</td><td>6.75</td><td>6.93</td><td>7.05</td></tr></tbody></table><p> 最小二乘误差为：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th></tr></thead><tbody><tr><td>L</td><td>1.3087</td><td>0.754</td><td>0.2771</td><td>0.4368</td><td>1.0644</td></tr></tbody></table><p> 故取切分点为：s=3.5</p><p> 后面同理</p></li><li><p>生成回归树：</p><p> 假设两次划分后即停止，则最终生成的回归树为：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206105253.png" alt="image-20220206105253300" style="zoom:67%;" /></li></ol><p>&nbsp;</p><h3 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h3><h4 id="DecisionTreeRegressor"><a href="#DecisionTreeRegressor" class="headerlink" title="DecisionTreeRegressor"></a>DecisionTreeRegressor</h4><p>&emsp;&emsp;sklearn中已经封装好了回归树的对象<a href="https://scikit-learn.org.cn/view/785.html">sklearn.tree.DecisionTreeRegressor</a>，使用时注意参数和接口的定义即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">tree</span>.<span class="title">DecisionTreeRegressor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    *, </span></span></span><br><span class="line"><span class="params"><span class="class">criterion=<span class="string">&#x27;mse&#x27;</span>, <span class="comment"># 特征选择时的误差计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    splitter=<span class="string">&#x27;best&#x27;</span>, <span class="comment"># 特征选择的策略</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 决策树最大深度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 决策树分叉时的最小信息增益的阀值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶子节点最少的样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶子节点最小的样本权重和</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="literal">None</span>, <span class="comment"># 最大特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小误差值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    presort=<span class="string">&#x27;deprecated&#x27;</span>, <span class="comment"># 数据是否预排序</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span><span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树回归器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回预测的确定系数<span class="title">R</span>^2</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>利用决策树对正弦曲线进行加噪观测拟合，学习近似正弦曲线的局部线性回归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sklearn.tree <span class="keyword">as</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a random dataset</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">X = np.sort(<span class="number">5</span> * rng.rand(<span class="number">80</span>, <span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line">y = np.sin(X).ravel()</span><br><span class="line">y[::<span class="number">5</span>] += <span class="number">3</span> * (<span class="number">0.5</span> - rng.rand(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit regression model</span></span><br><span class="line">regr = DecisionTreeRegressor(max_depth=<span class="number">2</span>)</span><br><span class="line">regr.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predict</span></span><br><span class="line">X_test = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.01</span>)[:, np.newaxis]</span><br><span class="line">y_test = regr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualize the tree</span></span><br><span class="line">dot_data = tree.export_graphviz(</span><br><span class="line">    regr,</span><br><span class="line">    out_file=<span class="literal">None</span>,</span><br><span class="line">    filled=<span class="literal">True</span>,</span><br><span class="line">    rounded=<span class="literal">True</span>,</span><br><span class="line">    special_characters=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">&quot;regression&quot;</span>, view=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the results</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, s=<span class="number">20</span>, edgecolor=<span class="string">&quot;black&quot;</span>,</span><br><span class="line">            c=<span class="string">&quot;darkorange&quot;</span>, label=<span class="string">&quot;original data&quot;</span>)</span><br><span class="line">plt.plot(X_test, y_test, color=<span class="string">&quot;cornflowerblue&quot;</span>,</span><br><span class="line">         label=<span class="string">&quot;regression&quot;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;target&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Decision Tree Regression&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>回归树结构：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206111245.png" alt="image-20220206111245582" style="zoom: 45%;" /><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206110710.png" alt="image-20220206110710194" style="zoom:40%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="随机森林回归器"><a href="#随机森林回归器" class="headerlink" title="随机森林回归器"></a>随机森林回归器</h2><p>&emsp;&emsp;思想和随机森林分类器基本一致，区别在于决策树变为回归树。sklearn模型中所有的参数，属性与接口，全部和随机森林分类器一致。仅有的不同就是回归树与分类树的不同，不纯度的指标，参数Criterion不一致。详见：<a href="https://scikit-learn.org.cn/view/650.html">sklearn.ensemble.RandomForestRegressor</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">RandomForestRegressor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>, <span class="comment"># 森林中树木的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    *, </span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;mse&#x27;</span>, <span class="comment"># 特征选择时的误差计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 树的最大深度，如果为None，则自由生长</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 拆分内部节点所需的最少样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶节点的最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶节点上所需的(所有输入样本的)总权重的最小加权分数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>, <span class="comment"># 寻找最佳分割特征时可选择的特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">True</span>, <span class="comment"># 是否使用有放回重复采样</span></span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>, <span class="comment"># 是否使用袋外样本估计泛化精度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>, <span class="comment"># 要并行运行的作业的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>, <span class="comment"># 在拟合和预测时控制冗余程度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>, <span class="comment"># 热启动，将现有的拟合模型属性用于在随后的拟合调用中初始化新模型</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>, <span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span><span class="comment"># 绘制样本的方式</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regression </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】集成学习 &amp; 随机森林</title>
      <link href="/2022/02/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
      <url>/2022/02/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;随机森林是将多棵决策树集成的一种算法，其基本单元是决策树，而本质则属于机器学习的一大分支——集成学习（Ensemble Learning）方法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142616.png" alt="image-20220203142616059" style="zoom: 40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>&emsp;&emsp;集成学习（Ensemble learning）通过构建并结合多个学习器来完成学习任务。将已有的分类或回归算法通过一定方式组合起来，形成一个性能更加强大的分类器，更准确的说这是一种分类算法的组装方法，即将弱分类器组装成强分类器的方法。可以说是集百家之所长，能在机器学习算法中拥有较高的准确率，不足之处就是模型的训练过程可能比较复杂，效率不是很高。</p><p>根据个体学习器的生成方式，目前的集成学习方法大致可以分为2类：</p><ul><li><p>基于Bagging</p><blockquote><p>个体学习器间不存在强依赖关系、可同时生成的并行化方法。</p><p>例：随机森林</p></blockquote></li><li><p>基于Boosting</p><blockquote><p>个体学习器间存在强依赖关系、必须串行生成的序列化方法，除了训练第一个之外，其他的学习器学习都需要依赖于前面生成的学习的结果。</p><p>例：AdaBoost、GBDT、XGBoost</p></blockquote></li></ul><p>&nbsp;</p><h3 id="Bagging算法"><a href="#Bagging算法" class="headerlink" title="Bagging算法"></a>Bagging算法</h3><p>&emsp;&emsp;Bagging（bootstrap aggregating）在原始训练集的随机子集上建立几个黑箱估计器的实例，然后将它们的个体预测聚合起来，形成最终的预测。这些方法通过在基本估计器(例如决策树)的构造过程中引入随机化，然后将其集成起来，从而降低单个基本估计器(如决策树)的方差。在许多情况下，bagging方法是一个非常简单的方法可以用来改进相对单一模型，而不需要调整底层。体现了<strong>并联</strong>的思想。</p><p><strong>算法流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）</span><br><span class="line">2. k个训练集，训练对应k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）</span><br><span class="line">3. 对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）</span><br></pre></td></tr></table></figure><p><strong>sklearn 使用示例</strong></p><p>使用 <code>breast_cancer</code> 数据集，用单个决策树和多个决策树集成的模型进行对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT</span>():</span></span><br><span class="line">    dt = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = dt.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;单个决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT_Bagging</span>():</span></span><br><span class="line">    bagging = BaggingClassifier(DecisionTreeClassifier(</span><br><span class="line">        criterion=<span class="string">&quot;entropy&quot;</span>), max_samples=<span class="number">0.5</span>, max_features=<span class="number">0.5</span>)</span><br><span class="line">    clf = bagging.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;多个决策树集成后的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    DT()</span><br><span class="line">    DT_Bagging()</span><br></pre></td></tr></table></figure><p>结果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142249.png" alt="image-20220203130737004" style="zoom:60%;" /><p>&nbsp;</p><h3 id="Boosting算法"><a href="#Boosting算法" class="headerlink" title="Boosting算法"></a>Boosting算法</h3><p>&emsp;&emsp;Boosting是一簇可将弱学习器提升为强学习器的算法。其工作机制为：先从初始训练集训练出一个基学习器，再根据基学习器的表现对样本分布进行调整，使得先前的基学习器做错的训练样本在后续收到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到实现指定的值T，或整个集成结果达到退出条件，然后将这些学习器进行加权结合，体现了<strong>串联</strong>的思想。</p><p><strong>算法流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对于训练集中的每个样本建立权值wi，表示对每个样本的关注度。当某个样本被误分类的概率很高时，需要加大对该样本的权值。</span><br><span class="line">2. 进行迭代的过程中，每一步迭代都是一个弱分类器。我们需要用某种策略将其组合，作为最终模型。（例如AdaBoost给每个弱分类器一个权值，将其线性组合最为最终分类器。误差越小的弱分类器，权值越大）</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><table><thead><tr><th>关注点</th><th>区别</th></tr></thead><tbody><tr><td>样本选择</td><td>Bagging采用的是Bootstrap随机有放回抽样；而Boosting每一轮的训练集是不变的，改变的只是每一个样本的权重</td></tr><tr><td>样本权重</td><td>Bagging使用的是均匀取样，每个样本权重相等；Boosting根据错误率调整样本权重，错误率越大的样本权重越大</td></tr><tr><td>预测函数</td><td>Bagging所有的预测函数的权重相等；Boosting中误差越小的预测函数其权重越大</td></tr><tr><td>并行计算</td><td>Bagging各个预测函数可以并行生成；Boosting各个预测函数必须按顺序迭代生成</td></tr></tbody></table><p>&emsp;&emsp;从偏差-方差的角度来说，Boosting主要关注减小偏差，而Bagging主要关注降低方差，也就说明Boosting在弱学习器上表现更好，而降低方差可以减小过拟合的风险，所以Bagging通常在强分类和复杂模型上表现得很好。</p><p>举个例子：Bagging在不减枝决策树、神经网络等易受样本扰动的学习器上效果更为明显。</p><p>&nbsp;</p><h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>  简单来说，集成算法就是训练一堆基学习器，然后通过某种策略把各个基学习器的结果进行合成，从而得到集成学习器的结果。常见的结合策略有：平均法、投票法、学习法</p><h4 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h4><p>  评价法包括简单平均法和加权平均法。加权平均法的权重一般从训练数据中学习而得，对规模比较大额集成来说，要学习的权重比较多，较容易导致过拟合，因此加权平均法不一定优于简单平均法。一般而言，在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法。</p><h4 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h4><p>  投票的思想是每个分类器都列出预测对象每个分类结果都概率值，然后多个分类器的分类概率累加在一起。之后的投票分为三种：绝对多数投票、相对多数投票、加权投票。绝对多数投票要求对某个类别预测的概率大于一半则标记，否则不计；相对投票则只计概率最高的类别结果；加权投票思想同加权平均。</p><h4 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h4><p>  当数据很多时，一种更为强大的结合策略是使用学习法，即通过另一个学习器来结合。其中典型代表为Stacking，在Stacking中把个体学习器称为初级学习器，用于结合的学习器称为次学习器或者元学习器。</p><p>（Stacking本身就是一种出名的集成学习方法，且有不少集成学习方法可以认为是其变体或者特例，周志华的西瓜书中把Stacking认为是一种结合策略）</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><h3 id="一般随机森林"><a href="#一般随机森林" class="headerlink" title="一般随机森林"></a>一般随机森林</h3><p>&emsp;&emsp;随机森林（Random Forest）从原始训练样本集N中有放回地重复随机抽取k个样本（bootstrap）生成新的训练样本集合，然后根据自助样本集生成k个分类树组成随机森林，新数据的分类结果按分类树投票多少形成的分数而定。其实质是对决策树算法的一种改进，将多个决策树合并在一起，每棵树的建立依赖于一个独立抽取的样品，森林中的每棵树具有相同的分布，分类误差取决于每一棵树的分类能力和它们之间的相关性。特征选择采用随机的方法去分裂每一个节点，然后比较不同情况下产生的误差。能够检测到的内在估计误差、分类能力和相关性决定选择特征的数目。单棵树的分类能力可能很小，但在随机产生大量的决策树后，一个测试样品可以通过每一棵树的分类结果经统计后选择最可能的分类。</p><p>&nbsp;</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.从训练数据中选取n个数据作为训练数据输入，一般情况下n是远小于整体的训练数据N的。</span><br><span class="line">2.选取了输入的训练数据的之后，需要构建决策树，具体方法是每一个分裂结点从整体的特征集M中选取m个特征构建，一般情况下m远小于M。</span><br><span class="line">3.按照选取最小的基尼指数分裂节点、构造每棵决策树。</span><br><span class="line">4.重复第2步和第3步多次，每一次输入数据对应一颗决策树，从而得到随机森林。</span><br><span class="line">5.对待预测数据进行预测，可以采用多数投票的方式或者平均的方式。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出，随机森林的随机性体现在2点：<strong>有放回抽取样本</strong>、<strong>特征变量选择范围</strong>。这两种随机的目的是降低森林估计器的方差。事实上，单个决策树通常表现出很高的方差，并且往往会过拟合。在森林中注入随机性产生的决策树具有一定的解耦预测误差（decoupled prediction errors）。通过取这些预测的平均值，可以抵消掉一些误差。随机森林通过组合不同的树来减少方差，有时以增加一点点偏差为代价。在实践中，方差减少通常是值得关注的，因此产生了一个整体更好的模型。</p><p>&nbsp;</p><h4 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h4><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">RandomForestClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>, <span class="comment"># 森林中树木的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    *,</span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;gini&#x27;</span>, <span class="comment"># 衡量分割质量的值，可选：gini、entropy</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 树的最大深度，如果为None，则自由生长</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 拆分内部节点所需的最少样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶节点的最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶节点上所需的(所有输入样本的)总权重的最小加权分数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>, <span class="comment"># 寻找最佳分割特征时可选择的特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">True</span>, <span class="comment"># 是否使用有放回重复采样</span></span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>, <span class="comment"># 是否使用袋外样本估计泛化精度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>, <span class="comment"># 要并行运行的作业的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>, <span class="comment"># 在拟合和预测时控制冗余程度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>, <span class="comment"># 热启动，将现有的拟合模型属性用于在随后的拟合调用中初始化新模型</span></span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>, <span class="comment"># 类的权重</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>, <span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span> <span class="comment"># 绘制样本的方式</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict_proba</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测输入样本<span class="title">X</span>的类别概率</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/633.html">sklearn.ensemble.RandomForestClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>breast_cancer</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT</span>():</span></span><br><span class="line">    dt = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = dt.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;单个决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RF</span>():</span></span><br><span class="line">    rf = RandomForestClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = rf.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;随机森林的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    DT()</span><br><span class="line">    RF()</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203141011.png" alt="image-20220203141011334" style="zoom:60%;" /><p>&nbsp;</p><h3 id="极端随机森林"><a href="#极端随机森林" class="headerlink" title="极端随机森林"></a>极端随机森林</h3><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p>极端随机森林和一般随机森林的区别主要在于：</p><ul><li><p>样本的选择</p><blockquote><p>对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra tree的每个决策树采用原始训练集。RandomForest应用的是Bagging模型，ExtraTree使用的所有的样本，只是特征是随机选取的，因为分裂是随机的，所以在某种程度上比随机森林得到的结果更加好</p></blockquote></li><li><p>分叉特征的选择</p><blockquote><p>在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，和传统的决策树相同。但是Extra tree比较激进，会随机的选择一个特征值来划分决策树</p></blockquote></li></ul><h4 id="sklearn使用-1"><a href="#sklearn使用-1" class="headerlink" title="sklearn使用"></a>sklearn使用</h4><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">ExtraTreesClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    *,</span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;gini&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/626.html">sklearn.ensemble.ExtraTreesClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>breast_cancer</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ET</span>():</span></span><br><span class="line">    et = ExtraTreesClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = et.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;极端决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RF</span>():</span></span><br><span class="line">    rf = RandomForestClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = rf.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;随机森林的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ET()</span><br><span class="line">    RF()</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142217.png" alt="image-20220203142217266" style="zoom:60%;" />]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Classifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】决策树——分类问题</title>
      <link href="/2022/01/30/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/30/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;<strong>决策树</strong>是一种用于分类和回归的非参数有监督学习方法。其目标是创建一个模型，通过学习从数据特性中推断出的简单决策规则来预测目标变量的值。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130183526.png" alt="image-20220130183526893" style="zoom: 45%;" /><span id="more"></span><p>&nbsp;</p><h2 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p>&emsp;&emsp;决策树（Dicision Tree）是一个类似于流程图的树形结构，树内部的每一个节点代表的是对一个特征的测试，树的分支代表该特征的每一个测试结果，而树的每一个叶子节点代表一个类别，树的最高层是就是根节点。其决策过程就好像问几个问题，只需要回答是或不是，最后推出被提问者的某个信息。决策树构建过程就好似“选择问什么问题”、“问几个问题”。</p><p>例：判断一个人是否有能力偿还信用卡开销</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130183557.png" alt="image-20220129205930153" style="zoom: 33%;" /><center>随便举个例子，此决策树不一定准确</center><h4 id="决策过程"><a href="#决策过程" class="headerlink" title="决策过程"></a>决策过程</h4><ol><li>利用不纯度（比如：熵）将整个数据集进行分割</li><li>使得分割后数据集的不纯度最小</li><li>不断对子数据集进行递归</li><li>直至无法进一步分割或者子数据集里数据的标签都一致时递归结束</li><li>分割的过程会形成一棵决策树</li><li>利用决策树将输入的数据归类到某一分割后的数据集中</li><li>该数据集所带有的标签就是决策的结果</li></ol><h4 id="对比线性分类模型"><a href="#对比线性分类模型" class="headerlink" title="对比线性分类模型"></a>对比线性分类模型</h4><p>&emsp;&emsp;树形模型是一个一个特征进行处理，之前线性模型是所有特征给予权重相加得到一个新的值。决策树与逻辑回归的分类区别也在于此，逻辑回归是将所有特征变换为概率后，通过大于某一概率阈值的划分为一类，小于某一概率阈值的为另一类；而决策树是对每一个特征做一个划分。</p><h4 id="节点的不纯度-impurity"><a href="#节点的不纯度-impurity" class="headerlink" title="节点的不纯度(impurity)"></a>节点的不纯度(impurity)</h4><p>&emsp;&emsp;由于决策树解决的是分类问题，因此希望一个节点代表一个类，即节点内的样本都是同一类数据。而构造决策树的过程也正是通过一个个非叶子节点的判断分叉，从而向下产生一个个仅含一个类（理想情况）的叶子结点。因此，节点的不纯度（描述内部数据的类别异同情况）是决策树的重要参数。不同的决策树算法对节点不纯度的描述也不同，但主要分为：<strong>熵</strong>和<strong>Gini指数</strong>两种。</p><h5 id="熵-entropy"><a href="#熵-entropy" class="headerlink" title="熵(entropy)"></a>熵(entropy)</h5><p>&emsp;&emsp;关于熵的定义可以从两个角度来解读，第一是物理学中的熵，第二是信息学。物理学中的熵出现在热力学第二定律中，描述物体的混乱度；而信息学中的熵常指信息熵，表征信息量。但总而言之，熵的共同含义是：“物质的内在的混乱程度”，熵越大，混乱度越高，也意味着节点内样本的类别差异越大。决策树算法中，节点熵的计算公式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129212919.png" alt="image-20220129212919431" style="zoom:60%;" /><h5 id="Gini指数"><a href="#Gini指数" class="headerlink" title="Gini指数"></a>Gini指数</h5><p>&emsp;&emsp;Gini指数表示在样本集合中一个随机选中的样本被分错的概率。Gini指数越小表示集合中被选中的样本被参错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。当集合中所有样本为一个类时，基尼指数为0。计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129212306.png" alt="image-20220129212306723" style="zoom:60%;" /><p>&nbsp;</p><h3 id="构造决策树"><a href="#构造决策树" class="headerlink" title="构造决策树"></a>构造决策树</h3><p>一棵决策树的生成过程主要分为3步：</p><ul><li><p>特征选择：</p><p>  从训练数据中众多的特征中选择一个特征作为当前节点的分叉标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法</p></li><li><p>生成决策树：</p><p>  根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分时停止决策树的生长</p></li><li><p>剪枝：</p><p>  决策树容易过拟合（分支太多），一般来需要剪枝，缩小树结构规模以缓解过拟合。剪枝分为：预剪枝、后剪枝两种</p></li></ul><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;因为在决策树中，分类是通过从根节点开始的一个个非叶子节点逐层分叉实现的，因此每个非叶子节点的分叉依据是决策树进行分类判断的本质。每个分叉都是通过对样本数据特征的不同而展开的。但是考虑到样本数据一般会有很多个特征都可以用作分类的参考依据，究竟每一层用哪个特征作为分叉依据，这是不同决策树算法的主要区别。</p><p>&emsp;&emsp;注意：在决策树中，所有的特征均为离散值。如果某个特征的值为连续值，那么需要通过分段等方法先将其离散化。</p><h5 id="基于信息增量"><a href="#基于信息增量" class="headerlink" title="基于信息增量"></a>基于信息增量</h5><p>&emsp;&emsp;从根节点向下，每层分叉的特征选择能带来最大信息增量（分叉后熵的减少量）的特征作为判断对象。具体而言，就是选择使分叉后的节点不纯度最低的那个特征作为本层的分叉依据。信息增量计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129225236.png" alt="image-20220129225236915" style="zoom:60%;" /><center>H(X|A)是按特征A分叉后的熵</center><h5 id="基于信息增量率"><a href="#基于信息增量率" class="headerlink" title="基于信息增量率"></a>基于信息增量率</h5><p>&emsp;&emsp;提出信息增量率是为了消除信息增量的一个弊端，即信息增量法趋向于选择值较多的特征，而未必是分类效果最好的特征。这其实是信息增量的表达式决定的，特征可选的值越多，分叉后的子集就越精细，熵越低，信息增量自然越高。因此采用信息增量率来归一化，客观比较：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129230143.png" alt="image-20220129230143683" style="zoom:60%;" /><h5 id="基于Gini指数"><a href="#基于Gini指数" class="headerlink" title="基于Gini指数"></a>基于Gini指数</h5><p>&emsp;&emsp;与信息增量类似，不过换成Gini指数作为不同特征的性能评估指标：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129230637.png" alt="image-20220129230637874" style="zoom:60%;" /><center>p(x|a)是条件概率</center><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从根节点出发，根节点包括所有的训练样本，递归下面的过程：</span><br><span class="line"></span><br><span class="line">if 当前节点内所有样本均属于同一类别:</span><br><span class="line">那么将该节点就成为叶节点，并将该节点标记为样本个数最多的类别</span><br><span class="line">else</span><br><span class="line">利用指定方法（例如信息增量法）选择对样本进行划分的最好特征</span><br><span class="line">按特征的几个值划分出几个子节点</span><br><span class="line"></span><br><span class="line">递归停止条件：</span><br><span class="line">1. 当前节点中所有的样本均为同一类别，那么产生叶节点 </span><br><span class="line">2. 已经没有特征可用于对当前节点样本行划分，即：attribute_list=null。此时强制产生叶节点，类别为数量最多的样本的类别</span><br><span class="line">3. 没有样本能满足剩余特征的取值，即：test_attribute=null。此时也强制产生叶节点，该节点的类别为数量最多的样本的类别</span><br></pre></td></tr></table></figure><h4 id="剪枝（泛化）"><a href="#剪枝（泛化）" class="headerlink" title="剪枝（泛化）"></a>剪枝（泛化）</h4><p>&emsp;&emsp;由于噪声等因素的影响，样本某些特征的取值与样本自身的类别可能不相匹配，基于这种数据生成的决策树的某些枝叶会产生一些错误；尤其是在决策树靠近枝叶的末端，由于样本变少，这种无关因素的干扰就会突显出来；由此产生的决策树可能存在过拟合的现象。剪枝就是通过统计学的方法删除不可靠的分支，使得整个决策树的分类速度和分类精度得到提高，避免过拟合，提高泛化能力。</p><p>剪枝分为：预剪枝、后剪枝</p><h5 id="预剪枝-Pre-Pruning"><a href="#预剪枝-Pre-Pruning" class="headerlink" title="预剪枝(Pre-Pruning)"></a>预剪枝(Pre-Pruning)</h5><p>简而言之，边建立决策树边进行剪枝的操作，设定一些规则来避免决策树的过度分支：</p><ul><li>信息增益（率）低于阈值则不分枝</li><li>节点的样本数少于阈值则不分枝</li><li>分叉后叶子结点样本数少于阈值则不分枝</li><li>树的深度大于阈值则不分枝</li><li>……</li></ul><p>（以上各种规则中，阈值的选取很大地影响决策树的性能，是关键的超参数之一）</p><h5 id="后剪枝-Post-Pruning"><a href="#后剪枝-Post-Pruning" class="headerlink" title="后剪枝(Post-Pruning)"></a>后剪枝(Post-Pruning)</h5><p>在决策树充分生长（过拟合）后，修剪掉多余的分支。这里要给出决策树的性能效果评价损失函数，从下向上剪枝以实现损失函数值最小。</p><p>评价函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129234252.png" alt="image-20220129234252614" style="zoom:60%;" /><p>其中，<code>C(T)</code> 是决策树对训练数据的预测误差，即模型与数据的拟合度：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129234608.png" alt="image-20220129234608798" style="zoom:60%;" /><p><code>|T|</code> 是决策树的叶子结点; <code>α</code> 是衡量 <code>C(T)</code> 和 <code>|T|</code> 权重的因子，<code>α</code> 越大，要求决策树越简单，即叶子结点越少，分类越粗。</p><p>&nbsp;</p><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><h3 id="三钟常用算法"><a href="#三钟常用算法" class="headerlink" title="三钟常用算法"></a>三钟常用算法</h3><p>&emsp;&emsp;决策树的生成大致如上所述，特征选择的评估有不同的方法，对应不同的决策树实现算法，其中主要包括：ID3、C4.5、CART 三个算法。</p><table><thead><tr><th>算法</th><th>特征选择依据</th><th>特点</th></tr></thead><tbody><tr><td>ID3</td><td>信息增益</td><td>仅能够处理离散特征，且信息增益偏向选择取值较多特征</td></tr><tr><td>C4.5</td><td>信息增益率</td><td>能够分段处理连续特征，且克服了信息增益的弊端</td></tr><tr><td>CART</td><td>Gini指数</td><td>生成的决策树只能是二叉树</td></tr></tbody></table><p>&nbsp;</p><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><h4 id="手写实现决策树（以ID3为例）"><a href="#手写实现决策树（以ID3为例）" class="headerlink" title="手写实现决策树（以ID3为例）"></a>手写实现决策树（以ID3为例）</h4><p><strong>问题</strong></p><p>给出：年龄、有无工作、有无房子这3个特征，判断是否适合放贷</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 计算给定数据集的经验熵（香农熵）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    shannonEnt: 经验熵</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="comment"># 返回数据集行数</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 保存每个标签（label）出现次数的字典</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]  <span class="comment"># 提取标签信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签没有放入统计次数的字典，添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># label计数</span></span><br><span class="line"></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵</span></span><br><span class="line">    <span class="comment"># 计算经验熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries  <span class="comment"># 选择该标签的概率</span></span><br><span class="line">        shannonEnt -= prob*log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 创建测试数据集</span></span><br><span class="line"><span class="string">Parameters: 无</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">    labels: 分类属性</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span>():</span></span><br><span class="line">    <span class="comment"># 数据集</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">    <span class="comment"># 分类属性</span></span><br><span class="line">    labels = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;有工作&#x27;</span>, <span class="string">&#x27;有自己的房子&#x27;</span>, <span class="string">&#x27;信贷情况&#x27;</span>]</span><br><span class="line">    <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet:待划分的数据集</span></span><br><span class="line"><span class="string">    axis: 划分数据集的特征</span></span><br><span class="line"><span class="string">    value: 需要返回的特征值</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span></span><br><span class="line">    <span class="comment"># 创建返回的数据集列表</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="comment"># 遍历数据集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 将符合条件的添加到返回的数据集</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            <span class="comment"># 去掉axis特征</span></span><br><span class="line">            reduceFeatVec = featVec[:axis]</span><br><span class="line">            reduceFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">            retDataSet.append(reduceFeatVec)</span><br><span class="line">    <span class="comment"># 返回划分后的数据集</span></span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 计算给定数据集的经验熵（香农熵）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    shannonEnt: 信息增益最大特征的索引值</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="comment"># 特征数量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计数数据集的香农熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    <span class="comment"># 信息增益</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 最优特征的索引值</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历所有特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取dataSet的第i个所有特征</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 创建set集合&#123;&#125;，元素不可重复</span></span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        <span class="comment"># 经验条件熵</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># subDataSet划分后的子集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算子集的概率</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            <span class="comment"># 根据公式计算经验条件熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt((subDataSet))</span><br><span class="line">        <span class="comment"># 信息增益</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="comment"># 打印每个特征的信息增益</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第%d个特征的增益: %.3f&quot;</span> % (i, infoGain))</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            <span class="comment"># 更新信息增益，找到最大的信息增益</span></span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            <span class="comment"># 记录信息增益最大的特征的索引值</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">            <span class="comment"># 返回信息增益最大特征的索引值</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 统计classList中出现次数最多的元素（类标签）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    classList: 类标签列表</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    sortedClassCount[0][0]: 出现次数最多的元素（类标签）</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span>(<span class="params">classList</span>):</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="comment"># 统计classList中每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">            classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 根据字典的值降序排列</span></span><br><span class="line">        sortedClassCount = <span class="built_in">sorted</span>(</span><br><span class="line">            classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 从根节点向下递归创建决策树</span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet: 训练数据集</span></span><br><span class="line"><span class="string">    labels: 分类属性标签</span></span><br><span class="line"><span class="string">    featLabels: 存储选择的最优特征标签</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    myTree: 决策树</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">dataSet, labels, featLabels</span>):</span></span><br><span class="line">    <span class="comment"># 取分类标签（是否放贷: yes or no）</span></span><br><span class="line">    classList = [item[-<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 如果类别完全相同，则停止继续划分</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历完所有特征时停止分叉，返回出现次数最多的类标签</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择最优特征</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 最优特征的标签</span></span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    featLabels.append(bestFeatLabel)</span><br><span class="line">    <span class="comment"># 根据最优特征的标签生成树</span></span><br><span class="line">    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="comment"># 删除已经使用的特征标签</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 得到训练集中所有最优特征的属性值</span></span><br><span class="line">    featValues = [item[bestFeat] <span class="keyword">for</span> item <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 去掉重复的属性值</span></span><br><span class="line">    uniqueVls = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="comment"># 遍历特征，创建决策树</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVls:</span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),</span><br><span class="line">                                                  labels, featLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用决策树进行分类</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    inputTree；已经生成的决策树</span></span><br><span class="line"><span class="string">    featLabels: 存储选择的最优特征标签</span></span><br><span class="line"><span class="string">    testVec: 测试数据列表，顺序对应最优特征标签</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    classLabel: 分类结果</span></span><br><span class="line"><span class="string">Modify: 2018-03-13</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span></span><br><span class="line">    <span class="comment"># 获取决策树节点</span></span><br><span class="line">    firstStr = <span class="built_in">next</span>(<span class="built_in">iter</span>(inputTree))</span><br><span class="line">    <span class="comment"># 下一个字典</span></span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">                classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                classLabel = secondDict[key]</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;构造决策树: &quot;</span>)</span><br><span class="line">    dataSet, labels = createDataSet()</span><br><span class="line">    featLabels = []</span><br><span class="line">    myTree = createTree(dataSet, labels, featLabels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;有效特征: <span class="subst">&#123;featLabels&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;决策树: <span class="subst">&#123;myTree&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试数据</span></span><br><span class="line">    testVec = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;测试: <span class="subst">&#123;testVec&#125;</span>&quot;</span>)</span><br><span class="line">    result = classify(myTree, featLabels, testVec)</span><br><span class="line">    <span class="keyword">if</span> result == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果: 放贷&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> result == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果: 不放贷&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130163735.png" alt="image-20220130163735362" style="zoom:60%;" /><h4 id="储存与导入"><a href="#储存与导入" class="headerlink" title="储存与导入"></a>储存与导入</h4><p>&emsp;&emsp;避免每次使用决策树都要从头开始拟合决策树，在一次构造后直接用 <code>pickle</code> 把决策树的参数 <code>dump</code> 到本地保存，下次使用时直接 <code>load</code> 出来使用显然效率更高。</p><p><strong>接上面的例子</strong></p><p>储存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明：存储决策树</span></span><br><span class="line"><span class="string">Parameters：</span></span><br><span class="line"><span class="string">    inputTree：已经生成的决策树</span></span><br><span class="line"><span class="string">    filename：决策树的存储文件名</span></span><br><span class="line"><span class="string">Returns：</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Modify：</span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span>(<span class="params">inputTree,filename</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        pickle.dump(inputTree,fw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    myTree=&#123;<span class="string">&#x27;有自己的房子&#x27;</span>:&#123;<span class="number">0</span>:&#123;<span class="string">&#x27;有工作&#x27;</span>:&#123;<span class="number">0</span>:<span class="string">&#x27;no&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;yes&#x27;</span>&#125;&#125;,<span class="number">1</span>:<span class="string">&#x27;yes&#x27;</span>&#125;&#125;</span><br><span class="line">    storeTree(myTree,<span class="string">&#x27;classifierStorage.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明:读取决策树</span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    filename：决策树的存储文件名</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    pickle.load(fr)：决策树字典</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span>(<span class="params">filename</span>):</span></span><br><span class="line">    fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    myTree = grabTree(<span class="string">&#x27;classifierStorage.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(myTree)</span><br></pre></td></tr></table></figure><h4 id="sklearn库调用决策树"><a href="#sklearn库调用决策树" class="headerlink" title="sklearn库调用决策树"></a>sklearn库调用决策树</h4><p>&emsp;&emsp;Scikit-Learn 是基于 Python 的机器学习工具，建立在 NumPy、SciPy、Pandas 和 Matplotlib 之上，里面的 API 的设计非常好，所有对象的接口简单。具有：分类、回归、聚类、降维、模型选择和预处理的现成模块可以使用。</p><p>scikit-learn：<a href="https://scikit-learn.org.cn/">中文社区</a></p><p><strong>使用步骤</strong></p><ul><li><p>准备数据集</p></li><li><p>数据预处理：填补空白值，处理脏数据</p></li><li><p>分析数据集：快速检查数据，并使用createPlot()函数绘制最终的树形图</p></li><li><p>拟合决策树：使用createTree()函数拟合决策树，并存储其参数</p></li><li><p>使用决策树：导入参数，进行分类预测</p></li></ul><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">tree</span>.<span class="title">DecisionTreeClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=’gini’, <span class="comment"># 特征选择时的节点不纯度计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    splitter=’best’, <span class="comment"># 特征选择的策略</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 决策树最大深度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 决策树分叉时的最小信息增益的阀值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶子节点最少的样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶子节点最小的样本权重和</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="literal">None</span>, <span class="comment"># 最大特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="number">1e-7</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>, <span class="comment"># 样本各类别的的权重</span></span></span></span><br><span class="line"><span class="params"><span class="class">    presort=<span class="literal">False</span> <span class="comment"># 数据是否预排序</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict_proba</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测输入样本<span class="title">X</span>的类别概率</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/784.html">sklearn.tree.DecisionTreeClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>iris</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_class_tree</span>():</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    x = iris[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    y = iris[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">    dtc = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line">    clf = dtc.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;预测: <span class="subst">&#123;clf.predict(x_test)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;实际: <span class="subst">&#123;y_test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_class_tree()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130180210.png" alt="image-20220130180210088" style="zoom:60%;" /><h4 id="决策树可视化"><a href="#决策树可视化" class="headerlink" title="决策树可视化"></a>决策树可视化</h4><p>&emsp;&emsp;把构造好的决策树可视化出来能方便剪枝或理解，用 <a href="https://scikit-learn.org.cn/view/788.html">sklearn.tree.export_graphviz-scikit-learn</a> 先以Graphviz格式导出决策树 <code>tree_data</code>，然后用 <code>graphviz.Source(tree_data).render(“name”)</code> 即可把决策树绘制并保存到 <code>name.pdf</code> 文件。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_class_tree</span>():</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    x = iris[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    y = iris[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">    dtc = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line">    clf = dtc.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;预测: <span class="subst">&#123;clf.predict(x_test)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;实际: <span class="subst">&#123;y_test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制决策树</span></span><br><span class="line">    dot_data = tree.export_graphviz(</span><br><span class="line">        clf, </span><br><span class="line">        out_file=<span class="literal">None</span>, </span><br><span class="line">        filled=<span class="literal">True</span>, <span class="comment"># 绘制彩色图</span></span><br><span class="line">        rounded=<span class="literal">True</span>, <span class="comment"># 方框设为圆角</span></span><br><span class="line">        special_characters=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    graph = graphviz.Source(dot_data)</span><br><span class="line">    graph.render(<span class="string">&quot;iris&quot;</span>, view=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_class_tree()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130180928.png" alt="image-20220130180928785" style="zoom:50%;" /><p>&nbsp;</p><p>或者也可以使用 <a href="https://scikit-learn.org.cn/view/789.html">sklearn.tree.export_text </a>来以文本格式导出树，示例如下：</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export_tree 绘制决策树</span></span><br><span class="line">r = tree.export_text(clf, feature_names=iris[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130181718.png" alt="image-20220130181718835" style="zoom:60%;" />]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Classifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用画图工具/方法</title>
      <link href="/2022/01/26/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/01/26/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为经常用到画流程图、时序图等，所以就总结一下常用的画图工具/方法：</p><ul><li>VSCode+PlantUML</li><li>Typora</li><li>神经网络结构图</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203174821.png" alt="image-20220203174227516" style="zoom:40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="MarkDown绘图"><a href="#MarkDown绘图" class="headerlink" title="MarkDown绘图"></a>MarkDown绘图</h2><p>&emsp;&emsp;Mermaid是一种简单的类似 Markdown 的脚本语言，通过 JavaScript 编程语言，将文本转换为图片。实现画图功能的并不是 Typora 本身，而是它内置的对 Mermaid 的支持。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title:example</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232624.png" alt="image-20220128232614051" style="zoom:50%;" /><p>&nbsp;</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><code>[*]</code> 表示开始或者结束，如果在箭头右边则表示结束。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232634.png" alt="image-20220128232634737" style="zoom:50%;" /><p>&nbsp;</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p>语法解释：<code>&lt;|--</code> 表示继承，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，学过 Java 的应该都知道。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232652.png" alt="image-20220128232652835" style="zoom:50%;" /><p>&nbsp;</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong>方向</strong></p><table><thead><tr><th>字母表示</th><th>含义</th></tr></thead><tbody><tr><td>TB</td><td>从上到下</td></tr><tr><td>BT</td><td>从下到上</td></tr><tr><td>LR</td><td>从左到右</td></tr><tr><td>RL</td><td>从右到左</td></tr></tbody></table><p><strong>节点</strong></p><table><thead><tr><th>表述</th><th>说明</th><th>含义</th></tr></thead><tbody><tr><td>id[文字]</td><td>矩形节点</td><td>表示过程</td></tr><tr><td>id(文字)</td><td>圆角矩形节点</td><td>表示开始与结束</td></tr><tr><td>id((文字))</td><td>圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开成对</td></tr><tr><td>id{文字}</td><td>菱形节点</td><td>表示判断、决策</td></tr><tr><td>id&gt;文字 ]</td><td>右向旗帜节点</td><td></td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">subgraph 分情况</span><br><span class="line">A(开始)--&gt;B&#123;判断&#125;</span><br><span class="line">end</span><br><span class="line">B--第一种情况--&gt;C[第一种方案]</span><br><span class="line">B--第二种情况--&gt;D[第二种方案]</span><br><span class="line">B--第三种情况--&gt;F&#123;第三种方案&#125;</span><br><span class="line">subgraph 分种类</span><br><span class="line">F-.第1个.-&gt;J((测试圆形))</span><br><span class="line">F-.第2个.-&gt;H&gt;右向旗帜形]</span><br><span class="line">end</span><br><span class="line">H---I(测试完毕)</span><br><span class="line">C--票数100---I(测试完毕)</span><br><span class="line">D---I(测试完毕)</span><br><span class="line">J---I(测试完毕)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232710.png" alt="image-20220128232710479" style="zoom:50%;" /><p>&nbsp;</p><h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><p>序列图共有5个部分，分别是：<strong>参与者、消息线、循环、选择、可选、并行、注解</strong></p><p><strong>消息线</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>-&gt;</td><td>无箭头的实线</td></tr><tr><td>–&gt;</td><td>无箭头的虚线</td></tr><tr><td>-&gt;&gt;</td><td>有箭头的实线(主动发出消息)</td></tr><tr><td>–&gt;&gt;</td><td>有箭头的虚线(响应)</td></tr><tr><td>-x</td><td>末端为X的实线(主动发出异步消息)</td></tr><tr><td>–x</td><td>有箭头的实线(以异步形式响应消息)</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title: 小明买书</span><br><span class="line"></span><br><span class="line">participant consumer as 小明</span><br><span class="line">participant store as 书店</span><br><span class="line">participant publisher as 出版社</span><br><span class="line"></span><br><span class="line">consumer -&gt;&gt; store: 想买一本限量版书籍</span><br><span class="line">store --&gt;&gt; consumer: 缺货</span><br><span class="line">consumer -&gt;&gt; store: 隔一个月再次询问</span><br><span class="line">store --&gt;&gt; consumer: 抢完了</span><br><span class="line">loop 一个星期一次</span><br><span class="line">consumer -x +store: 有货了吗</span><br><span class="line">store --x -consumer: 正在订,有货马上通知你</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">store -&gt;&gt; publisher: 我要订购一批货</span><br><span class="line">publisher --x store: 返回所有书籍的类别信息</span><br><span class="line"></span><br><span class="line">alt 书籍类别符合要求</span><br><span class="line">store -&gt;&gt; publisher: 请求书单信息</span><br><span class="line">publisher --x store: 返回该类别书单信息</span><br><span class="line"><span class="keyword">else</span> 书单里的书有市场需求</span><br><span class="line">store -&gt;&gt; publisher: 购买指定数据</span><br><span class="line">publisher --x store: 确认订单</span><br><span class="line"><span class="keyword">else</span> 书籍不符合要求</span><br><span class="line">store --&gt;&gt; publisher: 暂时不购买</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">par 并行执行</span><br><span class="line">publisher -&gt;&gt; publisher : 生产</span><br><span class="line">publisher -&gt;&gt; publisher : 销售</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">opt 书籍购买量&gt;=500 &amp;&amp; 库存&gt;=50</span><br><span class="line">publisher -&gt;&gt; store : 出货</span><br><span class="line">store --x publisher : 确认收货</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Note left of consumer : 图书收藏家</span><br><span class="line">Note over consumer,store : 去书店购买书籍</span><br><span class="line">Note left of store : 全国知名书店</span><br><span class="line">Note over store,publisher : 去出版社进货</span><br><span class="line">Note left of publisher : 持有版权的出版社</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line"> title Pie Chart</span><br><span class="line"> <span class="string">&quot;Dogs&quot;</span> : 386</span><br><span class="line"> <span class="string">&quot;cats&quot;</span> : 567</span><br><span class="line"> <span class="string">&quot;rabbit&quot;</span> : 700</span><br><span class="line"> <span class="string">&quot;pig&quot;</span>:365</span><br><span class="line"> <span class="string">&quot;tiger&quot;</span> : 15</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232805.png" alt="image-20220128232805096" style="zoom:50%;" /><p>&nbsp;</p><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><p>甘特图一般用来表示项目的计划排期，目前在工作中经常会用到,语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 工作计划</span><br><span class="line">    dateFormat  YYYY-MM-DD//底部的时间格式</span><br><span class="line">    </span><br><span class="line">    section Section</span><br><span class="line">    task1:a1, 2020-01-01, 30d</span><br><span class="line">    task2:des3, 2020-03-01, 15d</span><br><span class="line"> task3:crit, <span class="keyword">done</span>, 2020-02-30, 24h</span><br><span class="line">    Another task:after a1, 20d</span><br><span class="line">    </span><br><span class="line">    section Another</span><br><span class="line">    Task <span class="keyword">in</span> sec:2020-01-12, 12d</span><br><span class="line">    another task:24d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232832.png" alt="image-20220128232832655"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><p>&emsp;&emsp;时序图（Sequence Diagram），又名序列图、循序图、顺序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。</p><p>参考：<a href="https://blog.csdn.net/zh_weir/article/details/72675013?ops_request_misc=%7B%22request_id%22:%22164319070816780274150424%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319070816780274150424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-72675013.pc_search_insert_es_download&utm_term=plantuml&spm=1018.2226.3001.4187">PlantUML时序图</a></p><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>实、虚线</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232625.png" alt="image-20220126181332755" style="zoom:45%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123356.png" alt="image-20210825105656559" width="20%" /></td></tr><tr><td>加上消息序号</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126184441.png" alt="image-20220126184441218" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126184412.png" alt="image-20220126184412284" style="zoom:25%;" /></td></tr><tr><td>加上消息注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182343.png" alt="image-20220126182343867" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123358.png" alt="image-20210825112152648" width="50%" /></td></tr><tr><td>使用html标签</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182609.png" alt="image-20220126182609565" style="zoom: 50%;" /></td><td><img src="https://img-blog.csdnimg.cn/img_convert/e7e45fb167a8bdca3bbd15db36200413.png" alt="image-20210825120605218" style="zoom: 50%;" /></td></tr><tr><td>划分阶段</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182758.png" alt="image-20220126182757973" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123401.png" alt="image-20210825120927516" width="25%" /></td></tr><tr><td>延时</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182842.png" alt="image-20220126182842660" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123402.png" alt="image-20210825121326063" width="25%" /></td></tr><tr><td>加入间隔</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182914.png" alt="image-20220126182914287" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123403.png" alt="image-20210825122232668" width="25%" /></td></tr><tr><td>消息者组合</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183011.png" alt="image-20220126183011477" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123404.png" alt="image-20210825122610329" width="35%" /></td></tr><tr><td>加入时序图说明</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183107.png" alt="image-20220126183107261" style="zoom:40%;" /></td><td><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20210826125958845.png" width="25%" /></td></tr><tr><td>加入标题和隐藏底部对象</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183139.png" alt="image-20220126183139774" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123405.png" alt="image-20210825122941222" width="25%" /></td></tr><tr><td>不同消息者图案</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232626.png" alt="image-20220126183216677" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123406.png" alt="image-20210825110640942" width="60%" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p>参考：<a href="https://blog.csdn.net/zhangjikuan/article/details/53484558?ops_request_misc=%7B%22request_id%22:%22164319070816780274150424%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319070816780274150424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-53484558.pc_search_insert_es_download&utm_term=plantuml&spm=1018.2226.3001.4187">PlantUML流程图</a></p><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>基本</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185758.png" alt="image-20220126185758399" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185426.png" alt="image-20220126185426351" style="zoom: 60%;" /></td></tr><tr><td>if 判断</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185820.png" alt="image-20220126185820699" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185859.png" alt="image-20220126185859311" style="zoom:50%;" /></td></tr><tr><td>if-else 分支</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185937.png" alt="image-20220126185937281" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190005.png" alt="image-20220126190005635" style="zoom:50%;" /></td></tr><tr><td>while 循环A</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190401.png" alt="image-20220126190401364" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190056.png" alt="image-20220126190056722" style="zoom:50%;" /></td></tr><tr><td>while 循环B</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190421.png" alt="image-20220126190421580" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190432.png" alt="image-20220126190432003" style="zoom:50%;" /></td></tr><tr><td>并行分支</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190516.png" alt="image-20220126190516615" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190535.png" alt="image-20220126190535053" style="zoom:50%;" /></td></tr><tr><td>注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190606.png" alt="image-20220126190606694" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190652.png" alt="image-20220126190652905" style="zoom:50%;" /></td></tr><tr><td>箭头类型</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190723.png" alt="image-20220126190723569" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190751.png" alt="image-20220126190751147" style="zoom:50%;" /></td></tr><tr><td>加框</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190824.png" alt="image-20220126190824440" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190908.png" alt="image-20220126190908480" style="zoom:50%;" /></td></tr><tr><td>分类</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190941.png" alt="image-20220126190941323" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191010.png" alt="image-20220126191010243" style="zoom:50%;" /></td></tr><tr><td>分离</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191345.png" alt="image-20220126191345064" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191414.png" alt="image-20220126191414944" style="zoom:50%;" /></td></tr><tr><td>示例一</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191545.png" alt="image-20220126191545310" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191454.png" alt="image-20220126191454204" style="zoom:50%;" /></td></tr><tr><td>示例二</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191628.png" alt="image-20220126191628012" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191655.png" alt="image-20220126191655656" style="zoom:50%;" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p>类图显示了系统的静态结构<br>类：类图中的主要元素，用矩形表示。矩形的上层表示类名、中层表示属性、下层表示方法。<br>类之间的关系：关联、依赖、聚集、泛化和实现五种。</p><p>五种类间关系的图形表示介绍：</p><table><thead><tr><th>关联</th><th>依赖</th><th>聚集</th><th>泛化 extends</th><th>实现 implements</th></tr></thead><tbody><tr><td>带实线的箭头</td><td>带虚线的箭头</td><td>菱形箭头</td><td>带实线的三角形箭头</td><td>带虚线的三角形箭头</td></tr></tbody></table><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126192936.png" alt="image-20220126192936034" style="zoom: 67%;" /><p>参考：<a href="https://blog.csdn.net/junhuahouse/article/details/80767632?ops_request_misc=%7B%22request_id%22:%22164319596516780265433006%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319596516780265433006&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80767632.pc_search_insert_es_download&utm_term=plantuml%E7%B1%BB%E5%9B%BE&spm=1018.2226.3001.4187">PlantUML类图</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam packageStyle rect/&#x27; 加入这行代码，样式纯矩形&#x27;/</span><br><span class="line">interface Set&lt;&lt;接口&gt;&gt;&#123;</span><br><span class="line">boolean add (Object o)</span><br><span class="line">boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace com.ztman.org #green&#123;</span><br><span class="line">class HashSet&#123;</span><br><span class="line">+boolean add (Object o)</span><br><span class="line">+boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line">interface IntSet&#123;</span><br><span class="line">boolean add (int i)</span><br><span class="line">boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line">class IntHashSet&#123;</span><br><span class="line">+boolean add (int i)</span><br><span class="line">+boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Set &lt;|.. HashSet</span><br><span class="line">HashSet &lt;|-- IntHashSet</span><br><span class="line">IntSet &lt;|.. IntHashSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace cn #orange&#123;</span><br><span class="line">class TreeSet &#123;</span><br><span class="line">+boolean add (Object o)</span><br><span class="line">+boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line">class IntTreeSet&#123;</span><br><span class="line">+boolean add (int i)</span><br><span class="line">+boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">com.ztman.org.IntSet &lt;|.. IntTreeSet</span><br><span class="line">TreeSet &lt;|-- IntTreeSet</span><br><span class="line">.Set &lt;|.. TreeSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>定义一个类（上层-类名、中层-属性、下层-方法）</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193208.png" alt="image-20220126193208462" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193221.png" alt="image-20220126193221888" style="zoom:60%;" /></td></tr><tr><td>多样定义</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193308.png" alt="image-20220126193308095" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193329.png" alt="image-20220126193329644" style="zoom:50%;" /></td></tr><tr><td>静态属性+抽象方法</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193444.png" alt="image-20220126193444427" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193459.png" alt="image-20220126193459834" style="zoom:50%;" /></td></tr><tr><td>自定义类主题</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193549.png" alt="image-20220126193549745" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193609.png" alt="image-20220126193609454" style="zoom:50%;" /></td></tr><tr><td>注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193650.png" alt="image-20220126193650671" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193720.png" alt="image-20220126193720778" style="zoom: 70%;" /></td></tr><tr><td>类及衍生类之间的关系逻辑</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126194153.png" alt="image-20220126194153706" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126194207.png" alt="image-20220126194207216" style="zoom:50%;" /></td></tr><tr><td>以命名空间分割，并在不同空间内类之间建立关系</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126195117.png" alt="image-20220126195117872" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126195133.png" alt="image-20220126195133029" style="zoom: 70%;" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h2 id="神经网络结构图"><a href="#神经网络结构图" class="headerlink" title="神经网络结构图"></a>神经网络结构图</h2><h3 id="PlotNeuralNet"><a href="#PlotNeuralNet" class="headerlink" title="PlotNeuralNet"></a>PlotNeuralNet</h3><p>这是github上一个开源的用Latex转换为PDF来绘制神经网络结构图的工具，<a href="https://github.com/HarisIqbal88/PlotNeuralNet">地址</a>，使用方法如下：</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:HarisIqbal88/PlotNeuralNet.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开linux终端，按照所需依赖</span></span><br><span class="line">sudo apt-get install texlive-latex-base</span><br><span class="line">sudo apt-get install texlive-fonts-recommended</span><br><span class="line">sudo apt-get install texlive-latex-extra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line"><span class="built_in">cd</span> pyexamples/</span><br><span class="line">bash ../tikzmake.sh test_simple</span><br></pre></td></tr></table></figure><p>如果出现报错：$‘\r‘: command not found，是因为Shell脚本在Windows系统编写时，每行结尾是\r\n，而在Linux系统中行每行结尾是\n，所以在Linux系统中运行脚本时，会认为\r是一个字符，此时使用指令：<code>sed -i &#39;s/\r//&#39; ../tikzmake.sh</code> 来去除脚本中的\r字符，然后再次执行 <code>bash ../tikzmake.sh test_simple</code> ，效果是生成一个神经网络结果图的pdf文件。</p><p><strong>绘制自己的神经网络</strong></p><p>&emsp;&emsp;经过尝试，本以为可以自己建一个文件夹然后写python程序，然后通过示例中的方法用 <code>tikzmake.sh</code> 脚本生成pdf，但失败了，所以以后使用时就把 <code>pyexamples/</code> 目录下的python文件中的网络结构部分代码改成自己的，然后像上一步运行示例一样使用。</p><p>&emsp;&emsp; <code>pycore/</code> 目录下有各种神经网络组件的python转换latex接口</p><p>神经网络部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改过的</span></span><br><span class="line">arch = [</span><br><span class="line">    to_head(<span class="string">&#x27;..&#x27;</span>),</span><br><span class="line">    to_cor(),</span><br><span class="line">    to_begin(),</span><br><span class="line">    to_Conv(<span class="string">&quot;conv1&quot;</span>, <span class="number">512</span>, <span class="number">64</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>,</span><br><span class="line">            to=<span class="string">&quot;(0,0,0)&quot;</span>, height=<span class="number">64</span>, depth=<span class="number">64</span>, width=<span class="number">2</span>),</span><br><span class="line">    to_Pool(<span class="string">&quot;pool1&quot;</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>, to=<span class="string">&quot;(conv1-east)&quot;</span>),</span><br><span class="line">    to_Conv(<span class="string">&quot;conv2&quot;</span>, <span class="number">128</span>, <span class="number">64</span>, offset=<span class="string">&quot;(1,0,0)&quot;</span>,</span><br><span class="line">            to=<span class="string">&quot;(pool1-east)&quot;</span>, height=<span class="number">32</span>, depth=<span class="number">32</span>, width=<span class="number">2</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;pool1&quot;</span>, <span class="string">&quot;conv2&quot;</span>),</span><br><span class="line">    to_Pool(<span class="string">&quot;pool2&quot;</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>, to=<span class="string">&quot;(conv2-east)&quot;</span>,</span><br><span class="line">            height=<span class="number">28</span>, depth=<span class="number">28</span>, width=<span class="number">1</span>),</span><br><span class="line">    to_SoftMax(<span class="string">&quot;soft1&quot;</span>, <span class="number">10</span>, <span class="string">&quot;(3,0,0)&quot;</span>, <span class="string">&quot;(pool1-east)&quot;</span>, caption=<span class="string">&quot;SOFT&quot;</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;pool2&quot;</span>, <span class="string">&quot;soft1&quot;</span>),</span><br><span class="line">    to_Sum(<span class="string">&quot;sum1&quot;</span>, offset=<span class="string">&quot;(1.5,0,0)&quot;</span>,</span><br><span class="line">           to=<span class="string">&quot;(soft1-east)&quot;</span>, radius=<span class="number">2.5</span>, opacity=<span class="number">0.6</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;soft1&quot;</span>, <span class="string">&quot;sum1&quot;</span>),</span><br><span class="line">    to_end()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ../tikzmake.sh test_simple</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203172520.png" alt="image-20220203172520176" style="zoom: 33%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="NN-SVG"><a href="#NN-SVG" class="headerlink" title="NN-SVG"></a>NN-SVG</h3><p><a href="http://alexlenail.me/NN-SVG/LeNet.html">NN SVG</a> 是一个在线绘制神经网络结构体结构图的网站，可自定义网络层参数，十分方便</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203173138.png" alt="image-20220203173138234" style="zoom: 35%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="donets"><a href="#donets" class="headerlink" title="donets"></a>donets</h3><p>&emsp;&emsp;这是我无意间在github发现的一个轻量级绘制神经网络的开源python仓库：<a href="https://github.com/martisak/dotnets">dotnets</a>，使用 Python 和 Graphviz 生成前馈神经网络的图片。使用时更改 <code>dotnets.py</code> 中的网络结构即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">layers = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">layers_str = [<span class="string">&quot;Status&quot;</span>] + [<span class="string">&quot;Linear&quot;</span>] + [<span class="string">&quot;Relu&quot;</span>] + [<span class="string">&quot;Linear&quot;</span>] + [<span class="string">&quot;Beta&quot;</span>]</span><br><span class="line">layers_col = [<span class="string">&quot;none&quot;</span>] + [<span class="string">&quot;none&quot;</span>] * (<span class="built_in">len</span>(layers) - <span class="number">2</span>) + [<span class="string">&quot;none&quot;</span>]</span><br><span class="line">layers_fill = [<span class="string">&quot;black&quot;</span>] + [<span class="string">&quot;gray&quot;</span>] * (<span class="built_in">len</span>(layers) - <span class="number">2</span>) + [<span class="string">&quot;black&quot;</span>]</span><br><span class="line"></span><br><span class="line">penwidth = <span class="number">15</span></span><br><span class="line">font = <span class="string">&quot;Hilda 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;digraph G &#123;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tfontname = \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(font))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\trankdir=LR&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tsplines=line&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tnodesep=.08;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tranksep=1;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tedge [color=black, arrowsize=.5];&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tnode [fixedsize=true,label=\&quot;\&quot;,style=filled,&quot;</span> +</span><br><span class="line">      <span class="string">&quot;color=none,fillcolor=gray,shape=circle]\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clusters</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(layers)):</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\tsubgraph cluster_&#123;&#125; &#123;&#123;&quot;</span>.<span class="built_in">format</span>(i)))</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tcolor=&#123;&#125;;&quot;</span>.<span class="built_in">format</span>(layers_col[i])))</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tnode [style=filled, color=white, penwidth=&#123;&#125;,&quot;</span></span><br><span class="line">          <span class="string">&quot;fillcolor=&#123;&#125; shape=circle];&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">              penwidth,</span><br><span class="line">              layers_fill[i])))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\t&quot;</span>), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(layers[i]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;l&#123;&#125;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>, a), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tlabel = &#123;&#125;;&quot;</span>.<span class="built_in">format</span>(layers_str[i])))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nodes</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(layers)):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(layers[i - <span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(layers[i]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\tl&#123;&#125;&#123;&#125; -&gt; l&#123;&#125;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, a, i + <span class="number">1</span>, b))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><p><code>python3 dotnets.py | dot -Tpdf &gt; test.pdf</code></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203174821.png" alt="image-20220203174227516" style="zoom:40%;" />]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高效工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于强化学习的5G无线接入网络切片动态资源优化</title>
      <link href="/2022/01/24/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing/"/>
      <url>/2022/01/24/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;文章提出了一种针对 5G 无线接入网络切片的动态资源分配的强化学习解决方案。每个随机到达的网络切片请求到达时都有优先级（权重）、吞吐量、计算资源和延迟要求，如果可行，它会在其请求的持续时间内分配可用的通信和计算资源。由于每个资源分配决策都会使某些资源暂时不可用，所以只能优化当前资源分配的短视解决方案对于网络切片变得无效。基于此背景，文章提出了一种 Q-Learning 解决方案，以根据受通信和计算约束的时间范围内授予的网络切片请求的总权重来最大化网络效用。结果表明，相对于短视、随机和先到先得的解决方案，强化学习在 5G 网络效用方面提供了重大改进。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing.pdf">Reinforcement Learning for Dynamic Resource Optimization in 5G Radio Access Network Slicing</a></p><span id="more"></span><p>&nbsp;</p><h2 id="研究内容及现有研究"><a href="#研究内容及现有研究" class="headerlink" title="研究内容及现有研究"></a>研究内容及现有研究</h2><h3 id="研究导向"><a href="#研究导向" class="headerlink" title="研究导向"></a>研究导向</h3><p>&emsp;&emsp;由于当前的资源分配将使某些资源在未来不可用，仅考虑给定时刻的资源和需求的短视解决方案无法有效地在时间范围内优化资源。基于此，文章提出了基于 Q-learning 算法的 RL 方案为 5G 网络切片动态分配资源，考虑动态分配资源块 (RB)、发射功率和计算资源，以支持从 5G 基站 gNodeB 到用户设备 (UE) 的下行链路通信。来自 UE 的每个网络切片请求都与优先级、吞吐量、CPU 使用率和延迟（截止日期）要求相关联，并且在特定的持续时间内得到服务。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><table><thead><tr><th>论文</th><th>内容</th></tr></thead><tbody><tr><td>[5]</td><td>考虑了网络切片和移动边缘计算 (MEC) 技术中的网络优化问题，并证明为最小化不同移动虚拟网络运营商之间的干扰而制定的资源分配问题是 NP-hard问题</td></tr><tr><td>[6]</td><td>表明网络内深度学习对于应用程序和设备特定的识别和流量分类问题很有前景</td></tr><tr><td>[7]</td><td>使用深度学习来管理网络负载效率</td></tr><tr><td>[8]</td><td>将RL和静态/循环调度方法进行了比较</td></tr><tr><td>[9]</td><td>考虑了带宽和计算资源</td></tr><tr><td>[10]</td><td>将使用 RL 的资源分配与启发式、尽力而为和随机方法进行了比较</td></tr><tr><td>[11]</td><td>在端到端移动网络系统上实现了网络切片的原型</td></tr><tr><td>[12]</td><td>将RL应用于云 RAN 中的节能资源分配，通过考虑相同频率的多个发射器和接收器（而不是 5G 时频块）</td></tr><tr><td>[13]</td><td>通过利用对通信请求的预测来研究 RL 的资源分配</td></tr><tr><td>[14]-[16]</td><td>将RL 用于无线应用中的资源分配</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h2 id="无线资源和网络切片请求"><a href="#无线资源和网络切片请求" class="headerlink" title="无线资源和网络切片请求"></a>无线资源和网络切片请求</h2><p>&emsp;&emsp;系统模型如图1所示。假设5G网络中有一个gNodeB，有N个UE。每个 UE 都需要连接到 gNodeB 才能对其应用程序进行网络访问。 5G网络支持三种流量：eMBB、URLLC和mMTC，因此UE 请求的下行链路通信服务（从 gNodeB 到 UE）具有关于不同吞吐量、CPU 使用和延迟（截止日期）要求以及不同优先级（相对重要性）的动态 QoE 级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214250.png" alt="image-20220122214250256" style="zoom: 33%;" /><center>图 1</center><p>&emsp;&emsp;请求由 gNodeB 处理，然后将具有相应资源块的适当网络切片分配给请求。如果一个请求还没有得到答复，它会留在队列中，直到它的最后期限（从请求到达到服务启动的时间限制）到期。这么做的目的是最大化支持请求的加权数量或提供的服务总量，其中权重代表这些请求的优先级。作为网络资源，考虑带宽、通信（传输）功率和 CPU 使用率。在时间 t，有一组活动请求 A(t)，其中包括刚刚到达的请求或等待列表中的请求（即尚未满足且其截止日期尚未到期的请求）。 QoE 可以用不同的形式来衡量，其中考虑了吞吐量、CPU 使用率和延迟要求。 UE i 对其网络切片请求 j 的 CPU 使用要求为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122213945.png" alt="image-20220122213945523" style="zoom: 37%;" /><p>其中 P Cij 是分配的计算资源（由 CPU 使用率衡量），pCij 是所需的最小资源。对于吞吐量，UE i 对其请求 j 的 QoE 要求为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214004.png" alt="image-20220122214004535" style="zoom:37%;" /><p>其中 Dij 是实现的数据速率，dij 是最低要求速率。 Dij 由分配的带宽 Fij 、分配的 gNodeB 发射功率 P Tij （用于下行链路业务）、用于 gNodeB 和 UE i 之间通信的调制编码方案以及包括干扰和路径损耗在内的信道效应确定。请注意，gNodeB 的每个天线通过空间复用服务于不同的用户。对于 5G NR，频带或频带组合中给定数量的聚合载波的近似数据速率 (bps) 计算如下 [18]：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214052.png" alt="image-20220122214052828" style="zoom:37%;" /><p>其中 K 是频段或频段组合中聚合的分量载波 (CC) 的数量，Rmax = 948/1024。对于第 k 个 CC，v(k) Layers 是支持的最大层数，Q(k)m 是最大支持的调制阶数，f (k) 是可以取值 1、0.8、0.75 或 0.4 的缩放因子， μ 是[19]中定义的参数，T μs 是子帧中的平均 OFDM 符号持续时间，其中 T μs = 10−3 14·2μ 对于正常循环前缀，N BW (k),μ P RB 是最大资源在给定频带（或组合）中 UE 支持的最大带宽 BW (k) 中的块分配，并且 O(k) 是开销（对于频率范围 1 中的上行链路，等于 0.08）。假设具有 QPSK 调制、60 kHz 子载波间隔和 10 MHz 带宽的单天线 UE，(3) 变为 r = c ·K，其中常数 c 约为 12.59 ×106。</p><p>&emsp;&emsp;假设使用 LDPC 编码作为前向纠错，相应的误码率 (BER) 进一步降低了实现的数据速率 r。为了计算不同 SNR 水平的 BER，文章使用 LPDC 编码模拟了 AWGN 信道中 QPSK 信号的性能（见图 2）。对于高于 -1 dB 的 SNR 值，BER 值为 0。数据速率 r 基于给定 SNR 下的 BER 性能进行缩放。因此，当 Kij 是聚合 CC 的数量并且 BERij 是 UE i 对其请求 j 的 BER 时，QoE 要求变为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214208.png" alt="image-20220122214208479" style="zoom:37%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="动态资源分配的优化问题及Q-Learning模型"><a href="#动态资源分配的优化问题及Q-Learning模型" class="headerlink" title="动态资源分配的优化问题及Q-Learning模型"></a>动态资源分配的优化问题及Q-Learning模型</h2><h3 id="优化问题建模"><a href="#优化问题建模" class="headerlink" title="优化问题建模"></a>优化问题建模</h3><h4 id="短期分配优化"><a href="#短期分配优化" class="headerlink" title="短期分配优化"></a>短期分配优化</h4><p>设 <code>xij (t)</code> 表示在时间 t 是否满足 UE i 的请求 j 的二进制指示符（布尔值）。资源分配给网络切片的约束如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215408.png" alt="image-20220122215408681" style="zoom:50%;" /><p>其中 <code>F (t)</code>、<code>P C (t)</code> 和 <code>P T (t)</code> 分别是 gNodeB 在时间 t 的可用PRB、CPU计算资源和传输功率资源。 gNodeB 的某些资源可能已经分配给某些请求，这些请求尚未终止，因此某些资源可能不可用。</p><p>仅在时间 t 优化资源分配的短视目标是选择 Fij (t)、P Cij (t) 和 P Tij (t)，满足：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215439.png" alt="image-20220122215439619" style="zoom:50%;" /><p>其中 <code>wij</code> 是 UE i 的请求 j 反映其优先级的权重。上式也是网络切片分配优化的奖励。</p><h4 id="长期分配优化"><a href="#长期分配优化" class="headerlink" title="长期分配优化"></a>长期分配优化</h4><p>接下来考虑一定时间范围内的优化问题。资源从时间 t -1 更新到时间 t 如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215618.png" alt="image-20220122215618091" style="zoom:50%;" /><p>其中 <code>Fr(t - 1)</code>、<code>P Cr (t - 1)</code> 和 <code>P Tr (t - 1)</code> 是在时间 t -1 的PRB、CPU 使用率和传输能量，<code>Fa(t)</code>、<code>P Ca (t)</code> 和 <code>P Ta (t)</code> 分别是时间 t 内分配的PRB、CPU 使用率和传输功率资源。每个请求都有一个生命周期，如果在时间 t 满足（即服务在时间 t 开始），则该请求将在时间 t + lij 结束。将 R(t) 表示为在时间 t 结束（完成或过期）的请求集。在时间 t 释放和分配的资源由下式给出：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215745.png" alt="image-20220122215745803" style="zoom:50%;" /><p>和</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215758.png" alt="image-20220122215758606" style="zoom:50%;" /><p>然后，优化目标变为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215820.png" alt="image-20220122215820955" style="zoom:50%;" /><p>上式也是网络切片分配在长期优化时的奖励。</p><h3 id="强化学习算法"><a href="#强化学习算法" class="headerlink" title="强化学习算法"></a>强化学习算法</h3><p>&emsp;&emsp;文章使用 Q-learning 作为 Model-free RL 算法来学习确定在给定 State（可用资源和请求）下为 gNodeB 采取何种 Action（资源分配）的策略。 gNodeB 应用 Q-Learning 来计算函数 <code>Q : S × A → R</code> 来评估在状态 S 产生奖励 R 的动作 A 的质量，并维护为 Q 表。在每个时间 t，gNodeB 选择一个动作 at，观察一个奖励 rt，并从当前状态 st 转换到新状态 st+1（这个转换取决于当前状态 st 和动作 at），并更新 Q。</p><p>将 Q 初始化为随机矩阵开始，使用旧值和新信息的加权平均对 Q表 执行价值迭代更新，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122220114.png" alt="image-20220122220113981" style="zoom: 40%;" /><p>其中 <code>α</code> 是学习率 (0 &lt; α ≤ 1)，<code>γ</code> 是随着时间的推移奖励的折扣因子 (0 ≤ γ ≤ 1)，<code>maxa Q(st+1, a)</code> 是指Q的最优未来值的估计。</p><table><thead><tr><th>算法因子</th><th>对应值</th></tr></thead><tbody><tr><td>State</td><td><code>&#123;F(t)，PC (t)，PT (t)&#125;</code>，即gNodeB在时刻 t 的可用资源</td></tr><tr><td>Action</td><td>分配资源给请求</td></tr><tr><td>Reward</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215820.png" alt="image-20220122215820955" style="zoom:50%;" /></td></tr></tbody></table><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>为了比较，文章还考虑了三种基本算法：</p><ul><li><p><strong>Random algorithm</strong></p><p>  可用资源被分配给统一随机选择的网络切片请求</p></li><li><p><strong>FCFS algorithm</strong></p><p>  可用资源根据请求的到达时间分配给网络切片请求，即在任何给定时间，如果可用资源足以批准该请求，则首先回答最旧的网络切片请求</p></li><li><p><strong>Myopic algorithm</strong></p><p>  只有通过解决优化问题（8）才能分配可用资源以最大化当前效用</p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p>&emsp;&emsp;先假设 gNodeB 接收到可能来自三个 UE 的请求，然后扩展到了更多 UE。对于每个 UE，请求以每个时隙 0.5 的速率到达。一个时隙对应于每个时间块，长度为 0.23 ms，子载波间隔为 60 kHz。 CPU 使用率增加 2%（总共 50 个级别）。对于每个请求，权重是 [1,5] 中的随机整数，生命周期在 [1,10] 插槽中随机分配，期限在 [1,20] 插槽中随机分配。发射功率可以有 5 个级别，最大接收 SNR 在 [1.5,3] 中随机选择。总频率为 10 MHz，分为 11 个频段。运行超过 1000 个时隙的相同场景来测试不同的算法： Q-learning、随机、FCFS 和Myopic算法。其中 Q-learning的折扣因子设置为 γ = 0.95、学习率设置为 α = 0.1。</p><p>&emsp;&emsp;表 I 给出了 Q-learning 和基本算法的性能比较，该表显示了每种算法实现的网络效用以及 Q-learning 相对于其他算法的网络效用改进的比率。结果表明，Q-learning 相较其他算法实现了更大的效用（满足请求的总权重）。另一方面，Myopic算法在不考虑未来的情况下选择当前的最佳决策，性能优于 FCFS 和随机资源分配，但远远落后于 Q-learning。Q-learning 的效用范围为 [1731, 1831]，Myopic算法的效用范围为 [1359, 1466]。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111009.png" alt="image-20220124111002730" style="zoom:50%;" /><center>表 1</center><p>&emsp;&emsp;接下来增加向 gNodeB 发送网络切片请求的 UE 数量，并改变 UE 的到达率。图 2 显示了网络实用程序规模如何随使用 Q-learning 时的 UE 数量变化。注意，随着对固定资源的需求增加，网络效用随着 UE 数量的增加而下降。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111209.png" alt="image-20220124111209039" style="zoom:50%;" /><center>图 2</center><p>&emsp;&emsp;在长期优化问题中，权重 <code>wij</code> 作为优先级分配给 UE i 的请求 j。接下来评估权重对优化结果的影响。为此，文章固定了一个 UE 的所有请求的权重。第一种情况为[1,1,1]，即所有请求的权重为1。第二种情况为[1,3,5]，即UE 1的所有请求的权重为1，UE 2的所有请求的权重为3 ，并且所有UE 3的请求权重为5。第三种情况是[5,3,1]。即，所有 UE 1 的请求权重为 5，所有 UE 2 的请求权重为 3，所有 UE 3 的请求权重为 1。表 II 中显示了每个 UE 的服务请求数。结果表明，如果 UE 的权重增加并且大于其他 UE，则该 UE 的服务请求数量相对于其他 UE 增加。另一方面，在对网络效用的影响方面，权重的实际值并没有权重的顺序发挥那么大的作用，即权重[1,2,3]与权重[1,3,5]获得相同的结果。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111436.png" alt="image-20220124111436388" style="zoom:50%;" /><center>表 2</center><p>&emsp;&emsp;接下来考虑 5G 雷达频谱共存场景，其中雷达信号可能随着时间的推移占据多个频率块。考虑雷达信号的两种到达模式：第一个模式对应于独立同分布（i.i.d.）到达，雷达信号出现在任何时间（时隙），概率为 <code>pI</code>。第二种模式对应于会话（突发）到达，会话的生命周期是从 [10,50] 个插槽中均匀随机选择的。然后调整会话的到达以获得作为现有占用概率的 <code>pI</code>。假设雷达信号被可靠地检测到。在 [22] 中，研究表明，当应用深度学习时，检测雷达信号的潜在误差会变低。</p><p>&emsp;&emsp;图 3 中展示了当改变现有用户的两种（i.i.d.和突发）到达类型的 <code>pI</code> 时，Q-learning 实现的网络效用。 Q-learning成功地适应了现有用户的频谱占用模式，并有效地利用了现有用户的频谱占用留下的网络资源。正如预期的那样，通过 Q 学习实现的网络效用随着 <code>pI</code> 的增加而下降，但这种下降与 <code>pI</code> 呈次线性关系。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111839.png" alt="image-20220124111839174" style="zoom:50%;" /><center>图 3</center>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信的资源调度器</title>
      <link href="/2022/01/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>无线通信资源调度论文</strong></p><ul><li><p>Joint Time-Frequency Domain Proportional Fair Scheduler with HARQ for 3GPP LTE Systems</p><blockquote><p>时/频调度器</p><p>TD：PF</p><p>FD：比较了不同算法（无、RR、MAX、PF、DA）</p><p>结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。</p></blockquote></li><li><p>Multi-QoS-Aware Fair Scheduling for LTE</p><blockquote><p>时/频调度器</p><p>TD：PF</p><p>FD：GBR用RR、nGBR用优先级分配</p><p>将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。</p></blockquote></li><li><p>HARQ Aware Frequency Domain Packet Scheduler with Different Degrees of Fairness for the UTRAN Long Term Evolution</p><blockquote><p>时/频调度器</p><p>TD：提供用户所需的QoS参数</p><p>FD：根据TD调度器给定的输入实现最高的频谱效率</p><p>另一个结论：D-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></blockquote></li></ul><span id="more"></span><p>&nbsp;</p><h1 id="论文-1"><a href="#论文-1" class="headerlink" title="论文 1"></a>论文 1</h1><p>&emsp;&emsp;文章利用了联合时域和频域调度的潜在分集增益。其中时域 (TD) 调度器实现公平性约束，使用了比例公平（PF）调度算法，在吞吐量和公平性之间维持平衡。然后频域 (FD) 调度器中提高吞吐量，在选定用户的先验 TD 调度的约束下优化多用户频率分集的增益。</p><p>原文：<a href="https://lrk612.com/resources/Joint%20Time-Frequency%20Domain%20Proportional%20Fair%20Scheduler%20with%20HARQ%20for%203GPP%20LTE%20Systems.pdf">Joint Time-Frequency Domain Proportional Fair Scheduler with HARQ for 3GPP LTE Systems</a></p><p>&nbsp;</p><h2 id="OFDMA-系统和信道模型"><a href="#OFDMA-系统和信道模型" class="headerlink" title="OFDMA 系统和信道模型"></a>OFDMA 系统和信道模型</h2><p>&emsp;&emsp;OFDMA 是一种基于 OFDM 的多址接入方案，数据在不同的子载波上传输给不同的用户。OFDMA 凭借其较高的频谱效率、对多径衰落的良好免疫能力而适用于LTE系统。文章假设的LTE OFDMA下行系统的关键参数如表1所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152003.png" alt="image-20220121151835454" style="zoom: 33%;" /><center>表 1</center><p>&emsp;&emsp;对于LTE系统中的频率复用用户，总带宽被划分为子信道，表示为物理资源块（PRB）。 PRB 是频域调度的最小分辨率。 10MHz 系统中有 50 个 PRB，每个 PRB 由 12 个相邻的子载波组成。子载波带宽为 15kHz，PRB 带宽为 180kHz。图 1 显示了如何对子载波进行分组和分配的示例。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152005.png" alt="image-20220121151909967" style="zoom: 50%;" /><center>图 1</center><p>&emsp;&emsp;如图 2 所示，可以为每个 PRB 反馈单个信道质量指标 (CQI)（根据 12 个子载波的平均质量计算得出）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152004.png" alt="image-20220121151854348" style="zoom: 50%;" /><center>图 2</center><h2 id="时频调度器"><a href="#时频调度器" class="headerlink" title="时频调度器"></a>时频调度器</h2><p>&emsp;&emsp;在时频调度器中，第一层调度在时域（TD）中实现，第二层在频域（FD）中实现。 TD调度器旨在选择信道相对较好的用户，同时保持对所有用户的公平。结合这一点，文章对比了不同的FD调度器。图 3 显示了信息如何输入调度程序以及时域和频域调度程序之间的交互。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152208.png" alt="image-20220121152208509" style="zoom:55%;" /><center>图 3</center><h3 id="时域调度器"><a href="#时域调度器" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;时域中使用 PF 算法。该算法的本质是为所有用户分配大约相同数量的资源（在一段时间内平均），并尝试在任何给定的调度间隔内挑选出信道条件接近其峰值的用户作为Active UE。用户优先级评价指标计算方法如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152549.png" alt="image-20220121152549563" style="zoom: 33%;" /><p>其中 <code>Rk(t)</code> 表示当前请求的传输速率，通常是根据用户的 <code>SINR</code> 反馈从一组可用的 <code>MCS</code> 中选择的。 <code>Tk(t)</code> 表示用户在过去一个窗口期内的平均吞吐量，由下式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152648.png" alt="image-20220121152648092" style="zoom: 40%;" /><p>其中 <code>tc</code> 是平均吞吐量的窗口期时长。文章中 <code>tc</code> 设置为 500。<code>Tk(t)</code>初始值默认取为第一次报告的 <code>CQI</code>，并基于链路自适应 (LA) 中用户选择的 <code>MCS</code>。</p><p>&emsp;&emsp;在 OFDMA 的上下文中选择具有最高优先级的用户子集，其数量称为“复用用户”并表示为 <code>k</code>，用于后续的 FD 调度。考虑单元内的所有用户，包括具有新数据的用户以及等待重传的用户。由于混合 ARQ 的增益，重传的用户将被优先考虑，因为他们的重传将有更高的成功传输机会。等待重传的用户的有效率根据以下公式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152850.png" alt="image-20220121152850014" style="zoom: 40%;" /><p>其中 SNR_CC 是 Chase Combining 中重传的累积 SNR。</p><p>&nbsp;</p><h3 id="频域调度器"><a href="#频域调度器" class="headerlink" title="频域调度器"></a>频域调度器</h3><h4 id="No-Frequency-Domain-Scheduling-TD-PF）"><a href="#No-Frequency-Domain-Scheduling-TD-PF）" class="headerlink" title="No Frequency Domain Scheduling (TD-PF）"></a>No Frequency Domain Scheduling (TD-PF）</h4><p>&emsp;&emsp;频域不调度，意味着只在时域使用PF算法调度</p><h4 id="Round-Robin-FD-RR"><a href="#Round-Robin-FD-RR" class="headerlink" title="Round Robin (FD-RR)"></a>Round Robin (FD-RR)</h4><p>&emsp;&emsp;假设所有用户都需要相同的 QoS，以循环方式为TD中选出的Active UE进行分配。在重新分配给同一个用户之前，必须为所有用户分配一个 PRB。</p><h4 id="Max-C-I-（FD-MAX）"><a href="#Max-C-I-（FD-MAX）" class="headerlink" title="Max C/I （FD-MAX）"></a>Max C/I （FD-MAX）</h4><p>&emsp;&emsp;所有Active UE按SNR顺序排优先级进行PRB分配：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121162428.png" alt="image-20220121162428188" style="zoom:40%;" /><h4 id="Proportional-Fair-FD-PF"><a href="#Proportional-Fair-FD-PF" class="headerlink" title="Proportional Fair (FD-PF)"></a>Proportional Fair (FD-PF)</h4><p>&emsp;&emsp;优先级计算公式和上面时域的类似，按照优先级分配PRB：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121162434.png" alt="image-20220121162434640" style="zoom:40%;" /><p>其中 <code>Rk,j(t)</code> 表示 PRB j 处的瞬时可实现速率，<code>Tk(t)</code> 表示用户的平均吞吐量。为排名最高的用户 k 分配PRB j 以传输。</p><p>有两种 FD-PF 策略： </p><ul><li>每个新时间间隔（在分配所有 PRB 之后）都更新平均吞吐量 Tk(t)，记为 <code>FD PFⅠ</code></li><li>在每个 PRB 都被分配之后更新平均吞吐量 Tk(t) ，记为 <code>FD PFⅡ</code></li></ul><h4 id="Dynamic-Allocation-FD-DA"><a href="#Dynamic-Allocation-FD-DA" class="headerlink" title="Dynamic Allocation (FD-DA)"></a>Dynamic Allocation (FD-DA)</h4><p>&emsp;&emsp;上面所提出的算法确保选定用户之间的 PRB 份额相等，但容量不公平。DA算法具有较低复杂度，在同等资源约束下能给出近似最大化容量。在该算法中，N 表示从 1 到 50 的所有可用 PRB，k 表示每个时隙中要复用的用户数。算法如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121163036.png" alt="image-20220121163036592" style="zoom: 33%;" /><p>&nbsp;</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p>&emsp;&emsp;文章首先研究了随着小区中用户数量的增加，各种调度器的容量性能。</p><ul><li><p><code>FD-PF I</code> 和 <code>FD-PF II</code> 实现了几乎相同的性能，明显优于 <code>TD-PF</code>。</p></li><li><p>随着用户数量的增加，<code>FD-PF</code> 可以利用更多的多样性增益，从而提高性能增益，在资源分配相等的情况下明显优于 <code>FD-RR</code>。</p></li><li><p>当小区中有足够数量的用户时，<code>FD-DA</code> 调度器可以实现比 <code>TD-PF</code> 更高的吞吐量，其性能曲线的轻微振荡性质可归因于其当 PRB 的数量略超过用户数量的整数倍时，能够为强用户分配额外资源的能力。</p></li><li><p><code>FD-MAX</code> 调度器显然在容量方面提供了最好的性能，但在公平性方面预计不会达到良好的性能。</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121164713.png" alt="image-20220121164713673" style="zoom:38%;" /></li></ul><center>图 4 吞吐量随用户数量的变化</center><p>&emsp;&emsp;对于图 4 中的结果，每个时隙可能的复用用户数是固定的，并且等于小区中的用户数。但是，由于某些调度程序的性质，并非所有用户实际上都按时隙进行调度。图 5 显示了实际调度的数量。</p><ul><li><p>对于 <code>FD-RR</code> 和 <code>FD-DA</code> 调度算法，调度用户的数量始终等于复用用户的数量，因为这些算法确保所有用户之间的资源共享。 </p></li><li><p><code>FD-Max</code> 算法只偏爱具有高 SNR 的用户，这些用户取决于位置。</p></li><li><p>在 <code>FD-PF</code> 的结果中，策略 II 的平均调度用户数远高于策略 I。这是因为在策略 I 中，每个 PRB 之后的平均吞吐量没有瞬时更新，因此用户PF 排名较低的优先级将不会被选中。</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121165201.png" alt="image-20220121165201823" style="zoom:34%;" />  <center>图 5 复用用户数量对比调度的用户数量</center></li></ul><p>&emsp;&emsp;如果在频域中调度所有复用用户，多用户分集可能会被最大化，但时域中固有的多用户分集并没有被利用，特别是在等资源分配算法的情况下。图 6 显示了 <code>FD-PF I</code>、<code>FD-PF II</code> 和 <code>FD-DA</code> 调度器如何随着每个时隙中可能的多路复用用户数量的增加而执行。由于频域中的机会调度，这些调度器都受益于每个时隙中不断增加的复用用户数量。然而当大约 70% 的用户被复用时，增益会饱和，而当更多用户被复用时，增益会减小。这是因为资源分配给了所有用户，包括那些处于深度衰减中的用户，因此性能不佳。从这些结果可以得出结论，为了平衡时域和频域的分集增益，应该选择大约 50-70% 的所有用户作为可能的复用用户在每个时间实例中传输，以实现良好的交易-离开。特别是，<code>FD-DA</code> 在此范围内的性能明显优于两种 <code>FD-PF</code> 调度器。一旦由于将资源分配给所有可能的多路复用用户的约束，可能的多路复用用户的数量增加到超过此范围，<code>FD-DA</code> 性能就会更快地下降。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121173912.png" alt="image-20220121173912610" style="zoom:37%;" /><center>图 6 调度器性能随复用用户数量的变化</center><p>&emsp;&emsp;然后在图 7 中考虑了可能的多路复用用户数量等于所有用户的 50% 时的吞吐量性能（还显示了 100% 情况下的性能作为参考）。可以看出，当小区中有足够数量的用户时，<code>FD-DA</code> 优于所有除了 <code>TD-MAX</code> 之外其他的方案。还可以看出，<code>FD-PF</code> 策略对复用用户数量的敏感度远低于 <code>FD-DA</code>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121174323.png" alt="image-20220121174323663" style="zoom:37%;" /><center>图 7 选择50%复用用户时吞吐量表现</center><p>&emsp;&emsp;通常，吞吐量的增加是通过某种公平的妥协来实现的，反之亦然。因此，这里研究调度程序的公平性能。众所周知，按比例公平的调度程序应该最大化对数平均用户率的总和 [7]。文章采用了基于 [8] 的公平度量：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121174508.png" alt="image-20220121174508164" style="zoom:33%;" /><p>&emsp;&emsp;基于前面的结果，在一个 20 个用户的小区中，在每个时隙中选择 10 个（50%）复用用户进行 FD 调度取得了较好的结果。图 8 显示了各种调度器的公平性能，每个时隙中固定值为 10 个多路复用用户，以实现的公平度量的 cdf 的形式。 <code>FD-MAX</code> 在吞吐量方面是最佳的，但在公平性方面表现不如预期。 <code>FD-RR</code> 和 <code>TD-PF</code> 比 <code>FD-MAX</code> 实现了更好的公平性。通过利用时域和频域的多样性，可以更公平地为所有用户分配资源。因此，两种 <code>FD-PF</code> 策略都比 <code>TD-PF</code> 调度器实现了更好的公平性，<code>FD-PF II</code> 由于其更频繁地更新 Tk(t) 而更胜一筹。 <code>FD-DA</code> 试图在频域中最大化吞吐量，但通过分配相等的资源来保持公平元素，也表现良好，实现了比 <code>TD-PF</code> 和 <code>FD-PF I</code> 更好的公平性，与 <code>FD-PF II</code> 相似。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121175554.png" alt="image-20220121175554030" style="zoom:38%;" /><center>图 8</center><p>&nbsp;</p><p>&nbsp;</p><h1 id="论文-2"><a href="#论文-2" class="headerlink" title="论文 2"></a>论文 2</h1><p>&emsp;&emsp;文章提出了一种服务感知 MAC 调度器算法，该算法在 MAC 层内定义了五个新的 QoS 类别。考虑到不同的QoS等级以及不同的信道条件来执行调度。目标是执行公平的 QoS 感知调度以及小区吞吐量优化。</p><p>原文：<a href="https://lrk612.com/resources/Multi-QoS-Aware%20Fair%20Scheduling%20for%20LTE.pdf">Multi-QoS-Aware Fair Scheduling for LTE</a></p><p>&nbsp;</p><h2 id="LTE协议分层"><a href="#LTE协议分层" class="headerlink" title="LTE协议分层"></a>LTE协议分层</h2><h3 id="UE-Node"><a href="#UE-Node" class="headerlink" title="UE Node"></a>UE Node</h3><p>&emsp;&emsp;UE高级节点模型的分层层次结构如图所示，它包括两组协议：LTE空中接口相关协议和终端用户应用协议。 LTE Uu 协议包括 PDCP、RLC、MAC 和 PHY 层。除 PHY 层协议外，所有其他协议均按照 3GPP 规范 [10] 实现。给物理层建模只是为了在 eNB 和 UE 实体之间传输用户数据的传输块。增强型 MAC 调度器旨在模拟 PHY 层特性。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125547.png" alt="image-20220122125547704" style="zoom: 30%;" /><center>图 9</center><h3 id="eNB-Node"><a href="#eNB-Node" class="headerlink" title="eNB Node"></a>eNB Node</h3><p>&emsp;&emsp;eNB 高级节点模型的协议层如图所示。节点模型 PDCP、RLC 和 MAC 的右侧协议代表了与 Uu 相关的功能。而节点模型 GTP、UDP、IP 和以太网的左侧协议代表与传输相关的功能。 MAC 调度器位于 eNB 的 MAC 层。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20220122125605813.png" alt="image-20220122125605813" style="zoom:30%;" /><center>图 10</center><p>&nbsp;</p><h2 id="MAC层调度器"><a href="#MAC层调度器" class="headerlink" title="MAC层调度器"></a>MAC层调度器</h2><p>&emsp;&emsp;MAC调度器负责在下行链路和上行链路的用户之间调度空口资源。由于 LTE 中使用了 OFDM 技术，调度器可以时域和频域中分配无线电资源。最小的调度资源单元称为物理资源块（PRB）。为了简化 LTE MAC 调度，定义了两个阶段：时域 (TD) 和频域 (FD) 调度器。TD 调度器用于根据用户的 QoS 特性来区分用户。 FD调度器负责在优先用户之间分配无线电资源（即PRB）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125657.png" alt="image-20220122125657578" style="zoom: 33%;" /><center>图 11</center><p>&emsp;&emsp;本文的 MAC 调度器考虑了两种主要类型的 QoS Bearer：保证比特率 (GBR) 和非保证比特率 (non-GBR)。如表 2所示，基于 QoS 类别标识符 (QCI)，传入的数据包按其优先级顺序分为五个不同的 MAC QoS 类别，这些类别由 MAC 调度程序定义。两个最高的 MAC QoS 等级（1 和 2）代表 GBR 承载，而其他三个代表 nGBR 承载。 MAC 调度器对所有 GBR 承载执行严格的优先级调度（即首先服务），然后调度 nGBR 承载。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125719.png" alt="image-20220122125719413" style="zoom:50%;" /><center>表 2</center><h3 id="时域调度器-1"><a href="#时域调度器-1" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;TD 调度程序创建两个候选列表（一个用于 GBR，另一个用于 nGBR）。 GBR 候选列表将 MAC-QoS1 类中的所有Bearer添加到候选列表顶部，然后添加 MAC-QoS2 类的Bearer。对于 nGBR 承载列表，TD 调度器将整个 nGBR MAC-QoS 类承载加入候选列表，然后根据它们的优先级因子对其进行优先级排序：</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20220122125727993.png" alt="image-20220122125727993" style="zoom:45%;" /><p>这里 <code>PF0</code> 是第 0 次迭代的优先级因子，<code>M-QoSweight</code> 是 MAC QoS 类的权重，<code>Raccum</code> 是该承载过去的累积数据速率。 <code>Raccum</code> 计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125738.png" alt="image-20220122125738674" style="zoom:50%;" /><p>这里 <code>Rinst(n)</code> 是第 n 个 TTI 的累积承载数据速率，<code>α</code> 是平滑因子，<code>Rinst</code> 是第 n 个 TTI 的瞬时承载数据速率。</p><h3 id="频域调度器-1"><a href="#频域调度器-1" class="headerlink" title="频域调度器"></a>频域调度器</h3><p>&emsp;&emsp;FD调度器从TD调度器提供的GBR候选列表开始。 PRB 的分配是迭代完成的，每次迭代为一个承载分配一个具有最高 SINR 值的 PRB。候选列表中的承载按序（基于其优先级）根据最高 SINR 值选择下一个最佳 PRB，此 PRB 分配过程继续进行，直到候选列表中的所有承载都获得一个 PRB。在每次迭代结束时，计算每个承载实现的数据速率，并检查承载缓冲区中是否有足够的数据可用，或者是否为该特定承载实现了足够的保证速率。如果满足上述条件之一，则将承载从候选列表中删除并调度。</p><p>&emsp;&emsp;每个承载的数据速率是通过分配的 PRB 的 SINR 计算的，其中所有分配的 PRB 的有效 SINR 值可以通过使用有效指数 SINR 映射 (EESM) [11] 来计算。然后将其与根据加性高斯白噪声 (AWGN) 块误码率 (BLER) 曲线计算的目标 SINR 值进行比较（通过设置目标 BLER 值，例如 10%）。如果有效 SINR 低于目标值，则降低调制和编码方案 (MCS)，并重新计算有效 SINR。否则，使用 [12] 中定义的 3GPP 表，确定传输块大小 (TBS)，它表示该 TTI 的承载数据速率。一旦调度了所有的 GBR 承载，FD 调度器就开始调度 nGBR 承载。 FD 调度器从 nGBR 候选列表中挑选最高的 N 个 nGBR 承载来服务于该 TTI。这里也使用了 GBR 调度中使用的相同迭代过程，但有一个例外：在每次迭代之后，使用新计算的优先级因子重新确定 nGBR 承载的优先级，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125959.png" alt="image-20220122125959106" style="zoom:50%;" /><p>其中 <code>PFj</code> 是第 j 次迭代的优先级因子，<code>TBSj</code> 是第 j 次迭代的传输块大小。</p><p>&emsp;&emsp;之所以在迭代之间重新对 nGBR 承载进行优先级排序，主要是为了让信道条件比其他承载更好的 nGBR 承载有更多机会优先选择其最佳PRB。</p><p>&nbsp;</p><h2 id="仿真结果-1"><a href="#仿真结果-1" class="headerlink" title="仿真结果"></a>仿真结果</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>&emsp;&emsp;为了展示 LTE MAC 调度程序如何服务和处理不同 QoS 服务的混合，文章研究了三种不同的场景，如表 3 所示，定义了具有四种不同 QoS 服务（VoIP、视频、HTTP 和 FTP）的用户。由于它们的实时性，它们中的一些必须具有更高的优先级。文章研究如果在一个 QoS 类中混合所有这些服务而不区分 GBR 和 nGBR 会发生什么，以及如果将它们分开会发生什么。其余仿真配置如表 4 所示。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122134943.png" alt="image-20220122134943929" style="zoom:50%;" /><center>表 3</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122134953.png" alt="image-20220122134953849" style="zoom:50%;" /><center>表 4</center><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>&emsp;&emsp;VoIP 用户的平均空中接口吞吐量如图 12 所示。结果表明，即使与 nGBR 承载映射在一起，VoIP 用户在所有不同场景下的吞吐量都相同。原因是时域调度中中的 <code>Raccum</code> 值表示的比例公平特性。由于 VoIP 承载具有相对较小的累积数据速率，它往往会获得更高的优先级因子，并且总是首先被调度。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145556.png" alt="image-20220122145556521" style="zoom:50%;" /><center>图 12</center><p>&emsp;&emsp;VoIP 的平均端到端延迟如图 13 所示。可以注意到，Sc2 和 Sc3 的端到端延迟比 Sc1 略好，这是因为前面的场景将 VoIP 承载映射到更高的 MAC QoS 等级（M-QoS2 和 M-QoS1）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145644.png" alt="image-20220122145644012" style="zoom:50%;" /><center>图 13</center><p>&emsp;&emsp;图 14 显示了视频承载的平均空中接口吞吐量。结果表明，与视频承载映射到 GBR MAC 类的其他两个场景相比，视频承载在 Sc1 场景中的性能更差。在 Sc1 场景中，视频承载与 VoIP、HTTP 和 FTP 承载共享相同的 nGBR MAC QoS 类。由于视频承载的累积数据速率非常高（~ 300 kbps），它们不会一直得到服务。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145725.png" alt="image-20220122145725333" style="zoom:50%;" /><center>图 14</center><p>&emsp;&emsp;Sc1 场景中视频承载的性能下降可以在图 15 中清楚地看到，平均端到端延迟。与视频承载获得更严格优先级的其他两种情况相比，视频承载遭受明显更高的端到端延迟。查看图 16 和图 17 所示的 HTTP 承载结果，可以注意到当 HTTP 承载被分配到更高的 MAC QoS 类时，它们具有更好的应用程序性能。主要是当它没有与 FTP 承载混合并且被分配到比 FTP 更高的 MAC QoS 类时。这是因为时域调度中的 M-QoS 权重被设置为比其他场景高十倍。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145804.png" alt="image-20220122145804733" style="zoom:50%;" /><center>图 15</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145839.png" alt="image-20220122145839311" style="zoom:50%;" /><center>图 16</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145906.png" alt="image-20220122145906349" style="zoom:50%;" /><center>图 17</center><p>&emsp;&emsp;最后，FTP 承载结果如图 18 和图 19 所示。从完全混合场景 Sc1 到完全分离场景 Sc3 时，FTP 性能降低。平均吞吐量减少，平均文件下载时间增加。这是因为 FTP 承载映射到最低的 MAC QoS 类别，并且与其他服务相比，其服务的优先级较低。然而，给 FTP 承载较低的优先级是现实的，因为 FTP 不是实时应用程序，FTP 用户可以等待几秒钟来下载他们的文件，而对于像 VoIP 这样的应用程序则不能这样说。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145950.png" alt="image-20220122145950136" style="zoom:50%;" /><center>图 18</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122150003.png" alt="image-20220122150003682" style="zoom:50%;" /><center>图 19</center><p>&nbsp;</p><p>&nbsp;</p><h1 id="论文-3"><a href="#论文-3" class="headerlink" title="论文 3"></a>论文 3</h1><p>&emsp;&emsp;文章开发了一个两层调度框架，由一个时域 (TD) 调度器和一个频域 (FD) 调度器组成。结果表明这种方法可以有效地包含 HARQ 调度约束以及控制用户之间的公平性。</p><p>原文：<a href="https://lrk612.com/resources/HARQ%20Aware%20Frequency%20Domain%20Packet%20Scheduler%20with%20Different%20Degrees%20of%20Fairness%20for%20the%20UTRAN%20Long%20Term%20Evolution.pdf">HARQ Aware Frequency Domain Packet Scheduler with Different Degrees of Fairness for the UTRAN Long Term Evolution</a></p><p>&nbsp;</p><h2 id="调度器框架"><a href="#调度器框架" class="headerlink" title="调度器框架"></a>调度器框架</h2><p>&emsp;&emsp;调度中的实体：分组调度器、链路自适应（LA）和 HARQ 管理器之间的交互如图 20 所示。这些实体位于基站（eNode-B），以支持快速适应无线电频道条件。控制实体是包调度器。频域调度的最小单元是一个物理资源块（PRB），其带宽等于 375 kHz [1]。10 MHz 带宽中有24 个 PRB可用，每个 PRB 由 25 个相邻子载波组成。分组调度器可以咨询链路自适应，以获得小区中某些用户的支持数据速率的估计，用于不同的 PRB 分配。链路自适应基于来自用户的信道质量指示 (CQI) 反馈，以及来自过去传输的 Ack/Nack，以确保支持的数据速率的估计对应于某个块错误率 (BLER)第一次传输的目标。外环链路自适应用于稳定BLER性能[5]。 HARQ 管理器提供缓冲区状态信息以及未决 HARQ 重传的传输格式。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122152415.png" alt="image-20220122152415150" style="zoom:50%;" /><center>图 20</center><p>&emsp;&emsp;整个数据包调度框架如图 21 所示，其中提出了一个简单的两步算法。在步骤#1中，TD调度器选择在步骤#2中由FD调度器频率复用的N个用户。这个框架的复杂性较低，因为 FD 调度器只需要考虑每个 TTI 最多 N 个用户的频率复用。N的值是根据潜在的信令约束以及调度带宽中PRB的数量来设置的。假设小区中的用户数 D 大于 N (D &gt;N)，TD 调度器提供了控制用户 QoS 的主要机制，而 FD 调度器在给定来自 TD 调度程序的输入后，主要尝试优化每个 TTI 的频谱效率。由于 FD 调度器的用户多样性顺序有限，整体调度器性能将不是最佳的。值得注意的是，尽管调度框架由两个连续的步骤组成，但在许多情况下，TD 调度程序和 FD 调度程序之间存在依赖关系。 TD 调度器尤其如此，它依赖于过去交付给用户的平均吞吐量（即依赖于 FD 调度器）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122152712.png" alt="image-20220122152712124" style="zoom: 45%;" /><center>图 21</center><h3 id="时域调度器-2"><a href="#时域调度器-2" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;图 21 中的TD调度器选择调度优先级最高的N个用户进行后续FD调度，其中N是TD调度器的参数。设用户 m 的瞬时支持吞吐量为 <code>rm[n]</code>，由假设简单的全带宽传输的链路适配单元获得，其中 eNode-B 传输功率在 PRB 之间平均分配。在不同的时域调度器算法中，都有为用户 m 定义了优先级度量，调度器选择在调度时具有该度量最高值的 N 个用户。例如：</p><table><thead><tr><th align="center">TD算法</th><th>优先级因子</th><th>备注</th></tr></thead><tbody><tr><td align="center">TD-PF</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122153543.png" alt="image-20220122153543916" style="zoom:50%;" /></td><td>Tm[n] 表示过去的平均交付用户吞吐量，通过 [7] 中概述的递归方法计算，n 表示当前调度间隔</td></tr><tr><td align="center">TD-MT</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122153619.png" alt="image-20220122153619747" style="zoom:50%;" /></td><td>此调度程序优先考虑靠近 eNode-B 的用户（即取吞吐量大小作为优先级）</td></tr><tr><td align="center">TD-BET</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164635.png" alt="image-20220122153706045" style="zoom:50%;" /></td><td>该调度程序旨在保持相同的用户吞吐量，而与用户位置无关，不需要无线电信道的先验知识</td></tr></tbody></table><p>&emsp;&emsp;TD 调度程序考虑的用户集包括具有新数据的用户以及具有未决重传的用户。此外，TD 调度程序不会优先考虑具有未决重传的用户。</p><h3 id="HARQ-感知的频域调度器"><a href="#HARQ-感知的频域调度器" class="headerlink" title="HARQ 感知的频域调度器"></a>HARQ 感知的频域调度器</h3><p>&emsp;&emsp;FD 调度器负责将 M 个可用的 PRB 分配给 N 个选定的用户。为了从多用户频率分集调度中获益，希望将用户映射到他们体验相对良好信道质量的那些 PRB。这是一个较复杂的优化问题：由于附加的约束条件使未决的 HARQ 重传必须在与原始传输相同数量的 PRB 上传输，从而导致问题更加复杂。但是FD 调度器仍然可以自由选择 PRB来重传，只要 PRB 的数量与原始传输相同（自适应 HARQ）。HARQ 管理中涉及的步骤如图 22 所示。为了限制 HARQ 重传延迟，我们选择在 FD 调度器中优先处理未决的 HARQ 重传。因此，假设 N 个用户中的 Q 个有未决的重传，需要分配 K 个 PRB，这留下 Y =M - K 个 PRB 用于从剩余的 L 个用户传输新数据（图 22 中的步骤 A）。首先将最多 Y 个 PRB 分配给 L 个用户以传输新数据（步骤 B）。这在为信道质量相对较高的用户选择 PRB 时提供了最大的灵活性，并往往会使新数据的传输吞吐量最大化。随后将剩余的 K 个 PRB 分配给 Q 个等待重传的用户（步骤 C）。这意味着与新数据相比，选择好的 PRB 进行重传的自由度较小。采用这种方法是因为重传并不需要信道质量特别良好，因为由于 HARQ 组合增益，重传更容易被正确接收。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122154054.png" alt="image-20220122154054412" style="zoom:40%;" /><center>图 22</center><p>&emsp;&emsp;用 <code>rm,b[n]</code> 表示用户 m 在 PRB b 上的瞬时吞吐量，该吞吐量估计取自链路自适应，并基于特定 PRB 的 CQI 报告，且假设每个 PRB 的功率相等。基于此，文章研究了以下 FD 调度器的性能：</p><table><thead><tr><th>TD算法</th><th>优化目标</th><th>备注</th></tr></thead><tbody><tr><td>FD-EQ (Equal Resource)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155752.png" alt="image-20220122155752811" style="zoom:50%;" /></td><td>m‘是被选择分配PRB的用户</td></tr><tr><td>FD-PF (Proportional Fair)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155802.png" alt="image-20220122155802095" style="zoom:50%;" /></td><td></td></tr><tr><td>FD-TA (Throughput-to-Average)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155813.png" alt="image-20220122155813461" style="zoom:50%;" /></td><td>其中 <code>rm[n]</code> 表示基于使用单一优化 MCS 格式的全 BW 传输的瞬时支持吞吐量</td></tr></tbody></table><p>&nbsp;</p><h2 id="仿真结果-2"><a href="#仿真结果-2" class="headerlink" title="仿真结果"></a>仿真结果</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122163138.png" alt="image-20220122163138727" style="zoom: 67%;" /><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164123.png" alt="image-20220122164123780" style="zoom: 67%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164244.png" alt="image-20220122164244820" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于深度强化学习的网络切片资源管理</title>
      <link href="/2022/01/19/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Deep%20Reinforcement%20Learning%20for%20Resource%20Management%20in%20Network%20Slicing/"/>
      <url>/2022/01/19/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Deep%20Reinforcement%20Learning%20for%20Resource%20Management%20in%20Network%20Slicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;深度强化学习 (DRL) 侧重于如何通过尝试替代动作和强化产生更有益结果的倾向动作来与环境交互，是网络切片资源管理问题的一个有前途的解决方案。本文在简要回顾了 DRL 的基本概念后，研究了 DRL 在解决网络切片场景中一些典型资源管理的应用，包括<strong>无线资源切片</strong>和<strong>基于优先级的核心网络切片</strong>。最后还从一般的角度讨论了在网络切片中应用 DRL 可能面临的挑战。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119150855.png" alt="image-20220118210056206" style="zoom: 40%;" /><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Deep_Reinforcement_Learning_for_Resource_Management_in_Network_Slicing.pdf">Deep Reinforcement Learning for Resource Management in Network Slicing</a></p><span id="more"></span><p>&nbsp;</p><h2 id="问题导向及现有研究"><a href="#问题导向及现有研究" class="headerlink" title="问题导向及现有研究"></a>问题导向及现有研究</h2><p>为了提供更好的性能和成本效益的服务，切片上的实时资源管理主要面对如下问题：</p><ul><li><p>对于无线电接入网络，频谱是一种稀缺资源，保证频谱效率（SE）具有重要意义[8]；而对于核心网络，虚拟化功能受到计算资源的限制</p></li><li><p>切片租户的服务水平协议 (SLA) 通常对用户感知的体验质量 (QoE) 有着严格的要求 [9]</p></li><li><p>每个切片的实际需求很大程度上取决于移动用户的请求模式</p></li></ul><p>&emsp;&emsp;在 5G 时代，研究如何智能响应移动用户的服务请求动态至关重要 [7]，从而以可接受的频谱或计算资源为代价在每个切片中获得令人满意的 QoE [4]。网络切片的资源管理方向已经有一些相关工作，特别是在边缘计算 [10] 和物联网 [11] 等特定场景中。但是，这些工作都聚焦于特定场景而缺乏一般场景的考虑。[12] 建议采用遗传算法作为一般场景下切片间资源管理的进化手段，但是它并没有反映切片的 SLA 和所需资源量之间的关系。</p><p>&emsp;&emsp;AlphaGo [14] 的成功以及应用 DRL 在某些特定领域的资源分配问题中的应用，如功率控制 [16]、绿色通信 [17]、云无线接入网络 [18]、移动边缘计算和缓存 [19]-[21] 引起了将 DRL 应用于网络切片领域的研究兴趣。鉴于现有切片资源管理中具有挑战性的技术问题，仔细研究在以下方面应用 DRL 的性能至关重要：</p><ul><li><p>DRL的可行性</p><p>  DRL 是否在消耗可接受的网络资源（例如频谱）的同时产生令人满意的 QoE 结果？</p></li><li><p>对比现有资源管理方案</p><p>  例如，资源管理可以通过遵循精心设计的预测算法进行，也可以通过将可用资源等分到每个切片中来进行。前者意味着一个合理的选择，而后者则节省了大量的计算成本。因此，DRL 和方案之间的比较也很重要</p></li></ul><table><thead><tr><th>论文</th><th>相关内容</th></tr></thead><tbody><tr><td>[1]~[4]</td><td>5G相关概念</td></tr><tr><td>[5]~[7]</td><td>网络切片相关概念</td></tr><tr><td>[4]</td><td>QoE的含义，频谱资源与QoE的关系</td></tr><tr><td>[8]</td><td>频谱资源与频谱效率</td></tr><tr><td>[9]</td><td>服务水平协议 (SLA)  与 用户感知的体验质量 (QoE)  的关系</td></tr><tr><td>[10]</td><td>边缘计算中的网络切片资源管理</td></tr><tr><td>[11]</td><td>物联网中的网络切片资源管理</td></tr><tr><td>[12]</td><td>遗传算法应用于一般场景下的网络切片资源管理，但未反映SLA要求与所需资源量的关系</td></tr><tr><td>[13]~[15]</td><td>强化学习相关论文</td></tr><tr><td>[16]</td><td>强化学习求解功率控制中的资源分配问题</td></tr><tr><td>[17]</td><td>强化学习求解绿色通信中的资源分配问题</td></tr><tr><td>[18]</td><td>强化学习求解云无线接入网络中的资源分配问题</td></tr><tr><td>[19]~[21]</td><td>强化学习求解移动边缘计算和缓存中的资源分配问题</td></tr></tbody></table><p>&nbsp;</p><h2 id="网络切片资源管理"><a href="#网络切片资源管理" class="headerlink" title="网络切片资源管理"></a>网络切片资源管理</h2><h3 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h3><p>&emsp;&emsp;在无线通信的发展过程中，资源管理是一个永恒的话题。网络切片的资源管理可以从以下几个不同的角度来考虑：</p><ol><li><p><strong>无线资源和虚拟化网络功能</strong></p><p> &emsp;&emsp;如图所示，网络切片的资源管理涉及<strong>无线接入部分</strong>和<strong>核心网络部分</strong>，优化目标略有不同。</p><p> &emsp;&emsp;由于频谱资源有限，无线接入的资源管理关注如何为切片分配资源块（RB）以保持可接受的频谱效率(SE)，同时兼顾通信速率和低延迟。</p><p> &emsp;&emsp;核心网络中广泛采用的光传输将核心网络的优化方向转移到设计通用或专用的虚拟网络功能（VNF），以便以最小的调度延迟适当地转发来自特定切片的数据包。</p><p> &emsp;&emsp;通过平衡资源利用率（如 SE）和 QoE 满意度的权重，资源管理目标可以表示为 <code>R =ζ·SE+β·QoE</code>，其中 <code>ζ</code> 和 <code>β</code> 表示 SE 和 QoE 的权重</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118211133.png" alt="image-20220118211133807" style="zoom:50%;" /> <center>图2</center></li><li><p><strong>平等或优先调度</strong></p><p> &emsp;&emsp;作为控制平面的一部分，IETF [23] 已经为所有或多个切片定义了公共控制网络功能（CCNF）。 CCNF包括接入和移动管理功能（AMF）以及网络切片选择功能（NSSF），负责选择核心网络切片实例。因此，除了同等对待来自不同切片的流外，CCNF 还可能区分流。例如，来自超可靠低延迟通信 (URLLC) 服务的流可以以更高的优先级进行调度和配置，以便体验尽可能少的延迟。在这种情况下，为了平衡流的资源利用率（RU）和等待时间（WT），调度目标可以类似地写为RU和WT的加权和</p></li></ol><p>&emsp;&emsp;基于上述讨论可以得出结论：网络切片的资源管理目标应该考虑：频谱利用率(SE)、QoE 满意度、等待时间(WT)等因素，它们的加权总和作为强化学习Agent的Reward。</p><p>&nbsp;</p><h3 id="接入网：无线资源分配"><a href="#接入网：无线资源分配" class="headerlink" title="接入网：无线资源分配"></a>接入网：无线资源分配</h3><h4 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h4><p>&emsp;&emsp;在这一部分中，我们将讨论如何将 DRL 应用于无线电资源切片。在数学上，给定现有切片列表 <code>1,···,N</code> 共享聚合带宽 <code>W</code> 并具有波动需求 <code>d = (d1,···,dN )</code>，目标是给出带宽共享解决方案 <code>w = (w1,· ·· ,wN )</code>，从而使长期回报期望 <code>E&#123;R(w,d)&#125;</code> 最大化，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225751.png" alt="image-20220118225751473" style="zoom:67%;" /><p>&emsp;&emsp;求解这个优化问题的难点在于由于流量模型的波动性需求变化没有先验知识。因此，Model-Free的DQN模型正适用于此问题的求解。</p><h4 id="通信场景"><a href="#通信场景" class="headerlink" title="通信场景"></a>通信场景</h4><p>&emsp;&emsp;下文通过模拟一个场景来评估采用 DQN 解决此问题的性能，该场景包含一个具有三种业务（ VoIP、视频、URLLC）的单基站(BS)。在基站周围40米半径范围内随机分布有100个注册用户。这些订阅用户生成下表中的服务模型。VoIP 和视频服务完全采用 VoLTE 和视频流模型的参数设置，而 URLLC 服务采用 FTP 2 模型 [24] 的参数设置。从表(b)可以看出，URLLC 的数据包频率较低，而 VoLTE 对其数据包的带宽要求最小。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225918.png" alt="image-20220118225918334" style="zoom: 67%;" /><center>表(b)</center><h4 id="DQN建模"><a href="#DQN建模" class="headerlink" title="DQN建模"></a>DQN建模</h4><p>&emsp;&emsp;DQN相关参数如下表所示，Reward是系统 SE 和 切片 QoE。具体而言，DQN 代理每秒更新其 Q 值神经网络，并调整每个切片的带宽分配比例。每秒内以 0.5 ms 的粒度在每个切片内执行循环调度（Round-Robin）方法来分配频域资源，即每隔 0.5 ms 将每个 slice 的带宽顺序分配给每个 slice 内的活跃用户（Active UE）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225906.png" alt="image-20220118225906764" style="zoom:67%;" /><center>表(a)</center><h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>&emsp;&emsp;除了用 DQN 动态调整每秒的切片资源分配方案外，文章还列举了另外三种资源分配算法：</p><h5 id="基于需求预测的方法"><a href="#基于需求预测的方法" class="headerlink" title="基于需求预测的方法"></a>基于需求预测的方法</h5><p>先用<strong>长短期记忆（LSTM）</strong>来预测需求，即：VoIP、视频、URLLC 业务的活跃用户数量。根据预测结果，有两种方式来各切片分配带宽： </p><ul><li><p><strong>DP-No</strong> </p><p>  &emsp;&emsp;总带宽按各业务预测数据包数量比例分配。假设总带宽为 B，VoIP、视频、URLLC 的预测数据包数为 NVoIP、NVideo 和 NURLLC，则分配给这三个切片（即 VoIP、视频和 URLLC）的带宽分别为： </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118230416.png" alt="image-20220118230416930" style="zoom: 50%;" /></li><li><p><strong>DP-BW</strong> </p><p>  &emsp;&emsp;总带宽按（各业务预测数据包数量×该业务最低要求速率）的比例分配。假设三个切片所需的速率为 RVoIP、RVideo 和 RURLLC，则分配给 VoIP、视频和 URLLC 的带宽分别为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118230644.png" alt="image-20220118230644957" style="zoom:0%;" /></li></ul><p>然后各切片内部再使用Round-Robin方式为活跃用户分配带宽资源。</p><h5 id="硬切片法"><a href="#硬切片法" class="headerlink" title="硬切片法"></a>硬切片法</h5><p>总带宽平均分给三个业务的切片，然后各切片内部使用Round-Robin方式为活跃用户分配带宽资源。</p><h4 id="算法效果"><a href="#算法效果" class="headerlink" title="算法效果"></a>算法效果</h4><h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5><ul><li><p>系统频谱效率 SE </p><p>  每单位带宽每秒传输的比特数，其中从 基站(BS) 到用户的速率由香农容量公式得出。</p><p>  如果部分带宽已经分配给一个分片，但该分片在一个时隙没有业务活动，那么这部分带宽就被浪费了，从而降低了系统SE</p></li><li><p>QoE 满意率</p><p>  完全传输的满足速率和延迟要求的数据包数除以到达数据包的总数</p></li></ul><h5 id="DQN算法效果"><a href="#DQN算法效果" class="headerlink" title="DQN算法效果"></a>DQN算法效果</h5><p>&emsp;&emsp;下图展示了 DQN（γ = 0.9时）在无线资源管理中的学习过程。图 (a)∼(f) 给出了当 QoE 权重为 5000 且 SE 权重为 0.1 时 DQN 的初始性能。图 (g)∼(l) 提供了 50000 次学习更新中最后 50 次的性能。从这些子图中可以看出，DQN 一开始并不能很好地了解用户活动，分配的带宽波动很大。但是经过近 50000 次更新后，DQN 已经更加了解用户活动规律，并产生了一个状态带宽分配策略。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119143034.png" alt="image-20220119143034248"></p><center>图3.1</center><p>&emsp;&emsp;图 (m) 和图 (n) 显示了 SE 和 QoE 随每个学习时期的变化。从这两个子图中看出，较大的 QoE 权重会产生具有出色 QoE 性能的策略，同时会在系统 SE 性能上带来一定的损失。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119143057.png" alt="image-20220119143057419"></p><center>图3.2</center><h5 id="与其他算法对比"><a href="#与其他算法对比" class="headerlink" title="与其他算法对比"></a>与其他算法对比</h5><p>&emsp;&emsp;下面展示DQN与DP-No、DP-BW、硬切片和无切片4种的详细性能比较，其中 DQN 的Reward中QoE权重分次设为1、50、5000，且 DQN 的结果取 50000 次学习更新后的。</p><p>&emsp;&emsp;图 4(a)∼4(f) 使用饼图给出了分配给每个切片的总带宽的百分比，并在旁边标注了了 QoE 满意度。从图 4(a)∼4(b) 可以看出，传输天线从 64 个减少到 16 个（网络能力的下降和跨切片的潜在冲突的增加）时，网络带宽的重新分配倾向于消耗带宽但活动受限的 URLLC 切片。此外，从图 4(f) 可以看出，当下行传输使用 64 根天线时，“无切片”表现最好，因为传输能力足够，调度周期为 0.5 ms，而带宽分配给每个切片的速度每秒调整一次，因此捕捉需求变化的速度较慢。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144047.png" alt="image-20220119144047352"></p><center>图4.1    (a)DQN    (b)DQN    (c)DQN</center><p>&emsp;&emsp;当下行天线数量达到 32 根时，DQN 驱动方案对 URLLC 的 QoE 满意率为 81%，而“无切片”和“硬切片”方案分别仅提供 15% 和 41% 的 URLLC 满意率数据包。显然，应用 DQN 主要带来 URLLC 的 QoE 增益。原因在于，如表 (b) 所示，URLLC 的数据包大小的分布遵循截断的对数正态分布，平均值为 2 MByte，远大于 VoLTE 和视频服务。考虑到更大的传输量和严格的低延迟要求，要满足 URLLC 的 QoE 难度要大得多。在这种情况下，DQN 优于其他竞争方案，以略微降低频谱效率 (SE) 的代价提供 URLLC 的更高 QoE 增益。同时，图 4(d) 和图 4(e) 展示了基于需求预测的方案的分配结果，并显示出其明显较差的性能，因为图 3(a)∼3(c) 和图 3(g) )∼3(i) 表明视频数据包的数量在传输中占主导地位，简单的基于数据包数的预测无法捕捉需求和 QoE 之间的复杂关系。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144109.png" alt="image-20220119144109034"></p><center>图4.2    (d)DP-BW    (e)DP-No    (f)No Sliicing</center><p>&emsp;&emsp;图 4(g) 说明 DQN 的这种 QoE 优势是以降低 SE 为代价的。回顾 DQN 中奖励的定义，如果我们将 QoE 权重从 5000 降低到 1，DQN 可以学习另一种带宽分配策略（图 4(c)），从而产生更大的 SE 但更低的 QoE。图 4(g) ∼ 4(j) 进一步总结了 SE 或 QoE 满意度方面的性能比较，其中垂直误差条显示标准推导。这些子图验证了 DQN 在资源有限的场景中的灵活性和优势，以确保每个用户的 QoE。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144124.png" alt="image-20220119144124792"></p><center>图4.3    (g)System SE    (h)VolTE QoE    (i)Video QoE    (j)URLLC QoE</center><p>&nbsp;</p><h3 id="核心网：基于优先级的公共VNFS调度"><a href="#核心网：基于优先级的公共VNFS调度" class="headerlink" title="核心网：基于优先级的公共VNFS调度"></a>核心网：基于优先级的公共VNFS调度</h3><p>&emsp;&emsp;上节讨论了如何在接入网部分应用 DRL 到无线电资源切片中。类似地，如果将计算资源虚拟化为每个切片的 VNF，则可以解决核心网部分为每个 VNF 分配计算资源的问题。这一部分讨论针对普通 VNF 的基于优先级的核心网络切片。</p><h4 id="通信场景-1"><a href="#通信场景-1" class="headerlink" title="通信场景"></a>通信场景</h4><p>&emsp;&emsp;文章模拟了一个场景，其中存在 3 个服务功能链 (SFC)，它们具有相同的基本能力，但以不同的计算处理单元 (CPU) 为代价工作，并产生不同的配置结果（例如，等待时间）。基于商业价值或相关的 SLA，可以将流分为 3 类（例如，A 类、B 类和 C 类），优先级从 A 类到 C 类递减，并且基于优先级的调度规则定义：</p><ul><li>SFC I：将 A 类流量优先于其他流量</li><li>SFC II：同等对待 A 类和 B 类用户，但服务于 C 类流量的优先级较低</li><li>SFC III：平等对待所有流程</li></ul><p>SFC 的流程根据到达时间具有相同的优先级。每个 SFC 最终使用的 CPU 取决于其处理流的数量。此外，SFC I、II 和 III 需要 2、1.5 和 1 个 CPU，但无论流量大小如何，都会分别产生 10、15 和 20 毫秒时延。因此，受限于 CPU 数量的限制，每种类型的流将被调度到适当的 SFC，从而产生可接受的等待时间。因此，流的调度应该匹配和学习三类流的到达顾规律，DQN正派上用场。</p><h4 id="DQN建模-1"><a href="#DQN建模-1" class="headerlink" title="DQN建模"></a>DQN建模</h4><p>&emsp;&emsp;首先是DQN模型输入、输出和参数的具体设置。文章将 DQN 的State抽象为最近 5 个流的类别和到达时间以及新到达流的类别的汇总，而Reward定义为该流的处理和排队时间的加权总和，其中在这个总和中采用较大的权重来反映具有较高优先级的流的重要性。此外，文章还事先通过模拟来自三个类别用户的对数正态分布到达间隔时间的一些流来预训练其 NN。</p><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p>&emsp;&emsp;下面将 DQN 方案与直观的“无优先级”解决方案（将流量分配给 SFC，从而产生最短的等待时间）进行比较。图 5 通过随机生成 10000 个流并相应地提供相关性能，其中纵轴和横轴分别表示使用的 CPU 数量和流的等待时间。二维底纹颜色反映了具体等待时间和 CPU 利用率对应的流数。颜色越深意味着数值越大。 与“无优先级”解决方案相比，基于 DQN 的切片结果提供流程具有更短的平均等待时间（即比“无优先级”低 10.5%）和更充足的 CPU 使用率。也就是说，DQN 可以支持替代解决方案，通过首先为具有更高商业价值的用户服务来利用计算资源并减少等待时间。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118231408.png" alt="image-20220118231408140"></p><center>图5</center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;从本文的讨论中发现，将分配的资源与用户的活动需求相匹配将是有效实现网络切片的最关键挑战，而 DRL 可能是一个很有前途的解决方案。文章解释了 DQN 解决此问题的工作机制和应用动机，通过广泛的模拟进一步证明了 DQN 在两种典型切片场景中管理这种需求感知资源分配的优势，包括无线电资源切片和基于优先级的核心网络切片。结果表明，与基于需求预测和其他一些直观的解决方案相比，DQN 可以在资源受限的场景中隐含地包含需求（即用户活动）和供应（即资源分配）之间更深层次的关系，并提高网络切片的有效性和敏捷性。</p><p>&emsp;&emsp;然而，网络切片涉及许多方面，DQN 的应用需要仔细考虑：</p><ul><li><p>对新切片的接纳控制</p><p>  &emsp;&emsp;网络切片的成功意味着动态和敏捷的切片管理方案。因此，如果出现对新切片的请求，如何应用 DQN 及时调整策略也是一个有问题，因为定义的状态和动作空间需要适应切片空间的变化。</p></li><li><p>State和Reward的抽象</p><p>  &emsp;&emsp;第三部分提供了两个问题下的抽象状态和动作的方法。这两种方法在相关场景中听起来都很实用，并体现了 DQN 的灵活性。</p></li><li><p>获取奖励的延迟和准确性</p><p>  &emsp;&emsp;第三部分中，状态-动作的奖励是假设即时和准确的。但是这种假设在实际复杂的无线环境中不再成立，因为用户设备报告信息需要时间，网络可能无法成功接收反馈。</p></li><li><p>策略学习成本</p><p>  &emsp;&emsp;无线信道和用户活动的时变特性需要快速的策略学习方案。然而，目前的策略训练速度较慢。例如，文章作者在英特尔酷睿 i7-4712MQ 处理器中对基于优先级的网络切片策略的预训练需要两天时间才能收敛 Q 值函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2022/01/17/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/17/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;作为Unix操作系统的重要概念，进程和线程相关知识在程序设计中关键且重要。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117234703.png" alt="image-20220117233440701" style="zoom: 27%;" /><span id="more"></span><p>&nbsp;</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;进程是资源（CPU时间、内存等）分配的基本单位，程序运行时系统就会创建一个进程并为它分配资源，然后该进程进入就绪队列，进程调度器选中就绪的进程并为它分配CPU时间使该进程的程序开始运行。在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>&emsp;&emsp;Linux进程结构可由三部分组成：代码段、数据段、堆栈段，也就是程序、数据、进程控制块PCB（Process Control Block）组成。进程控制块是进程存在的惟一标识，系统通过PCB的存在而感知进程的存在。<br>&emsp;&emsp;系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行程序、退出进程以及改变进程的优先级等。而进程中的PCB用一个名为 <code>task_struct</code> 的结构体来表示，定义在 <code>include/linux/sched.h</code> 中，每当创建一新进程时，便在内存中申请一个空的 <code>task_struct</code> 结构，填入所需信息，同时，指向该结构的指针也被加入到task数组中，所有进程控制块都存储在task[]数组中。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：进程序只是指令集合，进程是被赋予了时间概念的指令，具有生命周期和不同状态</li><li>并发性：多个进程可以在单个CPU上并发执行，不会互相影响</li><li>独立性：每个进程拥有私有的地址空间，不同进程的信息无法相互直接使用，可以通过进程间通信来传输信息</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推 进</li><li>结构特征：进程由程序、数据和进程控制块三部分组成</li></ul><p>&emsp;&emsp;多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变。</p><h3 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h3><p>程序：完成特定任务的一系列指令集合 </p><blockquote><p>代码段+数据段</p><p>放在磁盘中的程序</p></blockquote><p>进程：进行就是正在进行中的程序</p><blockquote><p>用户角度： 进程是程序的一次动态执行过程</p><p>操作系统： 进程是操作系统分配资源的基本单位，也是最小单位</p></blockquote><p><strong>具体区别</strong></p><ul><li>程序是指令和数据的有序集合，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个 动态的概念</li><li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的</li><li>进程是由进程控制块、程序段、数据段三部分组成</li><li>进程具有创建其他进程的功能，而程序没有</li><li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程</li><li>在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单元都是进程</li></ul><p><strong>CPU执行程序过程</strong></p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117233010.png" alt="image-20220117233010543"></p><h3 id="进程的3种基本状态"><a href="#进程的3种基本状态" class="headerlink" title="进程的3种基本状态"></a>进程的3种基本状态</h3><p>&emsp;&emsp;CPU一次只能处理一个程序，CPU速度很快而内存很慢，所以CPU会有大量的时间都是空闲的。而CPU又是很昂贵的，为了解决浪费CPU的情况，就出现了中断处理，将程序分成一小片一小片的，这个进程执行一点，那个进程执行一点。虽然在内部进程的执行是一段一段的，但是CPU的速度很快的（速度都是纳秒级别的），所以我们是感受不到进程执行过程中的停顿的。</p><p>&emsp;&emsp;既然是一段一段执行，CPU在执行一个进程时，其他的进程就处于等待状态，为什么执行当前的这个进程而不是其他进程呢？这就要分情况讨论了，有可能是因为轮到它们的时间片用完了，也可能是它在等待某种资源等，所以在内存中每个进程的状态可能是不同的，进程的3种基本状态为：</p><table><thead><tr><th>状态</th><th align="left">说明</th></tr></thead><tbody><tr><td>就绪状态</td><td align="left">进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列</td></tr><tr><td>运行状态</td><td align="left">进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以 执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程</td></tr><tr><td>阻塞状态</td><td align="left">由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生 前即使把处理机分配给该进程，也无法运行</td></tr></tbody></table><p>再细分的话，可以分为7种状态：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117233202.png" alt="image-20220117233202038" style="zoom: 45%;" /><h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p>使用 <code>ps</code> 命令查看当前终端的进程：</p><blockquote><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117195333.png" alt="image-20220117195333110" style="zoom:50%;" /></blockquote><p>使用 <code>ps -ef</code> 命令查看系统全部进程：</p><blockquote><p>UID：启动进程的操作系统用户</p><p>PID：进程编号（用来kill）</p><p>PPID：进程的父进程编号</p><p>C：CPU使用的资源百分比</p><p>STIME：进程启动时间</p><p>TTY：进程所属的终端</p><p>TIME：使用掉的CPU时间</p><p>CMD：进程所执行的指令</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117195450.png" alt="image-20220117195450631" style="zoom:50%;" /></blockquote><p>如果进程太多，可以使用 <code>ps -ef | more</code> 命令使结果分页显示。</p><p>使用 <code>top</code> 查看进程</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118112901.png" alt="image-20220118112901440" style="zoom:45%;" /></blockquote><p>使用 <code>kill</code> 中止进程：</p><blockquote><p>killall &lt;进程名&gt;</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117215326.png" alt="image-20220117215326524" style="zoom:50%;" /><p>kill &lt;进程编号&gt;</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117215406.png" alt="image-20220117215406374" style="zoom:50%;" /></blockquote><p>获取本程序运行时的进程编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid()</span><br><span class="line">// 返回值即为进程编号</span><br></pre></td></tr></table></figure><p>注意，进程的编号是系统动态分配的，相同程序在不同时间执行时进程编号不同；进程编号会循环使用，但操作系统会保证同一时间进程编号不重复。</p><p>&nbsp;</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>&emsp;&emsp;进程的数据空间是独立、私有的，不能互相访问，但是在某些情况下进程间需要通信来实现某功能或交换数据，包括：</p><ol><li>数据传输：一个进程需要将它的数据发送给另一个进程</li><li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如通知进程退出）</li><li>进程控制：一个进程希望控制另一个进程的运行</li></ol><p>进程通信的方式大致分为六种：</p><table><thead><tr><th>方式</th><th>介绍</th></tr></thead><tbody><tr><td>管道(pipe)</td><td>包括无名管道、命名管道，无名管道可用于具有父进程和子进程之间的通信，命名管道则克服了管道没有名字的限制，故除了具有管道所具有的功能外，还支持无亲缘关系进程间的通信</td></tr><tr><td>消息队列(message)</td><td>进程可以向队列中添加消息，其他进程则可以读取队列中的消息</td></tr><tr><td>信号(signal)</td><td>信号用于通知其他进程有某种事件发生</td></tr><tr><td>共享内存(shared memory)</td><td>多个进程可以访问同一块内存空间</td></tr><tr><td>信号量(semaphore)</td><td>又称为信号灯，用于进程间对共享资源进行加锁</td></tr><tr><td>套接字(socket)</td><td>可用于不同计算机之间的进程间通信</td></tr></tbody></table><p>&emsp;&emsp;Socket可以完全替代只能在同一系统中进程之间通信的管道和消息队列；信号的应用场景非常多，主要用于进程的控制，例如通知正在运行中的后台服务程序退出；同一系统中，进程间采用共享内存交换数据的效率是最高的，为了避免对共享内存访问的冲突，一般会同信号量加锁一起使用。</p><p>&nbsp;</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;软中断信号（signal，又简称为信号）是Linux下用来在进程间传递消息的方式之一，也是进程间唯一的异步通信方式。从命名中可以看出信号的实质很像中断。进程间可以通过调用kill库函数发送软中断信号，Linux内核也可能给进程发送信号，用以告知该进程发生了某个异步事件。</p><p>&emsp;&emsp;注意，信号只用来告知进程发生了某个异步事件，并不用来传递数据。进程收到信号后会有三种处理方式：</p><ul><li>忽略，不做任何处理</li><li>执行预先设置的处理函数（就像中断服务程序一样）</li><li>采用系统的默认操作，大部分是终止进程</li></ul><h4 id="信号的来源"><a href="#信号的来源" class="headerlink" title="信号的来源"></a>信号的来源</h4><ol><li><p>用户</p><p>一般是键盘的输入会作为信号发送给进程，比如：<code>Ctrl + C</code> 发送SIGINT信号给进程，默认动作为终止进程；<code>Ctrl + \</code> 发送SIGQUIT信号给进程，默认动作为终止进程并进行内核映像转储（core dump）</p></li><li><p>内核</p><p>当进程执行出错时，内核给进程发送一个对应信号，例如：非法内存引用、浮点数溢出、执行非法指令</p></li><li><p>进程</p><p>C++的kill库函数用于进程间发送信号</p></li></ol><h4 id="信号的类型"><a href="#信号的类型" class="headerlink" title="信号的类型"></a>信号的类型</h4><table><thead><tr><th>信号名</th><th>信号值</th><th>默认处理动作</th><th>发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>A</td><td>终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td><strong>2</strong></td><td><strong>A</strong></td><td><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td>3</td><td>C</td><td>键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td>4</td><td>C</td><td>非法指令</td></tr><tr><td>SIGABRT</td><td>6</td><td>C</td><td>由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td>8</td><td>C</td><td>浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td><strong>9</strong></td><td><strong>AEF</strong></td><td><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td></tr><tr><td><strong>SIGSEGV</strong></td><td><strong>11</strong></td><td><strong>C</strong></td><td><strong>无效的内存引用</strong></td></tr><tr><td>SIGPIPE</td><td>13</td><td>A</td><td>管道破裂:写一个没有读端口的管道</td></tr><tr><td>SIGALRM</td><td>14</td><td>A</td><td>由alarm(2)发出的信号</td></tr><tr><td><strong>SIGTERM</strong></td><td><strong>15</strong></td><td><strong>A</strong></td><td><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>A</td><td>用户自定义信号1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>A</td><td>用户自定义信号2</td></tr><tr><td><strong>SIGCHLD</strong></td><td><strong>20,17,18</strong></td><td><strong>B</strong></td><td><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td></td><td>进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>DEF</td><td>终止进程</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>D</td><td>控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>D</td><td>后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>D</td><td>后台进程企图从控制终端写</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><ul><li>A：缺省的动作是终止进程</li><li>B：缺省的动作是忽略此信号，将该信号丢弃，不做处理</li><li>C：缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是可以得到进程当时执行时的数据值，方便确定转储的原因，并且调试程序</li><li>D：缺省的动作是停止进程，进入停止状况以后还能重新进行下去</li><li>E：信号不能被捕获</li><li>F：信号不能被忽略</li></ul><h4 id="信号的捕获处理"><a href="#信号的捕获处理" class="headerlink" title="信号的捕获处理"></a>信号的捕获处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">// signum: 表示信号的编号  </span></span></span><br><span class="line"><span class="function"><span class="comment">// handler: 表示信号的处理方式，有三种：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    1. SIG_IGN：忽略改信号，不作为</span></span></span><br><span class="line"><span class="function"><span class="comment">//    2. SIG_DFL：恢复该信号的默认处理方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//    3. 自定义处理函数，注意函数参数为 (int signum)</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"><span class="comment">// pid: 目标进程号，有三种情况：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    1. pid&gt;0 将信号sig传给号为pid的进程</span></span></span><br><span class="line"><span class="function"><span class="comment">//    2. pid=0 将信号sig传给同进程组的所有进程（包括自己），常用于父进程给子进程发送信号</span></span></span><br><span class="line"><span class="function"><span class="comment">//    3. pid=-1 将信号广播到系统内所有进程，例如系统关机时向所有登录窗口广播关机信息</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// sig: 被发送的信号编号</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的应用"><a href="#信号的应用" class="headerlink" title="信号的应用"></a>信号的应用</h4><p>&emsp;&emsp;程序运行在后台，如果想让中止它，直接 Ctrl C 或者 kill 掉并不是好办法，因为程序被杀的时候，程序突然死亡没有释放资源，会影响系统的稳定。如果能捕获Ctrl C 或者 kill向后台程序发送的信号，并且修改其对应的处理函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。除此之外，信号还可以用于网络服务程序抓包等。</p><h5 id="屏蔽信号"><a href="#屏蔽信号" class="headerlink" title="屏蔽信号"></a>屏蔽信号</h5><p>&emsp;&emsp;通常为了程序不被干扰，程序开头通常会屏蔽所有信号，然后再用signal函数对关心的信号设置相应的处理方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) <span class="built_in">signal</span>(i, SIG_IGN);</span><br></pre></td></tr></table></figure><h5 id="搞点好玩的"><a href="#搞点好玩的" class="headerlink" title="搞点好玩的"></a>搞点好玩的</h5><p>&emsp;&emsp;改变信号 <code>SIGINT</code> 和 <code>SIGTERM</code>的捕获处理，设计一个 <code>ctrl+C</code> 和 <code>kill</code> 都杀不掉的进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b杀不死，哈哈哈哈。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGTERM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;还是杀不死，哈哈哈哈。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">100</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, func); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>使用<code>Ctrl+C</code> 尝试关掉进程：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215258482.png" alt="image-20211023215258482" style="zoom: 67%;" /><p>用 <code>ps -ef | grep signal</code> 找到其进程号，尝试用 kill 直接干掉：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215522014.png" alt="image-20211023215522014" style="zoom: 50%;" /><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215427407.png" alt="image-20211023215427407" style="zoom:67%;" /><p>可以看见，<code>kill + 进程号</code> 或 <code>killall + 进程名</code> 对它都无效，那改怎么杀死这个进程呢？如图，用 <code>kill -9 进程号</code>：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215647601.png" alt="image-20211023215647601" style="zoom:50%;" /><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215658471.png" alt="image-20211023215658471" style="zoom: 67%;" /><p>因为<code>kill -9 进程号</code> 发送的信号是 <strong>SIGKILL</strong>，这个信号无法被捕获或忽略，能够快准狠杀掉进程</p><h5 id="使系统休眠"><a href="#使系统休眠" class="headerlink" title="使系统休眠"></a>使系统休眠</h5><p>&emsp;&emsp;这个是我尝试用 kill() 函数向系统所有进程发送 SIGKILL 信号后发现的，当然是在虚拟机上，我可不敢在主机上这样搞：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">kill</span>(<span class="number">-1</span>, SIGKILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是虚拟机进入休眠，输入密码后能再进入，原以为会直接关机呢……</p><p>&nbsp;</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>&emsp;&emsp;共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>&emsp;&emsp;共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号灯。</p><p>使用 <code>ipcs -m</code> 查看系统的共享内存：</p><blockquote><p>key：键值</p><p>shmid：共享内存编号</p><p>owner：创建者</p><p>perms：权限</p><p>bytes：大小</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224820.png" alt="image-20220117224820387" style="zoom:60%;" /></blockquote><p>使用 <code>ipcrm -m &lt;&gt;</code> 查看系统的共享内存：</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224912.png" alt="image-20220117224912685" style="zoom:60%;" /></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="C-封装函数"><a href="#C-封装函数" class="headerlink" title="C++封装函数"></a>C++封装函数</h5><p>Linux在c++头文件中提供了封装的函数用于操作共享内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取或创建"><a href="#获取或创建" class="headerlink" title="获取或创建"></a>获取或创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// key：共享内存的键值，是共享内存在系统中的编号，由程序员保证不同共享内存的编号不重复，通常用十六进制表示</span></span><br><span class="line"><span class="comment">// size：待创建的共享内存的大小，以字节为单位</span></span><br><span class="line"><span class="comment">// shmflg：共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存</span></span><br></pre></td></tr></table></figure><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// 把共享内存连接到当前进程的地址空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shm_id：由shmget函数返回的共享内存标识</span></span><br><span class="line"><span class="comment">// shm_addr：定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line"><span class="comment">// shm_flg：一组标志位，通常为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1</span></span><br></pre></td></tr></table></figure><h5 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="comment">// 该将共享内存从当前进程中分离，相当于shmat函数的反操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shmaddr：shmat函数返回的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure><h5 id="控制与删除"><a href="#控制与删除" class="headerlink" title="控制与删除"></a>控制与删除</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">// shm_id：shmget函数返回的共享内存标识符</span></span><br><span class="line"><span class="comment">// command：填IPC_RMID</span></span><br><span class="line"><span class="comment">// buf：填0</span></span><br><span class="line"><span class="comment">// shmctl()其实是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用。注意，用root创建的共享内存，不管创建的权限是什么，普通用户都无法删除</span></span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input the mode [1——Send / 2——Receive]: &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mode != <span class="number">1</span> &amp;&amp; mode != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Wrong mode!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input the shared memory key[hexadecimal]: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = <span class="built_in">shmget</span>((<span class="keyword">key_t</span>)key, <span class="number">1024</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">    <span class="keyword">char</span> *ptext = (<span class="keyword">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 写入内容</span></span><br><span class="line">        string text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (text != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;you&gt; &quot;</span>);</span><br><span class="line">            <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;%s&quot;</span>, text.<span class="built_in">c_str</span>());</span><br><span class="line">            cin &gt;&gt; text;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//读取内容</span></span><br><span class="line">        string text = ptext;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;player: %s\n&quot;</span>, text.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">while</span> (text != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text == ptext)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;player: %s\n&quot;</span>, ptext);</span><br><span class="line">            text = ptext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;shmctl(%d) failed\n&quot;</span>, key);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>写入端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224620.png" alt="image-20220117224620056" style="zoom:60%;" /></li><li><p>读取端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224639.png" alt="image-20220117224639270" style="zoom:60%;" /></li></ul><p>&nbsp;</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>&emsp;&emsp;信号量又称为信号灯，本质是一个计数器，用于协调多个进程或线程对共享数据对象的读写，防止冲突发生。它与信号（signal）一样不以传输数据为目的，而是向进程传到某个事件的发生。进程根据收到的信号量来判断是否对共享数据进行读写。从而保护共享资源（共享内存、消息队列、socket连接池等），保证同一时间只有一个进程占用。</p><p>&emsp;&emsp;信号量只允许进程除了创建和销毁外，对它做<strong>等待信号</strong>和<strong>发送信号</strong>两种操作。二进制信号量取值只有0、1，是最为常见的类型；通用信号量取值可以为多个整数值。</p><p>使用 <code>ipcs -s</code> 查看系统的信号量：</p><blockquote><p>key：键值</p><p>semid：信号量编号</p><p>owner：创建者</p><p>perms：权限</p><p>nsems：信号量数</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117221648.png" alt="image-20220117221648853" style="zoom: 60%;" /></blockquote><p>使用 <code>ipcrm sem &lt;semid&gt;</code>手动删除信号量</p><blockquote><p> 例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117221918.png" alt="image-20220117221918899" style="zoom:60%;" /></blockquote><h4 id="共享资源调度"><a href="#共享资源调度" class="headerlink" title="共享资源调度"></a>共享资源调度</h4><p>&emsp;&emsp;<strong>临界区</strong>是指一个访问公共资源的程序代码段，而这些公共资源无法同时被多个进程或线程访问。</p><p>程序进入临界区的调度原则：</p><ul><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入临界区，则应让出CPU，避免进程出现”忙等”现象。</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="C-封装函数-1"><a href="#C-封装函数-1" class="headerlink" title="C++封装函数"></a>C++封装函数</h5><p>Linux在c++头文件中提供了封装的函数用于操作信号量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux信号量函数都是针对成组的通用信号量进行操作，而不是只能针对一个二进制信号量。在一个进程要锁定多个资源的复杂情况下，这种方法比较快捷。</p><h5 id="获取或创建-1"><a href="#获取或创建-1" class="headerlink" title="获取或创建"></a>获取或创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// key：信号量的键值，是信号量在系统中的编号，需要保证唯一性，通常为16进制</span></span></span><br><span class="line"><span class="function"><span class="comment">// nsems：创建信号量集中信号量的个数，二进制信号量时设为1</span></span></span><br><span class="line"><span class="function"><span class="comment">// semflg：标志值，若要在信号量不存在时创建该信号量，则与 IPC_CREAT 按位取或作为参数；否则若信号量不存在就返回错误，errno=2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回值为semid，即信号量集的标识符，供程序后续访问此信号量；失败返回-1</span></span></span><br></pre></td></tr></table></figure><h5 id="初始化与删除"><a href="#初始化与删除" class="headerlink" title="初始化与删除"></a>初始化与删除</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span></span><br><span class="line"><span class="function"><span class="comment">// semctl()函数用于控制信号量，可设置其初始值或销毁信号量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// semid：信号量的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// sem_num：信号量集数组的下标</span></span></span><br><span class="line"><span class="function"><span class="comment">// command：是对信号量操作的命令种类：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    IPC_RMID：销毁信号量，不需要第四个参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//    SETVAL：初始化信号量的值，初始值由第四个参数决定</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第四个参数是个联合体：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    union semun</span></span></span><br><span class="line"><span class="function"><span class="comment">//  &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">//    int val; // 初始值</span></span></span><br><span class="line"><span class="function"><span class="comment">//      struct semid_ds *buf;</span></span></span><br><span class="line"><span class="function"><span class="comment">//      unsigned short *arry;</span></span></span><br><span class="line"><span class="function"><span class="comment">//  &#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br><span class="line"><span class="comment">// semid：信号量的标识符</span></span><br><span class="line"><span class="comment">// nsops：操作信号量的个数，即sops的个数</span></span><br><span class="line"><span class="comment">// sops：一个结构体</span></span><br><span class="line"><span class="comment">// struct sembuf</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//       short sem_num; // 信号量集的个数</span></span><br><span class="line"><span class="comment">//       short sem_op; // 信号量的操作：-1——等待，1——发送（释放）</span></span><br><span class="line"><span class="comment">//       short sem_flg; // 设置为SEM_UNDO，表示操作系统将跟踪这个信号量</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure><h5 id="示例：二进制信号灯控制共享内存操作"><a href="#示例：二进制信号灯控制共享内存操作" class="headerlink" title="示例：二进制信号灯控制共享内存操作"></a>示例：二进制信号灯控制共享内存操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> // 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sem_id;           <span class="comment">// 信号灯描述符。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;          <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;          <span class="comment">// 挂出信号灯。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">destroy</span><span class="params">()</span></span>;       <span class="comment">// 销毁信号灯。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line">    CSEM sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始信号灯。</span></span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = <span class="built_in">shmget</span>((<span class="keyword">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">    <span class="keyword">char</span> *ptext = (<span class="keyword">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d等待其他进程释放%d号共享内存的操作权\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">wait</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d获得%d号共享内存\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作本程序的ptext指针，就是操作共享内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d操作%d号共享内存中…………\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line">    <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;本程序的进程号---%d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">post</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d释放%d号共享内存的操作权\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="comment">// if (shmctl(shmid, IPC_RMID, 0) == -1)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;shmctl(0x5005) failed\n&quot;);</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取信号灯。</span></span><br><span class="line">    <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, <span class="number">0640</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;init 1 semget()&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">            sem_union.val = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_union) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;init semctl()&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;init 2 semget()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;destroy semctl()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;wait semop()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;post semop()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>依次开3个进程访问同一个共享内存，可以看见后来的进程等待前面进程释放锁后才能访问：</p><ul><li><p>进程1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222609.png" alt="image-20220117222609226" style="zoom: 60%;" /></li><li><p>进程2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222630.png" alt="image-20220117222630209" style="zoom:60%;" /></li><li><p>进程3</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222642.png" alt="image-20220117222642482" style="zoom:60%;" /></li></ul><p>&nbsp;</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h4 id="网络通信-Socket"><a href="#网络通信-Socket" class="headerlink" title="网络通信 Socket"></a>网络通信 Socket</h4><p>&emsp;&emsp;实现网络应用时要先从网络提供的接口开始，几乎所有计算机系统都将网络协议的软件实现作为操作系统的一部分，因此网络应用程序编程接口（API）一般都是操作系统提供的。套接字接口Socket是大部分操作系统都支持的一种流行接口，为计算机本地应用提供接入网络的功能。</p><p>&emsp;&emsp;Socket(套接字)可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的API，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 Socket中，该 Socket通过与网卡(NIC)相连的传输介质将这段信息送到另外一台主机的 Socket中，使对方能够接收到这段信息。 Socket是由IP地址和端口结合的，提供向应用层进程传送数据包的机制。socket把复杂的TCP/IP协议封装了起来，只要用好socket相关的函数即可完成网络通信。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826191343.png" alt="image-20210826190452059" width="30%" /><p><strong>Socket 类型</strong></p><p>&emsp;&emsp;socket主要提供了流（stream）和数据报（datagram）两种通信机制，即流socket和数据报socket。</p><p>&emsp;&emsp;流socket基于TCP协议，是一个有序、可靠、双向字节流的通道，传输数据不会丢失、不会重复、顺序也不会错乱。</p><p>&emsp;&emsp;数据报socket基于UDP协议，不需要建立和维持连接，可能会丢失或错乱。UDP不是一个可靠的协议，对数据的长度有限制，但是它的速度比较高。</p><h4 id="流Socket-工作流程"><a href="#流Socket-工作流程" class="headerlink" title="流Socket 工作流程"></a>流Socket 工作流程</h4><p>&emsp;&emsp;Socket在工作中分为客户端（Client）和服务端（Server）两部分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826191344.png" alt="image-20210826190900700" width="60%" /><p>&nbsp;</p><p><strong>服务端工作流程</strong></p><ol><li><p>创建socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"><span class="comment">// domain：将要使用的协议族，例如：AF_INET表示因特网协议族</span></span></span><br><span class="line"><span class="function"><span class="comment">// type：通信的语义，例如：SOCK_STREAM表示字节流、SOCK_DGRAM表示面向消息</span></span></span><br><span class="line"><span class="function"><span class="comment">// protocol：将要用到的特定协议，下面统一用0</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回值是该套接字的句柄（handle），即引用该套接字时使用的标识符</span></span></span><br></pre></td></tr></table></figure></li><li><p>把IP地址和端口绑定到socket上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含本地服务器IP地址和TCP端口号的结构体</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 绑定成功返回0</span></span></span><br></pre></td></tr></table></figure></li><li><p>设置socket为监听模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socket, backlog)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// backlog：该套接字允许连接的数量</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置成功返回0</span></span></span><br></pre></td></tr></table></figure></li><li><p>接受客户端的连接请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> *addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含服务器IP地址和TCP端口号的结构体，建立连接后会被写入客户端的对应信息</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 此函数是个阻塞操作，当建立连接时才返回，返回值是远程客户端的socket标识符</span></span></span><br></pre></td></tr></table></figure></li><li><p>与客户端重复通信，直到客户端断开连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">char</span> *message, <span class="keyword">int</span> msg_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 把message信息发送给对应socket的远程端，message长度为msg_len，flags统一为0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> buf_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从对应socket的远程端接收最大size为buf_len的信息到buffer，flags统一为0</span></span></span><br></pre></td></tr></table></figure></li><li><p>关闭socket，释放资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> socket)</span></span></span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;</p><p><strong>客户端工作流程</strong></p><ol><li><p>创建socket（方法同上）</p></li><li><p>向服务端发起连接请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含服务端服务器IP地址和TCP端口号的结构体</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 此函数也是个阻塞操作，当建立连接时才返回，返回值是远程服务器的socket描述符</span></span></span><br></pre></td></tr></table></figure></li><li><p>与服务端通信，数据发送完后断开连接（方法同上）</p></li><li><p>关闭socket，释放资源（方法同上）</p></li></ol><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入端口号！\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第1步：创建服务端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> listenfd;</span><br><span class="line">    <span class="keyword">if</span> ((listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2步：把服务端用于通信的地址和端口绑定到socket上。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 使用任意ip地址。</span></span><br><span class="line">    <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.190.134&quot;); // 使用指定ip地址。</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// 指定通信端口。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3步：把socket设置为监听模式。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：接受客户端的连接。</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;                             <span class="comment">// 客户端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> socklen = <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span>            <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">    clientfd = <span class="built_in">accept</span>(listenfd, (struct sockaddr *)&amp;clientaddr, (<span class="keyword">socklen_t</span> *)&amp;socklen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>, <span class="built_in">inet_ntoa</span>(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iret;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">recv</span>(clientfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对方：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">send</span>(clientfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败，通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入ip地址和端口！\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第1步：创建客户端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2步：向服务器发起连接请求。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">h</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span>) <span class="comment">// 指定服务端的ip地址。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 指定服务端的通信端口。</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>) <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> iret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">send</span>(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n发送失败，通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n接收失败，通信结束\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对方：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><ul><li><p>Server<br><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826203958.png" alt="image-20210826203841945"></p></li><li><p>Client</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826203959.png" alt="image-20210826203901839"></p></li></ul><p>&nbsp;</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>&emsp;&emsp;使用 <code>fork()</code> 函数可以产生一个新的进程，<code>fork()</code>的返回值用于区分父子进程，在父进程中其返回值为子进程编号，子进程中其返回值为0。子进程和父进程使用相同的代码段，子进程拷贝父进程的堆栈段和数据段，因此子进程拥有父进程的功能和其诞生时刻父进程的一切变量，但此后彼此之间没有相互影响，数据不互通。</p><h3 id="应用：并发的服务端"><a href="#应用：并发的服务端" class="headerlink" title="应用：并发的服务端"></a>应用：并发的服务端</h3><p>&emsp;&emsp;使用socket可以实现两个进程间的数据通信，两个进程分别充当服务端和客户端。如果想要一个服务端同时与多个客户端进行通信，可以使用多进程服务端（也有其他方法，比如多线程等）实现，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket服务端改为多进程，在每次accept到一个客户端的连接后生成一个子进程，让子进程负责和这个客户端通信，父进程继续accept客户端的连接。由此，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信，从而实现并发。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了服务端多进程实现并发以外，下面程序中还使用了多进程来实现服务端、客户端收发同步进行的功能，如果只是一个进程，那么无论是接收消息还是发送消息等待用户输入，都是阻塞性的，无法进行，因此又一次使用<code>fork()</code>开启一个进程，原进程负责接收消息，新进程负责发送消息等待用户输入。</p><p><strong>服务端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">同时又通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">        <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> subforkid = fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (subforkid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;服务端：&quot;</span>);</span><br><span class="line">                <span class="built_in">fflush</span>(stdin);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (subforkid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\r客户端：%s\n服务端：&quot;</span>, strbuffer);</span><br><span class="line">                <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpClient</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *serverip, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;127.0.0.1&quot;</span>, port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;127.0.0.1\&quot;,%d) failed,exit...\n&quot;</span>, port);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> forkid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (forkid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">        <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (forkid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r服务端：%s\n客户端：&quot;</span>, strbuffer);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与服务端断开连接。\n&quot;</span>);</span><br><span class="line">    TcpClient.~<span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_sockfd = <span class="number">0</span>; <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_sockfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd); <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *serverip, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">h</span>;</span> <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> ((h = <span class="built_in">gethostbyname</span>(serverip)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>服务端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117205918.png" alt="image-20220117205918084" style="zoom:55%;" /></li><li><p>客户端1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117204949.png" alt="image-20220117204949140" style="zoom: 55%;" /></li><li><p>客户端2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117205002.png" alt="image-20220117205002282" style="zoom: 55%;" /></li></ul><p>&emsp;&emsp;但是程序现在有一个问题，就是同一个窗口下开启多个进程时，多个进程都等待用户输入消息然后发送，但是如果两个进程同时申请在终端打印输入请求时，谁先打印并接收，谁后打印接收，这是个冲突，目前操作系统的处理看来是把二者排位一个队列，先后顺序执行，但其实应该由用户自己决定要把消息发给谁，以后再填这个坑。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>&emsp;&emsp;一个子进程在调用 <code>return</code> 或 <code>exit(0)</code> 结束生命时，其实并没有被真正销毁，而是留下一个僵尸进程。比如上面并发服务端在子进程使用 <code>return</code> 结束后，父进程并未回收子进程占用的资源，子进程成为僵尸进程，使用 <code>ps -ef</code> 查看可以看见僵尸进程被标记为 <code>&lt;defunct&gt;</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117211135.png" alt="1" style="zoom:50%;" /><p>&emsp;&emsp;若父进程先结束，子进程会被系统接管，此后子进程结束后系统会自动回收资源，不会形成僵尸进程。</p><p><strong>解决方法</strong></p><p>方法一：</p><p>&emsp;&emsp;子进程退出前会向父进程发送一个信号，父进程调用 <code>wait()</code> 函数等待该信号，等到之后就不会产生僵尸进程，父进程会回收子进程占用的资源。但其实在并发的服务程序中这是不现实的，因为父进程有其他的工作，不可能一直阻塞着等待子进程的结束信号。</p><p>方法二：</p><p>&emsp;&emsp;父进程忽视子进程的退出信号：<code>signal(SIGCHLD,SIG_IGN);</code></p><p>&nbsp;</p><p>&nbsp;</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;线程是一条执行路径，是程序执行时的最小单位，即进程的一个执行流，是CPU调度和分派的基本单位。一个进程可以由多个线程组成，线程间共享进程的所有资源，但也有自己的堆栈和局部变量。线程由CPU独立调度执行，在D多CPU环境下允许多个线程同时进行。</p><ul><li>对于单核CPU而言：多线程就是一个CPU在来回的切换，在交替执行。</li><li>对于多核CPU而言：多线程就是同时有多条执行路径在同时(并行)执行，每个核执行一个线程，多个核就有可能是一块同时执行的。</li></ul><p>使用 <code>top -H</code> 查看线程</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118130206.png" alt="image-20220118113211331" style="zoom:45%;" /></blockquote><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>&emsp;&emsp;一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，又是调度运行的基本单位，亦即执行处理机调度的基本单位。</p><ul><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p></li><li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量，即每个线程都有自己的堆栈和局部变量。</p></li><li><p>处理机分给线程，即真正在处理机上运行的是线程。</p></li><li><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p></li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>创建</td><td>准备好了一个多线程对象</td></tr><tr><td>就绪</td><td>等待CPU调度执行</td></tr><tr><td>运行</td><td>执行程序</td></tr><tr><td>阻塞</td><td>放弃CPU使用权，暂停执行线程，将线程挂起，将资源交给其他线程使用</td></tr></tbody></table><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>&emsp;&emsp;和多进程相比，多线程是一种比较节省资源的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进程间通信的方式进行。在同一个进程中，可以运行多个线程，运行于同一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享全局变量和对象，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。</p><p>&emsp;&emsp;不过Linux没有真正意义上的线程，它的实现是由进程来模拟，属于用户级线程。所以，在Linux系统下，进程与线程在性能和资源消耗方面没有本质的差别。但是进程不能共享全局数据，线程可以共享全局数据。</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><h4 id="C-封装函数-2"><a href="#C-封装函数-2" class="headerlink" title="C++封装函数"></a>C++封装函数</h4><p>Linux在c++头文件中提供了封装的函数用于操作线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意：编译时必须带上 <code>-pthread</code> 以调用静态链接库，因为pthread并不是Linux系统的默认库</p><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// thread: 指向线程标识符的地址。</span></span><br><span class="line"><span class="comment">// attr: 用于设置线程属性，一般为空，表示使用默认属性。</span></span><br><span class="line"><span class="comment">// start_routine: 线程运行函数的地址，填函数名就可以了。</span></span><br><span class="line"><span class="comment">// arg: 线程运行函数的参数。</span></span><br><span class="line"><span class="comment">// 新创建的线程从start_routine函数的地址开始运行，该函数只有一个无类型指针参数arg。若要向start_routine传递多个参数，可以将多个参数放在一个结构体中，然后把结构体的地址作为arg参数传入</span></span><br></pre></td></tr></table></figure><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>&emsp;&emsp;如果进程中的任一线程调用了exit，则整个进程会终止，所以，在线程的start_routine函数中，不能采用exit或return。</p><p>线程的终止有三种方式：</p><p>1）线程的 <code>start_routine()</code> 函数代码结束，自然消亡</p><p>2）线程的 <code>start_routine()</code> 函数调用 <code>pthread_exit()</code> 结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">// retval：填0</span></span><br></pre></td></tr></table></figure><p>3）被主进程或其它线程中止</p><h4 id="线程资源回收"><a href="#线程资源回收" class="headerlink" title="线程资源回收"></a>线程资源回收</h4><p>&emsp;&emsp;线程有<code>joinable</code>和<code>unjoinable</code>两种状态，如果线程是<code>joinable</code>状态，当线程主函数终止时（自己退出或调用<code>pthread_exit()</code>退出）不会释放线程所占用内存资源和其它资源，这种线程被称为“<strong>僵尸线程</strong>”。创建线程时默认是非分离的，或者称为可连接的（<code>joinable</code>）。可以通过将线程设置为<code>detached</code>状态来避免僵尸线程。</p><p><strong>方法一</strong></p><p>&emsp;&emsp;创建线程前，调用<code>pthread_attr_setdetachstate()</code>将线程设为<code>detached</code>，这样线程退出时，系统自动回收线程资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);  <span class="comment">// 设置线程的属性。</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pthid, &amp;attr, pth_main, (<span class="keyword">void</span>*)((<span class="keyword">long</span>)TcpServer.m_clientfd);</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>&emsp;&emsp;创建线程后，在创建线程的程序中调用<code>pthread_detach()</code>将新创建的线程设置为<code>detached</code>状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(pthid);</span><br></pre></td></tr></table></figure><p><strong>方法三</strong></p><p>&emsp;&emsp;在线程主函数中调用<code>pthread_detach()</code>改变自己的状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br></pre></td></tr></table></figure><p><strong>方法四</strong></p><p>&emsp;&emsp;创建线程后，在创建线程的程序中调用<code>pthread_join()</code>等待线程退出，一般不会采用这种方法，因为<code>pthread_join()</code>会发生阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span>(pthid, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>&emsp;&emsp;如果想要一个服务端同时与多个客户端进行通信，前面使用了多进程服务端，这里改用多线程实现，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket服务端改为多线程，在每次accept到一个客户端的连接后创建一个线程，把监听到的客户端地址和对应编号构造为结构体后作为参数传输给新线程，让这个线程负责和这个客户端通信，原线程继续accept客户端的连接。由此，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信，从而实现并发。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多线程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">但是未实现通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void CloseClient();    // 关闭客户端的socket，多线程服务端不需要这个函数。</span></span><br><span class="line">    <span class="comment">// void CloseListen();    // 关闭用于监听的socket，多线程服务端不需要这个函数。</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(TcpServer.m_listenfd); <span class="comment">// 手动关闭m_listenfd，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">int</span> clientid;</span><br><span class="line">&#125; _arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">pth_main</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 忽略全部的信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, EXIT);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> pthid; <span class="comment">// 创建一线程，与新连接上来的客户端通信</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> clientid = <span class="number">0</span>;</span><br><span class="line">        clientid++;</span><br><span class="line">        _arg *arg = (_arg *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_arg));</span><br><span class="line">        arg-&gt;clientfd = (<span class="keyword">long</span>)TcpServer.m_clientfd;</span><br><span class="line">        arg-&gt;clientid = clientid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid, <span class="literal">NULL</span>, pth_main, (<span class="keyword">void</span> *)arg) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败，程序退出。n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_detach</span>(pthid); <span class="comment">//将新创建的线程设置为detached状态，线程退出时，系统自动回收线程资源</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;与客户端%d通信的线程已创建。\n&quot;</span>, clientid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_main</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _arg *n = (_arg *)arg;</span><br><span class="line">    <span class="keyword">int</span> clientfd = (<span class="keyword">long</span>)n-&gt;clientfd; <span class="comment">// arg参数为新客户端的socket。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd, strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户%d：%s\n&quot;</span>, n-&gt;clientid, strbuffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(strbuffer, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd, strbuffer, <span class="built_in">strlen</span>(strbuffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>, strbuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, n-&gt;clientid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clientfd); <span class="comment">// 关闭客户端的连接。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>服务端</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145222.png" alt="image-20220118145222454" style="zoom:50%;" /></li><li><p>客户端1</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145241.png" alt="image-20220118145241350" style="zoom:50%;" /></li><li><p>客户端2</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145255.png" alt="image-20220118145255493" style="zoom:50%;" /></li></ul><p>&emsp;&emsp;注意到，这里的程序并没有同前面多进程示例中一样，在子进程内又采用了多进程实现服务端、客户端收发同步进行的功能。因为开一个进程占用的资源远多于线程，子进程其实可以开两个线程分别负责收/发，但这又涉及线程间对共享资源的使用冲突问题，解决方法之一就是下面的线程锁。</p><h3 id="线程同步与互斥锁"><a href="#线程同步与互斥锁" class="headerlink" title="线程同步与互斥锁"></a>线程同步与互斥锁</h3><p>&emsp;&emsp;多线程可以共享进程的资源（变量和对象），对编程带来了方便，但是某些对象虽然可以共享，但在同一个时间只能由一个线程使用，多个线程同时使用会产生冲突，例如socket连接，数据库连接池。互斥锁机制是同一时刻只允许一个线程占有共享的资源。</p><h4 id="初始化锁"><a href="#初始化锁" class="headerlink" title="初始化锁"></a>初始化锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="comment">// mutexattr：用于指定锁的属性（见下），如果为NULL则使用缺省属性</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_TIMED_NP</td><td>缺省值，即普通锁，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE_NP</td><td>嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK_NP</td><td>检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同</td></tr><tr><td>PTHREAD_MUTEX_ADAPTIVE_NP</td><td>适应锁，动作最简单的锁类型，等待解锁后重新竞争</td></tr></tbody></table><h4 id="阻塞加锁"><a href="#阻塞加锁" class="headerlink" title="阻塞加锁"></a>阻塞加锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 如果是锁是空闲状态，本线程将获得这个锁；如果锁已经被占据，本线程将排队等待，直到成功的获取锁</span></span><br></pre></td></tr></table></figure><h4 id="非阻塞加锁"><a href="#非阻塞加锁" class="headerlink" title="非阻塞加锁"></a>非阻塞加锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回 EBUSY，不是挂起等待</span></span><br></pre></td></tr></table></figure><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 线程把自己持有的锁释放</span></span><br></pre></td></tr></table></figure><h4 id="销毁锁"><a href="#销毁锁" class="headerlink" title="销毁锁"></a>销毁锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 销毁锁之前，锁必需是空闲状态（unlock），否则返回EBUSY</span></span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>&emsp;&emsp;实际使用后意识到，即使是用两个线程分别负责收/发，二者交换互斥锁的所有权时也是以时间为周期的，并且当其中一个线程阻塞时，另一个线程就一直无法获得锁的所有权，也阻塞了，因此多线程无法真正实现收/发同步。目前的效果是收/发依次执行：</p><p><strong>服务端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">又通过多线程和互斥锁实现了通信中收发依次进行（其实没必要多线程，就代码一上一下也能实现）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>; <span class="comment">//通信端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 申明一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(TcpServer.m_listenfd); <span class="comment">// 手动关闭m_listenfd，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_send</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forkid = (<span class="keyword">int</span>)arg; <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//将本线程设置为detached状态来避免成为僵尸线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 与服务端交互</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端%d：&quot;</span>, forkid);</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);                  <span class="comment">// usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_recv</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forkid = (<span class="keyword">long</span>)arg; <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//将本线程设置为detached状态来避免成为僵尸线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 与服务端交互</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d：%s\n服务端%d：&quot;</span>, forkid, strbuffer, forkid);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);                  <span class="comment">// usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 忽略全部的信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, EXIT);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="number">0</span>); <span class="comment">// 创建锁</span></span><br><span class="line">        <span class="keyword">pthread_t</span> pthid1, pthid2;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pthid1, <span class="literal">NULL</span>, pth_send, (<span class="keyword">void</span> *)forkid); <span class="comment">// 创建第一个线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pthid1, <span class="literal">NULL</span>, pth_recv, (<span class="keyword">void</span> *)forkid); <span class="comment">// 创建第二个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_join</span>(pthid1, <span class="literal">NULL</span>); <span class="comment">// 等待线程 1退出。</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(pthid2, <span class="literal">NULL</span>); <span class="comment">// 等待线程 2退出。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 销毁锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">同时又通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">        <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> subforkid = fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (subforkid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;服务端%d：&quot;</span>, forkid);</span><br><span class="line">                <span class="built_in">fflush</span>(stdin);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (subforkid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d：%s\n服务端%d：&quot;</span>, forkid, strbuffer, forkid);</span><br><span class="line">                <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】策略梯度：PG算法族</title>
      <link href="/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%EF%BC%9APG%E7%AE%97%E6%B3%95%E6%97%8F/"/>
      <url>/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%EF%BC%9APG%E7%AE%97%E6%B3%95%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;Q-Learning、Sarsa、DQN都是基于价值函数的学习方式，但在强化学习的领域中还有另一种优化流派：基于策略学习（策略梯度）</p><p>&emsp;&emsp;在我看来，基于价值的优化算法都是在固定的策略（例如：贪婪策略、ε-greedy策略等）下，尽可能地准确估计出状态或动作的价值，从而让策略能够准确地选出最佳动作。但是基于策略的优化算法更加直接，不再使用固定的策略，而是对策略不断优化，不需要先算出状态价值再判断，而是根据环境的状态直接给出最佳动作。</p><p>&emsp;&emsp;策略梯度算法族包括：DPG、Actor-Critic、DDPQ等</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112085053.png" alt="image-20220112085053424" style="zoom: 33%;" /><span id="more"></span><p>&nbsp;</p><h2 id="策略梯度（Policy-Gradient）"><a href="#策略梯度（Policy-Gradient）" class="headerlink" title="策略梯度（Policy-Gradient）"></a>策略梯度（Policy-Gradient）</h2><h3 id="Value-based-强化学习方法的不足"><a href="#Value-based-强化学习方法的不足" class="headerlink" title="Value-based 强化学习方法的不足"></a>Value-based 强化学习方法的不足</h3><ol><li><p>对连续动作的处理能力不足</p><p>DQN等算法只处理离散动作，无法处理连续动作，例如：力的方向和大小</p></li><li><p>对受限状态下的问题处理能力不足</p><p>使用特征来描述状态空间中某一个状态时，有可能因为个体观测的限制或者建模的限制导致真实环境下不同的状态具有相同的特征描述</p></li><li><p>无法解决随机策略问题</p><p>Value Based强化学习方法对应的最优策略通常是确定性策略，因为其是从众多行为价值中选择一个最大价值的行为，而有些问题的最优策略却是随机策略，这种情况下同样是无法通过基于价值的学习来求解的</p></li></ol><h3 id="Policy-based-强化学习方法的引入"><a href="#Policy-based-强化学习方法的引入" class="headerlink" title="Policy-based 强化学习方法的引入"></a>Policy-based 强化学习方法的引入</h3><p>&emsp;&emsp;回顾Value-Based方法，无论是Sarsa还是DQN算法族，其所做的工作都是通过某种方法对状态的价值进行计算，然后根据计算结果采用贪婪策略或者ε-greedy策略选择出对应的动作，以此来实现对最佳动作的选择。在Policy-Based方法中，同样是为了选择出每个状态下的最佳动作，但是却更加直接。这里不再采用固定不变的策略思想，而是将策略不断优化，不断改变得到更新更优的策略。此时策略π可以被被描述为一个包含参数θ的函数，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111162846.png" alt="image-20220111162846573" style="zoom: 45%;" /><p>&emsp;&emsp;将策略表示成一个连续的函数后就可以用连续函数的优化方法来寻找最优的策略了，策略可以是一个一般函数，也可以是一个神经网络。为了评估策略的优劣，需要引入评价目标，也就是优化目标。然后采用类似梯度下降的优化方法，对优化目标做策略的”梯度上升“，收敛后即可得到最佳策略。</p><h3 id="策略梯度的优化目标"><a href="#策略梯度的优化目标" class="headerlink" title="策略梯度的优化目标"></a>策略梯度的优化目标</h3><table><thead><tr><th>优化目标</th><th>定义式</th></tr></thead><tbody><tr><td>初始状态收获的期望</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111163508.png" alt="image-20220111163508366" style="zoom: 33%;" /></td></tr><tr><td>平均价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117182507.png" alt="image-20220111163740877" style="zoom:33%;" /></td></tr><tr><td>每一时间步的平均奖励</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164026.png" alt="image-20220111164026634" style="zoom:33%;" /></td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>无论哪种优化目标，其梯度都可以表示为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164440.png" alt="image-20220111164439961" style="zoom: 45%;" /><p>不同优化目标只有 <code>Qπ(s,a)</code> 部分不同，策略部分不改变，称为<strong>分值函数</strong>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164711.png" alt="image-20220111164710941" style="zoom: 45%;" /><h3 id="策略函数的设计"><a href="#策略函数的设计" class="headerlink" title="策略函数的设计"></a>策略函数的设计</h3><h4 id="Softmax策略函数"><a href="#Softmax策略函数" class="headerlink" title="Softmax策略函数"></a>Softmax策略函数</h4><p>&emsp;&emsp;主要应用于离散空间中，使用描述状态和行为的特征 <code>ϕ(s,a)</code> 与参数 <code>θ </code>的线性组合来权衡一个行为发生的几率，即：   </p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165453.png" alt="image-20220111165453539" style="zoom:45%;" /><p>则通过求导求出对应的分值函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165244.png" alt="image-20220111165244127" style="zoom: 45%;" /><h4 id="Gauss策略函数"><a href="#Gauss策略函数" class="headerlink" title="Gauss策略函数"></a>Gauss策略函数</h4><p>&emsp;&emsp;主要应用于连续行为空间，对应的行为从高斯分布 <code>N(ϕ(s)^T θ,σ^2)</code> 中产生。对应的分值函数通过对策略求导可以得到：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165543.png" alt="image-20220111165543029" style="zoom:45%;" /><p>&nbsp;</p><h2 id="蒙特卡罗策略梯度算法"><a href="#蒙特卡罗策略梯度算法" class="headerlink" title="蒙特卡罗策略梯度算法"></a>蒙特卡罗策略梯度算法</h2><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112085002.png" alt="image-20220112085002544"></p><p>&emsp;&emsp;蒙特卡罗策略梯度是最简单的策略梯度算法，使用价值函数 v(s) 来近似代替策略梯度公式里面的 Qπ(s,a)。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N个蒙特卡罗完整序列，训练步长α</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略函数的参数θ</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>for 每个蒙特卡罗序列：</p><ul><li><p>用蒙特卡罗法计算序列每个时间位置t的状态价值 vt</p></li><li><p>对序列每个时间位置t，使用梯度上升法更新策略函数的参数θ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112084515.png" alt="image-20220112084515658" style="zoom:50%;" /></li></ul></li><li><p>返回策略函数的参数θ（策略函数可以是Softmax策略，高斯策略或者其他策略 ）</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p><strong>问题</strong></p><p>&emsp;&emsp;以OpenAI Gym中的CartPole-v0游戏为例，介绍参见<a href="https://github.com/openai/gym/wiki/CartPole-v0">这里</a>。它的基本要求就是控制下面的cart移动使连接在上面的pole保持垂直不倒。这个任务只有两个离散动作，要么向左用力，要么向右用力。而state状态就是这个cart的位置和速度， pole的角度和角速度，4维的特征。坚持到200分的奖励则为过关。</p><p><strong>代码</strong></p><p>&emsp;&emsp;这里采用somftmax策略函数，用三层softmax神经网络表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">GAMMA = <span class="number">0.95</span>  <span class="comment"># discount factor</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy_Gradient</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.ep_obs, self.ep_as, self.ep_rs = [], [], []</span><br><span class="line">        self.create_softmax_network()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_softmax_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.tf_acts = tf.placeholder(tf.int32, [<span class="literal">None</span>, ], name=<span class="string">&quot;actions_num&quot;</span>)</span><br><span class="line">        self.tf_vt = tf.placeholder(tf.float32, [<span class="literal">None</span>, ], name=<span class="string">&quot;actions_value&quot;</span>)</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># softmax layer</span></span><br><span class="line">        self.softmax_input = tf.matmul(h_layer, W2) + b2</span><br><span class="line">        <span class="comment"># softmax output</span></span><br><span class="line">        self.all_act_prob = tf.nn.softmax(self.softmax_input, name=<span class="string">&#x27;act_prob&#x27;</span>)</span><br><span class="line">        self.neg_log_prob = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.softmax_input,</span><br><span class="line">                                                                           labels=self.tf_acts)</span><br><span class="line">        self.loss = tf.reduce_mean(</span><br><span class="line">            self.neg_log_prob * self.tf_vt)  <span class="comment"># reward guided loss</span></span><br><span class="line"></span><br><span class="line">        self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">            LEARNING_RATE).minimize(self.loss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, observation</span>):</span></span><br><span class="line">        prob_weights = self.session.run(self.all_act_prob, feed_dict=&#123;</span><br><span class="line">                                        self.state_input: observation[np.newaxis, :]&#125;)</span><br><span class="line">        <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        action = np.random.choice(</span><br><span class="line">            <span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]), p=prob_weights.ravel())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r</span>):</span></span><br><span class="line">        self.ep_obs.append(s)</span><br><span class="line">        self.ep_as.append(a)</span><br><span class="line">        self.ep_rs.append(r)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        discounted_ep_rs = np.zeros_like(self.ep_rs)</span><br><span class="line">        running_add = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.ep_rs))):</span><br><span class="line">            running_add = running_add * GAMMA + self.ep_rs[t]</span><br><span class="line">            discounted_ep_rs[t] = running_add</span><br><span class="line"></span><br><span class="line">        discounted_ep_rs -= np.mean(discounted_ep_rs)</span><br><span class="line">        discounted_ep_rs /= np.std(discounted_ep_rs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train on episode</span></span><br><span class="line">        self.session.run(self.train_op, feed_dict=&#123;</span><br><span class="line">            self.state_input: np.vstack(self.ep_obs),</span><br><span class="line">            self.tf_acts: np.array(self.ep_as),</span><br><span class="line">            self.tf_vt: discounted_ep_rs,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        self.ep_obs, self.ep_as, self.ep_rs = [], [], []    <span class="comment"># empty episode data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = Policy_Gradient(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.choose_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            agent.store_transition(state, action, reward)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="comment">#print(&quot;stick for &quot;,step, &quot; steps&quot;)</span></span><br><span class="line">                agent.learn()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.choose_action(</span><br><span class="line">                        state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;400轮左右收敛，但是并不稳定，平均Reward在200附近浮动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118104115.png" alt="image-20220118104115127" style="zoom: 40%;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;策略梯度提供了和 DQN 之类的方法不同的新思路，但是简单的蒙特卡罗策略梯度reinforce算法却并不完美。蒙特卡罗法需要完全的序列样本才能做算法迭代，同时蒙特卡罗法使用收获的期望来计算状态价值，会导致行为有较多的变异性，参数更新的方向很可能不是策略梯度的最优方向。因此，Policy-based的强化学习方法还需要改进，例如 Policy-based与Value-based结合的策略梯度方法Actor-Critic。</p><p>&nbsp;</p><h2 id="Actor-Critic算法"><a href="#Actor-Critic算法" class="headerlink" title="Actor-Critic算法"></a>Actor-Critic算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Actor-Critic 是2000年在NIPS上发表的一篇名为 <a href="https://lrk612.com/resources/Actor-Critic%20Algorithms.pdf">Actor-Critic Algorithms</a> 的论文中提出的，是一种训练模型的模式或技巧。</p><p>&emsp;&emsp;Actor-Critic包括两部分：演员(Actor)、评价者(Critic)。其中Actor使用策略函数，负责生成动作(Action)并和环境交互，而Critic使用价值函数，负责评估Actor的表现，并指导Actor下一阶段的动作。在Policy-Gradient中，策略函数就是Actor，但是那里没有Critic，而是使用了蒙特卡罗法来计算每一步的价值部分从而替代了Critic的功能，但是场景比较受限。因此现在使用类似DQN中用的价值近似来替代蒙特卡罗法，作为一个比较通用的Critic。</p><p>&emsp;&emsp;Actor-Critic算法中做了两组近似：</p><h4 id="策略函数的近似"><a href="#策略函数的近似" class="headerlink" title="策略函数的近似"></a>策略函数的近似</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090509.png" alt="image-20220112090509167" style="zoom:45%;" /><h4 id="价值函数的近似"><a href="#价值函数的近似" class="headerlink" title="价值函数的近似"></a>价值函数的近似</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090441.png" alt="image-20220112090441163" style="zoom: 45%;" /><p>&emsp;&emsp;也就是说，蒙特卡罗reinforce算法参数的参数更新公式（如下）中，vt的求取不再用蒙特卡罗法那样采样平均而是用DQN的近似价值函数求取，而分值函数部分∇θlogπθ(s,a)不变。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090613.png" alt="image-20220112090613113" style="zoom:45%;" /><p>&emsp;&emsp;通常使用Q网络来近似价值函数，所以汇总来说，就是Critic通过Q网络计算状态的最优价值vt，而Actor利用vt这个最优价值迭代更新策略函数的参数θ，进而选择动作，并得到反馈和新的状态，Critic使用反馈和新的状态更新Q网络参数w，在后面Critic会使用新的网络参数w来帮Actor计算状态的最优价值vt。</p><h4 id="可选形式"><a href="#可选形式" class="headerlink" title="可选形式"></a>可选形式</h4><p>&emsp;&emsp;Critic有多种选择，其网络输出作为Actor的优化目标，对应Actor多种策略梯度更新方法：</p><table><thead><tr><th>Critic</th><th>对应Actor更新方法</th><th>备注</th></tr></thead><tbody><tr><td>状态价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090936.png" alt="image-20220112090936577" style="zoom:33%;" /></td><td></td></tr><tr><td>动作价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091001.png" alt="image-20220112091001498" style="zoom:33%;" /></td><td></td></tr><tr><td>TD误差</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091050.png" alt="image-20220112091050308" style="zoom:33%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091237.png" alt="image-20220112091237744" style="zoom:33%;" /></td></tr><tr><td>优势函数</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091536.png" alt="image-20220112091536610" style="zoom: 33%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091703.png" alt="image-20220112091703913" style="zoom:33%;" /></td></tr><tr><td>TD(λ)误差</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112092148.png" alt="image-20220112092148003" style="zoom:33%;" /></td><td>基于后向TD(λ)误差，是TD误差和效用迹的乘积</td></tr></tbody></table><p>&emsp;&emsp;对于Critic本身的网络参数w，一般都是使用 <code>均方误差损失函数</code> 来做迭代更新，类似DQN系列中的迭代方法。</p><h3 id="算法流程（基于TD误差）"><a href="#算法流程（基于TD误差）" class="headerlink" title="算法流程（基于TD误差）"></a>算法流程（基于TD误差）</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112092450.png" alt="image-20220112092450135"></p><p>（评估点基于TD误差，Critic使用神经网络来计算TD误差并更新网络参数，Actor也使用Critic神经网络的结果来更新网络参数）</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、β、衰减因子γ、探索率ϵ、Critic网络结构、Actor网络结构</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Actor网络参数θ、Critic网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有的状态和动作对应的价值Q</p></li><li><p>for i in [ 1, T ]：</p><ol><li>初始化S为当前状态序列的第一个状态，拿到其特征向量Φ(S)</li><li>把Φ(S)输入Actor网络，得到输出动作A，并由环境获得新状态S’、奖励R</li><li>把Φ(S)、Φ(S‘ )分别输入Critic网络，分别得到输出的Q值V(S)、V(S’ )</li><li>计算TD误差 δ = R + γV(S′ ) − V(S)</li><li>计算均方差损失函数 ∑(R+γV(S′)−V(S,w))^2，梯度反向传播更新Critic网络参数w</li><li>更新Actor网络参数：</li></ol></li></ol><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091050.png" alt="image-20220112091050308" style="zoom:45%;" /><p>（这里以TD误差为评估点， 分值函数∇θlogπθ(St,A)可以选择softmax或者高斯分值函数 )</p><p>对应模型结构：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112103230.png" alt="image-20220112103230292" style="zoom:50%;" /><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;代码分为Actor和Critic两部分，Actor部分和上面策略梯度的代码差别不大，主要是梯度更新方法不同，策略梯度使用蒙特卡洛法计算出价值，这里Actor使用的是TD误差。Critic部分类似于之前的DQN的三层神经网络，但是输出只有一维，并且没有经验回放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">GAMMA = <span class="number">0.95</span>  <span class="comment"># discount factor</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env, sess</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.create_softmax_network()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = sess</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_softmax_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.tf_acts = tf.placeholder(tf.int32, [<span class="literal">None</span>, <span class="number">2</span>], name=<span class="string">&quot;actions_num&quot;</span>)</span><br><span class="line">        self.td_error = tf.placeholder(</span><br><span class="line">            tf.float32, <span class="literal">None</span>, <span class="string">&quot;td_error&quot;</span>)  <span class="comment"># TD_error</span></span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># softmax layer</span></span><br><span class="line">        self.softmax_input = tf.matmul(h_layer, W2) + b2</span><br><span class="line">        <span class="comment"># softmax output</span></span><br><span class="line">        self.all_act_prob = tf.nn.softmax(self.softmax_input, name=<span class="string">&#x27;act_prob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.neg_log_prob = tf.nn.softmax_cross_entropy_with_logits(logits=self.softmax_input,</span><br><span class="line">                                                                    labels=self.tf_acts)</span><br><span class="line">        self.exp = tf.reduce_mean(self.neg_log_prob * self.td_error)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里需要最大化当前策略的价值，因此需要最大化self.exp,即最小化-self.exp</span></span><br><span class="line">        self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">            LEARNING_RATE).minimize(-self.exp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, observation</span>):</span></span><br><span class="line">        prob_weights = self.session.run(self.all_act_prob, feed_dict=&#123;</span><br><span class="line">                                        self.state_input: observation[np.newaxis, :]&#125;)</span><br><span class="line">        <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        action = np.random.choice(</span><br><span class="line">            <span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]), p=prob_weights.ravel())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, state, action, td_error</span>):</span></span><br><span class="line">        s = state[np.newaxis, :]</span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        a = one_hot_action[np.newaxis, :]</span><br><span class="line">        <span class="comment"># train on episode</span></span><br><span class="line">        self.session.run(self.train_op, feed_dict=&#123;</span><br><span class="line">            self.state_input: s,</span><br><span class="line">            self.tf_acts: a,</span><br><span class="line">            self.td_error: td_error,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Critic</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env, sess</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = sess</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1q = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1q = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2q = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">        b2q = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">        self.state_input = tf.placeholder(</span><br><span class="line">            tf.float32, [<span class="number">1</span>, self.state_dim], <span class="string">&quot;state&quot;</span>)</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layerq = tf.nn.relu(tf.matmul(self.state_input, W1q) + b1q)</span><br><span class="line">        <span class="comment"># Q Value layer</span></span><br><span class="line">        self.Q_value = tf.matmul(h_layerq, W2q) + b2q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.next_value = tf.placeholder(tf.float32, [<span class="number">1</span>, <span class="number">1</span>], <span class="string">&quot;v_next&quot;</span>)</span><br><span class="line">        self.reward = tf.placeholder(tf.float32, <span class="literal">None</span>, <span class="string">&#x27;reward&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;squared_TD_error&#x27;</span>):</span><br><span class="line">            self.td_error = self.reward + GAMMA * self.next_value - self.Q_value</span><br><span class="line">            self.loss = tf.square(self.td_error)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">            self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">                self.epsilon).minimize(self.loss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self, state, reward, next_state</span>):</span></span><br><span class="line">        s, s_ = state[np.newaxis, :], next_state[np.newaxis, :]</span><br><span class="line">        v_ = self.session.run(self.Q_value, &#123;self.state_input: s_&#125;)</span><br><span class="line">        td_error, _ = self.session.run([self.td_error, self.train_op],</span><br><span class="line">                                       &#123;self.state_input: s, self.next_value: v_, self.reward: reward&#125;)</span><br><span class="line">        <span class="keyword">return</span> td_error</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    sess = tf.InteractiveSession()</span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    actor = Actor(env, sess)</span><br><span class="line">    critic = Critic(env, sess)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = actor.choose_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># gradient = grad[r + gamma * V(s_) - V(s)]</span></span><br><span class="line">            td_error = critic.train_Q_network(state, reward, next_state)</span><br><span class="line">            <span class="comment"># true_gradient = grad[logPi(s,a) * td_error]</span></span><br><span class="line">            actor.learn(state, action, td_error)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = actor.choose_action(</span><br><span class="line">                        state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;很明显，这个算法很难收敛，平均Reward总是很低</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118105019.png" alt="image-20220118105019197" style="zoom:50%;" /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Actor-Critic的优点是可以单步更新，比蒙特卡洛法的更新反馈更好、方差更小、稳定性更高。不过虽然基本版的Actor-Critic算法已经是一个很好的算法框架，但是离实际应用还比较远。主要原因是这里有两个神经网络，都需要梯度更新，而且互相依赖，所以难以收敛。</p><p>&emsp;&emsp;目前改进的比较好的有两个经典算法，一个是DDPG算法，使用了双Actor神经网络和双Critic神经网络的方法来改善收敛性。这个方法在从DQN到Nature DQN的过程中用过。另一个是A3C算法，使用了多线程的方式，一个主线程负责更新Actor和Critic的参数，多个辅线程负责分别和环境交互，得到梯度更新值，汇总更新主线程的参数。而所有的辅线程会定期从主线程更新网络参数。这些辅线程起到了类似DQN中经验回放的作用，但是效果更好。</p><p>&nbsp;</p><h2 id="DDPG"><a href="#DDPG" class="headerlink" title="DDPG"></a>DDPG</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="针对问题"><a href="#针对问题" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;对于某一些动作集合来说，它可能是连续值，或者非常高维的离散值，这样动作的空间维度极大。如果使用随机策略，即像DQN一样研究它所有的可能动作的概率，并计算各个可能的动作的价值的话，那需要的样本量是非常大才可行的。</p><h4 id="优化：DPG（确定性策略）"><a href="#优化：DPG（确定性策略）" class="headerlink" title="优化：DPG（确定性策略）"></a>优化：DPG（确定性策略）</h4><p>&emsp;&emsp;2014年，David Sliver发表了一篇名为 <a href="https://lrk612.com/resources/Deterministic%20Policy%20Gradient%20Algorithms.pdf">Deterministic Policy Gradient Algorithms</a> 的论文，文中证明了确定性策略梯度的存在，并给出了详细的计算方法。同一个随机策略在同一个状态处采用的动作基于一个概率分布，依概率取动作值，即不确定。而确定性策略则在不同概率的动作中取概率最大者，同一个状态的动作是唯一确定的，此时策略为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116163325.png" alt="image-20220113100808659" style="zoom:45%;" /><p>基于Q值的随机性策略梯度的梯度计算公式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113101331.png" alt="image-20220113101331271" style="zoom:45%;" /><p>其中状态的采样空间为ρπ，可见随机性策略梯度需要在整个动作的空间πθπθ进行采样。</p><p>而基于Q值的确定性策略梯度的梯度计算公式是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113101501.png" alt="image-20220113101501314" style="zoom:45%;" /><p>跟随机策略梯度的式子相比，少了对动作的积分，多了回报Q函数对动作的导数。</p><h4 id="DDPG原理"><a href="#DDPG原理" class="headerlink" title="DDPG原理"></a>DDPG原理</h4><p>&emsp;&emsp;从DPG到DDPG的过程，完全可以类比DQN到DDQN的过程。除了经验回放外还有双网络，即当前网络和目标网络。Actor双网络和Critic双网络总共四个网络结构。</p><h5 id="回顾DDQN的双网络模型"><a href="#回顾DDQN的双网络模型" class="headerlink" title="回顾DDQN的双网络模型"></a>回顾DDQN的双网络模型</h5><p>&emsp;&emsp;DDQN的当前网络负责对当前状态<code>S</code>使用<code>ε-greedy</code>法选择动作<code>A</code>，执行动作<code>A</code>获得新状态<code>S‘</code>和奖励<code>R</code>，将此样本放入经验池。对经验池中采样的下一状态<code>S’</code>使用贪婪<code>greedy</code>法选择动作<code>A’</code>，供目标网络计算目标Q值，然后当前网络反向传播更新参数，并定期把最新的网络参数复制到目标网络。</p><p>&emsp;&emsp;DDQN的目标网络基于经验回放计算目标Q值，供当前网络计算损失函数然后反向传播。</p><h5 id="DDPG工作原理"><a href="#DDPG工作原理" class="headerlink" title="DDPG工作原理"></a>DDPG工作原理</h5><p>&emsp;&emsp;与DDQN相比较，DDPG的Critic的当前网络/目标网络同DDQN相似，但是因为DDPG还有Actor双网络，因此DDPG用Actor当前网络代替DDQN中的<code>ε-greedy</code>法选择动作<code>A</code>、用Actor目标网络代替DDQN中的贪婪<code>greedy</code>法选择动作<code>A’</code>。</p><p>&emsp;&emsp;基于经验回放池和目标Actor网络提供的<code>S′</code>、<code>A′</code>计算目标Q值的一部分，这部分由于是评估，因此还是放到Critic目标网络完成。而Critic目标网络计算出目标Q值一部分后，Critic当前网络会计算目标Q值，进行网络参数的反向传播更新，并定期将当前网络参数复制到Critic目标网络。</p><h5 id="DDPG-4个网络的功能"><a href="#DDPG-4个网络的功能" class="headerlink" title="DDPG 4个网络的功能"></a>DDPG 4个网络的功能</h5><table><thead><tr><th>网络</th><th>功能</th></tr></thead><tbody><tr><td>Critic当前网络</td><td>负责价值网络参数w的更新，计算当前Q(S,A,w)，目标Q值yi=R+γQ’(S’,A’,w’)</td></tr><tr><td>Critic目标网络</td><td>计算目标Q值中的Q’(S’,A’,w’)部分，网络参数w’定期从w软更新</td></tr><tr><td>Actor当前网络</td><td>负责策略网络参数θ的迭代更新，根据当前状态S选择当前动作A，与环境交互生成S‘、R</td></tr><tr><td>Actor目标网络</td><td>根据经验池中采样的下一状态S’选择最优下一动作A‘，网络参数θ’定期从θ软更新</td></tr></tbody></table><h5 id="网络参数的软更新"><a href="#网络参数的软更新" class="headerlink" title="网络参数的软更新"></a>网络参数的软更新</h5><p>&emsp;&emsp;DDPG中网络参数的赋值并不是和DQN一样直接全部复制（硬更新），而是每次都只更新一点点（软更新）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113122829.png" alt="image-20220113122829564" style="zoom:45%;" /><p>（其中，τ是更新系数，典型值为0.01~0.1）</p><h5 id="动作噪声"><a href="#动作噪声" class="headerlink" title="动作噪声"></a>动作噪声</h5><p>&emsp;&emsp;为了学习过程增加一些随机性，从而增加学习的覆盖，DDPG对选择出来的动作<code>A</code>会增加一定的噪声<code>N</code>，即最终和环境交互的动作<code>A</code>为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123143.png" alt="image-20220113123143564" style="zoom:45%;" /><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><h6 id="Critic当前网络："><a href="#Critic当前网络：" class="headerlink" title="Critic当前网络："></a>Critic当前网络：</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123425.png" alt="image-20220113123425768" style="zoom:45%;" /><h6 id="Actor当前网络"><a href="#Actor当前网络" class="headerlink" title="Actor当前网络"></a>Actor当前网络</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123623.png" alt="image-20220113123623061" style="zoom:45%;" /><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125412.png" alt="image-20220113125412297" style="zoom:50%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Actor当前/目标网络，Critic当前/目标网络，参数分别为θ、θ′、w、w′，衰减因子γ、软更新系数τ、批量梯度下降的样本数m、目标Q网络参数更新频率C、最大迭代次数T、随机噪音函数N</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最优Actor当前网络参数θ、Critic当前网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化<code>θ</code>、<code>w</code>、<code>w′=w</code>、<code>θ′=θ</code>，清空经验池 D</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化<code>S</code>为当前状态序列的第一个状态，拿到其特征向量<code>Φ(S)</code></p></li><li><p>把状态<code>S</code>输入<strong>Actor当前网络</strong>得到输出动作：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125013.png" alt="image-20220113125013515" style="zoom:45%;" /></li><li><p>执行动作<code>A</code>，由环境得到新状态<code>S‘</code>、奖励 <code>R</code>、终止标志 <code>is_end</code></p></li><li><p>将 <code>&#123; ϕ(S)、A、R、ϕ(S′)、is_end &#125;</code> 这个五元组存入经验池 <code>D</code></p></li><li><p>前进一步：<code>S = S’</code></p></li><li><p>从经验池<code>D</code>中采样<code>m</code>个样本 <code>&#123; ϕ(Sj)、Aj、Rj、ϕ(S′j)、is_endj &#125; ，j=1,2...m</code> ， 用<strong>目标Critic网络</strong>结合公式计算当前目标Q值<code>yj</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113124619.png" alt="image-20220113124619535" style="zoom:45%;" /><p>（注意：<code>πθ′(ϕ(S′j))</code>是通过<strong>Actor目标网络</strong>得到 ）</p></li><li><p>用<strong>当前Critic网络</strong>计算Q估计值，梯度反向传播更新Critic当前网络参数 <code>w</code>，损失函数为均方误差：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123425.png" alt="image-20220113123425768" style="zoom:45%;" /></li><li><p>梯度反向传播更新Actor当前网络参数 <code>θ</code>，损失函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123623.png" alt="image-20220113123623061" style="zoom:45%;" /></li><li><p>if <code>i % C == 0</code>，则更新Critic目标网络和Actor目标网络参数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113122829.png" alt="image-20220113122829564" style="zoom:45%;" /></li><li><p>if  <code>S’ </code>是终止状态，break；else 跳回步骤 2.2</p></li></ol></li></ol><p>（注意，上面πθ由Actor目标网络得到，Q‘由Critic目标网络得到）</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;这里不用之前的CartPole游戏，因为它不是连续动作，而是使用Pendulum-v1游戏为例。目的是用最小的力矩使棒子竖起来，这个游戏的详细介绍参见<a href="https://github.com/openai/gym/wiki/Pendulum-v0">这里</a>。输入状态是角度的sin，cos值，以及角速度，一共三个值。动作是一个连续的力矩值。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################  hyper parameters  ####################</span></span><br><span class="line"></span><br><span class="line">MAX_EPISODES = <span class="number">2000</span></span><br><span class="line">MAX_EP_STEPS = <span class="number">200</span></span><br><span class="line">LR_A = <span class="number">0.001</span>    <span class="comment"># learning rate for actor</span></span><br><span class="line">LR_C = <span class="number">0.002</span>    <span class="comment"># learning rate for critic</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>     <span class="comment"># reward discount</span></span><br><span class="line">TAU = <span class="number">0.01</span>      <span class="comment"># soft replacement</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">10000</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">RENDER = <span class="literal">False</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;Pendulum-v1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################  DDPG  ####################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDPG</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a_dim, s_dim, a_bound,</span>):</span></span><br><span class="line">        self.memory = np.zeros(</span><br><span class="line">            (MEMORY_CAPACITY, s_dim * <span class="number">2</span> + a_dim + <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">        self.pointer = <span class="number">0</span></span><br><span class="line">        self.sess = tf.Session()</span><br><span class="line"></span><br><span class="line">        self.a_dim, self.s_dim, self.a_bound = a_dim, s_dim, a_bound,</span><br><span class="line">        self.S = tf.placeholder(tf.float32, [<span class="literal">None</span>, s_dim], <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">        self.S_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, s_dim], <span class="string">&#x27;s_&#x27;</span>)</span><br><span class="line">        self.R = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Actor&#x27;</span>):</span><br><span class="line">            self.a = self._build_a(self.S, scope=<span class="string">&#x27;eval&#x27;</span>, trainable=<span class="literal">True</span>)</span><br><span class="line">            a_ = self._build_a(self.S_, scope=<span class="string">&#x27;target&#x27;</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Critic&#x27;</span>):</span><br><span class="line">            <span class="comment"># assign self.a = a in memory when calculating q for td_error,</span></span><br><span class="line">            <span class="comment"># otherwise the self.a is from Actor when updating Actor</span></span><br><span class="line">            q = self._build_c(self.S, self.a, scope=<span class="string">&#x27;eval&#x27;</span>, trainable=<span class="literal">True</span>)</span><br><span class="line">            q_ = self._build_c(self.S_, a_, scope=<span class="string">&#x27;target&#x27;</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># networks parameters</span></span><br><span class="line">        self.ae_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Actor/eval&#x27;</span>)</span><br><span class="line">        self.at_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Actor/target&#x27;</span>)</span><br><span class="line">        self.ce_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Critic/eval&#x27;</span>)</span><br><span class="line">        self.ct_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Critic/target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># target net replacement</span></span><br><span class="line">        self.soft_replace = [tf.assign(t, (<span class="number">1</span> - TAU) * t + TAU * e)</span><br><span class="line">                             <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(self.at_params + self.ct_params, self.ae_params + self.ce_params)]</span><br><span class="line"></span><br><span class="line">        q_target = self.R + GAMMA * q_</span><br><span class="line">        <span class="comment"># in the feed_dic for the td_error, the self.a should change to actions in memory</span></span><br><span class="line">        td_error = tf.losses.mean_squared_error(labels=q_target, predictions=q)</span><br><span class="line">        self.ctrain = tf.train.AdamOptimizer(LR_C).minimize(</span><br><span class="line">            td_error, var_list=self.ce_params)</span><br><span class="line"></span><br><span class="line">        a_loss = - tf.reduce_mean(q)    <span class="comment"># maximize the q</span></span><br><span class="line">        self.atrain = tf.train.AdamOptimizer(</span><br><span class="line">            LR_A).minimize(a_loss, var_list=self.ae_params)</span><br><span class="line"></span><br><span class="line">        self.sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.a, &#123;self.S: s[np.newaxis, :]&#125;)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># soft target replacement</span></span><br><span class="line">        self.sess.run(self.soft_replace)</span><br><span class="line"></span><br><span class="line">        indices = np.random.choice(MEMORY_CAPACITY, size=BATCH_SIZE)</span><br><span class="line">        bt = self.memory[indices, :]</span><br><span class="line">        bs = bt[:, :self.s_dim]</span><br><span class="line">        ba = bt[:, self.s_dim: self.s_dim + self.a_dim]</span><br><span class="line">        br = bt[:, -self.s_dim - <span class="number">1</span>: -self.s_dim]</span><br><span class="line">        bs_ = bt[:, -self.s_dim:]</span><br><span class="line"></span><br><span class="line">        self.sess.run(self.atrain, &#123;self.S: bs&#125;)</span><br><span class="line">        self.sess.run(self.ctrain, &#123;self.S: bs,</span><br><span class="line">                      self.a: ba, self.R: br, self.S_: bs_&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_</span>):</span></span><br><span class="line">        transition = np.hstack((s, a, [r], s_))</span><br><span class="line">        <span class="comment"># replace the old memory with new memory</span></span><br><span class="line">        index = self.pointer % MEMORY_CAPACITY</span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_a</span>(<span class="params">self, s, scope, trainable</span>):</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">            net = tf.layers.dense(</span><br><span class="line">                s, <span class="number">30</span>, activation=tf.nn.relu, name=<span class="string">&#x27;l1&#x27;</span>, trainable=trainable)</span><br><span class="line">            a = tf.layers.dense(</span><br><span class="line">                net, self.a_dim, activation=tf.nn.tanh, name=<span class="string">&#x27;a&#x27;</span>, trainable=trainable)</span><br><span class="line">            <span class="keyword">return</span> tf.multiply(a, self.a_bound, name=<span class="string">&#x27;scaled_a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_c</span>(<span class="params">self, s, a, scope, trainable</span>):</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">            n_l1 = <span class="number">30</span></span><br><span class="line">            w1_s = tf.get_variable(</span><br><span class="line">                <span class="string">&#x27;w1_s&#x27;</span>, [self.s_dim, n_l1], trainable=trainable)</span><br><span class="line">            w1_a = tf.get_variable(</span><br><span class="line">                <span class="string">&#x27;w1_a&#x27;</span>, [self.a_dim, n_l1], trainable=trainable)</span><br><span class="line">            b1 = tf.get_variable(<span class="string">&#x27;b1&#x27;</span>, [<span class="number">1</span>, n_l1], trainable=trainable)</span><br><span class="line">            net = tf.nn.relu(tf.matmul(s, w1_s) + tf.matmul(a, w1_a) + b1)</span><br><span class="line">            <span class="keyword">return</span> tf.layers.dense(net, <span class="number">1</span>, trainable=trainable)  <span class="comment"># Q(s,a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################  training  ####################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env = gym.make(ENV_NAME)</span><br><span class="line">env = env.unwrapped</span><br><span class="line">env.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">a_dim = env.action_space.shape[<span class="number">0</span>]</span><br><span class="line">a_bound = env.action_space.high</span><br><span class="line"></span><br><span class="line">ddpg = DDPG(a_dim, s_dim, a_bound)</span><br><span class="line"></span><br><span class="line">var = <span class="number">3</span>  <span class="comment"># control exploration</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EPISODES):</span><br><span class="line">    s = env.reset()</span><br><span class="line">    ep_reward = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EP_STEPS):</span><br><span class="line">        <span class="keyword">if</span> RENDER:</span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add exploration noise</span></span><br><span class="line">        a = ddpg.choose_action(s)</span><br><span class="line">        <span class="comment"># add randomness to action selection for exploration</span></span><br><span class="line">        a = np.clip(np.random.normal(a, var), -<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        s_, r, done, info = env.step(a)</span><br><span class="line"></span><br><span class="line">        ddpg.store_transition(s, a, r / <span class="number">10</span>, s_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ddpg.pointer &gt; MEMORY_CAPACITY:</span><br><span class="line">            var *= <span class="number">.9995</span>    <span class="comment"># decay the action randomness</span></span><br><span class="line">            ddpg.learn()</span><br><span class="line"></span><br><span class="line">        s = s_</span><br><span class="line">        ep_reward += r</span><br><span class="line">        <span class="keyword">if</span> j == MAX_EP_STEPS-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Episode:&#x27;</span>, episode, <span class="string">&#x27; Reward: %i&#x27;</span> %</span><br><span class="line">                  <span class="built_in">int</span>(ep_reward), <span class="string">&#x27;Explore: %.2f&#x27;</span> % var, )</span><br><span class="line">            <span class="comment"># if ep_reward &gt; -300:RENDER = True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        total_reward = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            state = env.reset()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EP_STEPS):</span><br><span class="line">                env.render()</span><br><span class="line">                action = ddpg.choose_action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                state, reward, done, _ = env.step(action)</span><br><span class="line">                total_reward += reward</span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        ave_reward = total_reward/<span class="number">300</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Running time: &#x27;</span>, time.time() - t1)</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;DDPG参考了DDQN的算法思想，通过双网络和经验回放，加一些其他的优化，比较好的解决了Actor-Critic难收敛的问题。因此在实际产品中尤其是自动化相关的产品中用的比较多，是一个比较成熟的Actor-Critic算法。</p><p>&emsp;&emsp;以上就是Policy Based RL系列算法，算上前面的Value Based RL系列算法，还剩下Model Based RL系列算法没研究，后面再说。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】深度强化学习：DQN算法族</title>
      <link href="/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADQN%E7%AE%97%E6%B3%95%E6%97%8F/"/>
      <url>/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADQN%E7%AE%97%E6%B3%95%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;动态规划DP、蒙特卡罗MC、时序差分TD这些求解MDP问题的算法，使用的状态都是有限个离散状态，问题规模小时易求解。而当问题规模庞大，或者状态是连续的且离散化后依然规模庞大时，无法将Q表存在有限的内存中。因此用价值函数的近似表示来修改模型。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117234446.png" alt="image-20220117234446365" style="zoom:67%;" /><span id="more"></span><p>&nbsp;</p><h2 id="价值函数的近似表示"><a href="#价值函数的近似表示" class="headerlink" title="价值函数的近似表示"></a>价值函数的近似表示</h2><h4 id="状态价值函数"><a href="#状态价值函数" class="headerlink" title="状态价值函数"></a>状态价值函数</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162045.png" alt="image-20220116162045244" style="zoom: 67%;" /><h4 id="动作价值函数"><a href="#动作价值函数" class="headerlink" title="动作价值函数"></a>动作价值函数</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109095934.png" alt="image-20220109095934523" style="zoom: 33%;" /><p>&emsp;&emsp;具体的近似方法有很多，比如：线性表示法、决策树、最近邻、傅里叶变换等，但是最常用的是神经网络（DNN、CNN、RNN）</p><p>&emsp;&emsp;对于状态价值函数，神经网络的输入是状态s的特征向量，输出是状态价值v(s,w)。</p><p>&emsp;&emsp;对于动作价值函数，有两种方法，一种是输入状态s的特征向量和动作a，输出对应的动作价值q(s,a,w)，另一种是只输入状态s的特征向量，动作集合有多少个动作就有多少个输出q(s,a,w)（这里隐示了动作是有限个的离散动作）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109100417.png" alt="image-20220109100417543" style="zoom: 33%;" /><p>&nbsp;</p><h2 id="NIPS-DQN算法"><a href="#NIPS-DQN算法" class="headerlink" title="NIPS DQN算法"></a>NIPS DQN算法</h2><p>&emsp;&emsp;NIPS DQN是2013年由 DeepMind 在NIPS上发表的一篇论文中提出的，也是DQN算法族的第一位成员，是最原始的DQN算法。论文：<a href="https://lrk612.com/resources/Playing%20Atari%20with%20Deep%20Reinforcement%20Learning.pdf">Playing Atari with Deep Reinforcement Learning</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;基本思路来源于Q-Learning，但是和Q-Learning不同的地方在于，它Q值不是直接通过状态值S和动作A来计算，而是通过上面讲到的Q网络来计算，这个Q网络是一个神经网络。</p><h3 id="经验回放（experience-replay）"><a href="#经验回放（experience-replay）" class="headerlink" title="经验回放（experience replay）"></a><strong>经验回放（experience replay）</strong></h3><p>&emsp;&emsp;将每次和环境交互得到的奖励与状态更新情况都保存在经验池中，用于后面目标Q值的更新。Q-Learning有一张Q表来保存所有的Q值的当前结果的，而DQN在做动作价值函数更新时靠的就是经验回放。从通过经验回放得到的目标Q值和通过Q网络直接计算得到的Q估计值肯定是不等的，二者的差别构成神经网络的损失函数Loss Function，然后通过梯度的反向传播来更新神经网络的参数w，当w收敛后就得到的近似的Q值计算方法，进而贪婪策略也就求出来了。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220207145830.png" alt="image-20220207145830293" style="zoom:60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、Q网络结构、批量梯度下降的样本数m</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化Q网络的所有参数w，基于w初始化所有的状态和动作对应的价值Q，清空经验池D</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，拿到其特征向量ϕ(S)</p></li><li><p>把ϕ(S)输入Q网络，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作A</p></li><li><p>执行动作A，由环境得到新状态S‘ 对应的特征向量ϕ(S‘)、奖励R’、终止标志is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，把S‘  和A’ 输入神经网络结合贪婪策略计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109102614.png" alt="image-20220109102614326" style="zoom: 33%;" /></li><li><p>把S  和A 输入Q网络直接求Q估计值，由上一步从经验池回放得到的 yj 和此步得到的Q估计值，求出损失函数 Loss Function，梯度反向传播更新Q网络参数w。这里使用的是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，f步目标Q值和g步Q估计值的计算都用了同一个Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代的进行而变小）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;以OpenAI Gym中的CartPole-v0游戏为例，介绍参见<a href="https://github.com/openai/gym/wiki/CartPole-v0">这里</a>。它的基本要求就是控制下面的cart移动使连接在上面的pole保持垂直不倒。这个任务只有两个离散动作，要么向左用力，要么向右用力。而state状态就是这个cart的位置和速度， pole的角度和角速度，4维的特征。坚持到200分的奖励则为过关。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># Q Value layer</span></span><br><span class="line">        self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create training method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;800轮左右收敛，但是并不稳定，平均Reward在200附近浮动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151404.png" alt="image-20220117151357691" style="zoom:50%;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;DQN由于对价值函数Q做了近似表示，因此有了解决大规模强化学习问题的能力。但是DQN有个问题，就是它并不一定能保证Q网络的收敛，也就是说不一定可以得到收敛后的Q网络参数。这会导致训练出的模型效果很差。针对这个问题衍生出了DQN的很多变种，比如Nature DQN(NIPS 2015)、Double DQN、Dueling DQN等。</p><p>&nbsp;</p><h2 id="Nature-DQN算法"><a href="#Nature-DQN算法" class="headerlink" title="Nature DQN算法"></a>Nature DQN算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;2015年，DeepMind对NIPS DQN进行了一次重大改造，并在Nature上披露了这个模型，即：Nature DQN。论文：<a href="https://lrk612.com/resources/Human-level%20control%20through%20deep%20reinforcement%20learning.pdf">Human-level control through deep reinforcement learning</a></p><h4 id="针对问题"><a href="#针对问题" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;注意到上面DQN算法其实在实际应用时存在一些问题，其中一个就是目标Q值的计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109102614.png" alt="image-20220109102614326" style="zoom: 33%;" /><p>&emsp;&emsp;使用到了当前待训练网络的参数，而计算的结果 yj 又被用于反向传播更新网络的参数，二者循环依赖，相关性太强不利于算法收敛。</p><h4 id="优化：双网络结构"><a href="#优化：双网络结构" class="headerlink" title="优化：双网络结构"></a>优化：双网络结构</h4><p>&emsp;&emsp;Nature DQN尝试用两个Q网络来减少 <code>目标Q值的计算 </code>和 <code>待更新Q网络参数 </code>之间的依赖关系。</p><p>&emsp;&emsp;<strong>当前Q网络</strong>计算Q估计值用于选择动作，更新模型参数，<strong>目标Q网络</strong>用于计算目标Q值。目标Q网络的网络参数不需要迭代更新，而是每隔一段时间从当前Q网络复制过来，即延时更新，这样可以减少目标Q值和当前Q值的相关性。二者其余部分基本是完全相同的。（要注意的是，两个Q网络的结构是一模一样的。这样才可以复制网络参数 ）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220210140232.png" alt="image-20220210140117411" style="zoom:30%;" /><center>图片 via 18级种子班 zyh</center><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220207145618.png" alt="image-20220207145618398" style="zoom:60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、当前Q网络Q、目标Q网络Q′、批量梯度下降的样本数m、目标Q网络参数更新频率C</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数（目标Q网络只是辅助工具）</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w，清空经验池D</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前序列的第一个状态，求其特征向量 ϕ(S)</p></li><li><p>把 ϕ(S) 输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出（Q估计值），用 ε-greedy 策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池 D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，把S‘  和A’ 输入<strong>目标Q网络</strong>结合贪婪策略计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162500.png" alt="image-20220116162500661" style="zoom: 67%;" /><p>（注意：公式里的是Q’ 不是Q )</p></li><li><p>把S‘  和A’ 输入<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求损失函数Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数w。这里使用的仍是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /></li><li><p>if i%C == 0：更新<strong>目标Q网络</strong>参数w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，6步用目标Q网络计算目标Q值、2、7步用的是当前Q网络计算Q估计值。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;比起上面普通DQN的代码，这里有两个三层神经网络，一个是当前Q网络，一个是目标Q网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;1000轮左右收敛，比DQN更稳定，平均Reward基本固定在200</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151545.png" alt="image-20220117151545443" style="zoom:50%;" /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Nature DQN 对 普通DQN 做了相关性方面的改进，这个改进虽然不错，但是仍然没有解决DQN的 很多问题，比如：</p><ul><li>目标Q值的计算是否准确？全部通过max Q来计算有没有问题？</li><li>从经验池随机采样的方法好吗？按道理不同样本的重要性是不一样的。</li><li>Q值代表状态动作的价值，那么单独动作价值的评估会不会更准确？</li></ul><p>&emsp;&emsp;第一个问题对应的改进是Double DQN, 第二个问题的改进是Prioritised Replay DQN，第三个问题的改进是Dueling DQN。</p><p>&nbsp;</p><h2 id="Double-DQN算法"><a href="#Double-DQN算法" class="headerlink" title="Double DQN算法"></a>Double DQN算法</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Double DQN 是由DeepMind团队在2015年提出来的，由Double Q-Learning迁移而来，是传统机器学习的思路，即不一定非要有神经网络结构才能训练，只要有两个一模一样的Q-Learning或DQN网络就可以构成Double模型。论文：<a href="https://lrk612.com/resources/Deep%20Reinforcement%20Learning%20with%20Double%20Q-learning.pdf">Deep Reinforcement Learning with Double Q-learning</a></p><h4 id="针对问题-1"><a href="#针对问题-1" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;在DDQN之前，基本上所有的目标Q值都是通过贪婪法直接得到的，无论是Q-Learning、普通DQN 还是 Nature DQN。比如对于Nature DQN，虽然用了两个Q网络并使用目标Q网络计算目标Q值，其第 j 个样本的目标Q值的计算还是贪婪法得到的：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162500.png" alt="image-20220116162500661" style="zoom: 67%;" /><p>&emsp;&emsp;使用max虽然可以快速让Q值向可能的优化目标靠拢，但是很容易过犹不及，导致过度估计(Over Estimation)。所谓过度估计就是最终得到的算法模型有很大的偏差(bias)。而DDQN通过解耦 <code>目标Q值动作的选择</code> 和 <code>目标Q值的估计</code> 这两步，来达到消除过度估计的问题。</p><h4 id="优化：Q值与动作解耦"><a href="#优化：Q值与动作解耦" class="headerlink" title="优化：Q值与动作解耦"></a>优化：Q值与动作解耦</h4><p>Nature DQN对于非终止状态，其目标Q值的计算式子是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162949.png" alt="image-20220116162627124" style="zoom: 67%;" /><hr><p>但是在DDQN里，不再是直接把S‘ 输入目标Q网络然后按贪婪策略找最大Q值，而是先把S‘ 输入当前Q网络（用于估计Q值，需要被更新的那个网络）中找出最大Q值对应的动作amax(S′,j,w)，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192104.png" alt="image-20220110192104796" style="zoom:33%;" /><p>然后利用这个选择出来的动作amax(S′j,w)在目标网络里面去计算目标Q值。即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192330.png" alt="image-20220110192330730" style="zoom:33%;" /><p>综合起来写就是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192450.png" alt="image-20220110192450277" style="zoom:33%;" /><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、当前Q网络、目标Q网络、批量梯度下降的样本数m、目标Q网络参数更新频率C</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w，清空经验池D</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前状态序列的第一个状态, 拿到其特征向量 ϕ(S)</p></li><li><p>把ϕ(S)输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池 D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，用<strong>Q值与动作解耦的思想</strong>计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110193225.png" alt="image-20220110193225013" style="zoom:33%;" /></li><li><p>用<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求损失函数 Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数 w</p></li><li><p>if i%C == 0：更新<strong>目标Q网络</strong>参数 w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，f步两个网络都用了、g步只用到了当前Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;与Nature DQN代码只有在目标Q值的计算处不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        current_Q_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        max_action_next = np.argmax(current_Q_batch, axis=<span class="number">1</span>)</span><br><span class="line">        target_Q_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target_Q_value = target_Q_batch[i, max_action_next[i]]</span><br><span class="line">                y_batch.append(reward_batch[i] + GAMMA * target_Q_value)</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;1000轮左右收敛，比较稳定，但是平均Reward后期有抖动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151914.png" alt="image-20220117151914056" style="zoom:50%;" /><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;过估计问题是Q-Learning算法与生俱来的，并遗传给了后代”DQN“。从统计学的角度来看，如果在输出端对每个动作的估值Q的过估计幅度都一样，那么和没有过估计效果是一样的。但是如果过估计是不均匀的，那么这样学到的策略未必是最优解，此时Double DQN就派上用场了。</p><p>&nbsp;</p><h2 id="Prioritized-Replay-DQN算法"><a href="#Prioritized-Replay-DQN算法" class="headerlink" title="Prioritized Replay DQN算法"></a>Prioritized Replay DQN算法</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;优先回放的概念最早在2016年由发表于ICLR的论文：<a href="https://lrk612.com/resources/Prioritized%20experience%20%20replay.pdf">Prioritized experience  replay</a></p><h4 id="针对问题-2"><a href="#针对问题-2" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;普通DQN、Nature DQN、DDQN等都是通过经验回放来采样，进而做目标Q值的计算的。在采样时经验池里的所有样本都有相同的被采样概率。但是注意到在经验池里面的不同的样本由于TD误差的不同，对反向传播的作用是不一样的。TD误差越大，对反向传播的作用越大。而TD误差小的样本对反向梯度的计算影响不大。在Q网络中，TD误差就是目标Q网络计算的目标Q值和当前Q网络计算的Q值之间的差距。这样如果TD误差的绝对值|δ(t)|较大的样本更容易被采样，则算法会比较容易收敛。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="经验池优化"><a href="#经验池优化" class="headerlink" title="经验池优化"></a>经验池优化</h5><p>&emsp;&emsp;Prioritized Replay DQN的经验池中每个样本的优先级正比于TD误差绝对值|δ(t)|。由于引入了经验回放的优先级，Prioritized Replay DQN的经验池和之前的其他DQN算法的经验池不一样，因为这个优先级大小会影响它被采样的概率。在实际使用中，通常使用SumTree这样的二叉树结构来做带优先级的经验回放池样本的存储：</p><p>​                                                                    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210718214249.png" alt="image-20210717092213437" style="zoom: 33%;" /></p><p>&emsp;&emsp;所有的经验回放样本只保存在最下面的叶子节点上面，一个节点一个样本，内部节点不保存样本数据。叶子节点除了保存数据以外，还要保存该样本的优先级数值（TD误差）。对于内部节点每个节点只保存自己的儿子节点的优先级值之和。以上面的树结构为例，根节点是42，如果要采样一个样本，可以在[0, 42]之间做均匀采样，采样到哪个区间，就是哪个样本。</p><p>（注意：当Q网络参数进行了梯度更新后，需要重新计算TD误差，并将TD误差更新到SunTree上面）</p><h5 id="Loss-Function优化"><a href="#Loss-Function优化" class="headerlink" title="Loss Function优化"></a>Loss Function优化</h5><p>&emsp;&emsp;上面使用的损失函数都是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /><p>&emsp;&emsp;考虑了样本优先级的损失函数要加上优先权重因子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162911.png" alt="image-20220116162911599" style="zoom:67%;" /><p>&emsp;&emsp;( 其中wj是第j个样本的优先级权重，由TD误差|δ(t)|归一化得到 )</p><h3 id="算法流程（集成了DDQN）"><a href="#算法流程（集成了DDQN）" class="headerlink" title="算法流程（集成了DDQN）"></a>算法流程（集成了DDQN）</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、采样权重系数β、衰减因子γ、探索率ϵ、当前Q网络、目标Q网络、批量梯度下降的样本数m、目标Q网络参数更新频率C、SumTree的叶子节点数S</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w</p></li><li><p>初始化经验池SumTree的默认数据结构，SumTree的S个叶子节点的优先级pj都初始化为1</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前状态序列的第一个状态, 拿到其特征向量 ϕ(S)</p></li><li><p>把ϕ(S)输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入SumTree</p></li><li><p>前进一步：S = S’</p></li><li><p>从SumTree中<strong>依概率</strong> <code>P(j) = pj / ∑(pi)</code> 采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，用<strong>Q值与动作解耦的思想</strong>计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110193225.png" alt="image-20220110193225013" style="zoom:33%;" /></li><li><p>用<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求<strong>带优先权重因子wj的</strong>损失函数 Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数 w</p><p>优先权重因子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111145825.png" alt="image-20220111145825168" style="zoom:33%;" /><p>损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162911.png" alt="image-20220116162911599" style="zoom:67%;" /></li><li><p>用更新参数后的当前Q网络重新计算经验池中每个样本的Q估计值，然后用目标Q值和新的Q估计值算出新的TD误差作为优先级更新SumTree</p></li><li><p>if i%C == 0：更新目标Q网络参数w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤3.2</p></li></ol></li></ol><p>（注意，f步两个网络都用了、g步只用到了当前Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This SumTree code is a modified version and the original code is from:</span></span><br><span class="line"><span class="string">    https://github.com/jaara/AI-blog/blob/master/SumTree.py</span></span><br><span class="line"><span class="string">    Story data with its priority in the tree.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data_pointer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity  <span class="comment"># for all priority values</span></span><br><span class="line">        self.tree = np.zeros(<span class="number">2</span> * capacity - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># [-------------Parent nodes------------][------leaves to recode priority------]</span></span><br><span class="line">        <span class="comment">#             size: capacity - 1                       size: capacity</span></span><br><span class="line">        self.data = np.zeros(capacity, dtype=<span class="built_in">object</span>)  <span class="comment"># for all transitions</span></span><br><span class="line">        <span class="comment"># [--------------data frame-------------]</span></span><br><span class="line">        <span class="comment">#             size: capacity</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, p, data</span>):</span></span><br><span class="line">        tree_idx = self.data_pointer + self.capacity - <span class="number">1</span></span><br><span class="line">        self.data[self.data_pointer] = data  <span class="comment"># update data_frame</span></span><br><span class="line">        self.update(tree_idx, p)  <span class="comment"># update tree_frame</span></span><br><span class="line"></span><br><span class="line">        self.data_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.data_pointer &gt;= self.capacity:  <span class="comment"># replace when exceed the capacity</span></span><br><span class="line">            self.data_pointer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, tree_idx, p</span>):</span></span><br><span class="line">        change = p - self.tree[tree_idx]</span><br><span class="line">        self.tree[tree_idx] = p</span><br><span class="line">        <span class="comment"># then propagate the change through tree</span></span><br><span class="line">        <span class="keyword">while</span> tree_idx != <span class="number">0</span>:    <span class="comment"># this method is faster than the recursive loop in the reference code</span></span><br><span class="line">            tree_idx = (tree_idx - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            self.tree[tree_idx] += change</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_leaf</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Tree structure and array storage:</span></span><br><span class="line"><span class="string">        Tree index:</span></span><br><span class="line"><span class="string">             0         -&gt; storing priority sum</span></span><br><span class="line"><span class="string">            / \</span></span><br><span class="line"><span class="string">          1     2</span></span><br><span class="line"><span class="string">         / \   / \</span></span><br><span class="line"><span class="string">        3   4 5   6    -&gt; storing priority for transitions</span></span><br><span class="line"><span class="string">        Array type for storing:</span></span><br><span class="line"><span class="string">        [0,1,2,3,4,5,6]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        parent_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:     <span class="comment"># the while loop is faster than the method in the reference code</span></span><br><span class="line">            cl_idx = <span class="number">2</span> * parent_idx + <span class="number">1</span>         <span class="comment"># this leaf&#x27;s left and right kids</span></span><br><span class="line">            cr_idx = cl_idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cl_idx &gt;= <span class="built_in">len</span>(self.tree):        <span class="comment"># reach bottom, end search</span></span><br><span class="line">                leaf_idx = parent_idx</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:       <span class="comment"># downward search, always search for a higher priority node</span></span><br><span class="line">                <span class="keyword">if</span> v &lt;= self.tree[cl_idx]:</span><br><span class="line">                    parent_idx = cl_idx</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    v -= self.tree[cl_idx]</span><br><span class="line">                    parent_idx = cr_idx</span><br><span class="line"></span><br><span class="line">        data_idx = leaf_idx - self.capacity + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> leaf_idx, self.tree[leaf_idx], self.data[data_idx]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_p</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.tree[<span class="number">0</span>]  <span class="comment"># the root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span>(<span class="params"><span class="built_in">object</span></span>):</span>  <span class="comment"># stored as ( s, a, r, s_ ) in SumTree</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This Memory class is modified based on the original code from:</span></span><br><span class="line"><span class="string">    https://github.com/jaara/AI-blog/blob/master/Seaquest-DDQN-PER.py</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    epsilon = <span class="number">0.01</span>  <span class="comment"># small amount to avoid zero priority</span></span><br><span class="line">    alpha = <span class="number">0.6</span>  <span class="comment"># [0~1] convert the importance of TD error to priority</span></span><br><span class="line">    beta = <span class="number">0.4</span>  <span class="comment"># importance-sampling, from initial value increasing to 1</span></span><br><span class="line">    beta_increment_per_sampling = <span class="number">0.001</span></span><br><span class="line">    abs_err_upper = <span class="number">1.</span>  <span class="comment"># clipped abs error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.tree = SumTree(capacity)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store</span>(<span class="params">self, transition</span>):</span></span><br><span class="line">        max_p = np.<span class="built_in">max</span>(self.tree.tree[-self.tree.capacity:])</span><br><span class="line">        <span class="keyword">if</span> max_p == <span class="number">0</span>:</span><br><span class="line">            max_p = self.abs_err_upper</span><br><span class="line">        self.tree.add(max_p, transition)   <span class="comment"># set the max p for new p</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        b_idx, b_memory, ISWeights = np.empty((n,), dtype=np.int32), np.empty(</span><br><span class="line">            (n, self.tree.data[<span class="number">0</span>].size)), np.empty((n, <span class="number">1</span>))</span><br><span class="line">        pri_seg = self.tree.total_p / n       <span class="comment"># priority segment</span></span><br><span class="line">        self.beta = np.<span class="built_in">min</span>(</span><br><span class="line">            [<span class="number">1.</span>, self.beta + self.beta_increment_per_sampling])  <span class="comment"># max = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for later calculate ISweight</span></span><br><span class="line">        min_prob = np.<span class="built_in">min</span>(</span><br><span class="line">            self.tree.tree[-self.tree.capacity:]) / self.tree.total_p</span><br><span class="line">        <span class="keyword">if</span> min_prob == <span class="number">0</span>:</span><br><span class="line">            min_prob = <span class="number">0.00001</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = pri_seg * i, pri_seg * (i + <span class="number">1</span>)</span><br><span class="line">            v = np.random.uniform(a, b)</span><br><span class="line">            idx, p, data = self.tree.get_leaf(v)</span><br><span class="line">            prob = p / self.tree.total_p</span><br><span class="line">            ISWeights[i, <span class="number">0</span>] = np.power(prob/min_prob, -self.beta)</span><br><span class="line">            b_idx[i], b_memory[i, :] = idx, data</span><br><span class="line">        <span class="keyword">return</span> b_idx, b_memory, ISWeights</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">batch_update</span>(<span class="params">self, tree_idx, abs_errors</span>):</span></span><br><span class="line">        abs_errors += self.epsilon  <span class="comment"># convert to abs and avoid 0</span></span><br><span class="line">        clipped_errors = np.minimum(abs_errors, self.abs_err_upper)</span><br><span class="line">        ps = np.power(clipped_errors, self.alpha)</span><br><span class="line">        <span class="keyword">for</span> ti, p <span class="keyword">in</span> <span class="built_in">zip</span>(tree_idx, ps):</span><br><span class="line">            self.tree.update(ti, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_total = <span class="number">0</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.memory = Memory(capacity=REPLAY_SIZE)</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.ISWeights = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])</span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(</span><br><span class="line">            self.ISWeights * (tf.square(self.y_input - Q_action)))</span><br><span class="line">        self.abs_errors = tf.<span class="built_in">abs</span>(self.y_input - Q_action)</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_, done</span>):</span></span><br><span class="line">        transition = np.hstack((s, a, r, s_, done))</span><br><span class="line">        <span class="comment"># have high priority for newly arrived transition</span></span><br><span class="line">        self.memory.store(transition)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(state,one_hot_action,reward,next_state,done)</span></span><br><span class="line">        self.store_transition(state, one_hot_action, reward, next_state, done)</span><br><span class="line">        self.replay_total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.replay_total &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        tree_idx, minibatch, ISWeights = self.memory.sample(BATCH_SIZE)</span><br><span class="line">        state_batch = minibatch[:, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        action_batch = minibatch[:, <span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">        reward_batch = [data[<span class="number">6</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = minibatch[:, <span class="number">7</span>:<span class="number">11</span>]</span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        current_Q_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        max_action_next = np.argmax(current_Q_batch, axis=<span class="number">1</span>)</span><br><span class="line">        target_Q_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">11</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target_Q_value = target_Q_batch[i, max_action_next[i]]</span><br><span class="line">                y_batch.append(reward_batch[i] + GAMMA * target_Q_value)</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch,</span><br><span class="line">            self.ISWeights: ISWeights</span><br><span class="line">        &#125;)</span><br><span class="line">        _, abs_errors, _ = self.session.run([self.optimizer, self.abs_errors, self.cost], feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch,</span><br><span class="line">            self.ISWeights: ISWeights</span><br><span class="line">        &#125;)</span><br><span class="line">        self.memory.batch_update(tree_idx, abs_errors)  <span class="comment"># update priority</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;因为经验池使用SumTree结构导致计算量较大，训练起来很慢，不过600轮左右就收敛了，但后期同样有抖动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117154635.png" alt="image-20220117154635353" style="zoom:50%;" /><p>&nbsp;</p><h2 id="Dueling-DQN算法"><a href="#Dueling-DQN算法" class="headerlink" title="Dueling DQN算法"></a>Dueling DQN算法</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Dueling DQN 也是DeepMind的大作之一。论文：<a href="https://lrk612.com/resources/Dueling%20Network%20Architectures%20for%20Deep%20Reinforcement%20Learning.pdf">Dueling Network Architectures for Deep Reinforcement Learning</a></p><h4 id="优化：从网络结构下手"><a href="#优化：从网络结构下手" class="headerlink" title="优化：从网络结构下手"></a>优化：从网络结构下手</h4><p>&emsp;&emsp;DDQN中通过优化目标Q值的计算来优化算法，Prioritized Replay DQN中通过优化经验回放池按权重采样来优化算法，而在Dueling DQN中通过优化神经网络的结构来优化算法。</p><p>&emsp;&emsp;Dueling DQN将Q网络增加了两部分：第一部分仅与状态S有关，与具体要采用的动作A无关，叫做价值函数部分，记做 <code>V(S,w,α)</code> ；第二部分同时与状态状态S和动作A有关，这部分叫做优势函数(Advantage Function)部分，记为 <code>A(S,A,w,β)</code>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210718214253.png" alt="image-20210717102817738" style="zoom: 50%;" /><p>&emsp;&emsp;最终价值函数重新表示为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111151330.png" alt="image-20220111151330160" style="zoom:33%;" /><p>（其中，w是公共部分的网络参数，而α是价值函数部分独有的网络参数，β是优势函数部分独有的网络参数 。注意最右边减去均值的操作是在对优势函数部分做中心化的处理 ）</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;与Nature DQN代码只有两个Q网络的结构不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer 1</span></span><br><span class="line">            h_layer_1 = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for state value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Value&#x27;</span>):</span><br><span class="line">                W21 = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">                b21 = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">                self.V = tf.matmul(h_layer_1, W21) + b21</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for action value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Advantage&#x27;</span>):</span><br><span class="line">                W22 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">                b22 = self.bias_variable([self.action_dim])</span><br><span class="line">                self.A = tf.matmul(h_layer_1, W22) + b22</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Q Value layer</span></span><br><span class="line">                self.Q_value = self.V + \</span><br><span class="line">                    (self.A - tf.reduce_mean(self.A, axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer 1</span></span><br><span class="line">            h_layer_1t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for state value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Value&#x27;</span>):</span><br><span class="line">                W2v = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">                b2v = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">                self.VT = tf.matmul(h_layer_1t, W2v) + b2v</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for action value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Advantage&#x27;</span>):</span><br><span class="line">                W2a = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">                b2a = self.bias_variable([self.action_dim])</span><br><span class="line">                self.AT = tf.matmul(h_layer_1t, W2a) + b2a</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Q Value layer</span></span><br><span class="line">                self.target_Q_value = self.VT + \</span><br><span class="line">                    (self.AT - tf.reduce_mean(self.AT, axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;3000轮了都没收敛……</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117152314.png" alt="image-20220117152314892" style="zoom:50%;" /><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Dueling DQN使用了比较巧妙的方法，对状态的估值和独立于状态的动作优势估值进行解耦，从而使得网络能够学到更为准确的状态价值估值和动作优势估值。</p><p>&nbsp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这里一共总结了5种DQN算法：普通DQN、Nature DQN、DDQN、Prioritized Replay DQN、Dueling DQN，目前使用的比较主流的是后面三种算法思路，这三种算法思路也是可以混着一起使用的，相互并不排斥。</p><table><thead><tr><th>DQN算法族</th><th>特点</th></tr></thead><tbody><tr><td>NIPS DQN</td><td>第一个DQN算法，简单而有意义</td></tr><tr><td>Nature DQN</td><td>引入双网络结构，规避 <code>目标Q值的计算 </code>和 <code>待更新Q网络参数 </code>的过依赖</td></tr><tr><td>Double DQN</td><td>动作选择与动作估值解耦，规避过估计问题</td></tr><tr><td>Dueling DQN</td><td>优化神经网络的结构，将状态估值和动作优势估值解耦</td></tr><tr><td>Prioritized Replay DQN</td><td>在经验回放时引入优先级概念，提高网络学习效率</td></tr></tbody></table><p>&emsp;&emsp;当然DQN家族的算法远远不止这些，还有一些其他的DQN算法没有总结，比如使用一些较复杂的CNN和RNN网络来提高DQN的表达能力，又比如改进探索状态空间的方法等，主要是在DQN的基础上持续优化。</p><p>&emsp;&emsp;DQN算是深度强化学习的中的主流流派，代表了Value-Based这一大类深度强化学习算法。但是它也有自己的一些问题，就是绝大多数DQN只能处理离散的动作集合，不能处理连续的动作集合。虽然NAF DQN可以解决这个问题，但是方法过于复杂了。而深度强化学习的另一个主流流派Policy-Based而可以较好的解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计网课设】基于强化学习的TCP拥塞控制算法优化</title>
      <link href="/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
      <url>/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;我们使用mininet平台作为网络拓扑仿真工具，选择TCP拥塞控制算法作为研究对象，以项目组工作技术背景：5G无线通信场景中的强化学习作为切入点，对 Linux 内核搭载的经典 TCP 拥塞控制算法：Reno、Vegas、Veno、BBR、CUBIC进行调研学习，最终决定对超参数依赖性较强的TCP_Veno算法进行强化学习调优。期间我们把算法直接集成到Linux内核的拥塞控制模块，克服了内核态进程内存空间与用户态Python程序交互的映射问题，并使用C语言构造Python模块提高算法效率。同时，我们的强化学习环境也集成到了OpenAI Gym中。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116104456.png" alt="image-20220116104456599" style="zoom: 80%;" /><span id="more"></span><p>&nbsp;</p><h2 id="Linux-TCP拥塞控制算法"><a href="#Linux-TCP拥塞控制算法" class="headerlink" title="Linux TCP拥塞控制算法"></a>Linux TCP拥塞控制算法</h2><h3 id="Linux如何实现TCP拥塞控制"><a href="#Linux如何实现TCP拥塞控制" class="headerlink" title="Linux如何实现TCP拥塞控制"></a>Linux如何实现TCP拥塞控制</h3><p>&emsp;&emsp;其实在Linux内核代码中，拥塞控制包括4个部分：<code>拥塞控制框架</code>、<code>框架与 TCP 其余部分的接口</code>、<code>恢复状态机</code>、<code>不同拥塞的细节控制算法</code>，我们调研的重点是<strong>拥塞控制框架</strong>和<strong>框架与 TCP 其余部分的接口</strong>。</p><h4 id="TCP实现中的重要结构体-枚举类型"><a href="#TCP实现中的重要结构体-枚举类型" class="headerlink" title="TCP实现中的重要结构体/枚举类型"></a>TCP实现中的重要结构体/枚举类型</h4><h5 id="tcp-ca-state"><a href="#tcp-ca-state" class="headerlink" title="tcp_ca_state"></a>tcp_ca_state</h5><p>&emsp;&emsp;TCP 的拥塞控制实现中使用<strong>状态机</strong>来保持和在连接的不同状态之间切换，以用于恢复目的。这些不同的状态在 tcp.h 中的枚举类型中定义：</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Open</td><td>代表TCP连接处于正常状态，没有可疑事件。此状态下接收到的数据包通过快速路径。</td></tr><tr><td>Disorder</td><td>收到了ACK 或 dupACK，代表数据包乱序。此状态下一些处理从快路径移动到慢路径</td></tr><tr><td>CER</td><td>处理一些拥塞通知事件（例：ECN 或本地设备拥塞）时进入此状态</td></tr><tr><td>Recovery</td><td>这种状态表明拥塞窗口已经减小，连接处于快速重传阶段</td></tr><tr><td>Loss</td><td>这种状态表明由于 RTO 超时或 SACK 拒绝，拥塞窗口减小</td></tr></tbody></table><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tcp_ca_state</span> &#123;</span></span><br><span class="line">TCP_CA_Open = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Open(1&lt;&lt;TCP_CA_Open)</span></span><br><span class="line">TCP_CA_Disorder = <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span></span><br><span class="line">TCP_CA_CWR = <span class="number">2</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_CWR(1&lt;&lt;TCP_CA_CWR)</span></span><br><span class="line">TCP_CA_Recovery = <span class="number">3</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span></span><br><span class="line">TCP_CA_Loss = <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Loss(1&lt;&lt;TCP_CA_Loss)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h5 id="tcp-congestion-ops"><a href="#tcp-congestion-ops" class="headerlink" title="tcp_congestion_ops"></a>tcp_congestion_ops</h5><p>&emsp;&emsp;定义了用于不同可插拔拥塞控制算法的 TCP 拥塞处理接口，是一个函数调用指针的结构。在 tcp.h 文件中定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line">u32 key;</span><br><span class="line">u32 flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize private data (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*init)(struct sock *sk);</span><br><span class="line"><span class="comment">/* cleanup private data  (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*release)(struct sock *sk);</span><br><span class="line"><span class="comment">/* return slow start threshold (required) */</span></span><br><span class="line">u32 (*ssthresh)(struct sock *sk);</span><br><span class="line"><span class="comment">/* do new cwnd calculation (required) */</span></span><br><span class="line"><span class="keyword">void</span> (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);</span><br><span class="line"><span class="comment">/* call before changing ca_state (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*set_state)(struct sock *sk, u8 new_state);</span><br><span class="line"><span class="comment">/* call when cwnd event occurs (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*cwnd_event)(struct sock *sk, <span class="keyword">enum</span> tcp_ca_event ev);</span><br><span class="line"><span class="comment">/* call when ack arrives (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*in_ack_event)(struct sock *sk, u32 flags);</span><br><span class="line"><span class="comment">/* new value of cwnd after loss (required) */</span></span><br><span class="line">u32  (*undo_cwnd)(struct sock *sk);</span><br><span class="line"><span class="comment">/* hook for packet ack accounting (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*pkts_acked)(struct sock *sk, <span class="keyword">const</span> struct ack_sample *sample);</span><br><span class="line"><span class="comment">/* override sysctl_tcp_min_tso_segs */</span></span><br><span class="line">u32 (*min_tso_segs)(struct sock *sk);</span><br><span class="line"><span class="comment">/* returns the multiplier used in tcp_sndbuf_expand (optional) */</span></span><br><span class="line">u32 (*sndbuf_expand)(struct sock *sk);</span><br><span class="line"><span class="comment">/* call when packets are delivered to update cwnd and pacing rate,</span></span><br><span class="line"><span class="comment"> * after all the ca_state processing. (optional)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*cong_control)(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs);</span><br><span class="line"><span class="comment">/* get info for inet_diag (optional) */</span></span><br><span class="line"><span class="keyword">size_t</span> (*get_info)(struct sock *sk, u32 ext, <span class="keyword">int</span> *attr,</span><br><span class="line">   <span class="keyword">union</span> tcp_cc_info *info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[TCP_CA_NAME_MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中一些重要的函数说明如下：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>init()</td><td>在收到第一个确认(ACK)之后和第一次调用拥塞控制算法之前调用</td></tr><tr><td>pkts_acked()</td><td>收到确认某些新数据包的确认(ACK)时导致调用此函数，通过 num_acked 参数传递确认的数据包数</td></tr><tr><td>cong_avoid()</td><td>每次收到确认(ACK)并且拥塞控制状态允许拥塞窗口增加时调用此函数</td></tr><tr><td>undo_cwnd()</td><td>在检测到错误的丢失检测（由于错误的超时或数据包重新排序）时，返回流的拥塞窗口大小</td></tr></tbody></table><p>&nbsp;</p><h4 id="内核中-TCP-代码的主要文件"><a href="#内核中-TCP-代码的主要文件" class="headerlink" title="内核中 TCP 代码的主要文件"></a>内核中 TCP 代码的主要文件</h4><p>&emsp;&emsp;Linux Kernel中有关TCP的代码基本上都在<code>net/ipv4/</code>目录下，主要包括：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>tcp.h</td><td>包含TCP相关结构体的声明，在include/net/下</td></tr><tr><td>tcp.c</td><td>包含通用 TCP 代码、涵盖不同Socket之间的接口和TCP代码的其余部分</td></tr><tr><td>tcp_input.c</td><td>处理来自网络的传入数据包的最大和最重要的文件；包含恢复状态机的代码</td></tr><tr><td>tcp_output.c</td><td>处理向网络发送数据包；包含一些从拥塞控制框架调用的函数</td></tr><tr><td>tcp_ipv4.c</td><td>IPv4 TCP 特定代码；将相关数据包交给拥塞控制框架</td></tr><tr><td>tcp_timer.c</td><td>实现定时器管理功能</td></tr><tr><td>tcp_cong.c</td><td>实现可插拔 TCP 拥塞控制支持和拥塞控制的核心框架；默认使用 New Reno 机制</td></tr><tr><td>tcp_[name of algorithm].c</td><td>不同TCP拥塞控制算法文件，例如：tcp_vegas.c、tcp_cubic.c等</td></tr></tbody></table><p>&nbsp;</p><h4 id="TCP拥塞控制算法-注册-初始化-传参"><a href="#TCP拥塞控制算法-注册-初始化-传参" class="headerlink" title="TCP拥塞控制算法 注册-初始化-传参"></a>TCP拥塞控制算法 注册-初始化-传参</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>实现的算法可以通过实例化该结构体、调用注册函数实现算法的注册（例：bbr）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> <span class="title">tcp_bbr_cong_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.flags= TCP_CONG_NON_RESTRICTED,</span><br><span class="line">.name= <span class="string">&quot;bbr&quot;</span>,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.init= bbr_init,</span><br><span class="line">.cong_control= bbr_main,</span><br><span class="line">.sndbuf_expand= bbr_sndbuf_expand,</span><br><span class="line">.undo_cwnd= bbr_undo_cwnd,</span><br><span class="line">.cwnd_event= bbr_cwnd_event,</span><br><span class="line">.ssthresh= bbr_ssthresh,</span><br><span class="line">.min_tso_segs= bbr_min_tso_segs,</span><br><span class="line">.get_info= bbr_get_info,</span><br><span class="line">.set_state= bbr_set_state,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">bbr_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct bbr) &gt; ICSK_CA_PRIV_SIZE);</span><br><span class="line"><span class="keyword">return</span> tcp_register_congestion_control(&amp;tcp_bbr_cong_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li><p>算法的参数通常是定义在一个结构体里（例：cubic）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BIC TCP Parameters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> &#123;</span></span><br><span class="line">u32cnt;<span class="comment">/* increase cwnd by 1 after ACKs */</span></span><br><span class="line">u32last_max_cwnd;<span class="comment">/* last maximum snd_cwnd */</span></span><br><span class="line">u32last_cwnd;<span class="comment">/* the last snd_cwnd */</span></span><br><span class="line">u32last_time;<span class="comment">/* time when updated last_cwnd */</span></span><br><span class="line">u32bic_origin_point;<span class="comment">/* origin point of bic function */</span></span><br><span class="line">u32bic_K;<span class="comment">/* time to origin point</span></span><br><span class="line"><span class="comment">   from the beginning of the current epoch */</span></span><br><span class="line">u32delay_min;<span class="comment">/* min delay (msec &lt;&lt; 3) */</span></span><br><span class="line">u32epoch_start;<span class="comment">/* beginning of an epoch */</span></span><br><span class="line">u32ack_cnt;<span class="comment">/* number of acks */</span></span><br><span class="line">u32tcp_cwnd;<span class="comment">/* estimated tcp cwnd */</span></span><br><span class="line">u16unused;</span><br><span class="line">u8sample_cnt;<span class="comment">/* number of samples to decide curr_rtt */</span></span><br><span class="line">u8found;<span class="comment">/* the exit point is found? */</span></span><br><span class="line">u32round_start;<span class="comment">/* beginning of each round */</span></span><br><span class="line">u32end_seq;<span class="comment">/* end_seq of the round */</span></span><br><span class="line">u32last_ack;<span class="comment">/* last time when the ACK spacing is close */</span></span><br><span class="line">u32curr_rtt;<span class="comment">/* the minimum rtt of current round */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化函数中，算法申请私有空间，初始化参数</p></li><li><p>可以在算法模块中声明一些参数，并调<code>module_param(name,type,perm)</code>使得参数可以在insmod的时候传入（例：cubic）</p><ul><li>name 既是用户看到的参数名，又是模块内接受参数的变量</li><li>type 表示参数的数据类型，是下列之一：byte, short, ushort, int, uint, long, ulong, charp, bool, invbool;</li><li>perm 指定了在sysfs中相应文件的访问权限。访问权限与linux文件访问权限相同的方式管理，如0644，或使用stat.h中的宏如S_IRUGO表示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note parameters that are used for precomputing scale factors are read-only */</span></span><br><span class="line">module_param(fast_convergence, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(fast_convergence, <span class="string">&quot;turn on/off fast convergence&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><ul><li><p>根据上面的信息，我们知道算法的参数定义在结构体里</p></li><li><p>算法的每个步骤，都会从传入的socket得到一个算法结构体，这个过程是怎么实现的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***example cubic***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> *<span class="title">ca</span> =</span> inet_csk_ca(sk);</span><br><span class="line"><span class="comment">/***example bbr***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bbr</span> *<span class="title">bbr</span> =</span> inet_csk_ca(sk);</span><br></pre></td></tr></table></figure></li><li><p>首先从当前socket获取tcp socket结构体</p></li><li><ul><li>tcp_sock结构体定义于<code>/include/linux/tcp.h#L138</code></li><li>主要用来保存tcp相关的信息</li></ul></li><li><p>然后从socket获取算法结构体</p></li><li><ul><li>调用<code>inet_csk_ca</code>，获得<code>inet_csk(sk)-&gt;icsk_ca_priv</code></li><li><code>icsk_ca_priv</code>是<code>inet_connection_sock</code>结构体的一部分</li></ul></li></ul><p>&nbsp;</p><h3 id="Linux-内核拥塞控制算法浅析"><a href="#Linux-内核拥塞控制算法浅析" class="headerlink" title="Linux 内核拥塞控制算法浅析"></a>Linux 内核拥塞控制算法浅析</h3><h4 id="TCP-Vegas"><a href="#TCP-Vegas" class="headerlink" title="TCP Vegas"></a>TCP Vegas</h4><blockquote><p>REF:  <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p><p><em>A TCP sender can easily measure available bandwidth; the simplest measurement is cwnd/RTT (measured in packets/sec). Let us denote this bandwidth estimate by BWE; for the time being we will accept BWE as accurate, though see</em> <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html#ack-compression"><em>15.6.1  ACK Compression and Westwood+</em></a> <em>below. TCP Vegas estimates RTTnoLoad by the minimum RTT (RTTmin) encountered during the connection. The “ideal” cwnd that just saturates the bottleneck link is BWE×RTTnoLoad. Note that BWE will be much more volatile than RTTmin; the latter will typically reach its final value early in the connection, while BWE will fluctuate up and down with congestion (which will also act on RTT, but by increasing it).</em></p></blockquote><ul><li><p>特点：基于时延</p></li><li><p>拥塞判断标准：RTT增加</p></li><li><p>优点：较好地预测带宽</p></li><li><p>缺点：竞争性差。网络环境中有其他主机采用基于丢包的算法时，由于他们会尝试填满缓冲区，会导致Vegas估计地RTT增大，性能不断被挤占，只适用于<strong>只使用Vegas的网络环境</strong>中</p></li></ul><p>&nbsp;</p><h4 id="TCP-Veno"><a href="#TCP-Veno" class="headerlink" title="TCP Veno"></a>TCP Veno</h4><blockquote><p>REF:  <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p><ul><li><p><em>慢开始阶段</em></p><p><em>if Nqueue&lt;𝛽, cwnd = cwnd + 1 each RTT</em></p><p><em>if Nqueue≥𝛽, cwnd = cwnd + 0.5 each RTT</em></p></li><li><p><em>丢包发生时：</em></p><p><em>if Nqueue&lt;𝛽, the loss is probably not due to congestion; set cwnd = (4/5)×cwnd</em></p><p><em>if Nqueue≥𝛽, the loss probably is due to congestion; set cwnd = (1/2)×cwnd as usual</em></p></li></ul></blockquote><ul><li><p>特点：Reno + Vegas</p><ul><li><p>利用Vegas的RTT测量机制，同时保有Reno贪婪、线性增加的机制</p></li><li><p>遇到的丢包大部分是非拥塞产生时，Veno行为接近Reno</p></li></ul></li><li><p>优点：在<strong>时延带宽积适中的、丢包率高的链路</strong>表现好</p></li><li><p>缺点：不能解决长肥管道问题</p></li></ul><p>&nbsp;</p><h4 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h4><ul><li><p>特点：基于带宽和延迟（链路容量）</p></li><li><p>优点：</p><ul><li>避免Bufferfloat</li><li>丢包不作为拥塞控制信号，在长肥管道场景表现也很好，适用于<strong>高带宽、高时延、有一定丢包率的长肥网络</strong></li></ul></li><li><p>缺点：</p><ul><li>当网络设备缓存比较大的时候，竞争不过Cubic等激进算法</li><li>公平性问题：RTT越大，抢占能力越强</li></ul></li></ul><p>&nbsp;</p><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><ul><li><p>特点：</p><ul><li>基于丢包</li><li>AIMD（线性增乘性减）</li></ul></li><li><p>优点：</p><ul><li>在早期<strong>低带宽低时延</strong>网络中能很好发挥作用</li><li>公平性</li></ul></li><li><p>缺点：</p><ul><li>在高带宽高延时网络（long-fat pipe 长肥管道）中，RTT很大，ACK接收时延大，导致拥塞窗口增长慢</li></ul></li></ul><p>&nbsp;</p><h4 id="TCP-CUBIC"><a href="#TCP-CUBIC" class="headerlink" title="TCP CUBIC"></a>TCP CUBIC</h4><ul><li><p>特点：</p><ul><li>基于丢包</li><li>三次函数增加，乘性减小</li></ul></li><li><p>优点：</p><ul><li>Cubic算法的优点在于只要没有出现丢包，就不会主动降低自己的发送速度，可以最大程度的利用网络剩余带宽，提高吞吐量，在<strong>高带宽、低丢包率</strong>的网络中可以发挥较好的性能。</li></ul></li><li><p>缺点：</p><ul><li>无法区分拥塞丢包和传输错误丢包</li><li>过于激进，在没有出现丢包时会不停地增加拥塞窗口的大小，想要填满缓冲区，导致排队时延增加（Bufferbloat现象）</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116114931.png" alt="image-20220116114931639" style="zoom: 40%;" /><p>&nbsp;</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th><strong>名称</strong></th><th><strong>类型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>TCP Reno</td><td>基于丢包 AIMD</td><td>公平性</td><td>不适用于长肥网络</td></tr><tr><td>TCP Cubic</td><td>基于丢包   三次增乘性减</td><td>带宽利用率高</td><td>激进、Bufferbloat</td></tr><tr><td>TCP Vegas</td><td>基于时延RTT</td><td>较好预测带宽</td><td>竞争性差</td></tr><tr><td>TCP Veno</td><td>Reno + Vegas</td><td>折衷、综合以上优点</td><td>没解决长肥网络</td></tr><tr><td>TCP BBR</td><td>基于带宽和时延</td><td>避免Bufferbloat</td><td>公平性模糊</td></tr></tbody></table><p>&nbsp;</p><h2 id="强化学习改进Veno算法"><a href="#强化学习改进Veno算法" class="headerlink" title="强化学习改进Veno算法"></a>强化学习改进Veno算法</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h4 id="Veno算法核心"><a href="#Veno算法核心" class="headerlink" title="Veno算法核心"></a>Veno算法核心</h4><ol><li><p>根据拥塞窗口和往返时间估计当前队列堆积的报文个数N</p><blockquote><p>首先计算期望发送速率和实际速率：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115012.png" alt="image-20220116115012530" style="zoom: 67%;" /><p>二者差值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115023.png" alt="image-20220116115023138" style="zoom: 67%;" /><p>估计堆积报文个数N：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115036.png" alt="image-20220116115036767" style="zoom:67%;" /></blockquote></li><li><p>根据N值调整拥塞控制算法</p><blockquote><p>慢启动阶段：与Reno相同无变化</p><p>AIMD——加性增阶段：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115049.png" alt="image-20220116115049018" style="zoom:67%;" /><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;beta 是一个超参数、增速1、0.5也是超参</p><p>AIMD——乘性减阶段：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115059.png" alt="image-20220116115059582" style="zoom: 60%;" /><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4/5、1/2也是超参</p></blockquote></li></ol><h4 id="强化学习设计思路"><a href="#强化学习设计思路" class="headerlink" title="强化学习设计思路"></a>强化学习设计思路</h4><p>目标：优化超参数（核心函数：tcp_veno_cong_avoid（））</p><p>输入：</p><ul><li><p>basertt</p></li><li><p>minrtt   # 在Veno中这个变量其实是实时rtt，并不是最小rtt</p></li></ul><p>输出：</p><ul><li><p>beta</p></li><li><p>threshold1（加性增时）</p></li></ul><p>注意，加性增时的”0.5“在源代码中不是通过变量表示的，而是通过标志位veno-&gt;cnt，所以需要重构代码：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116131249.png" alt="image-20220116131249660" style="zoom:50%;" /><p>模型框架：(基于DQN)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105019.png" alt="image-20220116105019402" style="zoom: 33%;" /><h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p>github：<a href="https://github.com/Gaopeili/lgd">Computer Network Course Design using Mininet simulator</a></p><p>&nbsp;</p><h3 id="实验观察"><a href="#实验观察" class="headerlink" title="实验观察"></a>实验观察</h3><h4 id="仿真环境"><a href="#仿真环境" class="headerlink" title="仿真环境"></a>仿真环境</h4><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul><li>Mininet 2.3.0</li><li>Linux kernel v5.4</li><li>KVM搭建的Mininet虚拟机</li></ul><h5 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h5><p>&emsp;&emsp;选择搭建经典的 <code>bottleneck</code> 结构，设置传输过程中某条链路带宽较小且延迟较大，发送方以较大比特率发送数据，来构建出网络拓扑模型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105214.png" alt="image-20220116105213972" style="zoom:75%;" /><h5 id="拥塞场景"><a href="#拥塞场景" class="headerlink" title="拥塞场景"></a>拥塞场景</h5><p>&emsp;&emsp;创建好网络拓扑之后，调整各个client的发送速率，使用命令行工具iperf来模拟客户端与服务端。Client1，Client2以100Mbps的速率发送TCP数据包，Client3以50Mbps的速率发送UDP数据包，使用wireshark工具观察拥塞现象，发现throughput发生了明显的下降、RTT明显增加并且出现了丢包现象。</p><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p>&emsp;&emsp;观察到拥塞现象后，我们使用Linux内核提供的各种算法进行拥塞控制。从iperf提供的输出观察到了cwnd慢启动、加性增乘性减的过程，并且对比了不同算法之间的异同：</p><h5 id="算法性能测试"><a href="#算法性能测试" class="headerlink" title="算法性能测试"></a>算法性能测试</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105121.png" alt="image-20220116105121283"></p><p>&emsp;&emsp;从图中可见，Reno、Veno、RL_Veno因为拥塞控制机制相似，所以实际算法性能指标曲线大致相似，但是Veno比Reno平均吞吐量更高；BBR与Vegas因为拥塞控制机制相似，所以实际算法性能指标曲线也大致相似；CUBIC使用三次方函数拟合曲线，性能曲线形状与其他几种算法都不同。</p><h5 id="Veno与RL-Veno对比"><a href="#Veno与RL-Veno对比" class="headerlink" title="Veno与RL_Veno对比"></a>Veno与RL_Veno对比</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105147.png" alt="image-20220116105147073"></p><p>&emsp;&emsp;Veno、RL_Veno因为拥塞控制机制一致，所以实际算法性能指标曲线大致相同，但是由于RL_Veno中我们由强化学习Actor网络动态计算阈值β，所以在探索性上显得更为激进，但同时由于强化学习反馈敏感的特性，RL_Veno在收敛速度上也更胜一筹。</p><p>&nbsp;</p><h2 id="环境配置与仿真平台"><a href="#环境配置与仿真平台" class="headerlink" title="环境配置与仿真平台"></a>环境配置与仿真平台</h2><h3 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h3><p>查看当前可用的拥塞算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如图，服务器上ubuntu下目前可使用的拥塞控制有<code>cubic</code>和<code>reno</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115224959.png" alt="image-20220115224959598" style="zoom: 67%;" /><p>查看当前使用了哪种拥塞算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>目前是用的是<code>cubic</code>（默认）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115225127.png" alt="image-20220115225127025" style="zoom:67%;" /><p>设置当前使用的拥塞算法(为reno)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_congestion_control=reno</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115225212.png" alt="image-20220115225212546" style="zoom:67%;" /><p>&nbsp;</p><h3 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h3><p>&emsp;&emsp;Mininet是由斯坦福大学基于Linux <a href="https://so.csdn.net/so/search?q=Container&spm=1001.2101.3001.7020">Container</a>架构开发的一个进程虚拟化网络仿真工具，可以创建一个包含主机，交换机，控制器和链路的虚拟网络，其交换机支持OpenFlow，具备高度灵活的自定义软件定义网络。</p><p>官网：<a href="http://mininet.org/">Mininet</a></p><p>github仓库：<a href="https://github.com/mininet/mininet">mininet</a></p><h4 id="网络构建启动参数"><a href="#网络构建启动参数" class="headerlink" title="网络构建启动参数"></a>网络构建启动参数</h4><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>释放之前创建拓扑时占用的未释放资源</td></tr><tr><td>-h</td><td>查看帮助</td></tr><tr><td>–topo</td><td>定义创建的拓扑结构</td></tr><tr><td>–custom</td><td>创建自定义拓扑（python脚本）</td></tr><tr><td>–switch</td><td>定义要使用的交换机</td></tr><tr><td>–controller</td><td>定义要使用的控制器</td></tr><tr><td>–mac</td><td>自动设置设备的MAC地址</td></tr><tr><td>……</td><td></td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>dump</td><td>显示每个节点的接口设置和表示每个节点的进程PID</td></tr><tr><td>net</td><td>显示拓扑连接信息</td></tr><tr><td>nodes</td><td>显示节点信息</td></tr><tr><td>links</td><td>显示链路健壮性信息</td></tr><tr><td>dpctl</td><td>交换机流表控制</td></tr><tr><td>iperf</td><td>节点间tcp带宽测试</td></tr><tr><td>help</td><td>显示帮助信息</td></tr><tr><td>xterm</td><td>开启节点可视化操作界面(terminal)</td></tr><tr><td>py</td><td>执行后面python表达式</td></tr><tr><td>pingall</td><td>在网络中的所有主机之间执行ping测试</td></tr><tr><td>exit</td><td>退出mininet</td></tr></tbody></table><p>示例：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116104916.png" alt="image-20220116104916505"></p><h4 id="Python自定义拓扑脚本"><a href="#Python自定义拓扑脚本" class="headerlink" title="Python自定义拓扑脚本"></a>Python自定义拓扑脚本</h4><p>&emsp;&emsp;mininet支持使用python脚本自定义网络拓扑结构和通信场景设置，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwesomeBottleneckTopo</span>(<span class="params">Topo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Build Awesome Topo for Computer Network Design&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, client_num=<span class="number">3</span>, server_num=<span class="number">3</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  awesome_client1                                    awesome_server1(5Mbps)</span></span><br><span class="line">        <span class="comment">#                  \ 40Mbps                 40Mbps   /</span></span><br><span class="line">        <span class="comment">#  awesome_client2 --------- s1 --------- s2 -------- awesome_server2(30Mbps)</span></span><br><span class="line">        <span class="comment">#                  /          35Mbps(20ms)           \</span></span><br><span class="line">        <span class="comment">#  awesome_client3                                    awesome_server3(20Mbps)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># TODO(gpl): add awesome topo</span></span><br><span class="line">        self.clients = [self.addHost(<span class="string">f&#x27;h<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(client_num)]</span><br><span class="line">        self.servers = [self.addHost(<span class="string">f&#x27;n<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(server_num)]</span><br><span class="line"></span><br><span class="line">        self.s1 = self.addSwitch(<span class="string">&#x27;awesome-s1&#x27;</span>)</span><br><span class="line">        self.s2 = self.addSwitch(<span class="string">&#x27;awesome-s2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        linkops = <span class="built_in">dict</span>(bw=<span class="number">35</span>, delay=<span class="string">&#x27;5ms&#x27;</span>,</span><br><span class="line">                       max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">        self.addLink(self.s1, self.s2, **linkops)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;clients:&quot;</span>, self.clients)</span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            <span class="built_in">print</span>(client)</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(client, self.s1, **linkops)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(server, self.s2, **linkops)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    backwnd = BottleneckBackend(AwesomeBottleneckTopo())</span><br></pre></td></tr></table></figure><h4 id="GUI界面构建拓扑"><a href="#GUI界面构建拓扑" class="headerlink" title="GUI界面构建拓扑"></a>GUI界面构建拓扑</h4><p>&emsp;&emsp;mininet支持使用GUI图形界面构造网络拓扑结构，执行<code>mininet/examples/miniedit.py</code>脚本即可。</p><p>&nbsp;</p><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h3 id="任务分工"><a href="#任务分工" class="headerlink" title="任务分工"></a>任务分工</h3><table><thead><tr><th><strong>任务</strong></th><th><strong>负责人</strong></th></tr></thead><tbody><tr><td>Mininet拓扑、强化学习环境搭建、OpenAI-gym集成</td><td>gpl</td></tr><tr><td>Linux源码阅读、算法调研、驱动模块</td><td>dhy</td></tr><tr><td>CPython模块、Linux内核/用户空间映射、算法调研、系统测试</td><td>lrk</td></tr></tbody></table><h3 id="突出亮点"><a href="#突出亮点" class="headerlink" title="突出亮点"></a>突出亮点</h3><ul><li>新的工具（Mininet，iperf，dcpctl，wireshark…）</li><li>真实环境（与内核交互，可与真实环境通信）</li><li>参考资料较少（原创性强，成就感较大）</li><li>适当修改后可作为项目组新人培训任务</li></ul><h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li>Mininet CLI和python API用法差别较大，有一丢丢大坑</li><li>翻看内核源码，内核态和用户态交互</li><li>强化学习环境自行搭建并集成到gym中</li></ul><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ul><li>时间紧张，消融学习有待改进</li><li>部分代码还需重构</li><li>强化学习算法设计</li></ul><p>&nbsp;</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h5 id="Linux-Kernel-中TCP拥塞控制实现机制"><a href="#Linux-Kernel-中TCP拥塞控制实现机制" class="headerlink" title="Linux Kernel 中TCP拥塞控制实现机制"></a>Linux Kernel 中TCP拥塞控制实现机制</h5><p><a href="https://lrk612.com/resources/TCP-CongestionControlFinal.pdf">TCP’s Congestion Control Implementation in Linux Kernel</a></p><p><a href="http://www.yonch.com/tech/linux-tcp-congestion-control-internals">Linux TCP congestion control internals </a></p><p><a href="https://elixir.bootlin.com/linux/v5.4/source">在线查看各版本 Linux Kernel 源码</a></p><h5 id="TCP拥塞控制算法分析"><a href="#TCP拥塞控制算法分析" class="headerlink" title="TCP拥塞控制算法分析"></a>TCP拥塞控制算法分析</h5><p><a href="https://lrk612.com/resources/Veno.pdf">TCP Veno: TCP Enhancement for Transmission Over Wireless Access NetworksCheng</a></p><h5 id="mininet仿真平台"><a href="#mininet仿真平台" class="headerlink" title="mininet仿真平台"></a>mininet仿真平台</h5><p><a href="https://www.bilibili.com/video/BV1ft4y1a7ip?p=11">b站 mininet 使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识总结</title>
      <link href="/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络知识点总结</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160706.png" alt="20201001111251542" style="zoom: 50%;" /><p>改自18级种子班“卢神”：<a href="http://lwdreamofly.love/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/">计算机网络考试复习</a></p><p>参考：<a href="https://www.icourse163.org/learn/HIT-154005?tid=1465409451#/learn/content">哈工大计网mooc</a>、<a href="https://blog.csdn.net/lydms/article/details/106736730?ops_request_misc=%7B%22request_id%22:%22164118867316780261951158%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164118867316780261951158&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-106736730.pc_search_insert_es_download_v2&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">计算机网络博客</a>、《计算机网络—系统方法》、华科电信计网教学PPT</p><span id="more"></span><p>&nbsp;</p><h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ul><li>计算机网络可以视为是 <code>计算机技术</code> 和 <code>通信技术</code> 的合成</li><li>计算机网络设计需求<ul><li>可拓展的连通性<ul><li>为每个结点定义一个地址，路由转发消息</li></ul></li><li>高性价比的资源共享<ul><li>分组交换而不是电路交换</li></ul></li><li>支持通用服务<ul><li>设计传输协议</li></ul></li><li>可管理性</li></ul></li><li>网络通信方式包括 <code>点到点</code> 、 <code>广播</code> 、 <code>点到多点</code> 、 <code>多点到多点</code></li><li>公用电话交换网（PSTN）中的交换设备提供 <code>电路交换</code> 方式</li><li>世界上第一个投入运行的分组交换网是 <code>ARPAnet</code></li><li><code>ARPAnet</code>是最早验证分组交换的网络之一</li><li>Internet起源于<code>ARPAnet</code></li><li>根据计算机网络的定义，其主要特征包括<code>支持计算机资源的共享</code>、<code>互联的计算机系统是自治的系统</code>、<code>联网的计算机系统之间需要遵循共同的网络协议</code></li><li>关于计算机网络的最简单定义是：一些相互连接的、以共享资源为目的的、自治的计算机的集合<ul><li>自治：无主从关系</li></ul></li><li>计算机网络按照网络规模大小可以分为：<code>PAN</code>、<code>LAN</code>、<code>MAN</code>、<code>WAN</code><ul><li>PAN：personal area network 个人区域网络<ul><li>无线连接：蓝牙、红外、NFC</li><li>有线连接：USB电缆</li><li>常用于传输小文件，如：音乐、照片、日历、约定等</li></ul></li><li>LAN：local area network 局域网<ul><li>基于广播技术发展而来</li><li>由一组设备组成，如：计算机+服务器+交换机+打印机、校园网、公司内网等</li><li>最常见的局域网类型是<code>以太网</code>，两台或多台计算机通过电缆连接到以太网交换机上</li></ul></li><li>MAN：metropolitan area network 城域网<ul><li>一种比校园网区域还大的网络</li><li>一种横跨一个城市或城镇的多个建筑的网络</li><li>通常使用高速连接，如：光缆</li><li>一种高速网路，能够在城市中共享数据和资源提供服务</li></ul></li><li>WAN：wide area network 广域网<ul><li>基于交换技术发展而来</li><li>WAN是最大的网络类型，一个WAN可以包含多个MAN、LAN、PAN</li></ul></li></ul></li><li>局域网LAN和广域网WAN的区别<ul><li>覆盖范围</li><li>协议</li></ul></li><li>网络分类方法：<code>局域网/广域网</code>、<code>有线网/无线网</code>、<code>环形网/星形网</code></li><li>常见的网络拓扑：<code>环形结构</code>、<code>总线结构</code>、<code>网状结构</code>、<code>星形结构</code>、<code>树形结构</code>、<code>混合性结构</code></li><li>网络结构<ul><li>网络边缘<ul><li>主机（端系统）、客户/服务器、对等（P2P）应用模型</li></ul></li><li>接入网络<ul><li>家庭接入网络、机构接入网络、</li><li>数字用户线路（DSL）、电缆网络、无线接入网络</li></ul></li><li>网络核心<ul><li>互联的路由器网络</li><li>关键功能：路由+转发</li></ul></li></ul></li></ul><h2 id="1-2-交换原理"><a href="#1-2-交换原理" class="headerlink" title="1.2 交换原理"></a>1.2 交换原理</h2><ul><li><p><code>虚电路</code>、<code>TCP</code>能提供面向连接的服务</p></li><li><p>三中交换方式：电路交换、报文交换、分组交换</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103184648.png" alt="image-20220103184648837" style="zoom:50%;" /></li><li><p>使用存储—转发技术的是：报文交换、分组交换</p></li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在通信之前需要在通信双方间建立一条双方独占的物理信道，这个信道由双方之间的交换设备和链路逐段连接而建成的<ul><li>优点：<ul><li>带宽保证。数据直达，传输延迟小，具有很强的实时性</li><li>通信可靠。双方通信是有序的，不存在乱序问题，并且丢包概率低</li><li>路由机制简单。基于时分或频分复用，不需要进行数据包头部地址识别</li><li>既可以用于传输模拟信号，也可以用于传输数字信号</li><li>适用于实时和交互式通信</li></ul></li><li>缺点：<ul><li>建立连接平均时间较长，影响效率</li><li>对信道利用率低，建立的物理通路即使空闲仍占用通路</li><li>不同类型、规格、速率的终端难以相互进行通信，且易发生差错</li></ul></li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li><p>以<code>报文</code>为数据交换的单位，报文中携带目标地址、源地址等信息</p></li><li><p>优点：</p><ul><li>不存在建立时延，可以即时发送</li><li>当某条传输路径发生故障时能够自动选择另一条路径进行传输，提高了传输稳定性</li><li>即使不同类型、规格、速率的终端也可以实现通信</li><li>可以多目标发送</li><li>交换方式会自动建立数据传输的优先级，提高信道利用率</li></ul></li><li><p>缺点：</p><ul><li>数据交换结点需要经历存储、转发这个过程，所以会引起转发时延</li><li>只能用于数字信号</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>报文交换的升级版，仍采用<strong>存储转发</strong>的方式，但会将一个长报文先分割为若干个较短的分组，然后将短分组添加包头后逐个发送</p><ul><li>优点：<ul><li>不存在链路空闲时的带宽浪费，加速了数据的网络传输</li><li>简化了存储管理，从而减少了出错机率和重发数据量</li><li>由于其分组的特点，在优先级策略传输中更具优势</li><li>相较电路交换，更加适用于突发数据的传输</li></ul></li><li>缺点：<ul><li>时延问题仍存在，但得到减少</li><li>每个分组需要包含源地址和目的地址等信息的首部</li><li>存在乱序、分组丢失或重复问题</li><li>通信效率不高</li></ul></li></ul></li><li><p>报文交换以完整报文进行存储和转发，分组交换以分割后的报文分组进行存储和转发</p></li><li><p><strong>这里涉及报文交换和分组交换的时间计算题</strong></p><ul><li><p>分组交换时间计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164253.png" alt="image-20220102164253412" style="zoom: 33%;" /></li></ul></li><li><p>现有的公共数据网主要采用的技术是<code>分组交换</code>，包含：<code>数据报</code>、<code>信元交换</code>、<code>虚电路</code></p><ul><li><strong>信元交换</strong><ul><li>又叫做异步传输模式（Asynchronous Transfer Mode，ATM），是一种<strong>面向连接</strong>的快速分组交换技术，通过建立虚电路来进行数据传输</li></ul></li><li><strong>数据报服务</strong><ul><li>为网络层提供<strong>无连接方式</strong></li><li>无连接服务<ul><li>不事先为分组的传输确定一个具体的路径，每个分组会独立确定传输路径，不同分组传输路径可能不同</li><li>可能会乱序到达</li><li>主机<strong>不知道</strong>网络是否可以传送该分组</li></ul></li><li>发短消息时，数据报比虚电路报文分组交换甚至电路交换更快（不需要耗时建立连接）</li></ul></li><li><strong>虚电路服务</strong><ul><li>为网络层提供<strong>连接方式</strong></li><li>连接方式<ul><li>首先为分组的传输确定一个传输路径，即建立连接，然后沿着该连接对应的同一个传输路径传输系列分组</li></ul></li><li>健壮性不如数据报服务</li><li>分组不需要选择路由</li><li>电路交换需要在两站之间建立一条专用通路，但是虚电路服务不需要；虚电路的分组需要含电路号，但是电路交换不需要，电路交换不是分组</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103085634.png" alt="image-20220103085633946" style="zoom: 33%;" /><table><thead><tr><th></th><th>数据报服务</th><th>虚电路服务</th></tr></thead><tbody><tr><td>连接的建立</td><td>不需要</td><td>需要</td></tr><tr><td>目的地址</td><td>每个分组中都包含都有完整的目的地址</td><td>仅在建立连接时使用，之后每个分组使用长度较短的虚电路号判断路径即可，不需要包含目的地址</td></tr><tr><td>路由的选择</td><td>每个分组独立进行路由选择和转发</td><td>属于同一条虚电路所有分组按照同一路由转发</td></tr><tr><td>分组顺序</td><td>不保证分组有序到达</td><td>保证分组有序到达</td></tr><tr><td>可靠性</td><td>不保证可靠通信，可靠性由用户主机（更高层协议）保证</td><td>可靠性由网络保证</td></tr><tr><td>对网络故障的适应性</td><td>出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td><td>所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td>差错处理和流量控制</td><td>由用户主机进行流量控制，不保证数据报的可靠性</td><td>可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></li></ul></li></ul><h2 id="1-3-网络应用"><a href="#1-3-网络应用" class="headerlink" title="1.3 网络应用"></a>1.3 网络应用</h2><ul><li>计算机网络通信的显著特点：<code>间歇性</code>、<code>突发性</code></li><li>如果源端发送的每一个消息均希望被目的端接收，可以采用<code>请求/响应</code>的通信方式</li></ul><h2 id="1-4-网络体系架构"><a href="#1-4-网络体系架构" class="headerlink" title="1.4 网络体系架构"></a>1.4 网络体系架构</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>实体（Entity）</p><ul><li>定义：构成网络系统各个层次的抽象对象</li><li>向高层提供服务</li><li>通过调用底层实体提供的服务与远程计算机的对等实体进行通信<ul><li>对等实体：网络中不同主机（结点）的相同层次之间互为对等实体</li></ul></li></ul></li><li><p>协议（Protocol）</p><ul><li>定义：两个或多个网络对等实体之间通信所需遵从的特定规则</li><li>是为进行网络的数据交换和网络通信而建立的规则、标准或约定</li><li>向上层实体提供服务</li><li>协议三要素：<strong>语法</strong>、<strong>语义</strong>、<strong>时序</strong><ul><li>语法：数据与控制信息的结构或格式、信号电平</li><li>语义：需要发出何种控制信息、完成何种动作以及做出何种响应、差错控制</li><li>时序：事件顺序、速度匹配</li></ul></li></ul></li><li><p>实体的接口（Interface）</p><ul><li>垂直（向上）：服务接口</li><li>水平（对端）：与远程计算机对等实体的对等接口</li></ul></li><li><p>同一系统相邻两层的实体进行交互的地方称为：<strong>服务访问点</strong></p></li><li><p>网络体系结构是网络层次结构和各层协议的集合</p></li><li><p>协议与服务</p><ul><li>协议的实现保证了能够向上一层提供服务，要实现本层协议还需要使用下面一层所提供的服务</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务</li><li>协议是水平的，即协议是控制对等实体间通信的规则</li><li>服务是垂直的，即服务是下层向上层通过层间接口提供的</li></ul></li></ul><h3 id="层次化网络体系结构"><a href="#层次化网络体系结构" class="headerlink" title="层次化网络体系结构"></a>层次化网络体系结构</h3><ul><li><p>计算机网络架构的分层</p><ul><li>每一层都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面清晰，交互接口尽可能简单</li><li>下层对上层相对独立，上层调用下层提供的服务</li><li>各层的定义主要在功能方面，不应指定具体的实现方法</li></ul></li><li><p>计算机网络体系采用层次结构的主要原因</p><ul><li>使各层次的功能相对独立，使得各层次实现技术的进步不影响相邻层次，从而保证体系结构的完整性</li><li>层次结构的方法可以简化计算机网络的实现</li></ul></li><li><p>分层的实现</p><ul><li>封装<ul><li>通过封装，协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li><li>首部、尾部的加载和分离</li></ul></li><li>复用与解复用<ul><li>复用来自源结点不同高层实体的数据，将数据解复用至目的结点对应的高层实体</li><li>在发送端主机复用，在接收端主机解复用</li></ul></li></ul></li><li><p>下层协议的实现对上层的服务用户是透明的</p></li></ul><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><ul><li><p>在 OSI 参考模型中，第 N 层是第 N+1 层的服务提供者</p></li><li><p>在分层网络模型中，第N层提供的服务是利用第N-1层提供的服务和第N层协议，与对等实体交换信息实现的</p></li><li><p><strong>OSI七层网络体系</strong></p><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>为应用进程提供服务：文件传输、电子邮件、文件服务、虚拟终端</td><td>TFTP、HTTP、SNMP、DNS、Telnet等</td></tr><tr><td>表示层</td><td>数据格式转换、代码转换、数据加密</td><td>—</td></tr><tr><td>会话层</td><td>建立、管理和维护会话</td><td>—</td></tr><tr><td>传输层</td><td>建立、管理和维护端对端（进程间）的连接（可靠数据传输）</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>为数据包IP选址和路由</td><td>IP、ICMP、OSPF、EIGRP、IGMP等</td></tr><tr><td>数据链路层</td><td>帧传输及错误检测功能、提供介质访问和链路管理</td><td>SLIP、CSLIP、PPP、MTU</td></tr><tr><td>物理层</td><td>以二进制数据形式在物理媒介上传输数据</td><td>ISO2110、IEEE802、IEEE802.2</td></tr></tbody></table></li><li><p>示意图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164610.png" alt="image-20220102164610829" style="zoom:33%;" /></li><li><p>数据封装与通信过程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164642.png" alt="image-20220102164642039" style="zoom: 33%;" /></li><li><p><strong>物理层（Physical）</strong></p><ul><li>透明地传输原始比特流</li><li>定义物理设备的标准，如：网线的接口类型、光纤的接口类型、各种传输介质的传输速率等</li><li>规定：比特编码、数据率、比特同步方式、传输模式</li></ul></li><li><p><strong>数据链路层（Data Link）</strong></p><ul><li>负责物理链路上相邻结点间的数据传输</li><li>物理层比特流数据组合成帧并利用协议发送帧</li><li>控制对物理介质的访问 </li><li>提供差错检测/纠正、流量控制</li></ul></li><li><p><strong>网络层（Network）</strong></p><ul><li>负责源主机到目的主机的数据分组（packet）交付</li><li>定义了IP地址，通过IP进行逻辑寻址，遵循IP协议</li><li>在不同网络之间实现路由+转发（交换机、路由器）</li></ul></li><li><p><strong>传输层（Transport）</strong></p><ul><li>提供源主机到目的主机（端到端进程间）的完整报文传输服务</li><li>连接控制、流量控制、差错控制</li></ul></li><li><p><strong>会话层（Session）</strong></p><ul><li>建立和管理应用程序之间的通信</li><li>建立/解除与物理其他接口的联系</li></ul></li><li><p><strong>表示层（Presentation）</strong></p><ul><li>数据格式化、代码转换、数据加密、数据压缩</li><li>解决不同系统之间的通信语法问题</li></ul></li><li><p><strong>应用层（Application）</strong></p><ul><li>文件传输、电子邮件、文件服务、虚拟终端</li><li>传输的数据根据应用层的协议进行服务</li></ul></li><li><p><strong>记忆口诀</strong></p><ul><li><strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>ell <strong>S</strong>tupid <strong>P</strong>eople <strong>A</strong>nything</li></ul></li></ul></li></ul><h3 id="TCP-IP四层体系结构"><a href="#TCP-IP四层体系结构" class="headerlink" title="TCP/IP四层体系结构"></a><strong>TCP/IP四层体系结构</strong></h3><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>协议或组件</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、DNS、FTP</td></tr><tr><td>运输层（传输层）</td><td>TCP、UDP</td></tr><tr><td>网际层（IP层）</td><td>IP</td></tr><tr><td>网络接口层（网络接入层）</td><td>网络接口</td></tr></tbody></table></li><li><p>瘦腰结构</p></li><li><p>解决计算机之间通信问题是在：网际层（对应网络层）</p></li><li><p>TCP/IP协议族的网络层提供的是：<strong>无连接不可靠的数据报服务</strong></p></li><li><p>物理层、数据链路层、网络层传送的数据单位分别为：<code>比特</code>、<code>帧</code>、<code>分组</code></p></li><li><p>对比OSI七层参考模型</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103190907.png" alt="image-20220103190906970" style="zoom:50%;" /></li><li><p>七层——四层——五层</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104165049.png" alt="image-20220104165049457"></p></li></ul><h3 id="几种物理设备"><a href="#几种物理设备" class="headerlink" title="几种物理设备"></a>几种物理设备</h3><table><thead><tr><th>设备</th><th>功能</th><th>层级</th></tr></thead><tbody><tr><td>中继器 RP</td><td>根据输入端的信号重新生成原始信号，再通过输出端传送出去，扩大网络传输的距离</td><td>L1</td></tr><tr><td>集线器 Hub</td><td>将网线集中到一起的机器，也就是多台主机和设备的连接器</td><td>L1</td></tr><tr><td>网桥 Bridge</td><td>根据数据帧内容转发数据给其他相邻的网络；过滤/转发数据帧，拓展LAN</td><td>L2</td></tr><tr><td>交换机 Switch</td><td>MAC寻址，将数据帧转发到另一个目标MAC地址。和网桥的升级，具有集线器一样的集中连接功能，又具有网桥的数据交换功能</td><td>L2</td></tr><tr><td>路由器 Router</td><td>IP寻址，将分组报文转发到另一个目标路由器地址</td><td>L3</td></tr><tr><td>网关 Gateway</td><td>在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连</td><td>&gt;L3</td></tr></tbody></table><ul><li><p>集线器的缺点是：<strong>不能过滤网络流量</strong></p></li><li><p>连接在集线器上的结点<strong>共享</strong>集线器带宽（均分），连接在交换机上的结点独占交换机带宽</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125432.jpg" alt="img" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125445.jpg" alt="img" style="zoom:33%;" /></li></ul><h2 id="1-5-网络性能评估"><a href="#1-5-网络性能评估" class="headerlink" title="1.5 网络性能评估"></a>1.5 网络性能评估</h2><h3 id="链路带宽"><a href="#链路带宽" class="headerlink" title="链路带宽"></a>链路带宽</h3><ul><li>指链路上每秒所能传输的比特数，单位bps</li><li>取决于链路时钟和信道编码</li><li>带宽往往大于吞吐量</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li><p>端到端时延</p><ul><li>将报文从网络一端传到另一端所花费的时间</li><li>= 处理时延 + 排队时延 + 传输时延 + 传播时延</li></ul></li><li><p>传输时延（发送时延）：</p><ul><li>主机或路由器发送数据帧所需的时间，即从帧的一个比特开始到最后一个比特发送完毕所需的时间</li><li>传输时延 = 分组长度 / 链路带宽</li></ul></li><li><p>传播时延</p><ul><li>电磁波在信道中传播一定距离所需的时间</li><li>与数据大小无关</li><li>传播时延 = 物理链路长度 / 电磁波传播速率（注意环境）</li></ul></li><li><p>处理时延</p><ul><li>主机或路由器在收到分组时分析首部、提取数据主体、差错检测等<strong>存储转发</strong>操作处理花费的时间</li></ul></li><li><p>排队时延</p><ul><li>分组通过网络传输时要经过很多路由器，进入路由器后要先输入队列中排队等待处理。在路由器确定了转发接口后还要在输出队列中等待转发</li></ul></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>等效于第一个比特到达接收方之前，发送方可以发送的比特数上限</li><li>是网络中能够保持的最大比特数</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103192043.png" alt="image-20220103192042971" style="zoom:50%;" /></li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><p>单位时间内发送方和接收方之间成功传输的数据量</p></li><li><p>受到各种因素影响，吞吐量小于带宽，带宽10Mbps的链路一吞吐量可能只能达到2Mbps左右</p></li><li><p><strong>链路吞吐量</strong>为：A端结点、B端结点、通信线路三者吞吐量的最小值</p></li><li><p><strong>网络设备吞吐量</strong></p><ul><li>单位时间内，网络设备各端口存储转发的比特数之<strong>和</strong></li><li>取决于输入输出端口硬件和程序算法设计</li><li>是没有帧丢失时，设备能接收并转发的最大数据速率</li></ul></li><li><p>计算机网络最主要的性能指标：<code>带宽</code>、<code>时延</code></p></li></ul><p>&nbsp;</p><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络适配器</p><ul><li>功能<ul><li>进行串行/并行转换</li><li>对数据进行缓存</li><li>设备驱动程序</li></ul></li><li>接口特性<ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>规程特性</li></ul></li></ul></li><li><p><code>链路</code>：物理传输媒质</p></li><li><p>信息传输速率单位：<code>bps</code></p></li><li><p>码元传输速率单位：<code>波特（Baud, 1/s）</code></p></li><li><p>承载信息量的基本信号单位：<code>码元</code></p></li><li><p>通信系统必备的三个基本要素：<code>信源</code>、<code>通信媒介</code>、<code>信宿</code></p></li><li><p><code>调制速率</code>：每秒钟载波调制状态改变的数值，单位：波特，又称为波特率，即码元的传输速率</p></li><li><p><code>比特率</code>：数据的传输速率，单位：bps</p></li><li><p>两台设备之间实现通信必备：<code>网卡</code>、<code>传输媒介</code>、<code>协议</code></p></li><li><p>链路层的数据封装和解封都由<code>网卡</code>完成</p></li><li><p>常见通信方式：</p><ul><li><p>单工通信（Simplex Communication）</p><p>信息只能单方向传输，发送端和接收端是固定的</p></li><li><p>半双工通信（Half-duplex Communication）</p><p>可以对调发送端和接收端，但是不能同时双边互发信息</p></li><li><p>全双工通信（Full-duplex Communication）</p><p>任意时刻都可以在双向同时传输信息</p></li></ul></li></ul><h3 id="网络通信编码"><a href="#网络通信编码" class="headerlink" title="网络通信编码"></a>网络通信编码</h3><ul><li><p>不归零（NRZ）</p><ul><li>编码方式<ul><li>1——&gt;高电平</li><li>0——&gt;低电平</li></ul></li><li>问题<ul><li>连续的0可能被误认为没有信号</li><li>连续的1可能导致基线漂移</li><li>时钟恢复困难</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194708.png" alt="image-20220103194708738" style="zoom: 50%;" /></li></ul></li><li><p>不归零反转（NRZI）</p><ul><li>编码方式<ul><li>1——&gt;信号跳变</li><li>0——&gt;信号保持</li></ul></li><li>问题<ul><li>可以解决连续1的问题，但是不能解决连续0的问题</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194833.png" alt="image-20220103194833948" style="zoom:50%;" /></li></ul></li><li><p>曼彻斯特编码（Manchester）</p><ul><li>编码方式<ul><li>1——&gt;高到低跳变</li><li>0——&gt;低到高跳变</li></ul></li><li>问题<ul><li>信号跳变速率翻倍</li><li>比特率是信号跳变速率的一般，编码效率:50%</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195035.png" alt="image-20220103195035160" style="zoom:50%;" /></li></ul></li><li><p>4B/5B</p><ul><li>编码方式<ul><li>用5个比特对4个比特的数据进行编码, 其中每个代码(5个比特)中最多有1个前导0, 且末端最多有2个0</li><li>采用NRZI对5比特编码</li><li>编码效率：80%</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195154.png" alt="image-20220103195154290" style="zoom: 67%;" /></li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><h2 id="3-1-相关概念"><a href="#3-1-相关概念" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h2><ul><li><p>链路层在每台主机的网络适配器（网卡）上实现，或者集成在芯片上</p></li><li><p>网络适配器之间的通信</p><ul><li>发送端<ul><li>将分组封装为数据帧</li><li>增加差错检测、可靠传输、流量控制等功能</li></ul></li><li>接收端<ul><li>完成差错检测、实施可靠传输、流量控制等</li><li>提取分组并交付至上层协议</li></ul></li></ul></li><li><p>链路层服务：</p><ul><li>组帧（framing）<ul><li>封装数据报构成数据帧，加首部和尾部</li><li>帧同步</li></ul></li><li>链路接入（link access）<ul><li>如果是共享介质，需要解决信道接入问题</li><li>帧首部中的MAC地址用于标识帧的源和目的</li></ul></li><li>相邻节点间可靠交付</li><li>流量控制</li><li>差错检测</li></ul></li><li><p>MAC地址</p><ul><li>又称为LAN地址、物理地址、以太网地址</li><li>局域网中每块网卡都有一个唯一的MAC地址，是硬件设备的唯一标识</li><li>作用：用于局域网标识一个帧从哪个接口发出，到达哪个物理相连的其他接口</li><li>48位MAC地址固化在网卡的ROM中，一般不会软件改动</li></ul></li><li><p>ARP地址解析</p><ul><li>ARP表<ul><li>LAN中每个IP结点（主机、路由器）维护一个表，存储某些LAN结点的IP/MAC地址映射关系</li><li>经过TTL时间后遗弃此映射关系（一般是20min）</li></ul></li><li>ARP即插即用，结点自主广播ARP查询分组，获得对应IP的主机应答其MAC地址，创建ARP表，超时（TTL）会自动刷新，无需干预</li></ul></li><li><p>透明传输1：传输的数据内容、格式、编码方式无限制</p></li></ul><h3 id="组帧（帧定界问题）"><a href="#组帧（帧定界问题）" class="headerlink" title="组帧（帧定界问题）"></a>组帧（帧定界问题）</h3><ul><li>面向字节的协议<ul><li>把每一帧看作一个字节集合</li><li>两种方法<ul><li>字符计数法</li><li>起止标记法</li></ul></li></ul></li><li>面向比特的协议<ul><li>把数据帧看作比特的集合</li><li>高级链路控制规程（HDLC）</li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>应用最广泛的LAN技术</p></li><li><p>网络速率:10Mbps——10Gbps</p></li><li><p>以太网的优点是：<code>可扩充性好</code>、<code>成本低</code>、<code>施工方便</code></p></li><li><p>以太网参考模型一般只包括：<code>物理层</code>和<code>数据链路层</code></p></li><li><p>以太网的碰撞窗口或争用期为：<strong>往返时延</strong></p></li><li><p>不可靠的服务：差错帧直接丢弃，丢弃帧中数据的恢复依靠高层协议（<strong>无确认</strong>）</p></li><li><p><strong>无连接</strong>的服务：发送帧的网卡与接受帧的网卡没有握手过程</p></li><li><p>MAC协议：二进制指数退避算法的CSMA/CD（不是必须）</p><ul><li>检测到冲突中止发送后，进入二进制指数退避</li></ul></li><li><p>以太网交换机：</p><ul><li>是链路层设备<ul><li>存储—转发以太网帧</li><li>检验到达帧的目的MAC地址，选择向一个或多个输出链路转发帧</li><li>利用CSMA/CD访问链路，发送帧</li></ul></li><li>透明：主机感受不到交换机的存在</li><li>即插即用</li><li>自学习，无需配置（目的帧不在交换表中时泛洪查找）</li><li>全双工通信</li><li>注意，交换机使用泛洪构建转发表；路由器则通过路由算法计算IP转发表</li><li>洪泛法的基本思想是：收到的信息都会往所有可能连接的路径上转发</li></ul></li><li><p>虚拟局域网VLAN：</p><ul><li>VLAN（Virtual Local Area Network）是由一些局域网网段构成的与物理位置无关的逻辑组</li><li>利用以太网交换机可以很方便地实现 VLAN</li><li>每一个 VLAN 的工作站可处在不同的局域网中</li></ul></li></ul><h3 id="无线局域网-IEEE802-11"><a href="#无线局域网-IEEE802-11" class="headerlink" title="无线局域网 IEEE802.11"></a>无线局域网 IEEE802.11</h3><ul><li><p>无线链路特性</p><ul><li>信号强度递减（路径损耗）</li><li>其他信号源干扰（各种频段）</li><li>多径传播（乱序到达）</li><li>隐藏终端问题（中间隔着障碍物）</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102214759.png" alt="image-20220102214759049" style="zoom:33%;" /></li><li><p>均使用CSMA/CA多路访问控制协议</p></li><li><p><strong>截断二进制指数</strong>类型退避算法解决了：站点检测到冲突后延迟发送的时间</p></li><li><p>无线局域网不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>是因为无线局域网：并非所有站点都能听见对方、无线介质传输特征复杂，存在隐藏终端、暴露终端等问题</p></li><li><p>无线通信网中，应对隐藏终端、暴露终端问题的方法是：<code>RTS/CTS 机制</code>（CSMA/CA）</p></li><li><p>无线局域网：</p><ul><li>无线局域网可分为两大类，即有固定基础设施的和无固定基础设施的</li><li>无固定基础设施的无线局域网又叫做自组织(AD HOC)网络</li><li>有固定基础设施的无线局域网，使用无线接入点（AP）作为基础设施</li></ul></li><li><p>无线局域网主要采用了<strong>预约信道</strong>方法解决数据帧的碰撞问题</p></li></ul><h3 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h3><ul><li>网桥<ul><li>实现：<code>过滤数据帧</code>、<code>转发数据帧</code>、<code>拓展LAN</code>功能</li><li>工作在<strong>数据链路层</strong></li><li>可以访问同一个网络中站点的<strong>物理</strong>地址</li><li>透明网桥是通过查找端口—地址表来决定转发路径的，而端口—地址表是网桥通过<strong>自学习算法</strong>生成的</li><li>通过将帧中的<strong>目的结点的物理地址</strong>和自己地址表中的信息比较，实现帧的转发和过滤</li></ul></li><li>交换机根据<code>数据报</code>、<code>虚电路</code>、<code>源路由</code>选择分组转发时的输出端口</li></ul><h2 id="3-2-差错检测"><a href="#3-2-差错检测" class="headerlink" title="3.2 差错检测"></a>3.2 差错检测</h2><ul><li><p>二维奇偶校验</p><ul><li>奇偶校验码可以检查出奇数个比特错误</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200424.png" alt="image-20220103200424868" style="zoom:50%;" /></li></ul></li><li><p>循环冗余校验（CRC）</p><ul><li><p>M(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200819.png" alt="image-20220103200819939" style="zoom:50%;" /></li><li><p>C(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200844.png" alt="image-20220103200844704" style="zoom:50%;" /></li><li><p>P(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200907.png" alt="image-20220103200907613" style="zoom:50%;" /></li><li><p>判错条件：接收方判断P(x)是否可以整除C(x)</p></li><li><p>不同C(x)可以检测出特定的比特错误：</p><ul><li><p>所有1 &amp; 2-比特的错误</p></li><li><p>任意奇数个错误</p></li><li><p>任何小于k 比特的连续比特错误序列</p></li><li><p>部分大于 k 比特的连续比特错误序列</p></li></ul></li></ul></li><li><p>Internet校验和</p><ul><li>计算接受数据的校验和，并与发来的校验和字段内容比较是否一致</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151136.png" alt="image-20220103151136608" style="zoom: 33%;" /></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151200.png" alt="image-20220103151200255" style="zoom:33%;" /></li></ul></li></ul><h2 id="3-3-可靠传输机制"><a href="#3-3-可靠传输机制" class="headerlink" title="3.3 可靠传输机制"></a>3.3 可靠传输机制</h2><ul><li><p>基本方法：<code>确认ACK</code>、<code>定时器超时</code>、<code>帧序号</code></p></li><li><p>核心机制：<code>差错检测CRC</code>、<code>ACK确认</code>、<code>定时器</code>、<code>超时重传</code>、<code>帧序号</code>、<code>滑动窗口</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204529.png" alt="image-20220103204529325" style="zoom:50%;" /></li></ul><h3 id="自动请求重传（ARQ）机制"><a href="#自动请求重传（ARQ）机制" class="headerlink" title="自动请求重传（ARQ）机制"></a>自动请求重传（ARQ）机制</h3><ul><li>采用ACK确认和超时定时器的可靠传输机制</li><li>接收方<ul><li>对数据帧进行差错检测</li><li>对正确帧进行确认, 丢失错误帧</li><li>丢弃禁止接收的数据帧</li></ul></li><li>发送方<ul><li>发送原始数据帧</li><li>对错误帧和丢失帧进行重传</li></ul></li></ul><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul><li><p>最简单的ARQ机制</p></li><li><p>内容</p><ul><li>每发送完一个数据帧, 发送方在继续发送下一个数据帧之前必须等待确认</li><li>如果在一定的时间范围内，发送方未收到确认(ACK), 则发送定时器超时激发, 发送方重传原始数据帧</li></ul></li><li><p>两种不同的帧丢失情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103201722.png" alt="image-20220103201722314" style="zoom:50%;" /></li><li><p>使用帧序号的目的是<strong>处理重复帧</strong></p></li><li><p>缺点</p><ul><li>链路带宽利用率低</li></ul></li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul><li>采取流水线设计，允许未收到确认，连续发送数据帧</li></ul><h4 id="后退N帧（Go-Back-N）"><a href="#后退N帧（Go-Back-N）" class="headerlink" title="后退N帧（Go-Back-N）"></a>后退N帧（Go-Back-N）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>接收方收到新数据帧时回传连续序号帧中的最大序号值（未必是当前接收帧的序号，因为可能是后发先到乱序 或者 前面有丢包）</p></li><li><p>如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202238.png" alt="image-20220103202238229" style="zoom:50%;" /></li></ul></li><li><p>优点: 接收方不需要缓存接收到的乱序帧，确认简单</p></li><li><p>缺点: 正确帧也可能被重传，效率较低</p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203815.png" alt="image-20220103203815365" style="zoom:67%;" /></li><li><p>例题：</p><ul><li><p>两台主机之间的数据链路层采用后退 N 帧协议传输数据，数据传输速率为 16kbps，单</p><p>向传播时延为 270ms，数据帧长度范围是 128-512 字节，接收方总是以与数据帧等长</p><p>的帧进行确认，为使信道利用率达到最高，帧序列的比特数至少为多少？</p><p>答：</p><p>&emsp;&emsp;即求从发送一个帧到接收到这个帧的确认为止的时间内最多可以发送数据帧的数量，对这个数量进行二进制编码所需的位数。</p><p>要尽可能多发帧，应以短的数据帧（传输时延短，发的快）计算，首先计算出发送一帧的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192243.png" alt="image-20220102192243529" style="zoom:50%;" /><p>发送一帧到收到确认的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103161327.png" alt="image-20220103161327331" style="zoom: 67%;" /><p>这段时间总共可以发送：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192351.png" alt="image-20220102192351213" style="zoom:50%;" /><p>发送10个左右的帧，编号至少需要4位二进制数，因此至少4比特。</p></li></ul></li></ul><h4 id="选择性重传（SR）"><a href="#选择性重传（SR）" class="headerlink" title="选择性重传（SR）"></a>选择性重传（SR）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>如果第k个帧丢失, 仅重传第k个帧</p></li><li><p>接收方对每一个帧进行确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202252.png" alt="image-20220103202252901" style="zoom:50%;" /></li></ul></li><li><p>优点: 链路利用率较高</p></li><li><p>缺点: 接收方更复杂</p></li><li><p><strong>发送窗口大小 == 接收窗口大小</strong></p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203849.png" alt="image-20220103203849702" style="zoom:67%;" /></li><li><p>存在问题</p><ul><li><p>无法区分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204012.png" alt="image-20220103204012029" style="zoom:50%;" /></li><li><p>解决方法：（k为序号比特位数）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204146.png" alt="image-20220103204146783" style="zoom:50%;" /></li></ul></li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><ul><li><p>引入滑动窗口对收发行为进行控制</p></li><li><p>基本思路</p><ul><li><p>发送方</p><ul><li><p>发送窗口大小：发送方在未收到确认前能够发送的数据帧的最大个数</p></li><li><p>发送方在未收到确认前最多可以发送多个数据帧 (受限于 发送窗口大小)</p></li><li><p>对未确认的数据帧缓存</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203220.png" alt="image-20220103203220318" style="zoom:50%;" /></li></ul></li><li><p>接收方</p><ul><li><p>接收窗口大小：接收方所能接收的乱序期望数据帧的最大个数</p></li><li><p>接收方通过ACK告知发送方下一次期望其传送的数据帧编号, 避免每次收到数据帧都发送确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203238.png" alt="image-20220103203238050" style="zoom:50%;" /></li></ul></li></ul></li><li><p>接收方行为</p><ul><li>接收数据帧<ul><li>如果一个数据帧到达(帧序号为SeqNum )</li><li>如果SeqNum ≤ LFR 或SeqNum &gt; LAF<ul><li>n数据帧落在接收窗口外, 则丢弃该数据帧</li></ul></li><li>如果LFR &lt; SeqNum ≤ LAF<ul><li>数据帧落在接收窗口内, 则接收</li></ul></li></ul></li><li>回复ACK<ul><li>SeqNumToAck = 未确认数据帧的最大SeqNum</li><li>接收方进确认 SeqNumToAck之前的数据帧, 即使更大序号的数据已接收</li><li>设置LFR = SeqNumToAck , 调整LAF = LFR + RWS</li></ul></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203742.png" alt="image-20220103203742576" style="zoom: 67%;" /></li><li><p>优点</p><ul><li>不仅保证帧在物理链路上的可靠传输</li><li>而且保证帧传输的顺序</li><li>支持流量控制，接收方通过反馈机制可以抑制发送方速率</li></ul></li></ul><h2 id="3-4-媒质接入控制（MAC协议）"><a href="#3-4-媒质接入控制（MAC协议）" class="headerlink" title="3.4 媒质接入控制（MAC协议）"></a>3.4 媒质接入控制（MAC协议）</h2><ul><li>解决多路访问问题的前提是：<strong>寻址</strong></li></ul><h3 id="静态信道划分MAC协议"><a href="#静态信道划分MAC协议" class="headerlink" title="静态信道划分MAC协议"></a>静态信道划分MAC协议</h3><ul><li>多路复用技术<ul><li>时分复用（TDMA）</li><li>频分复用（FDMA）</li><li>码分复用（CDMA）</li><li>……</li></ul></li><li>网络负载重时效率高、公平，负载轻时效率低</li></ul><h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><ul><li>基本思想及特点<ul><li>信道不划分，允许冲突</li><li>采用冲突“恢复”机制</li><li>网络负载轻时效率高，负载重时冲突严重</li></ul></li></ul><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><ul><li>内容<ul><li>一旦数据帧到达, 立即发送 </li><li>如果发生冲突, 节点等待随机时间后重发数据直到发送成功</li></ul></li><li>效率 = 0.18</li></ul><h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><ul><li>内容<ul><li>当节点获得新的数据帧, 等待下一时隙到达开始发送</li><li>如果不存在冲突: 节点可以在下一时隙到达发送新的数据帧</li><li>如果发生冲突: 节点以概率p在每一个后续时隙内发送数据直到发送成功</li></ul></li><li>优点<ul><li>一个活跃节点可以持续以全速(信道带宽)发送数据帧</li><li>高度去中心化: 不需要中央调度</li><li>简单</li></ul></li><li>缺点<ul><li>存在冲突, 浪费时隙</li><li>存在空闲时隙</li><li>节点可能花费较长的时间进行冲突监测与退避重传</li><li>要求时钟同步</li></ul></li><li>效率 = 0.37</li></ul><h4 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h4><h5 id="普通CSMA"><a href="#普通CSMA" class="headerlink" title="普通CSMA"></a>普通CSMA</h5><ul><li><p>载波监听多路访问（Carrier Sensing Multiple Access）</p></li><li><p>内容</p><ul><li>发送前监听信道</li><li>如果信道空闲, 发送整个数据帧</li><li>如果信道忙, 延迟发送 </li></ul></li><li><p>冲突</p><ul><li><p>传播时延导致两个结点无法监听到对方的发送</p></li><li><p>导致整个数据帧被浪费</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103210353.png" alt="image-20220103210353350" style="zoom: 33%;" /></li></ul></li></ul><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><ul><li><p>要点：<code>冲突检测</code>、<code>多点接入</code>、<code>载波监听</code></p></li><li><p>机制：<strong>争用带宽</strong></p></li><li><p>内容</p><ul><li><p>边发边听，听到马上停止发送以减少信道浪费；不发就不听</p></li><li><p>有线局域网易实现；无线局域网难以实现（接收信号强度太低，无法与噪声区分）</p></li><li><p>为保证不发生碰撞，在传输时间内必须能收到最远端主机发送的信号（见下面最差冲突情况），即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102203719.png" alt="image-20220102203719361" style="zoom: 25%;" /></li></ul></li><li><p>冲突</p><ul><li><p>结点检测数据帧发送过程中是否发生冲突</p></li><li><p>如果发生冲突，则立即停止发送当前帧，改发送冲突信号广播通知其他结点，然后进行退避处理</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103224755.png" alt="image-20220103224755596" style="zoom: 50%;" /></li><li><p><strong>二进制退避算法</strong></p><ul><li>第k次冲突，则选择{0,1,2,…,2^k-1}中随机选择一个数乘以512bit，这个值对应的时延作为本次退避的等待时间</li><li>512bit对应51.2us，这是最初时最大覆盖以太网(2500米)往返最大时延</li></ul></li><li><p>冲突的最差情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225225.png" alt="image-20220103225225595" style="zoom: 67%;" /></li></ul></li><li><p>效率</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225357.png" alt="image-20220103225357197" style="zoom:50%;" /></li><li><p><strong>以太网</strong>MAC协议用的就是这个</p></li><li><p>计算题</p><p>在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1Gbps，电缆中的信号传播速度是200000km/s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要______？</p><p>答：</p><p>&emsp;&emsp;本题隐藏条件是应该在最坏情况下计算，这样才能保证一定免数据帧冲突问题：（）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102194429.png" alt="image-20220102194429684" style="zoom:50%;" /><p>&emsp;&emsp;设传输线路的长度是L，那么信号在电缆中传输一个来回的时间是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193852.png" alt="image-20220102193852730" style="zoom:50%;" /><p>&emsp;&emsp;设最短帧长度是：（最短帧长度 = 传播一个来回时间 * 传输速率）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193926.png" alt="image-20220102193926664" style="zoom:50%;" /><p>&emsp;&emsp;所以如果MIN减小了800bit，则对应L需要<strong>减小80m</strong>。</p><p>&emsp;&emsp;标准答案：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211555.png" alt="image-20220103211555710" style="zoom: 50%;" /></li></ul><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><ul><li><p>机制：<strong>预约带宽</strong></p></li><li><p>思想</p><ul><li>无线信道传输存在隐藏终端和信道衰落问题，导致难以进行碰撞检测</li><li>与CSMA/CD不同，CSMA/CA目标不是监测碰撞，而是避免碰撞</li></ul></li><li><p>内容</p><ul><li><p>发送端</p><ul><li>如果监听到信道空闲<ul><li>将在一个被称作分布式帧间间隔（DIFS）的短时间段后发送该帧</li></ul></li><li>如果监听到信道正忙 <ul><li>选取一个随机回退值计时</li><li>当信道空闲时递减该值</li><li>当计数值减为0时，该站点发送整个数据帧并等待确认</li><li>如果未收到确认，增加回退值，重复第2步</li></ul></li></ul></li><li><p>接收端</p><ul><li>如果数据帧接收成功<ul><li>在SIFS时间后返回确认信息（确认信息在隐藏终端问题中是必须的）</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103233916.png" alt="image-20220103233916031" style="zoom:50%;" /></li><li><p>虚拟载波监听（预约信道）</p><ul><li><p>在发送数据帧之前交换控制信息</p><ul><li><p>发送方 询问 “Request-to-Send” (RTS)，包括数据帧长度</p></li><li><p>接收方 广播 “Clear-to-Send” (CTS)</p></li></ul></li><li><p>如果发送方收到 CTS，则开始发送数据 (指定长度)</p></li><li><p>其他节点收到 CTS，则认定信道在指定长度数据帧发送期间处于繁忙状态</p></li><li><p>如果多个节点同时检测到一个空闲链路并试图发送一个RTS，那么他们的RTS帧将彼此冲突。当发送端在一段时间内没有收到CTS帧时，节点知道发生冲突，会<strong>等待一段随机时间后</strong>再试</p></li><li><p>RTS、CTS都很短，因此开销小，并且可以完全避免数据帧碰撞</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103234630.png" alt="image-20220103234630447" style="zoom:50%;" /></li></ul></li></ul></li><li><p><strong>无线局域网</strong>MAC协议用的就是这个</p><ul><li>不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>的原因<ul><li>无线信道传输中并非所有站点都能听见对方、无线介质传输特征复杂，无线信道传输存在隐藏终端、暴露终端等问题</li><li>无线信道传输难以同时收发，接收信号强度明显弱于发送信号</li></ul></li></ul></li></ul><h3 id="轮转MAC协议"><a href="#轮转MAC协议" class="headerlink" title="轮转MAC协议"></a>轮转MAC协议</h3><ul><li><p>特点</p><ul><li>结点轮流发送</li><li>待发送数据量大的节点占用信道更长时间</li><li>无冲突</li></ul></li><li><p>方式一：轮询</p><ul><li><p>主节点 “邀请” 从节点轮流发送数据</p></li><li><p>典型应用于“dumb” 从设备</p></li><li><p>关注点：轮询开销、时延、主节点失效</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211115.png" alt="image-20220103211115624" style="zoom:50%;" /></li></ul></li><li><p>方式二：令牌传递</p><ul><li><p>控制<strong>令牌</strong>在节点之间依序传递.</p></li><li><p>令牌帧</p></li><li><p>关注点：令牌开销、时延、令牌丢失</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211204.png" alt="image-20220103211204403" style="zoom:50%;" /></li><li><p>例：蓝牙、FDDI、令牌环网</p></li></ul></li></ul><h2 id="3-5-其他知识点"><a href="#3-5-其他知识点" class="headerlink" title="3.5 其他知识点"></a>3.5 其他知识点</h2><ul><li>IEEE802将数据链路层划分为两个子层，上为：<code>LLC</code>、下为：<code>MAC</code><ul><li>IEEE802 又称为LMSC（LAN /MAN Standards Committee， 局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）</li><li>IEEE802系列标准把数据链路层分成LLC（Logical Link Control，逻辑链路控制）和MAC（Media Access Control，媒介接入控制）两个子层。LLC子层在IEEE802.2标准中定义，为802标准系列共用；而MAC子层协议则依赖于各自的物理层</li></ul></li><li>10Mb/s和100Mb/s自适应系统是指：端口之间10Mb/s和100Mb/s传输率的自动匹配功能</li><li>局域网采用的拓扑结构包括：<code>总线型</code>、<code>星型</code></li><li>对于术语10base-T，base表示连接线上的信号时基带信号<ul><li>10base-T是双绞线以太网，1990年由IEEE新认可，编号IEEE802.3i，T表示采用双绞线，现10base-T采用的是非屏蔽双绞线（UTP）</li><li>技术指标<ul><li>数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Base表示基带传输，T代表双绞线</li><li>每段双绞线最大有效长度 100m，采用高质量的双绞线（5类线），最大长度可到<strong>150m</strong>(HUB与工作站间及两个HUB之间)</li><li>支持共享式和交换式两种组网方式</li><li>一条通路允许最大连接HUB数 4个</li><li>拓扑结构：星形或总线形</li><li>访问控制方式 CSMA/CD</li><li>帧长度可变，最大1518个字节</li><li>每个HUB可连接的工作站 96个</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络互联与路由器"><a href="#4-1-网络互联与路由器" class="headerlink" title="4.1 网络互联与路由器"></a>4.1 网络互联与路由器</h2><ul><li>网络层核心功能：转发+路由</li><li>面向无连接的IP协议的信息传输方式是：<code>数据报</code></li><li>路由器的功能<ul><li>解决异构网络之间的互联问题</li><li>路由选择</li><li>分组转发</li><li>数据分段</li><li>协议转换</li><li>数据封装</li><li>不包括流量控制</li></ul></li><li>路由器在能够开始向输出链路传输分组的第一bit之前，必须先接收到整个分组，这种机制称为：<strong>存储转发</strong></li><li><code>ARP</code>协议的作用是：将IP地址映射到数据链路层地址（MAC地址），反过来是<code>RARP</code></li><li>每台路由器都依赖<strong>ARP</strong>协议，否则无法正确工作</li><li><code>ARP</code>将IP地址转换为物理地址，<code>RARP</code>将物理地址转换为IP地址</li><li>路由器连接的<strong>异构网络</strong>指的是：<strong>数据链路层和物理层均不同</strong></li><li>路由器涉及Internet体系结构的<strong>网络接口层</strong>和<strong>网络层</strong></li><li>路由器可以隔离<code>ARP</code>广播帧</li><li><code>intranet</code>与<code>internet</code>互联，必须的互联设备是路由器</li><li>路由器 VS 交换机<ul><li>路由器第三层，交换机第二层</li><li>路由器：寻址，转发（依靠 IP 地址）<br>交换机：过滤，转发（依靠 MAC 地址）</li></ul></li></ul><h2 id="4-2-交换和桥接"><a href="#4-2-交换和桥接" class="headerlink" title="4.2 交换和桥接"></a>4.2 交换和桥接</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>定义<ul><li>有多个输入端和多个输出端的设备</li><li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口<ul><li>数据链路层交换机——交换——数据帧——mac地址</li><li>网络层交换机——转发——数据报datagram/数据包packet/分组——ip地址</li></ul></li><li>交换机各端口速率和交换机自身带宽一致，不论端口数量</li></ul></li><li>电路交换机（Circuit switch）<ul><li>不是直接相连的</li><li>每部电话连到一个交换设备：交换机</li><li>保证两部电话机建立单独的电路链接</li></ul></li><li>分组交换机（Packet switch）<ul><li>计算机连接到分组交换机</li><li>分组可从一台主机传输到另外一台主机</li><li>采取存储转发将分组从输入端口交换到正确的输出端口</li><li>每个端口发送速率和交换机本身带宽一直，相当于<strong>独占</strong>带宽</li></ul></li></ul><h3 id="交换网络"><a href="#交换网络" class="headerlink" title="交换网络"></a>交换网络</h3><ul><li><p>分类</p><ul><li><p>电路交换网络</p></li><li><p>分组交换网络：数据报、虚电路、源路由</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082156.png" alt="image-20220104082156187" style="zoom:50%;" /></li></ul></li></ul><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a><strong>数据报网络</strong></h4><ul><li>无连接</li><li>标识：每一个分组包含的目的地址</li><li>交换机决策：基于转发表<ul><li>交换机查询转发表确定分组的输出端口</li><li>转发表的构造与维护: 基于收集的桥接/路由信息</li></ul></li><li>数据报网络<ul><li>主机可以随时随地发送分组</li><li>主机无法知道网络是否可以传送该分组或目的主机是否可以接收</li><li>每个分组的转发均基于首部的目的地址, 分组之间相互独立</li><li>一台交换机或一条链路出现故障时, 并不会对通信产生任何严重的影响</li><li>实例：ARPnet</li></ul></li></ul><h4 id="虚电路（VC）网络"><a href="#虚电路（VC）网络" class="headerlink" title="虚电路（VC）网络"></a><strong>虚电路（VC）网络</strong></h4><ul><li><p>面向连接：预先建立连接</p></li><li><p>转发方式</p><ul><li><p>分组标识: 虚电路标识 (VCI)</p><ul><li>每一个分组包含一个 VCI</li></ul></li><li><p>交换机决策: 基于虚电路表</p><ul><li>交换机查询转发表确定分组的输出端口</li></ul></li><li><p>连接过程</p><ul><li>连接建立, 数据传输, 连接释放</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104074943.png" alt="image-20220104074943281" style="zoom:50%;" /></li></ul></li><li><p>虚电路的建立</p><ul><li>永久型虚电路（Permanent Virtual Circuit，PVC）<ul><li>网络管理员手工配置, 或由网络管理员产生信令探测形成</li><li>长期生存的虚电路</li></ul></li><li>交换型虚电路（Switched Virtual Circuit，SVC）<ul><li>主机动态发送信令建立连接</li><li>实际网络中SVC更为普遍</li><li>SVC信令<ul><li>建立<ul><li>源主机发送建立连接请求<ul><li>建立连接请求包含目的主机的完整地址</li></ul></li><li>中间交换机<ul><li>记录建立连接请求消息的输入端口</li><li>选择一个未使用的VCI值</li><li>确定输出端口</li><li>在虚电路表中插入一条记录</li><li>转发建立连接请求至下一个交换机</li></ul></li><li>目的主机<ul><li>选择一个可用的VCI值</li><li>沿着连接建立请求消息的路径反向发送确认消息</li></ul></li><li>中间交换机<ul><li>形成VC表记录</li></ul></li></ul></li><li>释放<ul><li>源主机发送释放连接消息</li><li>……</li></ul></li></ul></li></ul></li></ul></li><li><p>特点</p><ul><li>主机发送第一个数据分组前至少有一个RTT的时延, 用于连接建立</li><li>虽然建立连接请求包含目的主机的完整地址, 但每一个数据分组中仅带有一个很小的标识, 分组首部开销较小</li><li>如果一个连接上的交换机或链路出现故障, 连接就会被破坏, 需要建立新的连接</li><li>连接建立过程为虚电路提供了资源预留避免拥塞（对比：数据报网络是拥塞后恢复的策略）</li></ul></li></ul><h4 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a><strong>源路由</strong></h4><ul><li><p>源节点为每一个分组提供网络交换分组时所需的路由信息</p></li><li><p>源路由方法</p><ul><li>分组识别: 整条路径上所有交换机的端口序列<ul><li>分组首部包含从源节点到目的节点的整条路径的所有交换机的输出端口编号</li></ul></li><li>交换决策: 基于分组首部的路由<ul><li>交换机通过首部中的”下一个端口”指针读取下一个转发端口进行分组转发</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104075700.png" alt="image-20220104075700182" style="zoom:50%;" /></li><li><p>特点</p><ul><li>源节点知道全部的网络拓扑结构信息, 从而构造分组首部的源路由来指导交换机的分组转发</li><li>首部长度不固定, 由整条路径的跳数确定</li><li>源路由选择存在一个网络的规模性问题</li></ul></li></ul><h3 id="网桥和局域网交换机"><a href="#网桥和局域网交换机" class="headerlink" title="网桥和局域网交换机"></a>网桥和局域网交换机</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul><li>传统以太网局限性<ul><li>最多2500m的覆盖范围</li><li>最多容纳1024台主机</li></ul></li><li>拓展网络<ul><li>通过中继器再生放大信号</li><li>设计一种新的节点实现多个以太网之间的数据帧转发——&gt;网桥，有时通称为 以太网交换机</li></ul></li></ul><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><ul><li><p>是交换机的一种实现，实现了Ethernet的拓展</p></li><li><p>单一局域网的总通信量为10Mbps, 连接n个网桥的吞吐量最多能够达到<em>n</em> *10Mbps</p></li><li><p>在数据链路层拓展局域网使用网桥，在物理层拓展局域网使用转发器和集线器</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104081701.png" alt="image-20220104081701849" style="zoom:50%;" /></li></ul><h5 id="1-解决无脑全转发的问题：透明网桥"><a href="#1-解决无脑全转发的问题：透明网桥" class="headerlink" title="1. 解决无脑全转发的问题：透明网桥"></a>1. 解决无脑全转发的问题：透明网桥</h5><ul><li>网桥启动时, 转发表为空</li><li>通过<strong>逆向</strong>学习法构建<strong>端口—地址表</strong><ul><li>示例：洪泛法</li></ul></li><li>如果转发表中无对应记录, 则向所有其他端口转发数据帧</li><li>丢弃超时的记录(一段时间内未更新)，即 soft state</li><li>通过将帧中的目的结点的物理地址和自己地址表中的信息进行比较，实现帧的转发和过滤</li></ul><h5 id="2-解决网络环路问题：生成树算法"><a href="#2-解决网络环路问题：生成树算法" class="headerlink" title="2. 解决网络环路问题：生成树算法"></a>2. 解决网络环路问题：生成树算法</h5><ul><li>内容<ul><li>发送数据的源网桥的id</li><li>发送网桥认定的根网桥的id</li><li>从发送网桥到根网桥的距离 (跳数)</li><li>最初每个网桥认为自己是根节点</li><li>每个网桥生成配置消息并从每个端口发送出去</li><li>当网桥的某个端口收到新的配置消息后, 更新每个端口的配置消息</li><li>当网桥学习发现自己既不是根节点也不是指派节点时则停止发送配置信息</li><li>系统稳定时, 仅根网桥产生配置消息, 其他网桥仅在那些指派网桥的端口上转发这些配置消息</li><li>根节点周期性的发送配置消息</li><li>如果网桥在一段时间后仍未收到配置消息, 则重新宣布自己是根节点, 重新生成配置消息并转发</li></ul></li></ul><h5 id="3-解决广播和多播问题"><a href="#3-解决广播和多播问题" class="headerlink" title="3. 解决广播和多播问题"></a>3. 解决广播和多播问题</h5><ul><li>问题<ul><li>上述仅考虑了网桥的单播数据帧 </li><li>网桥的目标是透明的扩展局域网, 必须支持广播和多播</li></ul></li><li>解决<ul><li>广播：每个网桥将带有目标广播地址的数据帧传到除了接收它的端口以外的其他活动(选择)的端口</li><li>多播：扩展生成树算法用来裁减掉那些不需要转发多播帧的网络</li></ul></li></ul><h5 id="4-解决拓展性问题：虚拟局域网VLAN"><a href="#4-解决拓展性问题：虚拟局域网VLAN" class="headerlink" title="4. 解决拓展性问题：虚拟局域网VLAN"></a>4. 解决拓展性问题：虚拟局域网VLAN</h5><ul><li>拓展性差<ul><li>当连接网段的数量增加时, 生成树算法扩展性存在局限性</li><li>在一个大规模的网络中, 广播帧会影响网络的性能</li></ul></li><li>解决：虚拟局域网VLAN<ul><li>每一个虚拟局域网分配一个标识符</li><li>只有两个网段的标识符相同时, 才能完成数据帧的转发</li></ul></li></ul><h5 id="网桥-VS-交换机"><a href="#网桥-VS-交换机" class="headerlink" title="网桥 VS 交换机"></a>网桥 VS 交换机</h5><ul><li>网桥一般只有2个输入或输出端口，交换机有多个</li><li>网桥里的 MAC 地址表则是一个端口对应多个地址，交换机里则是一个端口对应一个 MAC 地址</li></ul><h3 id="共享式VS交换式以太网"><a href="#共享式VS交换式以太网" class="headerlink" title="共享式VS交换式以太网"></a>共享式VS交换式以太网</h3><h4 id="设备对比"><a href="#设备对比" class="headerlink" title="设备对比"></a>设备对比</h4><ul><li>共享式以太网：集线器Hub</li><li>交换式以太网：交换机Switch</li><li>以太网集线器——&gt;网桥——&gt;交换机<ul><li>集线器：在共享媒介局域网的核心设备，CSMA/CD</li><li>网桥：早期版本的交换机，用于局域网扩展，在不同网段之间转发数据帧</li><li>交换机：每个端口是个网桥，端口之间转发数据帧，不同端口之间可以传输隔离</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082122.png" alt="image-20220104082122447" style="zoom:50%;" /><h4 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h4><ul><li>共享式：共享带宽，用CSMA/CD应对冲突</li><li>交换式：除非两个源端口发往同一目的端口，否则不存在冲突（专用带宽）</li></ul><h2 id="4-3-IP服务模型与协议"><a href="#4-3-IP服务模型与协议" class="headerlink" title="4.3 IP服务模型与协议"></a>4.3 IP服务模型与协议</h2><ul><li><p>IP协议提供的服务类型是：<strong>无连接的数据报服务</strong></p><ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li></ul></li><li><p>为了防止IP数据报在Internet上无限制地传递，告知路由器是否应该丢弃某个数据报，在IP数据报首部设置了<code>生存时间TTL</code>字段</p></li><li><p>IP服务模型</p><ul><li><p>数据报传输</p><ul><li><p><strong>尽力而为</strong>的不可靠传输服务</p></li><li><p>数据报的路由选择与转发</p><ul><li>无连接方式</li></ul></li><li><p>分段与重组</p><ul><li><p>最大传输单元MTU</p><ul><li><p>是链路层数据可封装数据的上限，不同链路不同</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103103928.png" alt="image-20220103103928162" style="zoom: 33%;" /></li><li><p>大IP分组向较小MTU链路转发时，可以被分片，用IP首部相关字段标识分片的序号</p></li></ul></li><li><p>IP数据报分片发生在<strong>路由器</strong>，而重组发生在<strong>目的主机</strong></p></li><li><p>如果某一个分段丢失, 目的主机将放弃重组进程并丢弃已收到的分段</p></li><li><p>计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104114.png" alt="image-20220103104114780" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104156.png" alt="image-20220103104156874" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104222.png" alt="image-20220103104222098" style="zoom: 33%;" /></li></ul></li></ul></li></ul></li></ul><h2 id="4-4-IP地址及其划分"><a href="#4-4-IP地址及其划分" class="headerlink" title="4.4 IP地址及其划分"></a>4.4 IP地址及其划分</h2><h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><ul><li><p>IP地址是网络层中识别主机的<code>逻辑地址</code></p></li><li><p>层次化寻址：两级地址空间（网络号+主机号）</p></li><li><p>网络地址</p><ul><li>IP地址的网络号唯一标识一个网络</li><li>在同一个局域网上的主机或路由器的IP地址中的网络号必须一样</li><li>用网桥互连的网段仍然是一个局域网，只能有一个网络号</li><li>路由器总是具有两个或以上的IP地址</li><li>IP地址不能直接用来通信，在实际网络的链路上传送数据必须使用硬件地址（MAC）</li></ul></li><li><p>主机没有IP地址但要加入网络时，使用<code>DHCP</code>；主机发送数据但不知目的主机的硬件地址时，使用<code>ARP</code>；数据报传输过程中出现差错时，使用<code>ICMP</code></p></li></ul><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><ul><li><p>有类IP地址</p><ul><li><p>A类网络IP地址范围：1.0.0.1 - 127.255.255.254（<code>16777216-2</code>个主机/子网，2^24）</p></li><li><p>B类网络IP地址范围：128.0.0.1 - 191.255.255.254（<code>65536-2</code>个主机/子网，2^16）</p></li><li><p>C类网络IP地址范围：192.0.0.1 - 223.255.255.254（<code>256-2</code>个主机/子网，2^8）</p></li><li><p>D类网络IP地址范围：224.0.0.1 - 239.255.255.254（只用于多播）</p></li><li><p>E类网络IP地址范围：240.0.0.1 - 255.255.255.254（留给未来使用）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104634.png" alt="image-20220103104634464" style="zoom: 33%;" /></li></ul></li><li><p>私有IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104904.png" alt="image-20220103104904787" style="zoom: 25%;" /></li></ul><h3 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h3><ul><li><p>网络号与主机号</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104547.png" alt="image-20220103104547071" style="zoom: 33%;" /></li><li><p>特殊IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104827.png" alt="image-20220103104827382" style="zoom:33%;" /></li><li><p>子网划分</p><ul><li><p>IP地址：原本的主机号高位比特改为子网号（SubID）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105116.png" alt="image-20220103105116448" style="zoom:25%;" /></li><li><p>子网掩码：NetID、SubID位全取1，用于表示利用多少位划分子网</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105245.png" alt="image-20220103105245490" style="zoom:33%;" /><ul><li><p>用于确定子网IP信息：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105333.png" alt="image-20220103105333288" style="zoom:33%;" /></li></ul></li><li><p>划分子网时，优先分配<strong>较大</strong>的子网</p></li><li><p>一个C类网络子网划分例子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105529.png" alt="image-20220103105529431" style="zoom:33%;" /></li><li><p>IP子网寻址示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085055.png" alt="image-20220104085055931" style="zoom:50%;" /></li><li><p>切记，子网中网络地址（全0）和广播地址（全1）占用了2个地址，因此子网主机数量实际上是<strong>可用主机号数量加2</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085338.png" alt="image-20220104085338005" style="zoom: 50%;" /></li><li><p>已知网络类型和子网掩码，计算子网和主机数</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104150405.jpg" alt="img" style="zoom: 25%;" /><p>B类有16位（后16位）的主机位，依题，其中前10（8+2）位用作子网号，则子网有2^10=1024个，主机有2^6-2=62个</p></li></ul></li><li><p>优点</p><ul><li>提高了地址分配效率，加入一个新的物理网络时不需要用光B类或C类网络的所有地址</li><li>有利于信息聚合，减少路由器为了转发数据报到这些网络所需存储的信息量</li></ul></li></ul><h3 id="无分类编址CIDR与路由聚合"><a href="#无分类编址CIDR与路由聚合" class="headerlink" title="无分类编址CIDR与路由聚合"></a>无分类编址CIDR与路由聚合</h3><ul><li>CIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号，消除传统的A、B、C类网络地址界限</li><li>CIDR将网络前缀都相同的连续IP地址组成CIDR地址块</li><li>融合子网地址与子网掩码，方便子网划分<ul><li><p>无类地址格式：<code>a.b.c.d/x</code>，其中x是前缀长度（子网掩码里1的个数）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103110934.png" alt="image-20220103110927258" style="zoom: 33%;" /></li></ul></li><li>优点<ul><li><p>提高IPv4地址空间分配效率</p></li><li><p>提高路由效率，减少了路由表和转发表的记录数量（这是子网划分处理不了的）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103111123.png" alt="image-20220103111123578" style="zoom:33%;" /></li></ul></li><li>最长前缀匹配优先<ul><li><p>在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口</p></li><li><p>使用CIDR查找路由表时可能会得到多个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，路由就越具体</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104145741.jpg" alt="Screenshot_20220104-145630_Superstar" style="zoom: 25%;" /></li></ul></li></ul><h3 id="地址转换协议（ARP）"><a href="#地址转换协议（ARP）" class="headerlink" title="地址转换协议（ARP）"></a>地址转换协议（ARP）</h3><ul><li>给定目的主机的IP地址, ARP可以找到同属一个物理网络内部的目的主机的物理地址</li><li>ARP采用<strong>广播机制</strong>，路由器可以隔绝ARP广播</li><li>每一个主机维护一个ARP表：<ul><li>并不是由一个服务器来负责回答请求，而是“自给自足”</li><li>15分钟记录未更新则超时失效</li></ul></li><li>当ARP表中无目的IP地址的对应记录，则ARP协议开始启动</li><li>工作原理<ul><li>主机X广播一个 ARP请求报文来探寻未知的节点D的IP地址</li><li>节点D 向源节点反馈其物理地址<ul><li>D节点 在本地ARP表中增加或更新节点X对应的记录</li></ul></li><li>节点X将收到的信息写入其ARP表</li><li>同一网络内的其他主机<ul><li>如果本地的ARP表中已存在节点X的IP地址对应的记录, 则更新记录</li><li>否则，do nothing</li></ul></li></ul></li></ul><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><ul><li><p>DHCP协议在应用层实现，借助UDP数据报在链路层广播</p></li><li><p>DHCP允许主机自动从服务器获取：IP地址、子网掩码、默认网关地址、DNS服务器与IP地址</p></li><li><p>即插即用</p></li><li><p>允许地址重复使用</p></li><li><p>支持在用地址续租</p></li><li><p>支持移动用户加入网络</p></li><li><p>DHCP服务器会给出包含配置参数的提议供主机选择</p></li><li><p>新到主机（DHCP客户）获取IP地址的过程：</p><ul><li><p>主机广播：“DHCP discover”</p></li><li><p>DHCP服务器利用“DHCP offer”进行响应</p></li><li><p>主机请求IP地址：“DHCP request”</p></li><li><p>DHCP服务器分配IP地址：“DHCP ack”</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103135749.png" alt="image-20220103135749025" style="zoom: 33%;" /></li></ul></li></ul><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><ul><li><p>网络地址转换（NAT）</p></li><li><p>实现<code>本地设备IP地址</code>和<code>与外界通信时所用IP地址</code>之间的转换</p></li><li><p>本地网络内不同设备有不同IP地址，但是在对外交流时使用<strong>同一NAT IP地址</strong>的<strong>不同端口号</strong></p></li><li><p>内部网络设备对外界网络不可见，即外界无法直接寻址（安全）</p></li><li><p>本地网络IP地址的变更无需通告外界网络</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103140400.png" alt="image-20220103140400114" style="zoom:33%;" /></li></ul><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><ul><li><p>互联网控制报文协议（ICMP）</p></li><li><p><code>ping</code>发出的是ICMP报文，目的IP回复对应ICMP报文，用于检测网络连通性</p></li><li><p><code>traceroute</code>发出TTL=1的数据包，第一个接收到路由器回回传ICMP报文（TTL=0），然后<code>traceroute</code>发出TTL=2的数据包给第二个路由器，递推得到到达目的节点所经过的路由器序列</p></li><li><p>支持主机或服务器：差错检测、网络探寻</p></li><li><p>ICMP差错报文</p><ul><li><p>终点不可达</p><ul><li>终点不可达分为：网络不可达、主机不可达、协议不可达、端口不可达、需要分片但DF比特已置1、源路由失败，共6种情况，向源站发送对应的代码字段0~5的不可达报文</li></ul></li><li><p>端口不可达</p><ul><li>UDP的规则之一是：如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP报文</li></ul></li><li><p>源站抑制：</p><ul><li>当路由器或主机由于拥塞而丢弃数据报时，就向源站发送源站抑制报文，使源站知道应当将数据报发送速率放慢</li></ul></li><li><p>时间超时</p><ul><li>当路由器收到生存时间TTL为0的数据报时，除了丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送超时报文</li></ul></li><li><p>参数问题</p><ul><li>当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文</li></ul></li><li><p>改变路由（重定向）</p><ul><li>将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器</li></ul></li></ul></li><li><p>以下几种数据报不会导致产生ICMP差错报文：</p><ul><li>ICMP差错报文（但是ICMP查询报文可能会产生ICMP差错报文）</li><li>目的地址是广播地址或多播地址的数据报</li><li>作为链路层广播的数据报</li><li>不是IP分片的第1片</li><li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址</li></ul></li><li><p>ICMP网络探寻报文</p><ul><li>回声（Echo）请求与应答（Reply）报文</li><li>时间戳请求与应答报文</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul><li><p>RFC2373中详细定义了IPv6地址，按照定义，一个完整的IPv6地址的表示法：xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx<br>例如：2031:0000:1F1F:0000:0000:0100:11A0:ADDF（4位×8段）</p><p>为了简化其表示法，rfc2373提出<strong>每段中前面的0可以省略</strong> ；<strong>连续的0可省略为”::”，但只能出现一次</strong>。例如：</p><table><thead><tr><th>原地址</th><th>简写</th></tr></thead><tbody><tr><td>1080:0:0:0:8:800:200C:417A</td><td>1080::8:800:200C:417A</td></tr><tr><td>FF01:0:0:0:0:0:0:101</td><td>FF01::101</td></tr><tr><td>0:0:0:0:0:0:0:1</td><td>::1</td></tr><tr><td>0:0:0:0:0:0:0:0</td><td>::</td></tr></tbody></table></li><li><p>数据格式</p><ul><li>定长40字节报头</li><li>不允许片段</li></ul></li><li><p>IP隧道（IPv4向IPv6过渡）</p><ul><li><p>IPv4路由器中IPv6数据报作为IPv4数据报的负载</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104101322.png" alt="image-20220104101322686" style="zoom:50%;" /></li></ul></li></ul><h2 id="4-5-路由算法与协议"><a href="#4-5-路由算法与协议" class="headerlink" title="4.5 路由算法与协议"></a>4.5 路由算法与协议</h2><h3 id="转发-VS-路由"><a href="#转发-VS-路由" class="headerlink" title="转发 VS 路由"></a>转发 VS 路由</h3><ul><li><p>转发（数据平面）</p><ul><li>过程：获得一个分组, 查看其目的地址，查询本地转发表，将分组从输出端口发送出去</li><li>节点(路由器/交换机)本地执行</li></ul></li><li><p>路由（控制平面）</p><ul><li>转发表的构建过程</li><li>通常由基于复杂分布式算法的路由协议完成</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104084242.png" alt="image-20220104084242379" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104090244.png" alt="image-20220104090244257" style="zoom: 67%;" /></li></ul><h3 id="距离向量（DV）路由选择"><a href="#距离向量（DV）路由选择" class="headerlink" title="距离向量（DV）路由选择"></a>距离向量（DV）路由选择</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>与路由器直接连接的网络的距离值为0</li><li>每个节点构造一个包含到所有其他节点的”距离”(代价)的一维数组(一个向量)</li><li>并将该向量分发给其邻节点</li><li>节点根据接收到的距离向量计算到达其他所有节点的最短路径</li><li>经过距离向量的迭代交换和计算过程最终构造完整的路由表</li><li>注意，只能找到去每个网络的最短路径中的一条，不能所有都找到</li></ul></li><li><p>步骤</p><ul><li><p>步骤1：最初节点将向量中可直接到达的邻节点的代价设置为<strong>1</strong>，到所有其他节点的代价赋值为<strong>∞</strong></p></li><li><p>步骤2：节点将距离向量发送至直接可达的邻节点</p></li><li><p>步骤3：根据从邻节点<strong>Y</strong>收到的距离向量，节点<strong>X</strong></p><ul><li>计算本节点到达所有其他节点的距离：将来自<strong>Y</strong>的向量中到达所有其他节点的距离(例如 <strong>Z</strong>)加上本节点到<strong>Y</strong>的距离 (即<strong>1</strong>）</li><li>比较计算结果与本地向量中对应结果的大小：如果计算结果更小，则用该值替换本地距离向量的对应结果，并记录NextHop 为<strong>Y</strong></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091156.png" alt="image-20220104091156375" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091222.png" alt="image-20220104091222480" style="zoom:50%;" /></li></ul></li><li><p>链路代价变化</p><ul><li>节点检测到本地链路代价改变 </li><li>更新路由信息，重新计算距离矢量</li><li>如果DV发生改变，通知相应的邻居</li></ul></li><li><p>无穷计算问题</p><ul><li><p>场景</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091516.png" alt="image-20220104091516434" style="zoom:50%;" /></li><li><p>方案A：采用最大跳数取代无穷大</p></li><li><p>方案B：水平分割</p><ul><li>不向提供路由的邻节点发送更新报文</li><li>例如：节点B不向节点A发送有关节点E的更新信息，因为节点B到达节点的用路由是从节点学习而来的</li></ul></li><li><p>方案C：带反向抑制的水平分割</p><ul><li>节点B通告到达节点E的代价为无穷大，以确保节点A最终不会使用节点B来到达节点E</li></ul></li><li><p>上述解决方案在路由循环超过3节点的网络环境中网络会失效</p></li></ul></li></ul><h4 id="路由选择信息协议（RIP）"><a href="#路由选择信息协议（RIP）" class="headerlink" title="路由选择信息协议（RIP）"></a>路由选择信息协议（RIP）</h4><ul><li>基于距离向量算法</li><li>30s更新一次距离向量</li><li>跳数最大值为15，16意味无穷大</li></ul><h3 id="链路状态（LS）路由选择"><a href="#链路状态（LS）路由选择" class="headerlink" title="链路状态（LS）路由选择"></a>链路状态（LS）路由选择</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>每个节点都知道怎样到达它的邻节点(link state), 并向通告给其他所有节点, 因此<strong>每个节点都可以获得完整的网络信息</strong>来建立其路由表</li><li>链路状态的度量可以是：距离、带宽、时延、费用等</li></ul></li><li><p>依赖链路状态的<strong>可靠洪范</strong></p><ul><li>链路状态报文(Link State Message)<ul><li>链路状态分组, LSP (Link State Packet)</li><li>创建LSP的节点ID</li><li>与该节点直接相邻的节点信息列表 &lt;AdjacentNode, Cost&gt;, 其中包括到这些邻节点的链路代价</li><li>序号 Seq</li><li>LSP的生命周期</li></ul></li><li>保证链路状态分组的洪泛<ul><li>采用确认和重传机制</li><li>通过序号</li><li>不发回发送LSP的节点</li></ul></li><li>新的链路状态分组快速洪泛, 旧的分组快速被删除<ul><li>采用序列号和TTL</li><li>长序列号</li><li>逐跳递减TTL</li></ul></li><li>链路状态洪泛的触发器<ul><li>周期性计时器超时</li><li>拓扑结构变化</li></ul></li></ul></li><li><p>路由计算（基于Dijkstra算法）</p><ul><li><p>算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092709.png" alt="image-20220104092709471" style="zoom: 67%;" /></li><li><p>示例1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092448.png" alt="image-20220104092448663" style="zoom:50%;" /></li><li><p>示例2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103100722.png" alt="image-20220103100722586" style="zoom: 33%;" /></li></ul></li><li><p>算法分析</p><ul><li>时间复杂度：O(n^2)，可优化为O(nlogn)</li><li>可能存在路由震荡（无穷计算）</li><li>优点<ul><li>快速稳定</li><li>不会产生过多的通信量</li><li>快速响应拓扑变化</li></ul></li><li>缺点<ul><li>节点存储的信息量大(所有其他节点的LSP)</li></ul></li></ul></li><li><p>如果在一个使用链路状态路由的互联网络中有5个路由器和6个网络，那么存在<code>5</code>个路由表，每个表中至少有<code>6</code>个表项，在路由器中存在<code>1</code>个不同的链路状态数据库</p></li><li><p>链路状态 VS 距离向量</p><ul><li>链路状态：每个节点只告诉所有其他节点与之<strong>相邻</strong>的链路状态</li><li>距离向量：每个节点只与直接相连的节点通信，但是包含到达<strong>所有</strong>节点的距离</li></ul></li></ul><h4 id="开放最短路径优先（OSPF）"><a href="#开放最短路径优先（OSPF）" class="headerlink" title="开放最短路径优先（OSPF）"></a>开放最短路径优先（OSPF）</h4><ul><li>基于链路状态算法</li><li>高级特征（RIP没有）<ul><li>安全性：所有OSPF报文需要认证 (避免恶意入侵)</li><li>允许多条相同代价的路径存在 (RIP中仅允许一条路径)</li><li>对一条链路而言，可以依据不同的TOS分配不同的代价值(例如：卫星链路从实时性考虑代价较大, 但从尽最大努力交付能力来说代价较小)</li><li>支持单播和多播<ul><li>多播OSPF (MOSPF)使用与OSPF相同的拓扑数据</li></ul></li><li>在一个较大的域内采用<strong>层次化</strong>OSPF</li></ul></li><li>OSPF协议将一个自治域划分成若干区域，有一种特殊区域叫做主干区域<ul><li>域之间通过边界路由器互联</li><li>在自治系统中有4中路由器：区域内部路由器、主干路由器、区域边界路由器、自治域边界路由器</li><li>主干路由器可以兼做区域边界路由器</li></ul></li></ul><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Internet将整个网络划分为许多较小单位AS：由同一个管理机构管理，使用统一的路由策略的路由器的集合</li><li>每一个自治系统(AS)在一个独立的管理实体的控制之下<ul><li>示例：校园网络、公司网络</li></ul></li><li>由此，路由协议也分为两大类：<strong>内部网关协议IGP</strong>、<strong>外部网关协议EGP</strong></li></ul><h4 id="内部网关协议（IGP）"><a href="#内部网关协议（IGP）" class="headerlink" title="内部网关协议（IGP）"></a>内部网关协议（IGP）</h4><ul><li>内部网关协议（Interior Gateway Protocol）是一个在自治网络内部网关（主机和路由器）间交换路由信息的协议。路由信息用于网间协议（IP）或者其他网络协议来说明路由传送是如何进行的</li><li>包括：RIP、OSPF、IS-IS、IGRP、EIGRP等</li><li>选路原则：优先级、开销、负载均衡</li><li>典型协议<ul><li>RIP协议<ul><li>RIP协议是一种内部网关协议，底层是贝尔曼福特算法，是一种动态路由选择协议。</li><li>基于<strong>距离向量</strong>算法，使用跳数来衡量到达目标地址的路由距离</li><li>运行在<strong>UDP</strong>协议之上，使用520端口，使用224.0.0.9作为组播地址向外组播路由信息</li><li>以跳数作为选择路由的度量标准，只适用于<strong>小区域</strong></li><li>通过广播UDP报文来交换信息，<strong>30s</strong>发送一次路由信息更新</li><li>最多支持的跳数为15，16及以上就表示为不可达</li><li>要求路由器维护从它到每个内部路由器的距离向量</li><li>使用<strong>毒性逆转</strong>法预防乒乓环路无穷计算，设置无穷大距离为16</li></ul></li><li>OSPF协议<ul><li>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议</li><li>基于<strong>链路状态</strong>路由协议</li><li>运行于<strong>IP</strong>协议之上</li><li>允许使用多条相同费用的路径（RIP只能选择一条）</li><li>以带宽、延迟作为选择路由的度量标准，适用于<strong>大中型</strong>网络</li></ul></li></ul></li></ul><h4 id="外部网关协议（EGP：BGP）"><a href="#外部网关协议（EGP：BGP）" class="headerlink" title="外部网关协议（EGP：BGP）"></a>外部网关协议（EGP：BGP）</h4><ul><li>外部网关协议（Exterior Gateway Protocol）是AS之间使用的路由协议，目前只有一个协议：BGP</li><li><strong>边界网关（BGP）协议</strong><ul><li>运行于<strong>TCP</strong>基础上</li><li>属于域间路由选择，“把互联网粘合在一起”</li><li>基于<strong>路径向量</strong>算法（不使用距离向量（收敛慢）、链路状态（强迫告知敏感信息，不安全））<ul><li>支持灵活的路由策略（商业要求）</li><li>避免无穷计算</li><li>核心思想: 通告整个路径<ul><li>路由表要包括分组到达目的网络的路径</li><li>所交换的网络可达性信息是：<strong>到达某个网络所经过的路径</strong></li></ul></li></ul></li><li>使用<strong>TCP</strong>作为传输层协议</li><li>内容：<ul><li>节点知道多条到达目的地的路径<ul><li>在路由表中存储所有的路由</li><li>采用策略选择一条最好的路由</li></ul></li><li>增量更新<ul><li>通告<ul><li>一旦选择一条新的路由, 则将节点id加入路径向量</li><li>… 并(有选择性的)通告其他邻居</li></ul></li><li>撤销<ul><li>如果路由不再有效</li><li>… 发送撤销路由消息</li></ul></li></ul></li></ul></li><li>主要功能是和其他的 BGP 系统交换网络可达信息</li><li>BGP的邻居关系（或称通信对端/对等实体）是通过人工配置实现的，对等实体之间通过TCP（端口179)会话交互数据</li><li>BGP路由器会周期地发送19字节的保持存活keep-alive消息来维护连接（默认周期为30秒）</li><li>热土豆路由<ul><li>有多个网关路由器可以到达目的子网时，选择最小费用路径的区域间路由器</li></ul></li></ul></li></ul><p><strong>直接封装RIP、OSPF、BGP报文的协议分别为：UDP、IP、TCP</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>又称为 组播，与一组主机进行通信，指多个接收者可以收到同一个或者同一组源节点发送的相同内容的分组</li><li>避免单播的低效和广播的无区分性</li><li>发送主机使用多播地址发送分组时不需要了解接收者的位置信息和状态信息</li><li>组播协议（IGMP）<ul><li>IGMP协议运行于主机与组播路由器之间，这描述了IGMP的应用场景</li><li>只有主机和路由器才会使用，如果是路由器和路由器之间，是不会使用IGMP的</li><li>IGMP提供了在转发组播数据包到目的地的最后阶段所需的信息，实现如下双向的功能：<ol><li>主机通过IGMP通知路由器希望接收或离开某个特定组播组的信息</li><li>路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护</li></ol></li></ul></li></ul><h4 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h4><ul><li>ISP使用</li><li>解决BGP的路由黑洞问题</li></ul><h4 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h4><ul><li>目的地址为家乡地址的IP分组，将会以标准的IP路由机制发送到家乡网络</li><li>家乡链路与外地链路比家乡网络与外地网络更精确地表示出移动结点接入点位置</li><li>家乡代理通过隧道将发送给移动节点的 IP 分组转发给移动节点</li><li>终端系统处理<ul><li>间接选路: 从通信者到漫游节点的通信，通过本地代理，然后被转发到漫游网络</li><li>直接选路: 通信者获得漫游节点的外部地址/转交地址, 直接发送给漫游节点</li></ul></li><li>三角路由（间接选路）<ul><li>通信者-本地网络-漫游节点</li></ul></li></ul><p>&nbsp;</p><h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><ul><li><p>网络层负责主机到主机的通信，传输层负责进程到进程的通信</p></li><li><p>基本理论和基本机制</p><ul><li><p>发送端多路复用，接收端解复用</p></li><li><p>复用/解复用</p><ul><li>无连接的解复用：UDP的Socket，用二元组（目的IP地址，目的端口号）标识</li><li>面向连接的解复用：TCP的Socket，用四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识</li></ul></li><li><p>可靠数据传输机制</p><ul><li>差错检测（校验和）</li><li>确认机制（含序号分组和ACK）</li><li>确认重传机制（ARQ协议）</li><li>停—等协议——&gt;流水线机制——&gt;滑动窗口协议：后退N帧（GBN）、选择性路由（SR）</li></ul></li></ul></li><li><p>TCP/IP协议族的层次中，解决计算机之间通信问题是在<strong>网络层</strong></p></li><li><p>在OSI参考模型中，提供流量控制功能的是：<strong>数据链路层</strong>、<strong>传输层</strong></p></li></ul><h2 id="5-2-用户数据报（UDP）协议"><a href="#5-2-用户数据报（UDP）协议" class="headerlink" title="5.2 用户数据报（UDP）协议"></a>5.2 用户数据报（UDP）协议</h2><ul><li>关于UDP的描述<ul><li>发送数据之前不需要建立连接（减少延迟）</li><li>没有拥塞控制，应用可以更好地控制发送时间和速率</li><li>相对于IP数据报服务，UDP在IP之上只增加了<strong>端口</strong>的功能和<strong>差错检测</strong>功能（校验和，checksum）</li><li>UDP用户数据报只能提供不可靠的交付，可能乱序、丢失</li></ul></li><li>关于端口的描述<ul><li>端口就是传输层服务访问点</li><li>端口号只具有本地意义，在Internet中不同计算机的相同端口号是没有联系的</li><li>Socket由IP地址和端口号组成</li></ul></li><li>UDP协议中，伪首部的作用是：为差错检测提供帮助</li><li>为解决UDP报文的可靠传输问题：<ul><li>在应用层增加可靠性机制</li><li>应用特定的错误恢复机制</li></ul></li><li>优点<ul><li>控制数据发送的内容和时间</li><li>不存在连接建立时延</li><li>无状态连接</li><li>报文首部开销较小</li></ul></li><li>缺点<ul><li>不保证报文的传送, 可能出现乱序到达</li><li>无拥塞控制</li><li>抑制TCP流</li></ul></li><li>应用<ul><li>域名解析系统：DNS</li><li>多媒体应用</li></ul></li></ul><h2 id="5-3-可靠字节流（TCP）协议"><a href="#5-3-可靠字节流（TCP）协议" class="headerlink" title="5.3 可靠字节流（TCP）协议"></a>5.3 可靠字节流（TCP）协议</h2><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><ul><li>面向连接<ul><li>终端主机在数据交换之前需要连接连接</li><li>全双工：数据可双向传输</li></ul></li><li>可靠性<ul><li>保证数据的传送</li><li>数据按序到达</li></ul></li><li>流量控制<ul><li>控制发送方的速率避免接收方过载</li><li>在链路层也存在流量控制</li></ul></li><li>拥塞控制<ul><li>控制发送方速率避免网络过载</li><li>拥塞控制由网络层和传输层协作解决</li></ul></li></ul><h4 id="TCP帧结构"><a href="#TCP帧结构" class="headerlink" title="TCP帧结构"></a>TCP帧结构</h4><ul><li>1 - 2 字节：源端口号</li><li>3 - 4 字节：目的端口号</li><li>5 - 8 字节：序列号Seq</li><li>9 - 12 字节：确认号ACK</li><li>14字节：标志位SYN</li><li>17 - 20 字节：缺省通告窗口AdvertisedWindow，描述接收方窗口大小</li><li>其中，AdvertisedWindow必须大于链路的时延带宽积；Sequence Number必须大于AdvertisedWindow的2倍，且大于链路带宽×数据段最大TTL（支持数据段最大生存期）</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220105074604.png" alt="image-20220104235736233" style="zoom: 33%;" /><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><ul><li><p>Client发送建立连接请求（SYN=1，Seq=x）至Server</p></li><li><p>Server回复确认前序请求（ACK=1，ack=x+1），同时捎带对发送进程的连接请求（SYN=1，Seq=y）——&gt;(ACK=1，ack=x+1，SYN=1，Seq=y)</p></li><li><p>Client回复确认前序请求（ACK=1，ack=y+1）</p></li><li><p>为什么三次握手？</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104103543.png" alt="image-20220104103543736" style="zoom: 67%;" /></li></ul><h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><ul><li>Client发送连接断开请求（FIN=1，Seq=u）至Server</li><li>Server回复确认前序请求（ACK=1，ack=u+1），同时继续发送待传输数据（Seq=v）</li><li>Server等待上层应用数据传输完毕之后，Server重复确认前序请求（ACK=1，Seq=u+1），同时发送连接断开请求（FIN=1，Seq=w）</li><li>Client回复确认前序请求（ACK=1，ack=w+1，Seq=u+1），继续等待2<code>MSL</code>时间后关闭</li></ul><h4 id="TCP数据报中变量"><a href="#TCP数据报中变量" class="headerlink" title="TCP数据报中变量"></a>TCP数据报中变量</h4><ul><li>建立连接阶段，seq=随机值；后续阶段，seq=对面发送数据报的序号</li><li>ack = 希望接收的数据报的序号 = 对方数据报seq值 + 1</li><li>ACK是标志位，= 1说明为ACK信号</li></ul><h2 id="5-4-TCP滑动窗口算法"><a href="#5-4-TCP滑动窗口算法" class="headerlink" title="5.4 TCP滑动窗口算法"></a>5.4 TCP滑动窗口算法</h2><ul><li><p>TCP采用改进的滑动窗口算法实现：</p><ul><li>保证数据的可靠传送</li><li>确保数据的有序传送</li><li><strong>流量控制</strong> (基于变化的 AdvertisedWindow 字段)</li></ul></li><li><p>滑动窗口算法采用变化的接收窗口大小</p><ul><li><p>接收方通知发送方其窗口大小，该值可能随时间变化</p></li><li><p>接收窗口大小通过TCP首部的AdvertisedWindow字段描述</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104104349.png" alt="image-20220104104349810" style="zoom:50%;" /></li></ul></li><li><p>ACK信息还包括期望接受的下一字节</p></li><li><p>触发传输</p><ul><li>当收集到的字节数达到MSS 时</li><li>发送进程明确要求TCP发送时</li><li>定时器激活</li></ul></li><li><p>超时重传</p><ul><li><p>采用自适应机制估计当前RTT作为定时依据</p></li><li><p>原始算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105042.png" alt="image-20220104105041940" style="zoom: 67%;" /></li><li><p>Karn/Partridge算法</p><ul><li>TCP重传时停止计算RTT样本值</li><li>每次重传后设置下次超时的值为上次的两倍（指数退避）</li></ul></li><li><p>Jacobson/Karn算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105153.png" alt="image-20220104105153647" style="zoom:50%;" /></li></ul></li></ul><h2 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h2><ul><li><p>发送端限制发送速率</p><ul><li><p>拥塞窗口CongWin</p><ul><li><p>发送端的发送窗口上限值应取<strong>接收方窗口</strong>和<strong>拥塞窗口</strong>中的较小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143429.png" alt="image-20220103143429277" style="zoom: 33%;" /></li></ul></li><li><p>接收窗口 VS 拥塞窗口</p><ul><li>接受窗口用于流量控制，避免快速发送方使慢速接收方过载</li><li>拥塞窗口用于拥塞控制，避免多个发送方使网络过载</li></ul></li><li><p>发送窗口 = min（接收窗口，拥塞窗口，链路时延带宽积）</p></li></ul></li><li><p>拥塞事件</p><ul><li>超时</li><li>3个重复ACK</li></ul></li><li><p>调整发送速率</p><ul><li>加性增——乘性减：AIMD<ul><li>加性增：每个RTT将CongWin增大一个MSS——<strong>拥塞避免</strong></li><li>乘性减：发生拥塞事件后将CongWin减半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143712.png" alt="image-20220103143712710" style="zoom: 50%;" /></li></ul></li><li>慢启动：SS<ul><li>TCP初始时，CongWin=1</li><li>开始阶段，指数性增长：每个RTT（收到ACK时）将CongWin翻倍</li><li>考虑在一个具有 10ms 往返时延的线路上采用慢启动拥塞机制。假设没有发生网络拥塞，该 TCP 的报文段大小为 2KB，接收方可用接收窗口为 24KB。那么发送方需要<code>40</code>ms 时间才能达到该接收窗口大小<ul><li>已知最大报文段式2KB，开始的突发量分别是2KB、4KB、8KB、16KB，接下来即为24KB，因为不能超过接收窗口，因此，需要40ms才能发送第一个完全窗口</li></ul></li></ul></li><li>状态切换：<ul><li>变量Threshold记录AIMD和SS切换的阈值</li><li>朴素思想：<ul><li>CongWin小于Threshold时采用SS，大于Threshold时采用AIMD</li><li>发生拥塞事件时Threshold置为拥塞事件瞬间CongWin大小的一半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144059.png" alt="image-20220103144059883" style="zoom:50%;" /></li></ul></li><li>实际规定：<ul><li>收到3个重复ACK时，<strong>快速恢复</strong><ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin减少一半</li><li>采用AIMD</li></ul></li><li>发生超时事件时<ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin置为1</li><li>采用SS</li><li>达到Threshold时再换为AIMD</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144605.png" alt="image-20220103144605452" style="zoom:50%;" /></li><li>设 TCP 的拥塞窗口的慢启动门限值初始为 12（单位为报文段），当拥塞窗口达到 16 时出现超时，再次进入慢启动过程。问从这时起，需要<code>12</code>次往返时延才能恢复到超时那时的拥塞窗口大小<ul><li>出现超时后，拥塞窗口设为1，拥塞避免门限为8<br>因此经过3个RTT后拥塞窗口增加为8<br>在经过8个RTT后拥塞窗口增加到16<br>因此共需要8+3=11个RTT才能使拥塞窗口恢复为超时时的16</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>快速重传</strong></p><ul><li>在收到3次重复ACK时，不必等待超时计时器，立刻重传对应序号的分组以避免超时</li></ul></li><li><p>公平性</p><ul><li><p>TCP具有公平性，带宽平均分配（原因：加性增、乘性减）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104110059.png" alt="image-20220104110059041" style="zoom:50%;" /></li><li><p>但与UDP同时抢占资源时不占优势</p></li></ul></li><li><p>其他</p><ul><li>TCP协议中观察网络拥塞的办法是 <code>以超时作为网络拥塞的标志</code></li><li>在 TCP/IP 中，实施流量控制的目的是 <code>保证接收方总是来得及接收发送方发出的报文或分组</code></li><li>在 TCP 协议中，如果发送窗口直接按照接收方的通知窗口设置，其结果是 <code>突发流量导致分组无法到达接收方</code></li><li>在 TCP 协议中，如果发送方收到三个重复的 ACK 后, 发送方将会 <code>快速重传未被确认的报文段</code></li><li>多媒体应用经常不使用 TCP 的原因可能是 <code>不希望数据传输速率受限于拥塞窗口</code></li><li>主机 A 和主机 B 之间建立了一个 TCP 连接，TCP 最大的数据段长度为 1000 字节，若主机 A 当前的拥塞窗口为 4000 字节，在主机 A 向主机 B 连续发送两个最大段之后，成功收到主机 B 回复的第一段的确认，确认报文中通告的接收窗口大小为 2000 字节，则此时主机 A 还可以向主机 B 发送的最大字节数是 <code>1000</code><ul><li>第一个段的确认段中通告的接收窗口大小为2000字节，即表明在接受到第一个报文段后，还有2000字节的缓存空间可用。 由于发送方发送了二个报文段，第二个段将占用剩下的2000字节中的1000字节，即一共还有（ 2000-1000=1000 ）字节，因而，此时主机甲还可以向主机乙发送的最大字节数是1000字节</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h3 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络应用体系结构</p><ul><li>客户机/服务器（C/S）结构<ul><li>Web应用</li><li>Email应用</li><li>DNS应用</li></ul></li><li>点对点结构(P2P)结构<ul><li>BitTorrent、文件共享（电驴）、即时消息（QQ）</li></ul></li><li>混合型结构</li></ul></li><li><p>通过<code>IP地址</code>对主机进行寻址后通过<code>端口号</code>标识不同进程</p><ul><li>HTTP Server：80</li><li>Email Server：25</li></ul></li><li><p>在整个Internet上，使用<code>IP地址+端口号</code>唯一标识一个特定的应用进程</p></li><li><p>在 Internet 域名体系中，域的下面可以划分子域，各级域名用圆点分开，按照 <code>从右到左越来越小的方式分多层排列</code></p></li><li><p>当一台计算机从 FTP 服务器下载文件时，在该 FTP 服务器上对数据进行封装的五个转换步骤是 <code>消息，报文段，数据报，数据帧，比特</code></p></li><li><p>网络应用实例</p><ul><li>E-mail</li><li>Web</li><li>即时通信（QQ）</li><li>远程登陆（ssh、telnet）</li><li>P2P文件共享（BitTorrent）</li><li>IP电话（Skype）</li><li>……</li></ul></li></ul><h3 id="Web应用与HTTP协议"><a href="#Web应用与HTTP协议" class="headerlink" title="Web应用与HTTP协议"></a>Web应用与HTTP协议</h3><ul><li><p>万维网WWW（World Wide Web）</p><ul><li>浏览器是运行于计算机上的万维网客户端程序；万维网文档所驻留的计算机则运行服务器程序</li><li>WWW工作过程可简要描述为：<ul><li>浏览器于服务器之间建立TCP连接</li><li>浏览器发出HTTP请求报文</li><li>服务器给出HTTP响应报文</li><li>断开TCP连接</li><li>响应时间 = 2×RTT+文件传输时间</li></ul></li><li>一个超文本由多个信息源链接而成，利用一个链接可使用户找到因特网上的另一个文档<ul><li>超文本：含有链接到其他文本的链接点的文本</li></ul></li></ul></li><li><p>Web</p><ul><li>网页由某些<strong>对象</strong>组成</li><li>对象可以是HTML文件、JPEG图片、Java Applet、音频文件……</li><li>网页由包含以上某些对象的基本HTML文件构成</li><li>每个对象都由一个URL定位</li></ul></li><li><p>超文本传输协议（HTTP）</p><ul><li>网络的应用层协议</li><li>无状态协议，服务器不保存客户端之前请求的信息记录</li><li>客户机/服务器模型（C/S）<ul><li>客户机：浏览器请求和接收消息，显示web对象</li><li>服务器：Web 服务器发送对象给浏览器，作为对请求的响应</li></ul></li><li>使用TCP传输协议<ul><li>客户端发送连接请求（产生socket）给服务器的80端口</li><li>服务器接收从客户端发送来的<strong>TCP</strong>连接请求</li><li>浏览器（HTTP客户端）和Web服务器（HTTP服务器）之间交换HTTP 消息 (应用层协议消息)</li><li>关闭TCP连接</li></ul></li></ul></li><li><p>Web使用<code>HTTP</code>协议进行信息传输</p></li><li><p>用户—服务器状态：Cookies技术</p><ul><li><p>因为HTTP协议为无状态，所以为了保存上次浏览内容，引入Cookie技术</p></li><li><p>Client访问Server时带上Cookie编号，Server为每个编号Client维护后台数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103155836.png" alt="image-20220103155836735" style="zoom: 33%;" /></li></ul></li></ul><h3 id="域名解析服务DNS"><a href="#域名解析服务DNS" class="headerlink" title="域名解析服务DNS"></a>域名解析服务DNS</h3><ul><li><p>实现主机名到IP地址的映射</p><ul><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录</li><li>当客户请求域名服务器转换名字时，服务器首先按标准过程检查它是否被授权管理该名字</li><li>域名服务器向客户报告缓存中有关名字与地址的绑定(binding)信息</li></ul></li><li><p>采用分布式数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104111337.png" alt="image-20220104111337451" style="zoom:50%;" /></li><li><p>查询过程示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160151.png" alt="image-20220103160151420" style="zoom:33%;" /></li><li><p>例题</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160126.png" alt="image-20220103160126557" style="zoom: 33%;" /></li></ul><h3 id="Email服务与SMTP协议"><a href="#Email服务与SMTP协议" class="headerlink" title="Email服务与SMTP协议"></a>Email服务与SMTP协议</h3><ul><li>Email应用组件<ul><li>邮件客户端</li><li>邮件服务器</li><li>SMTP协议（Simple Mail Transfer Protocol）、MIME、POP协议<ul><li>使用TCP协议从客户端向服务器可靠的发送电子邮件消息，端口号25</li><li>直接传输: 发送服务器到接收服务器</li><li>传输的三个阶段<ul><li>握手 (问候)</li><li>消息发送</li><li>终止</li></ul></li><li>命令/响应的交互<ul><li>命令：ASCII文本信息</li><li>响应：状态码与短语</li></ul></li><li>消息必须是7位ASCII码</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmap内存映射——用户空间与内核空间的直接交流</title>
      <link href="/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;<code>mmap</code>是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read()</code>、<code>write()</code>等系统调用函数。同时，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209123614.png" alt="image-20220209123614653" style="zoom: 30%;" /><span id="more"></span><p>&nbsp;</p><h2 id="Linux虚拟内存"><a href="#Linux虚拟内存" class="headerlink" title="Linux虚拟内存"></a>Linux虚拟内存</h2><p>&emsp;&emsp;进程的虚拟地址空间由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质空间，即具有同样特性的连续地址范围。下图中的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射都是一个独立的虚拟内存区域，而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092829.png" alt="image-20220102092829331" style="zoom:33%;" /><p>&emsp;&emsp;Linux内核使用<code>vm_area_struct</code>结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个<code>vm_area_struct</code>结构来表示不同类型的内存区域。各个<code>vm_area_struct</code>结构使用链表或者树形结构来链接，方便进程快速访问。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220101235153.png" alt="image-20220101235152947" style="zoom:50%;" /><p>&emsp;&emsp;<code>vm_area_struct</code>结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个<code>vm_ops</code>指针，其内部可引出所有针对这个区域能使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用的信息都可以从<code>vm_area_struct</code>中获得。<code>mmap</code>就是创建一个新的<code>vm_area_struct</code>结构并将其与文件的物理磁盘地址相连。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a>mmap内存映射</h2><h3 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h3><p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p><ol><li>进程在用户空间调用库函数<code>mmap()</code></li><li>在当前进程的虚拟地址空间中寻找一段空闲的满足要求的连续虚拟地址</li><li>为此虚拟地址分配一个<code>vm_area_struct</code>结构，并对其各域进行初始化</li><li>将新建的虚拟结构<code>vm_area_struct</code>插入进程的虚拟地址区域链表或树中</li></ol><p><strong>（二）调用内核空间的系统调用函数<code>mmap()</code>（不同于用户空间的<code>mmap()</code>），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p><ol><li>为映射分配新的虚拟地址后，通过映射的文件指针在文件描述符表中找到其对应的文件描述符，再通过文件描述符链接到内核“已打开文件集”中该文件的文件结构体<code>struct file</code>，每个文件结构体维护着这个已打开文件的各项相关信息</li><li>通过该文件的文件结构体链接到<code>file_operations</code>模块，调用内核函数<code>mmap()</code></li><li>内核<code>mmap()</code>函数通过虚拟文件系统<code>inode</code>模块定位到文件磁盘物理地址</li><li>通过<code>remap_pfn_range()</code>函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。注意：此时这片虚拟地址仍没有任何数据关联到主内存中</li></ol><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，接下来系统会自动实现文件内容到物理内存（主存)的拷贝</strong></p><ol><li>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</li><li>缺页异常进行一系列判断，确定无非法操作后内核发起请求调页过程</li><li>调页过程现在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用<code>nopage()</code>函数把所缺页从磁盘装入主存中</li><li>之后进程即可对这片主存进行读或写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，即完成了写入文件的过程。</li></ol><p>注：修改过的脏页面不会立即更新到文件中而是有延迟，可以调用<code>msync()</code>函数强制同步</p><p>&nbsp;</p><h3 id="对比常规文件操作"><a href="#对比常规文件操作" class="headerlink" title="对比常规文件操作"></a>对比常规文件操作</h3><h4 id="常规文件操作"><a href="#常规文件操作" class="headerlink" title="常规文件操作"></a>常规文件操作</h4><ol><li>进程发起读取文件请求</li><li>内核通过查找进程文件符表，定位到内核“已打开文件集”上的文件信息，从而找到此文件的<code>inode</code></li><li><code>inode</code>在<code>address_space</code>上查找要请求的文件页是否已经缓存在页缓存中。<ul><li>如果在，则直接返回这片文件页的内容</li><li>如果不在，则通过<code>inode</code>定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程</li></ul></li></ol><p>&emsp;&emsp;总结来说常规文件操作需要从磁盘到页缓存再到用户主存两次数据拷贝。而<code>mmap</code>操控文件只需要从磁盘到用户主存一次数据拷贝过程。即<code>mmap</code>实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此效率更高时延更小。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102002540.png" alt="image-20220102002540469" style="zoom:50%;" /><p>&nbsp;</p><h3 id="优点及作用"><a href="#优点及作用" class="headerlink" title="优点及作用"></a>优点及作用</h3><ol><li>对文件的读取操作跨过了页缓存，减少了数据拷贝次数和时间开销，用内存读写取代了I/O读写，提高文件读取效率</li><li>实现了内核空间和用户空间的高效交互方式，彼此的修改操作可以直接反映在映射的内存区域内并被对方空间捕捉</li><li>提供进程间共享内存的通信方式，并且进程A第一次读取地址内容时通过缺页从磁盘复制文件到页面中后，进程B再读同样地址内容时虽然也会缺页，但是不需要再从文件磁盘里复制，而是直接使用已保存在内存中的文件数据</li><li>可用于实现高效的大规模数据传输，避免了大量文件I/O操作的时间开销</li></ol><p>&nbsp;</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    start：映射区的开始地址</span></span><br><span class="line"><span class="function">    length：映射区长度</span></span><br><span class="line"><span class="function">    prot：期望的内存保护标志，不能与文件的打开模式冲突，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    PROT_READ：页内容可以被读取</span></span><br><span class="line"><span class="function">    PROT_WRITE：页可以被写入</span></span><br><span class="line"><span class="function">    PROT_EXEC：页内容可以被执行</span></span><br><span class="line"><span class="function">PROT_NONE：页不可访问</span></span><br><span class="line"><span class="function">   flags：指定映射对象的类型，映射选项和映射页是否可以共享，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    MAP_SHARED：与其它所有映射这个对象的进程共享映射空间</span></span><br><span class="line"><span class="function">    MAP_PRIVATE： 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</span></span><br><span class="line"><span class="function">    MAP_ANONYMOUS：匿名映射，映射区不与任何文件关联</span></span><br><span class="line"><span class="function">    fd：文件描述符，如果flags设定为MAP_ANONYMOUS，为了兼容问题，其值应为-1</span></span><br><span class="line"><span class="function">    offset：被映射对象内容的起点</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">在进程地址空间中解除一个映射关系，addr是调用<span class="title">mmap</span><span class="params">()</span>返回的地址，len是映射区大小，成功则返回0，失败返回-1。当映射关系解除后，对原来地址的访问会引发段错误。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    flags：</span></span><br><span class="line"><span class="function">    MS_ASYNC：采用异步写方式</span></span><br><span class="line"><span class="function">MS_SYNC：采用同步写方式</span></span><br><span class="line"><span class="function">MS_INVALIDATE：从文件中读回数据</span></span><br><span class="line"><span class="function">一般进程在映射空间对共享内存的改变不会直接回写到磁盘中，调用<span class="title">munmap</span><span class="params">()</span>后才同步，调用<span class="title">msync</span><span class="params">()</span>可以强制同步修改过的脏页面使其立即更新到磁盘文件中。</span></span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><code>mmap()</code>映射区域的大小必须是物理页大小（page_size）的整数倍（32位系统中通常是4k字节）。因为内存的最小粒度是页，而进程的虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，<code>mmap()</code>从磁盘到虚拟地址空间的映射也必须是页</li><li>内核可以跟踪被内存映射的底层对象（文件）大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的字节。如果文件大小一直在扩张，只要还在映射区域范围内就能够被合法访问到。但如果文件本身大小有限，则内存中写入的数据超过文件大小时，超出部分不会被写入文件</li><li>映射建立之后，即使文件关闭，映射也依然存在。因为映射的是磁盘地址而不是文件本身，和文件句柄无关。同时可用于进程通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射</li></ol><p>&nbsp;</p><h5 id="情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中"><a href="#情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中" class="headerlink" title="情形一：一个文件大小是5000字节，mmap()函数从文件的起始位置开始，映射5000字节到虚拟内存中"></a>情形一：一个文件大小是5000字节，<code>mmap()</code>函数从文件的起始位置开始，映射5000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;因为单位物理页的大小是4096字节，所以实际映射到虚拟内存区域的有8192个字节，5000~8192的字节部分用零填充。此时：</p><ul><li>读/写0~4999字节时会返回操作文件内容</li><li>读5000~8191字节时，结果全是0；写5000~8191字节时，进程不报错但是所写内容不会回写到文件中</li><li>读/写8192以外的磁盘部分时，返回<code>SIGSECV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102093046.png" alt="image-20220102093046402" style="zoom:33%;" /><p>&nbsp;</p><h5 id="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"><a href="#情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中" class="headerlink" title="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"></a>情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;文件实际映射到虚拟内存区域的有8192个字节，对应两个物理页，因此这两个物理页都可以合法读写，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常：</p><ul><li>进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中</li><li>对于5000~8191字节，进程可以进行读写过程不报错，但是内容在写入前均为0，另外，写入后不会反映在文件中</li><li>对于8192~14999字节，进程不能对其进行读写，会报<code>SIGBUS</code>错误</li><li>对于15000以外的字节，进程不能对其读写，会引发<code>SIGSEGV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102090515.png" alt="image-20220102090515453" style="zoom: 50%;" /><p>&nbsp;</p><h5 id="情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"><a href="#情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr" class="headerlink" title="情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"></a>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;如果在建立之初就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，会返回<code>SIGBUS</code>错误。但是如果每次操作<code>ptr</code>前先增加文件大小，那么<code>ptr</code>在文件大小内部的操作就是合法的。这样方便随时扩充文件空间，不造成空间浪费。</p><p>&nbsp;</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>p1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">match_file</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">int</span> *length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *length = sb.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_mmap</span><span class="params">(<span class="keyword">char</span> *mmap, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read[%d]:  %s\n&quot;</span>, count++, mmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    mapped = match_file(argv[<span class="number">1</span>], &amp;length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每隔一秒查看存储映射区是否被修改 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read_mmap(mapped, length);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="keyword">char</span> *context[<span class="number">6</span>] = &#123;<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;てんどう万象&quot;</span>, <span class="string">&quot;today is Thursday&quot;</span>, <span class="string">&quot;Xi Nei&quot;</span>, <span class="string">&quot;54618888&quot;</span>, <span class="string">&quot;德丽莎世界第一可爱&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有文件映射将无法修改文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;read[%d]:  %s\n&quot;, count++, mapped);</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(mapped, <span class="string">&#x27;0&#x27;</span>, sb.st_size);</span><br><span class="line">            <span class="built_in">strcpy</span>(mapped, context[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wirte[%d]:  %s\n&quot;</span>, count++, context[i]);</span><br><span class="line"></span><br><span class="line">            msync(mapped, PAGE_SIZE, MS_ASYNC);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 间隔一秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，修改内容长度不能大于原文件长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092156.png" alt="image-20220102092156158"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C自定义Python内置模块</title>
      <link href="/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;Python 可以非常方便地和 C 进行相互的调用。</p><p>&emsp;&emsp;一般不会使用 C 去直接编写一个 Python 的模块。通常是需要把 C 的相关模块包装一下，然后在 Python 中可以直接调用它。或者是，把 Python 逻辑中的某一效率要求很高的部分使用 C 来实现。整个过程大概是：</p><ol><li>引入 Python.h 头文件</li><li>编写包装函数</li><li>函数中处理从 Python 传入的参数</li><li>实现功能逻辑</li><li>处理 C 中的返回值，包装成 Python 对象</li><li>在一个 PyMethodDef 结构体中注册需要的函数</li><li>在一个初始化方法中注册模块名</li><li>把这个 C 源文件编译成链接库</li></ol><span id="more"></span><p>&nbsp;</p><h3 id="用C写Python扩展模块的文件"><a href="#用C写Python扩展模块的文件" class="headerlink" title="用C写Python扩展模块的文件"></a>用C写Python扩展模块的文件</h3><h4 id="Step1：引入Python-h头文件"><a href="#Step1：引入Python-h头文件" class="headerlink" title="Step1：引入Python.h头文件"></a>Step1：引入Python.h头文件</h4><p>&emsp;&emsp;下面用到的函数都在该头文件中定义好了，并且它还包含了一些标准头文件: <code>&lt;stdio.h&gt;</code>，<code>&lt;string.h&gt;</code>，<code>&lt;errno.h&gt;</code> 和 <code>&lt;stdlib.h&gt;</code>。这个头文件一般位于 Python 的主目录中，例如在我ubuntu中是<code>/usr/include/Python3.8</code></p><h4 id="Step2：编写包装函数"><a href="#Step2：编写包装函数" class="headerlink" title="Step2：编写包装函数"></a>Step2：编写包装函数</h4><p>&emsp;&emsp;因为 Python 用到的函数与普通的 C 函数在输入和输出上会有一些不同，所以需要把普通的 C 做一些封装来给 Python 用。本质是定义暴露给<code>CPython</code>解析器的C函数</p><p>&emsp;&emsp;在实现功能的过程中可以先完全不考虑这东西是拿给 Python 用的，只专注于使用 C 把它写好就可以了。功能写好并测试没有问题之后再做 Python 封装的工作。包装函数一般声明成 static ，并且函数类型和传参都是<code>PyObject*</code>类型。这是因为Python是C语言实现的，在C语言中Python对象都由<code>PyObject</code>结构体表示。但虽然C语言是强类型语言，只用一种类型是没办法正常工作，但其实<code>PyObject</code>结构体内包含了大部分C语言数据类型的存储方式，通过不同的解析函数或者参数即可指定解析出对应C类型。</p><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>&emsp;&emsp;在C程序中，函数的定义统一用<code>PyObject</code>，并且无论原Python程序中对应函数传的参数有几个，统一写两个参数：<code>PyObject* self, PyObject* args</code>（若没有传参则都不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参解析"><a href="#传参解析" class="headerlink" title="传参解析"></a>传参解析</h5><p>&emsp;&emsp;上面说过，无论参数数量和类型，一律用<code>PyObject* self, PyObject* args</code>来声明，实际在函数定义中会使用Python的API函数<code>PyArg_ParseTuple()</code>来获得真正的参数，它会检查参数类型并将其转换为 C 值，使用模板字符串确定需要的参数类型以及存储被转换的值的 C 变量类型。当解析成功时返回<code>True</code>，若其传入参数无效则返回<code>False</code>并抛出<code>PyExc_TypeError</code>异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(count: <span class="keyword">int</span>, saying: <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数这样解析参数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> *saying;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PyArg_ParseTuple(args, <span class="string">&quot;is&quot;</span>, &amp;symbol, &amp;symbol) == False)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h5><p>&emsp;&emsp;注意函数在声明时和传参一样也是<code>PyObject*</code>类型，所以很自然能想到其返回值也是该类型。但与传参时相反，返回值是从C语言数据类型构造为<code>PyObject*</code>类型，这里使用的是另一个Python的API函数：<code>Py_BuildValue()</code>，它与<code>PyArg_ParseTuple()</code>类似，都是使用格式字符串解析参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span> -&gt; <span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> count, saying</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;is&quot;</span>, count, saying);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用<code>Py_BuildValue()</code>的格式化字符串形式：</p><table><thead><tr><th>调用语句</th><th>解析值</th></tr></thead><tbody><tr><td>Py_BuildValue(“”)</td><td>None</td></tr><tr><td>Py_BuildValue(“i”, 123)</td><td>123</td></tr><tr><td>Py_BuildValue(“iii”, 123, 456, 789)</td><td>(123, 456, 789)</td></tr><tr><td>Py_BuildValue(“s”, “hello”)</td><td>‘hello’</td></tr><tr><td>Py_BuildValue(“y”, “hello”)</td><td>b’hello’</td></tr><tr><td>Py_BuildValue(“ss”, “hello”, “world”)</td><td>(‘hello’, ‘world’)</td></tr><tr><td>Py_BuildValue(“s#”, “hello”, 4)</td><td>‘hell’</td></tr><tr><td>Py_BuildValue(“y#”, “hello”, 4)</td><td>b’hell’</td></tr><tr><td>Py_BuildValue(“()”)</td><td>()</td></tr><tr><td>Py_BuildValue(“(i)”, 123)</td><td>(123,)</td></tr><tr><td>Py_BuildValue(“(ii)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“(i,i)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“[i,i]”, 123, 456)</td><td>[123, 456]</td></tr><tr><td>Py_BuildValue(“{s:i,s:i}”, “abc”, 123, “def”, 456)</td><td>{‘abc’: 123, ‘def’: 456}</td></tr><tr><td>Py_BuildValue(“((ii)(ii)) (ii)”, 1, 2, 3, 4, 5, 6)</td><td>(((1, 2), (3, 4)), (5, 6))</td></tr></tbody></table><p>&nbsp;</p><h4 id="Step3：把定义好的C函数注册为API"><a href="#Step3：把定义好的C函数注册为API" class="headerlink" title="Step3：把定义好的C函数注册为API"></a>Step3：把定义好的C函数注册为API</h4><p>&emsp;&emsp;注册API，需要用到一个<code>PyMethodDef</code>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_name;   <span class="comment">/* API被调用时的名称 */</span></span><br><span class="line">    PyCFunction ml_meth;    <span class="comment">/* 对应C函数的函数名 */</span></span><br><span class="line">    <span class="keyword">int</span>         ml_flags;   <span class="comment">/* 对应C函数传递的参数类型 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_doc;    <span class="comment">/* 函数说明 */</span></span><br><span class="line">&#125;PyMethodDef;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在C程序中定义一个由<code>PyMethodDef</code>类型成员组成的数组，每个成员对应一个定义好的C函数。这里需要注意第三个参数<code>ml_flags</code>，它代表C函数传参的规范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">METH_VARARGS：</span><br><span class="line">这是最常用的ml_flags值，代表该C函数需要两个 PyObject* 类型参数。第一个是此方法的 self 对象（对于模块函数，它是模块本身(class)，对于非模块函数，它是NULL）；第二个参数（通常称为 args）是一个表示所有参数的元组对象。此参数通常使用 PyArg_ParseTuple() 或 PyArg_UnpackTuple() 处理。</span><br><span class="line"></span><br><span class="line">METH_KEYWORDS：</span><br><span class="line">表示接受关键字参数。这种情况下C函数需要接受第三个 PyObject * 对象，表示字典参数，使用 PyArg_ParseTupleAndKeywords() 来解析出参数。</span><br><span class="line"></span><br><span class="line">METH_FASTCALL：</span><br><span class="line">仅支持位置参数的快速调用约定。第一个参数是 self，第二个参数是 PyObject* 值的 C 数组，指示参数，第三个参数是参数的数量（数组的长度）</span><br><span class="line"></span><br><span class="line">METH_NOARGS：</span><br><span class="line">表示第一个参数通常命名为 self 并将保存对模块或对象实例的引用。在所有情况下，第二个参数将为 NULL。</span><br><span class="line"></span><br><span class="line">更多类型详见：https://docs.python.org/3/c-api/structures.html#c.PyMethodDef</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func1</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func2</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyMethodDef my_methods[] </span>= &#123;</span><br><span class="line">    &#123; <span class="string">&quot;name1&quot;</span>, func1, METH_VARARGS, <span class="string">&quot;description of func1&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name2&quot;</span>, func2, METH_VARARGS, <span class="string">&quot;description of func2&quot;</span> &#125;</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step4：把注册好的API注册到模块中"><a href="#Step4：把注册好的API注册到模块中" class="headerlink" title="Step4：把注册好的API注册到模块中"></a>Step4：把注册好的API注册到模块中</h4><p>&emsp;&emsp;&emsp;与注册API类似，注册模块也用到一个结构体<code>PyModuleDef</code>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span>&#123;</span></span><br><span class="line">  PyModuleDef_Base m_base;<span class="comment">/* 通常都填为PyModuleDef_HEAD_INIT */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_name; <span class="comment">/* Python导入时用的模块名&lt;module_name&gt; */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_doc; <span class="comment">/* 对模块的说明，Python调用时通过__doc__查看 */</span></span><br><span class="line">  Py_ssize_t m_size;<span class="comment">/* 填 -1 */</span></span><br><span class="line">  PyMethodDef *m_methods;<span class="comment">/* 这里填上面注册API的PyMethodDef类型数组 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef_Slot</span>* <span class="title">m_slots</span>;</span></span><br><span class="line">  traverseproc m_traverse;</span><br><span class="line">  inquiry m_clear;</span><br><span class="line">  freefunc m_free;</span><br><span class="line">&#125;PyModuleDef;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;LrkModule&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lrk’s module&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step5：定义构造函数PyInit-lt-ModuleName-gt"><a href="#Step5：定义构造函数PyInit-lt-ModuleName-gt" class="headerlink" title="Step5：定义构造函数PyInit_&lt;ModuleName&gt;"></a>Step5：定义构造函数<code>PyInit_&lt;ModuleName&gt;</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;中后半部分必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_LrkModule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="方法一：直接编译"><a href="#方法一：直接编译" class="headerlink" title="方法一：直接编译"></a>方法一：直接编译</h4><p>注意链接<code>Python.h</code>所在的目录，并指定输出.so文件名称，后续调用此模块的python文件导入时用的就是这个名字：</p><p><code>gcc LrkModule.c -I /usr/include/python3.8 -shared -o LrkModule.so</code></p><h4 id="方法二：用编译脚本"><a href="#方法二：用编译脚本" class="headerlink" title="方法二：用编译脚本"></a>方法二：用编译脚本</h4><p>写一个编译此文件的Python脚本setup.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行<code>python setup.py install</code>编译生成build/目录并装载下面的.so文件</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><code>my_module.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">echo</span><span class="params">(PyObject* self, PyObject* args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* what;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> count;</span><br><span class="line">    PyArg_ParseTuple(args, <span class="string">&quot;si&quot;</span>, &amp;what, &amp;count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Python said: %s %d\n&quot;</span>, what, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> feedback = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;i&quot;</span>, feedback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PyMethodDef 是一个结构体</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;echo&quot;</span>, echo, METH_VARARGS, <span class="string">&quot;echo something&quot;</span> &#125;, </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;lrk&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;后面必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_lrk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lrk</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="built_in">print</span>(lrk.echo(<span class="string">&quot;hello\n&quot;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br><span class="line">python test.py</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p><strong>References</strong><br><a href="https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function">https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function</a><br><a href="https://docs.python.org/3/c-api/index.html">https://docs.python.org/3/c-api/index.html</a><br><a href="https://www.python.org/dev/peps/pep-0007/">https://www.python.org/dev/peps/pep-0007/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】时序差分模型：SARSA &amp; Q-Learning</title>
      <link href="/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/"/>
      <url>/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;时序差分法是求解强化学习问题的重要方法，按照在线学习和离线学习可以分为两大类，其中最基础的两个代表算法就是 SARSA 和 Q-Learning</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229105335.png" alt="image-20211229105335429"></p><span id="more"></span><p>&nbsp;</p><h2 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h2><h3 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>&emsp;&emsp;Sarsa是一种使用时序差分法求解强化学习控制问题的经典方法，即给定强化学习的5个要素：状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ，求解最优的动作价值函数q∗和最优策略π∗。</p><p>&emsp;&emsp;作为一种时序差分法模型，Sarsa是不基于环境模型的Model-free算法，它对控制问题的求解和蒙特卡罗法类似，都是价值迭代，即通过价值函数的更新，来更新当前的策略，再通过新的策略，来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;时序差分法的控制问题可以分为两类：</p><ul><li><p>在线控制(on policy)：</p><p>​        一直使用同一个策略来更新价值函数和选择新的动作</p></li><li><p>离线控制(off policy)：</p><p>​        会使用两个不同的控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数</p></li></ul><p>​        Sarsa属于在线控制类，即一直使用一个策略来更新价值函数和选择新的动作，而这个策略就是ϵ−greedy法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084500.png" alt="image-20211229084500896" style="zoom: 50%;" /><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>&emsp;&emsp;Sarsa的名字其实包含了其算法执行流程，Sarsa = S(状态)+A(动作)+R(奖励)+S‘(新状态)+A’(新动作)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084714.png" alt="image-20211229084714235" style="zoom:50%;" /><p><strong>迭代</strong></p><p>&emsp;&emsp;首先基于ϵ−greedy算法在当前状态<code>S</code>选择一个动作<code>A</code>，这样系统会转到一个新的状态<code>S′</code>，同时给一个即时奖励<code>R</code>，在新的状态<code>S′</code>下基于ϵ−greedy算法在状态<code>S‘</code> 选择一个动作<code>A′</code>，但是注意这时候并不执行这个动作<code>A′</code>，只是用来更新价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 67%;" /><p>&emsp;&emsp;其中，<code>γ</code>是衰减因子，<code>α</code>是迭代步长。这里和蒙特卡罗法求解在线控制问题的迭代公式的区别主要是，收获<code>Gt</code>的表达式不同，对于时序差分，收获<code>Gt</code>的表达式是<code>R+γQ(S′,A′)</code>。除了收获<code>Gt</code>的表达式不同，Sarsa算法和蒙特卡罗在线控制算法基本类似。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229090934.png" alt="image-20211229090934145"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A</p></li><li><p>执行动作A，由环境得到新状态S‘ 和奖励R</p></li><li><p>依据ϵ−greedy算法对状态S‘ 选出动作A’</p></li><li><p>对当前状态S和动作A，更新价值函数Q（S，A）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 50%;" /></li><li><p>前进一步：S = S’，A = A‘</p></li><li><p>if  S’是终止状态，break；else 跳回步骤b</p></li></ol></li></ol><p>（注意：步长α一般需要随着迭代逐渐变小，这样才能保证动作价值函数Q可以收敛。当Q收敛时，策略ϵ−greedy算法也就收敛了）</p><p>&nbsp;</p><h4 id="示例一：Windy-GridWorld"><a href="#示例一：Windy-GridWorld" class="headerlink" title="示例一：Windy GridWorld"></a>示例一：Windy GridWorld</h4><p><strong>问题</strong></p><p><strong>问题</strong></p><p>&emsp;&emsp;一个10×7的长方形格子世界，标记有一个起始位置 S 和一个终止目标位置 G，格子下方的数字表示对应的列中一定强度的风。当个体进入该列的某个格子时，会按图中箭头所示的方向自动移动数字表示的格数，借此来模拟世界中风的作用。同样格子世界是有边界的，个体任意时刻只能处在世界内部的一个格子中。个体并不清楚这个世界的构造以及有风，也就是说它不知道格子是长方形的，也不知道边界在哪里，也不知道自己在里面移动移步后下一个格子与之前格子的相对位置关系，当然它也不清楚起始位置、终止目标的具体位置。但是个体会记住曾经经过的格子，下次在进入这个格子时，它能准确的辨认出这个格子曾经什么时候来过。格子可以执行的行为是朝上、下、左、右移动一步，每移动一步只要不是进入目标位置都给予一个 -1 的惩罚，直至进入目标位置后获得奖励 0 同时永久停留在该位置。现在要求解的问题是个体应该遵循怎样的策略才能尽快的从起始位置到达目标位置。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># world height</span></span><br><span class="line">WORLD_HEIGHT = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># world width</span></span><br><span class="line">WORLD_WIDTH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wind strength for each column</span></span><br><span class="line">WIND = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># possible actions</span></span><br><span class="line">ACTION_UP = <span class="number">0</span></span><br><span class="line">ACTION_DOWN = <span class="number">1</span></span><br><span class="line">ACTION_LEFT = <span class="number">2</span></span><br><span class="line">ACTION_RIGHT = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># probability for exploration</span></span><br><span class="line">EPSILON = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sarsa step size</span></span><br><span class="line">ALPHA = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reward for each step</span></span><br><span class="line">REWARD = -<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">START = [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">GOAL = [<span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">ACTIONS = [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">state, action</span>):</span></span><br><span class="line">    <span class="comment"># (i, j) is bird&#x27;s location, i++ while go down and j++ while go right</span></span><br><span class="line">    i, j = state</span><br><span class="line">    <span class="keyword">if</span> action == ACTION_UP:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - <span class="number">1</span> - WIND[j], <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_DOWN:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(<span class="built_in">min</span>(i + <span class="number">1</span> - WIND[j], WORLD_HEIGHT - <span class="number">1</span>), <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_LEFT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_RIGHT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">min</span>(j + <span class="number">1</span>, WORLD_WIDTH - <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># play for an episode</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">episode</span>(<span class="params">q_value</span>):</span></span><br><span class="line">    <span class="comment"># track the total time steps in this episode</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize state</span></span><br><span class="line">    state = START</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose an action based on epsilon-greedy algorithm</span></span><br><span class="line">    <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">        action = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_ = q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], :]</span><br><span class="line">        action = np.random.choice([action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">            values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># keep going until get to the goal state</span></span><br><span class="line">    <span class="keyword">while</span> state != GOAL:</span><br><span class="line">        next_state = step(state, action)</span><br><span class="line">        <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">            next_action = np.random.choice(ACTIONS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            values_ = q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], :]</span><br><span class="line">            next_action = np.random.choice(</span><br><span class="line">                [action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sarsa update</span></span><br><span class="line">        q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action] += \</span><br><span class="line">            ALPHA * (REWARD + q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], next_action] -</span><br><span class="line">                     q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action])</span><br><span class="line">        state = next_state</span><br><span class="line">        action = next_action</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sarsa</span>():</span></span><br><span class="line">    q_value = np.zeros((WORLD_HEIGHT, WORLD_WIDTH, <span class="number">4</span>))</span><br><span class="line">    episode_limit = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    steps = []</span><br><span class="line">    ep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ep &lt; episode_limit:</span><br><span class="line">        steps.append(episode(q_value))</span><br><span class="line">        <span class="comment"># time = episode(q_value)</span></span><br><span class="line">        <span class="comment"># episodes.extend([ep] * time)</span></span><br><span class="line">        ep += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    steps = np.add.accumulate(steps)</span><br><span class="line"></span><br><span class="line">    plt.plot(steps, np.arange(<span class="number">1</span>, <span class="built_in">len</span>(steps) + <span class="number">1</span>))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Time steps&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Episodes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.savefig(<span class="string">&#x27;./sarsa.png&#x27;</span>)</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the optimal policy</span></span><br><span class="line">    optimal_policy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_HEIGHT):</span><br><span class="line">        optimal_policy.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_WIDTH):</span><br><span class="line">            <span class="keyword">if</span> [i, j] == GOAL:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            bestAction = np.argmax(q_value[i, j, :])</span><br><span class="line">            <span class="keyword">if</span> bestAction == ACTION_UP:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_DOWN:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_LEFT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_RIGHT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Optimal policy is:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> optimal_policy:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wind strength for each column:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>([<span class="built_in">str</span>(w) <span class="keyword">for</span> w <span class="keyword">in</span> WIND]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sarsa()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229092057.png" alt="image-20211229092057649" style="zoom:67%;" /><h4 id="示例二：3×3迷宫"><a href="#示例二：3×3迷宫" class="headerlink" title="示例二：3×3迷宫"></a>示例二：3×3迷宫</h4><p><strong>代码</strong></p><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa/Sarsa_maze">github</a></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="Sarsa-λ-算法"><a href="#Sarsa-λ-算法" class="headerlink" title="Sarsa(λ)算法"></a>Sarsa(λ)算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​        多步时序差分TD(λ)的价值函数迭代方法对应就是SARSA(λ)在线控制算法。TD(λ)有前向和后向这两种等价的价值函数迭代方式，在控制问题的求解时，基于反向认识的 SARSA(λ)算法将可以有效地在线学习，数据学习完即可丢弃。因此SARSA(λ)算法默认都是基于反向来进行价值函数迭代。</p><p><strong>状态价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p><strong>动作价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100235.png" alt="image-20211229100235740" style="zoom:50%;" /><p>&emsp;&emsp;除了状态价值函数<code>Q(S,A)</code>的更新方式，多步参数λ以及反向认识引入的效用迹<code>E(S,A)</code>，其余算法思想和SARSA类似。</p><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100839.png" alt="image-20211229100839670"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ、多步参数λ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A，初始化所有状态动作的效用迹E为0</p></li><li><p>执行动作A，由环境得到新状态S‘ 和奖励R</p></li><li><p>依据ϵ−greedy算法对状态S‘ 选出动作A’</p></li><li><p>更新效用迹函数E(S, A) 和 误差 δ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101924.png" alt="image-20211229101924200" style="zoom:50%;" /></li><li><p>对当前序列中<strong>所有</strong>状态S和对应动作A，更新价值函数Q(S, A)和效用迹函数E(S, A) ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101944.png" alt="image-20211229101944186" style="zoom:50%;" /></li><li><p>前进一步：S = S’，A = A‘</p></li><li><p>if  S’是终止状态，break；else 跳回步骤b</p></li></ol></li></ol><p>（注意：对于步长α，和Sarsa一样，一般也需要随着迭代的进行逐渐变小才能保证动作价值函数Q收敛）</p><p>&nbsp;</p><h4 id="示例：3×3迷宫"><a href="#示例：3×3迷宫" class="headerlink" title="示例：3×3迷宫"></a>示例：3×3迷宫</h4><p><strong>代码</strong></p><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa(lamda)/Sarsa_lamda_maze">github</a></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;SARSA算法和动态规划法比起来，不需要环境的状态转换模型，和蒙特卡罗法比起来，不需要完整的状态序列，因此比较灵活。在传统的强化学习方法中使用比较广泛。</p><p>&emsp;&emsp;但是SARSA算法也有一个传统强化学习方法共有的问题，就是无法求解太复杂的问题。在 SARSA 算法中，Q(S,A) 的值使用一张大表来存储的，如果状态和动作都达到百万乃至千万级，需要在内存里保存的这张大表会超级大，甚至溢出，因此不是很适合解决规模很大的问题。当然，对于不是特别复杂的问题，使用SARSA还是很不错的一种强化学习问题求解方法。</p><p>&nbsp;&nbsp;</p><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><blockquote><p>关键词：时序差分、model-free、off-policy、ϵ-greedy、价值迭代</p></blockquote><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>&emsp;&emsp;Q-Learning也是一种使用时序差分求解强化学习控制问题的方法，它通过价值函数的更新来更新策略，通过策略来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;它与Sarsa最大的区别在于Q-Learning是离线控制(off-policy)算法，会使用两个控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数。具体而言，Q-Learning会使用ϵ−greedy算法来选择新的动作，这部分和SARSA完全相同。但是对于价值函数的更新，Q-Learning使用的是greedy法，而不是SARSA的ϵ−greedy法。这一点就是SARSA和Q-Learning本质区别。</p><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>算法思想</strong></p><p>&emsp;&emsp;Q-Learning是强化学习算法中value-based的算法，Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取动作a (a∈A)能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward，所以算法的主要思想就是将State与Action构建成一张Q-Table来存储Q值，然后根据Q值来选取能够获得最大的收益的动作。</p><table><thead><tr><th>Q-Table</th><th>A1</th><th>A2</th><th>…</th></tr></thead><tbody><tr><td>s1</td><td>q(s1,a1)</td><td>q(s1,a2)</td><td>…</td></tr><tr><td>s2</td><td>q(s2,a1)</td><td>q(s2,a2)</td><td>…</td></tr><tr><td>s3</td><td>q(s3,a1)</td><td>q(s3,a2)</td><td>…</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p><strong>算法拓扑图</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103423.png" alt="image-20211229103423423" style="zoom: 33%;" /><p>&emsp;&emsp;首先基于状态S，用ϵ−greedy策略选择到动作<code>A</code>，然后执行动作<code>A</code>，得到奖励<code>R</code>，并进入状态<code>S′</code>，此时如果是Sarsa，会继续基于状态<code>S′</code>，用ϵ−greedy策略选择<code>A′</code>，然后来更新价值函数。但是Q-Learning则不同。对于Q-Learning，它基于状态<code>S′</code>，没有使用ϵ−greedy策略而是使用贪婪策略选择<code>A′</code>，也就是说，选择使Q(S′,a)最大的<code>a</code>作为<code>A′</code>来更新价值函数而不存在探索的可能：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103904.png" alt="image-20211229103904453" style="zoom:50%;" /><p>&emsp;&emsp;对应拓扑图中最下面三个黑球中选择一个使<code>Q(S&#39;,a)</code>最大的动作<code>A&#39;</code>，此时选择的动作只会参与价值函数的更新，不会真正的执行。价值函数更新后，新的执行动作需要基于状态<code>S′</code>，用ϵ−greedy法重新选择得到。这一点也和SARSA稍有不同。对于SARSA，价值函数更新使用的<code>A′</code>会作为下一阶段开始时候的执行动作。</p><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229091010.png" alt="image-20211229091010771"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有的状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li>初始化S为当前序列的第一个状态</li><li>用ε-greedy策略在当前状态S选择出动作A</li><li>执行动作A，由环境得到新状态S’ 和奖励R</li><li>按公式更新价值函数</li><li>前进一步：S = S’</li><li>if  S’是终止状态，break；else 跳回步骤b</li></ol></li></ol><h3 id="示例：直线寻宝"><a href="#示例：直线寻宝" class="headerlink" title="示例：直线寻宝"></a>示例：直线寻宝</h3><p><strong>问题</strong></p><p>&emsp;&emsp;宝藏在长度为6的直线的另一端，训练一个不知环境的小车以最短步数到达宝藏处。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)  <span class="comment"># reproducible</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N_STATES = <span class="number">6</span>   <span class="comment"># the length of the 1 dimensional world</span></span><br><span class="line">ACTIONS = [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>]     <span class="comment"># available actions</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>   <span class="comment"># greedy police</span></span><br><span class="line">ALPHA = <span class="number">0.1</span>     <span class="comment"># learning rate</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>    <span class="comment"># discount factor</span></span><br><span class="line">MAX_EPISODES = <span class="number">10</span>   <span class="comment"># maximum episodes</span></span><br><span class="line">FRESH_TIME = <span class="number">0.08</span>    <span class="comment"># fresh time for one move</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span>(<span class="params">n_states, actions</span>):</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, <span class="built_in">len</span>(actions))),     <span class="comment"># q_table initial values</span></span><br><span class="line">        columns=actions,    <span class="comment"># actions&#x27;s name</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># print(table)    # show table</span></span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">state, q_table</span>):</span></span><br><span class="line">    <span class="comment"># This is how to choose an action</span></span><br><span class="line">    state_actions = q_table.iloc[state, :]</span><br><span class="line">    <span class="comment"># act non-greedy or state-action have no value</span></span><br><span class="line">    <span class="keyword">if</span> (np.random.uniform() &gt; EPSILON) <span class="keyword">or</span> ((state_actions == <span class="number">0</span>).<span class="built_in">all</span>()):</span><br><span class="line">        action_name = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># act greedy</span></span><br><span class="line">        <span class="comment"># replace argmax to idxmax as argmax means a different function in newer version of pandas</span></span><br><span class="line">        action_name = state_actions.idxmax()</span><br><span class="line">    <span class="keyword">return</span> action_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_env_feedback</span>(<span class="params">S, A</span>):</span></span><br><span class="line">    <span class="comment"># This is how agent will interact with the environment</span></span><br><span class="line">    <span class="keyword">if</span> A == <span class="string">&#x27;right&#x27;</span>:    <span class="comment"># move right</span></span><br><span class="line">        <span class="keyword">if</span> S == N_STATES - <span class="number">2</span>:   <span class="comment"># terminate</span></span><br><span class="line">            S_ = <span class="string">&#x27;terminal&#x27;</span></span><br><span class="line">            R = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S + <span class="number">1</span></span><br><span class="line">            R = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># move left</span></span><br><span class="line">        R = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">            S_ = S  <span class="comment"># reach the wall</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> S_, R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span>(<span class="params">S, episode, step_counter</span>):</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">&#x27;-&#x27;</span>]*(N_STATES-<span class="number">1</span>) + [<span class="string">&#x27;T&#x27;</span>]   <span class="comment"># &#x27;---------T&#x27; our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">        interaction = <span class="string">&#x27;Episode %s: total_steps = %s&#x27;</span> % (</span><br><span class="line">            episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r                                &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">&#x27;o&#x27;</span></span><br><span class="line">        interaction = <span class="string">&#x27;&#x27;</span>.join(env_list)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rl</span>():</span></span><br><span class="line">    <span class="comment"># main part of RL loop</span></span><br><span class="line">    q_table = build_q_table(N_STATES, ACTIONS)</span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EPISODES):</span><br><span class="line">        step_counter = <span class="number">0</span></span><br><span class="line">        S = <span class="number">0</span></span><br><span class="line">        is_terminated = <span class="literal">False</span></span><br><span class="line">        update_env(S, episode, step_counter)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_terminated:</span><br><span class="line"></span><br><span class="line">            A = choose_action(S, q_table)</span><br><span class="line">            <span class="comment"># take action &amp; get next state and reward</span></span><br><span class="line">            S_, R = get_env_feedback(S, A)</span><br><span class="line">            q_predict = q_table.loc[S, A]</span><br><span class="line">            <span class="keyword">if</span> S_ != <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">                <span class="comment"># next state is not terminal</span></span><br><span class="line">                q_target = R + GAMMA * q_table.iloc[S_, :].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q_target = R     <span class="comment"># next state is terminal</span></span><br><span class="line">                is_terminated = <span class="literal">True</span>    <span class="comment"># terminate this episode</span></span><br><span class="line"></span><br><span class="line">            q_table.loc[S, A] += ALPHA * (q_target - q_predict)  <span class="comment"># update</span></span><br><span class="line">            S = S_  <span class="comment"># move to next state</span></span><br><span class="line"></span><br><span class="line">            update_env(S, episode, step_counter+<span class="number">1</span>)</span><br><span class="line">            step_counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> q_table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q_table = rl()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nQ-table:\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(q_table)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229104502.png" alt="image-20211229104502770" style="zoom: 67%;" /><p>其他示例见<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Q-Learning">github</a></p><h3 id="Q-Learning-vs-Sarsa"><a href="#Q-Learning-vs-Sarsa" class="headerlink" title="Q-Learning  vs  Sarsa"></a>Q-Learning  vs  Sarsa</h3><p>&emsp;&emsp;Q-Learning直接学习的是最优策略，而Sarsa在学习最优策略的同时还在做探索。这导致在学习最优策略的时候，如果用Sarsa，为了保证收敛，需要制定一个策略，使ϵ−greedy策略的超参数ϵ在迭代的过程中逐渐变小。Q-Learning没有这个烦恼。</p><p>&emsp;&emsp;另外一个就是Q-Learning直接学习最优策略，但是最优策略会依赖于训练中产生的一系列数据，所以受样本数据的影响较大，因此受到训练数据方差的影响很大，甚至会影响Q函数的收敛。Q-Learning的深度强化学习版Deep Q-Learning也有这个问题。</p><p>&emsp;&emsp;在学习过程中，Sarsa在收敛的过程中鼓励探索，这样学习过程会比较平滑，不至于过于激进，导致出现像Q-Learning可能遇到一些特殊的最优“陷阱”。比如经典的强化学习问题”Cliff Walk”。</p><p>&emsp;&emsp;在实际应用中，如果是在模拟环境中训练强化学习模型，推荐使用Q-Learning，如果是在线生产环境中训练模型，则推荐使用SARSA。</p><h3 id="Double-Q-Learning"><a href="#Double-Q-Learning" class="headerlink" title="Double Q-Learning"></a>Double Q-Learning</h3><p>&emsp;&emsp;为了规避Q-Learning中贪婪策略带来的过估计问题，DeepMind团队在2015年发表的论文 <a href="https://lrk612.com/resources/Deep%20Reinforcement%20Learning%20with%20Double%20Q-learning.pdf">Deep Reinforcement Learning with Double Q-learning</a> 中提出双评估器的思想，其关键在于将 <code>目标Q值动作的选择</code> 和 <code>目标Q值的估计</code> 这两步进行解耦，从而规避过估计的弊端。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209120640.png" alt="image-20220209120640642"></p><p>其中，和Q-Learning的主要区别有两点：</p><ul><li><p>采用双估计器，每个epoch开头依概率选择一个作为Q估计器，另一个用于计算目标Q值</p></li><li><p>更新Q估计器的Q表时，公式变为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209121130.png" alt="image-20220209121130121" style="zoom:60%;" /><p>  意味着Q值不再是用Q估计器直接给出，而是先用Q估计器结合贪婪策略选出动作，然后由另二个估计器给出该动作的Q值</p></li></ul><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span>                   <span class="comment"># learning rate</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>               <span class="comment"># greedy policy</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>                 <span class="comment"># reward discount</span></span><br><span class="line">TARGET_REPLACE_ITER = <span class="number">100</span>   <span class="comment"># target update frequency</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">320</span></span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)</span><br><span class="line">env = env.unwrapped</span><br><span class="line">N_ACTIONS = env.action_space.n</span><br><span class="line">N_STATES = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, </span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># class torch.nn.Linear(in_features, out_features, bias=True)</span></span><br><span class="line">        self.fc1 = nn.Linear(N_STATES, <span class="number">10</span>)</span><br><span class="line">        self.fc1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)   <span class="comment"># initialization</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">10</span>, N_ACTIONS)</span><br><span class="line">        self.out.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)   <span class="comment"># initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        actions_value = self.out(x)</span><br><span class="line">        <span class="keyword">return</span> actions_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.eval_net, self.target_net = Net(), Net()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># for target updating</span></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span></span><br><span class="line">        <span class="comment"># for storing memory</span></span><br><span class="line">        self.memory_counter = <span class="number">0</span></span><br><span class="line">        <span class="comment"># initialize memory</span></span><br><span class="line">        self.memory = np.zeros((MEMORY_CAPACITY, N_STATES * <span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = Variable(torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>))</span><br><span class="line">        <span class="comment"># input only one sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:   <span class="comment"># greedy</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()[</span><br><span class="line">                <span class="number">0</span>]     <span class="comment"># return the argmax</span></span><br><span class="line">            <span class="comment"># torch.max(input, dim, keepdim=False, out=None) -&gt; (Tensor, LongTensor)</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># random</span></span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, N_ACTIONS)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_</span>):</span></span><br><span class="line">        <span class="comment"># set s,a,r,s_ the arrary of 1*N</span></span><br><span class="line">        transition = np.hstack((s, [a, r], s_))</span><br><span class="line">        <span class="comment"># another type of the hstack , the result is the same</span></span><br><span class="line">        another_result = np.hstack((s, a, r, s_))</span><br><span class="line">        <span class="comment"># use % can loop from 0 to 2000</span></span><br><span class="line">        index = self.memory_counter % MEMORY_CAPACITY</span><br><span class="line">        <span class="comment"># save the info_this_step into memory</span></span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.memory_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># target parameter update</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_REPLACE_ITER == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># by random , choose the row&#x27;s number from memory_capacity , total row&#x27;s number is batch_size(32)</span></span><br><span class="line">        sample_index = np.random.choice(MEMORY_CAPACITY, BATCH_SIZE)</span><br><span class="line">        b_memory = self.memory[sample_index, :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># in the memory, the 1st---4th column is state_now , the 5th is action , the 6th is reward</span></span><br><span class="line">        <span class="comment"># the final 4 column is state_next</span></span><br><span class="line">        b_s = Variable(torch.FloatTensor(b_memory[:, :N_STATES]))</span><br><span class="line">        b_a = Variable(torch.LongTensor(</span><br><span class="line">            b_memory[:, N_STATES:N_STATES+<span class="number">1</span>].astype(<span class="built_in">int</span>)))</span><br><span class="line">        b_r = Variable(torch.FloatTensor(b_memory[:, N_STATES+<span class="number">1</span>:N_STATES+<span class="number">2</span>]))</span><br><span class="line">        b_s_ = Variable(torch.FloatTensor(b_memory[:, -N_STATES:]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># q_eval w.r.t the action in experience</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>, b_a)  <span class="comment"># shape (batch, 1)</span></span><br><span class="line"></span><br><span class="line">        q_eval_test = self.eval_net(b_s)</span><br><span class="line">        <span class="comment"># argmax axis = 0 means column , 1 means row</span></span><br><span class="line">        <span class="comment"># we choose the max acion value , the action is column , so axis = 1</span></span><br><span class="line">        Q1_argmax = np.argmax(q_eval_test.data.numpy(), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># q_next = self.target_net(b_s_).detach()     # detach from graph, don&#x27;t backpropagate</span></span><br><span class="line">        q_next = self.target_net(b_s_)</span><br><span class="line"></span><br><span class="line">        q_next_numpy = q_next.data.numpy()</span><br><span class="line"></span><br><span class="line">        q_update = np.zeros((BATCH_SIZE, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> iii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            q_update[iii] = q_next_numpy[iii, Q1_argmax[iii]]</span><br><span class="line"></span><br><span class="line">        q_update = GAMMA * q_update</span><br><span class="line">        q_update = torch.FloatTensor(q_update)</span><br><span class="line"></span><br><span class="line">        variable11 = Variable(q_update)</span><br><span class="line">        q_target = b_r + variable11</span><br><span class="line">        <span class="comment"># q_target = b_r + GAMMA * q_next.max(1)[0]   # shape (batch, 1)</span></span><br><span class="line">        loss = self.loss_func(q_eval, q_target)</span><br><span class="line"></span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dqn = DQN()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nCollecting experience...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i_episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):</span><br><span class="line">    observation = env.reset()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># render environment</span></span><br><span class="line">        env.render()</span><br><span class="line">        <span class="comment"># choose action</span></span><br><span class="line">        action = dqn.choose_action(observation)</span><br><span class="line">        <span class="comment"># take action</span></span><br><span class="line">        obeservation_, reward, done, info = env.step(action)</span><br><span class="line">        <span class="comment"># store data</span></span><br><span class="line">        dqn.store_transition(observation, action, reward, obeservation_)</span><br><span class="line">        <span class="comment"># data is enough then do the RL</span></span><br><span class="line">        <span class="keyword">if</span> dqn.memory_counter &gt; MEMORY_CAPACITY:</span><br><span class="line">            dqn.learn()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># state update</span></span><br><span class="line">        observation = obeservation_</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;对于Q-Learning和Sarsa这样的时序差分算法，对于小型的强化学习问题是非常灵活有效的，但是在大数据时代，异常复杂的状态和可选动作，使Q-Learning和Sarsa要维护的Q表异常的大，甚至远远超出内存，这限制了时序差分算法的应用场景。在深度学习兴起后，基于深度学习的强化学习开始占主导地位。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】强化学习基础模型及求解</title>
      <link href="/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;强化学习 (Reinforcement Learning) 是一个机器学习大家族中的分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用。比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事。强化学习让程序从对当前环境完全陌生, 成长为一个在环境中游刃有余的高手。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150606.png" alt="image-20220126150606364" style="zoom: 67%;" /><span id="more"></span><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="在机器学习中的位置"><a href="#在机器学习中的位置" class="headerlink" title="在机器学习中的位置"></a>在机器学习中的位置</h3><p>&emsp;&emsp;强化学习是和监督学习，非监督学习并列的第三种机器学习方法，是机器学习中的一个独立领域。与后两者相同，强化学习有自己一套比较完整的数据处理、建模、训练、调优的套路，成为了一种方法论或模型体系。</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>&emsp;&emsp;监督学习是比较传统的一个机器学习领域，简而言之是给定（输入，输出）对，反向推导从输入到输出这个映射中的参数值或组合，即给定映射形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150457.png" alt="image-20220126110940334" style="zoom: 67%;" /><p>然后根据已有数据集(x, y)键值对推导参数 <code>θ</code> ，这个过程称为训练。</p><h4 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h4><p>&emsp;&emsp;非监督学习也是比较传统的一个机器学习领域，比较常见的是聚类模型，例如：K-Means算法，只给定输入 x，输出并没有给定目标值。</p><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>&emsp;&emsp;强化学习和监督学习最大的区别是它没有监督学习已经准备好的训练数据输出值。强化学习只有奖励值，但是这个奖励值和监督学习的输出值不一样，它不是事先给出的，而是延后给出的。同时，强化学习的每一步与时间顺序前后关系紧密。而监督学习的训练数据之间一般都是独立的，没有这种前后的依赖关系。</p><p>&emsp;&emsp;强化学习和非监督学习的区别。也还是在奖励值这个地方。非监督学习是没有输出值也没有奖励值的，它只有数据特征。同时和监督学习一样，数据之间也都是独立的，没有强化学习这样的前后依赖关系。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229085342.png" alt="image-20211229085342314" style="zoom:50%;" /><p>&nbsp;</p><h3 id="强化学习建模"><a href="#强化学习建模" class="headerlink" title="强化学习建模"></a>强化学习建模</h3><h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>Agent / Brain</td><td>强化学习中做决策的智能体(机器人)</td></tr><tr><td>Environment</td><td>被学习的环境或对象，一般对Agent是未知的“黑盒子”</td></tr><tr><td>State 、 Observation</td><td>Agent对Environment的感知，是做出决策的信息来源</td></tr><tr><td>Action</td><td>Agent基于感知信息和决策算法，对决定在当下对Environment执行的动作</td></tr><tr><td>Reward</td><td>Environment对Agent执行Action的反馈</td></tr></tbody></table><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227234235.png" alt="image-20211227234234718" style="zoom: 33%;" /><p>&emsp;&emsp;由上，强化学习模型其实就是智能体<code>Agent</code>观测环境<code>Environment</code>后得到环境当前所处的状态信息<code>State</code>，然后基于自身决策算法决定对环境执行一个动作<code>Action</code>，这个动作使环境的状态发生了变化，并由此反馈给智能体一个信息<code>Reward</code>，以告知其动作的好坏，智能体基于反馈优化自己做决策的算法。不断重复这个过程，从而让智能体形成能够带来最大价值的决策算法。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>&emsp;&emsp;注意这里说的模型与强化学习本身数学模型并不是同一个概念，这里的模型是指环境Environment，通常用两个式子就可以描述一个模型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126113400.png" alt="image-20220126113400549" style="zoom:67%;" /><p>&emsp;&emsp;第一个公式表示<code>t</code>时刻状态为<code>s</code>，执行动作<code>a</code>后转换为状态<code>s’</code>的概率；第二个公式表示<code>t</code>时刻状态为<code>s</code>，执行动作<code>a</code>的奖励的期望值（因为可能转换到不同的状态）。如果知道这两个环境的这两个公式，那么这个环境对于智能体来说就不是“黑盒子”，因为它的一切输入、输出及奖励都可以直接数学推导得出，而不再需要通过试错的方式来观察。因此，最佳策略算法的问题转化为最优化问题，不止或者不再需要用强化学习来求解，使用其他机器学习算法都可以解决。</p><h5 id="Model-Based"><a href="#Model-Based" class="headerlink" title="Model-Based"></a>Model-Based</h5><p>&emsp;&emsp;顾名思义，Model-Based的强化学习算法就是必须已知环境的上述两个信息才能求解。但这时完全可以用其他更优的算法代替强化学习了。</p><h5 id="Model-Free"><a href="#Model-Free" class="headerlink" title="Model-Free"></a>Model-Free</h5><p>&emsp;&emsp;Model-Free的强化学习算法不需要已知环境模型就可以求解，而这也是实际工程中最常用的，是强化学习的价值所在。</p><p>&nbsp;</p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>&emsp;&emsp;强化学习模型求解过程本质就是智能体在不断与环境交互，产生序列：<code>S0,A0,R1,S1,A1,R2,...</code>，并在这个过程中推导出最优的决策算法，从而实现价值最大化。</p><h4 id="直接法（基于策略）"><a href="#直接法（基于策略）" class="headerlink" title="直接法（基于策略）"></a>直接法（基于策略）</h4><p>&emsp;&emsp;直接法的前提是策略形式为： <code>a=π(s|θ)</code> ，即由参数 <code>θ</code> 描述策略，优化策略就是优化参数 <code>θ</code>。那么既然是要优化，就一定有优化的目标或评价函数，在这里是所有状态State下动作Action的奖励期望值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150458.png" alt="image-20220126115026053" style="zoom:70%;" /><p>&emsp;&emsp;但实际上，大多策略都不是仅靠参数<code>θ</code>就能描述的，因此强化学习的优化用的主要是下面的间接法。</p><h4 id="间接法（基于价值）"><a href="#间接法（基于价值）" class="headerlink" title="间接法（基于价值）"></a>间接法（基于价值）</h4><p>&emsp;&emsp;间接法的思想就是，计算出各个状态在策略<code>π</code>下的价值，然后决策时选择能够达到最大价值的下一状态的动作，这就是最优策略。其中，状态价值公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085646.png" alt="image-20211228085646607" style="zoom: 50%;" /><center>γ是折扣因子，反映价值的远见性</center><p>&emsp;&emsp;可见，优化策略的问题转化为了如何根据公式计算每个状态价值的问题。事实上，后面的三种经典求解强化学习的算法思想也都是在间接法求最优策略，使用不同的方法计算状态价值。</p><h4 id="On-Line-和-Off-Line-学习"><a href="#On-Line-和-Off-Line-学习" class="headerlink" title="On-Line 和 Off-Line 学习"></a>On-Line 和 Off-Line 学习</h4><p>&emsp;&emsp;强化学习的有两种学习方式，在线学习是指Agent一边与环境交互收集样本，一遍更新策略；离线学习是指Agent事先像监督学习一样得到完整的训练，然后用最终策略与环境交互。虽然离线学习在现成数据集下可以快速训练得到较好的策略，不需要像在线学习那样一个动作得到一次反馈，然后花时间更新策略，训练地较慢。但是在现实场景中，并没有机会存储足够多的样本供离线学习训练，绝大多数基于时间差分法的强化学习训练都倾向于在线学习。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="动态规划DP（Model-Based）"><a href="#动态规划DP（Model-Based）" class="headerlink" title="动态规划DP（Model-Based）"></a>动态规划DP（Model-Based）</h2><p>&emsp;&emsp;动态规划是一门相对独立的学科，是运筹学的一个分支。运筹学本身的学科体系就比较复杂且不断壮大，包括：线性规划、非线性规划、组合规划、图论、决策分析、排队论、博弈论、搜索论等，动态规划关注如何用数学方法求解一个决策过程的最优化问题。将问题的最优解分解为若干小问题的最优解，即通过寻找子问题的最优解之间的递推关系来得到问题的最优解。而动态规划求解强化学习的算法是建立在马尔可夫决策过程基础上的。</p><p>&nbsp;</p><h3 id="马尔可夫决策过程MDP"><a href="#马尔可夫决策过程MDP" class="headerlink" title="马尔可夫决策过程MDP"></a>马尔可夫决策过程MDP</h3><p>&emsp;&emsp;在强化学习中，agent与environment一直在互动。在每个时刻t，agent会接收到来自环境的状态s，基于这个状态s，agent会做出动作a，然后这个动作作用在环境上，于是agent可以接收到一个奖赏Rt+1，并且agent就会到达新的状态。所以，其实agent与environment之间的交互就是产生了一个序列：<code>S0,A0,R1,S1,A1,R2,...</code></p><p>&emsp;&emsp;称这个为序列决策过程。而马尔科夫决策过程（Morkov Decision Process）就是一个典型的序列决策过程的一种公式化。有了马尔科夫的假设，才能推导出状态价值的贝尔曼方程式，从而用递推的方式计算状态价值。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&emsp;&emsp;下一个状态的产生只和当前的状态有关，即：<code>P(St+1 | St) = P(St+1 | S1,...,St)</code></p><p>&emsp;&emsp;直观上讲，下一个状态的产生跟所有历史状态是有关的，也就是等式右边所示。但是Markov的定义则是忽略掉历史信息，只保留了当前状态的信息来预测下一个状态，这称为无后效性/马尔可夫性。一个 MDP 可以由一个 5 元组表示为 <code>M = &lt;S,A,P(s&#39;|s,a),R,γ&gt;</code>：</p><blockquote><p><strong>S</strong> → 一个状态（state）的集合<br><strong>P</strong> → 一个受行为影响的状态转移概率矩阵<br><strong>A</strong> →一个有限动作集<br><strong>R</strong> →  一个用于计算回报的函数<br><strong>γ</strong> → 一个折扣因子，用于做未来回报计算时的衰减系数，γ ∈ ( 0 , 1 )</p></blockquote><p>&nbsp;</p><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><p><strong>状态转移概率Pss′a</strong></p><p>对于一个具体的状态s和它的下一个状态s’，它们的状态转移概率(就是从s转移到s’的概率)定义为：</p><p>&emsp;&emsp;<code>Pss′a = P(St+1=s′|St=s,At=a)</code></p><p>也就是说，下一个状态的产生只受到当前状态和动作的影响。</p><p><strong>策略π</strong></p><p>&emsp;&emsp;<code>Policy： π(a|s) = P(At=a|St=s)</code></p><p>policy π表示的是在给定的state下，一个关于action的概率分布。即表示在一个状态s下，agent接下来可能会采取的任意一个action的概率分布（可能一开始不知道概率是多少）。对于每一个状态s都会有这样一个π(a|s)，所有状态的π(a|s）就形成整体策略π。策略π是指所有状态都要使用这个策略，不是单独指某一个状态。</p><p>无论怎样，我们的目标是最大化累积奖赏，所以我们可以通过不断地改进我们的策略，使得我们最后能够获得最大累积奖赏。</p><p><strong>状态价值函数Vπ</strong></p><p>定义式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085646.png" alt="image-20211228085646607" style="zoom: 50%;" /><p>递推形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /><p>计算机通常使用递推式迭代地求出MDP中每个状态的价值函数，而不是用定义式硬算。</p><p><strong>动作价值函数<em>Qπ</em></strong></p><p>定义式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085745.png" alt="image-20211228085745128" style="zoom:50%;" /><p>​                                                                              <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085806.png" alt="image-20211228085806768" style="zoom:50%;" /></p><p>递推形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>计算机通常使用递推式迭代地求出MDP中每个状态的价值函数，而不是用定义式硬算。</p><p><strong>状态价值与动作价值的递推关系</strong></p><p>状态价值函数是所有动作价值函数基于策略π的期望：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085947.png" style="zoom:50%;" /><p>利用上递推式，也很容易从状态价值函数vπ(s)表示动作价值函数qπ(s,a)，即：</p><p>​                                                                    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090008.png" style="zoom:50%;" /></p><p>二者转化关系如图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090154.png" alt="image-20211228090154012" style="zoom: 33%;" /><p>&emsp;&emsp;总而言之，状态 / 动作价值有两部分相加组成，第一部分是即时奖励，第二部分是环境所有可能出现的下一个状态的概率乘以该下一状态的状态价值，最后求和，并加上衰减。两式联立得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090245.png" alt="image-20211228090244956" style="zoom:50%;" /><center>这两个表达式又称为贝尔曼方程</center><p>&nbsp;</p><h4 id="最优价值函数"><a href="#最优价值函数" class="headerlink" title="最优价值函数"></a>最优价值函数</h4><p>&emsp;&emsp;根据间接法的思想，解决强化学习问题意味着要寻找一个最优的策略让个体在与环境交互过程中获得始终比其它策略都要多的收获，这个最优策略可以用 π∗表示。一旦找到这个最优策略π∗，那么就解决了这个强化学习问题。而策略的优劣可由价值函数反映，因此最优策略问题转化为最优价值函数问题。</p><ol><li><p><strong>最优状态价值函数</strong>是所有策略下产生的众多状态价值函数中的最大者：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090541.png" alt="image-20211228090541867" style="zoom:50%;" /></li><li><p><strong>最优动作价值函数</strong>是所有策略下产生的众多动作状态价值函数中的最大者：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090616.png" alt="image-20211228090616747" style="zoom: 50%;" /></li></ol><p><strong>转化关系：</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228091126.png" alt="image-20211228091126423" style="zoom: 50%;" /><p>&nbsp;</p><h3 id="策略迭代-求解强化学习"><a href="#策略迭代-求解强化学习" class="headerlink" title="策略迭代 求解强化学习"></a>策略迭代 求解强化学习</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140030.png" alt="image-20211228140030255"></p><p>&emsp;&emsp;根据之前基于任意一个给定策略<code>π</code>与环境进行交互，然后用贝尔曼方程计算状态价值，然后根据状态价值调整动作策略<code>π</code>，这个方法叫做策略迭代(Policy Iteration)。最简单的调整方法就是贪婪法：个体在某个状态下选择的行为是其能够到达后续所有可能的状态中状态价值最大的那个状态。</p><p><strong>流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用当前策略π∗与环境交互，用贝尔曼方程计算当前策略π*对应的状态价值v∗</span><br><span class="line">2. 根据刚刚计算的状态价值v∗以一定的方法（比如贪婪法）更新策略π∗</span><br><span class="line">3. 重复第1、2步，一直迭代下去，直到策略π∗和状态价值v∗收敛为止</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="价值迭代-求解强化学习"><a href="#价值迭代-求解强化学习" class="headerlink" title="价值迭代 求解强化学习"></a>价值迭代 求解强化学习</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140047.png" alt="image-20211228140046899"></p><p>&emsp;&emsp;相比策略迭代，价值迭代不需要等到状态价值收敛才调整策略，而是随着状态价值的迭代及时调整策略, 这样可以大大减少迭代次数。此时的状态价值的更新方法也和策略迭代不同，此时贝尔曼方程迭代式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>&emsp;&emsp;可见由于策略调整，现在价值每次更新倾向于贪婪法选择的最优策略对应的后续状态价值，这样收敛更快。</p><p><strong>流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用当前策略π∗与环境交互，用贝尔曼方程计算当前策略π*对应的状态价值v∗</span><br><span class="line">2. 根据刚刚计算的状态价值v∗以上述公式更新策略v∗</span><br><span class="line">3. 重复第1、2步，一直迭代下去，直到状态价值v∗收敛为止</span><br><span class="line">4. 根据收敛的v*，以贪婪思想更新得到最优策略π∗</span><br></pre></td></tr></table></figure><p>对比策略迭代可知，价值迭代中，策略π始终不变，更新的只有价值v*，等到v*收敛后才更新策略π，一步到位；</p><p>而策略迭代中，更新的主体的策略π，每轮更新后计算新的价值v*，然后继续更新π，直到策略π收敛。</p><p>&nbsp;</p><h3 id="异步动态规划"><a href="#异步动态规划" class="headerlink" title="异步动态规划"></a>异步动态规划</h3><p>&emsp;&emsp;上面几个都是<strong>同步动态规划算法</strong>，即每轮迭代会计算出所有的状态价值并保存起来，在下一轮中使用这些保存起来的状态价值来计算新一轮的状态价值。另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。</p><p><strong>原位动态规划 (in-place DP)</strong></p><p>&emsp;&emsp;此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。</p><p><strong>优先级动态规划 (prioritized sweeping DP)</strong></p><p>&emsp;&emsp;该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。</p><p><strong>实时动态规划 (real-time DP)</strong></p><p>&emsp;&emsp;实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。</p><p>&nbsp;</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;动态规划算法主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此还需要寻找其他的针对复杂问题的强化学习问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="蒙特卡罗法MC（Model-free）"><a href="#蒙特卡罗法MC（Model-free）" class="headerlink" title="蒙特卡罗法MC（Model-free）"></a>蒙特卡罗法MC（Model-free）</h2><p>&emsp;&emsp;蒙特卡罗法又叫做统计模拟方法，是一种以概率统计理论为指导的数值计算方法。其核心思想是：多次实验逼近客观分布真实值。</p><p>&nbsp;</p><h3 id="不基于模型的强化学习问题"><a href="#不基于模型的强化学习问题" class="headerlink" title="不基于模型的强化学习问题"></a>不基于模型的强化学习问题</h3><p>&emsp;&emsp;在上面动态规划法中，模型状态转化概率矩阵P始终是已知的，即MDP已知，一般称这样的强化学习问题为Model-based的强化学习问题。Model-based强化学习问题可以通过动态规划来评估一个给定的策略，通过不断迭代最终得到最优价值函数，具体的做法有两个：一个是策略迭代，一个是值迭代。</p><p>&emsp;&emsp;然而有很多强化学习问题没有办法事先得到模型状态转化概率Pss’a，即不基于模型的<strong>Model-free</strong>强化学习（面向黑盒子学习），为了能够从环境中学习，需要让agent与environment交互，得到一些经历（样本）。然后通过这些经历来进行策略评估与策略迭代，从而最终得到最优策略。这种做法的理论是从蒙特卡罗方法（Monte-Carlo）中来的。</p><p>&nbsp;</p><h3 id="蒙特卡罗思想"><a href="#蒙特卡罗思想" class="headerlink" title="蒙特卡罗思想"></a>蒙特卡罗思想</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135735.png" alt="image-20211228135716095"></p><p>&emsp;&emsp;通过采样若干个<code>经历完整的状态序列(episode)</code>后求均值来估计状态的真实价值。所谓的经历完整，就是这个序列<strong>必须是达到终点</strong>的，这样才能拿到最终回报。比如下棋问题要分出输赢，驾车问题要成功到达终点或者失败。有了很多组这样经历完整的状态序列，不需要借助模型本身就可以近似的估计状态价值，进而求解预测和控制问题。</p><p>&emsp;&emsp;采样得到的完整序列示例：<code>S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</code></p><p>&emsp;&emsp;借助大数定律思想以统计的方式算出状态价值后，策略的优化基本和动态规划一样，用<strong>价值迭代</strong>。</p><p><strong>对比动态规划</strong></p><ul><li>关键区别是状态价值的计算方法不同</li><li>不依赖于模型状态转化概率</li><li>从经历过的完整序列学习，完整的经历越多，学习效果越好</li></ul><p><strong>首次访问与每次访问</strong></p><p>&emsp;&emsp;同样一个状态可能在一个完整的状态序列（episode）中重复出现，第一种应对方法是仅把状态序列中第一次出现该状态时的收获值纳入到收获平均值的计算中；另一种是针对一个状态序列中每次出现的该状态，都计算对应的收获值并纳入到收获平均值的计算中。两种方法对应的蒙特卡罗法分别称为：<strong>首次访问(first visit)</strong> 和<strong>每次访问(every visit)</strong> 蒙特卡罗法。第二种方法比第一种的计算量要大一些，但是在完整的经历样本序列少的场景下会比第一种方法适用。</p><p><strong>累进更新平均值（incremental mean)</strong></p><p>&emsp;&emsp;按照蒙特卡洛求平均值来代表状态价值的公式里，每个状态都需要维护一个计数器和累加器，分别保存其出现次数和价值之和用于最后求平均，这样浪费了太多的存储空间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150459.png" alt="image-20220126143115081" style="zoom: 67%;" /><p>注意，这里的 <code>Gt</code> 不能用贝尔曼方程计算，只能由采样的奖励值序列按定义式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228095500.png" alt="image-20211228095500637" style="zoom:50%;" /><p>&emsp;&emsp;数学上的优化方法是在迭代计算收获均值，即每次保存上一轮迭代得到的收获均值与次数，当计算得到当前轮的收获时，即可计算当前轮收获均值和次数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126143244.png" alt="image-20220126143244239" style="zoom:67%;" /><p>其中，<code>k</code>采样序列episode的个数，可以证明这样计更新价值V和上面的结果是一致的，但大大节省空间。</p><p>&nbsp;</p><h3 id="价值迭代"><a href="#价值迭代" class="headerlink" title="价值迭代"></a>价值迭代</h3><p>&emsp;&emsp;蒙特卡罗法求解强化学习问题的思路和动态规划价值迭代的的思路类似。区别在于价值vk(s)的计算方法（蒙特卡洛使用采样然后取平均来算），然后基于据一定的方法（比如贪婪法）更新当前策略π。最后得到最优价值函数v∗和最优策略π∗。</p><p><strong>对比动态规划：</strong></p><p>​        1.  状态价值的计算方法不同，动态规划用贝尔曼方程迭代，蒙特卡罗法用采样数据求平均</p><p>​        2. 蒙特卡罗法一般是优化最优动作价值函数q∗，而不是状态价值函数v∗</p><p>​        3. 动态规划一般基于贪婪法更新策略，而蒙特卡罗法一般采用<strong>ϵ−greedy</strong>法更新：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228141900.png" alt="image-20211228141900761" style="zoom: 18%;" /><center>m是可选行动的个数</center><p>在实际求解时，为了使算法可以收敛，一般ϵ会随着算法的迭代过程逐渐减小并趋于0。这样在迭代前期，鼓励探索；而后期由于已经有了足够的探索量，开始趋于保守，以贪婪为主，使算法可以稳定收敛。</p><p><strong>算法：（以every-visit为例）</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最有动作价值函数q∗、最优策略π∗</span><br></pre></td></tr></table></figure><p>流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化所有的动作价值Q(s, a)=0，状态次数N(s, a)=0，采样次数k=0，随机初始化一个策略π</span><br><span class="line">2. k=k+1，基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:</span><br><span class="line">S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</span><br><span class="line">3. 对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：</span><br><span class="line">    Gt = 对n累加到T[(γ^(t-n))*(Rt+n)]</span><br><span class="line">    N(s, a) ++</span><br><span class="line">    Q(s, a) += (Gt-Q(s, a))/N(s,a)</span><br><span class="line">4. 基于新计算出的动作价值，更新当前的ϵ−greedy策略：</span><br><span class="line">    ϵ = 1/k</span><br><span class="line">    π = ϵ−greedy()</span><br><span class="line">5. 若所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗，对应的策略π(a|s)即为最优策略π∗，否则转到第二步</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;蒙特卡罗法是不基于模型的强化问题求解方法，它可以避免动态规划求解过于复杂，同时不需要事先知道环境转化模型，因此常用于海量数据和复杂模型。但是它每次采样都需要一个完整的状态序列，如果没有完整的状态序列，或者很难拿到较多的完整的状态序列，因此在实际问题中蒙特卡罗法用的不多，所以还需要寻找其他的更灵活的不基于模型的强化问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="时序差分法TD（Model-free）"><a href="#时序差分法TD（Model-free）" class="headerlink" title="时序差分法TD（Model-free）"></a>时序差分法TD（Model-free）</h2><h3 id="时序差分法"><a href="#时序差分法" class="headerlink" title="时序差分法"></a>时序差分法</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135332.png" alt="image-20211228135332814"></p><p>&emsp;&emsp;时序差分法和蒙特卡罗法类似，都是不基于模型的强化学习问题求解方法。蒙特卡罗法中<code>Gt</code>的计算需要完整序列，而时序差分法没有完整的状态序列，只有部分的状态序列，由贝尔曼方程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /><p>可知，可以用<code>Rt+1+γv(St+1)</code>来近似的代替收获Gt。</p><p>一般我们把<code>Rt+1+γV(St+1)</code>称为<strong>目标值</strong>，<code>Rt+1+γV(St+1)−V(St)</code>称为<strong>TD误差</strong>，将用目标值近似代替收获G(t)的过程称为<strong>引导</strong>(bootstrapping)。这样只需要两个连续的状态与对应的奖励，就有了近似收获Gt的表达式，可以去求解时序差分的预测问题和控制问题了。</p><p>&nbsp;</p><p><strong>对比蒙特卡洛法：</strong></p><p>时序差分的预测问题求解和蒙特卡罗法类似，但是主要有两个不同点：</p><ul><li><p>收获Gt的表达式不同</p><ul><li>蒙特卡罗 G(t) 需要遍历完整过程才能得出：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228102751.png" alt="image-20211228102751434" style="zoom: 50%;" /></li><li>时序差分 G(t)记录连续两个状态就可得出，称为 <strong>TD Target</strong> ：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110419.png" alt="image-20211228110419330" style="zoom: 50%;" /></li></ul></li><li><p>迭代式子的系数不同，时序差分没有完整的序列，也就没有对应的次数N(St, At)，一般用一个[0,1]的系数α代替：</p><ul><li><p>蒙特卡罗:    </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110505.png" alt="image-20211228110505164" style="zoom:50%;" /></li><li><p>时序差分: </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110514.png" alt="image-20211228110514567" style="zoom:50%;" /></li></ul></li></ul><p>&emsp;&emsp;（并且蒙特卡罗法一般只优化动作价值函数Q，时序差分状态价值、动作价值函数都会优化）</p><ul><li>时序差分法在知道最终结果之前就可以学习，甚至没有最终结果也可以学习，还可以在持续进行的环境中学习。而蒙特卡罗法则要等到最后结果才能学习，因此时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。</li><li>时序差分法在更新状态价值时使用的是<strong>TD目标值</strong>，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的<strong>有偏估计</strong>，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的<strong>无偏估计</strong>，这一点蒙特卡罗法占优。</li><li>虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。</li></ul><p>&nbsp;</p><h3 id="n步时序差分："><a href="#n步时序差分：" class="headerlink" title="n步时序差分："></a>n步时序差分：</h3><p>&emsp;&emsp;上面用TD Target代替收获Gt的公式中，St只向前一步到St+1，若用向前2步、n步来近似代替Gt，则为n步时序差分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228105615.png" alt="image-20211228105615429" style="zoom: 33%;" /><p>&emsp;&emsp;（当n越来越大，趋于无穷，或者说趋于使用完整的状态序列时，n步时序差分就等价于蒙特卡罗法了）</p><p>&nbsp;</p><h3 id="TD-λ"><a href="#TD-λ" class="headerlink" title="TD(λ)"></a>TD(λ)</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112323.png" alt="image-20211228112323589"></p><p>&emsp;&emsp;n步时序差分选择多少步数是一个超参数调优问题(一般3~10比较好)。为了能在不增加计算复杂度的情况下综合考虑所有步数的预测，引入一个[0,1]新的参数λ，定义收获是n从1到∞所有步的收获乘以权重的和：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100620.png" alt="image-20211229100620726" style="zoom:50%;" /><p>每一步的权重是<code>(1−λ)*λ^(n−1)</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112010.png" alt="image-20211228112009881" style="zoom: 33%;" /><p>&emsp;&emsp;进而有价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228142817.png" alt="image-20211228142817279" style="zoom:25%;" /><p>&emsp;&emsp;从前向来看，一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时，就是上面的普通时序差分法；当λ=1时，就是蒙特卡罗法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111541.png" alt="image-20211228111540959" style="zoom:25%;" /><p>&emsp;&emsp;从反向来看，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为<strong>频率启发(frequency heuristic) 式</strong>；而把电击归因于最近少数几次状态的影响，则称为<strong>就近启发(recency heuristic) 式</strong>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111604.png" alt="image-20211228111604749" style="zoom:25%;" /><p><strong>效用迹E</strong></p><p>&emsp;&emsp;给每一个状态引入一个数值：<strong>效用值</strong> 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发(同事反映二者)。而所有状态的效用值总称为**效用迹(eligibility traces, ES)**。定义为：</p><p>​                        <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135203.png" alt="image-20211228135203250" style="zoom:25%;" />    </p><p>&emsp;&emsp;此时价值函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p>&nbsp;</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;时序差分和蒙特卡罗法比它更加灵活，学习能力更强，因此是目前主流的强化学习求解问题的方法，现在绝大部分强化学习乃至深度强化学习的求解都是以时序差分的思想为基础的。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token Bucket参数范围的推导</title>
      <link href="/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/"/>
      <url>/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文研究了从两种情况下观察到的网络数据流的流量模式中导出<strong>令牌桶参数</strong>的问题：</p><ul><li>给定数据流对应一组令牌桶参数，所有数据包都立即传送，不产生任何延迟或丢失</li><li>在上述模型中添加一个缓存队列，以临时存储在桶中积累足够的令牌之前无法立即传送的数据包。队列具有平滑流量的效果，因此对令牌桶参数的要求较低，同时还使得派生的令牌桶参数随时间的波动较小。</li></ul><p>然后对两个模型严格分析了给定数据流的队列大小和令牌桶参数之间的关系，计算数据流中每个数据包的排队延迟并用于描述调整后的排队后流量模式。</p><p>并且就两个模型分别介绍了用于推导基于测量的流量规范 (MBTS) 的简单高效算法以及经验结果。这种 MBTS 技术减轻了用户为在综合服务网络中保留网络资源而预先明确表征流量的需要。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Network%20traffic%20characterization%20using%20token%20bucket%20model.pdf">Network traffic characterization using token bucket model</a></p><span id="more"></span><p>&nbsp;</p><h2 id="令牌桶概念及问题"><a href="#令牌桶概念及问题" class="headerlink" title="令牌桶概念及问题"></a>令牌桶概念及问题</h2><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>&emsp;&emsp;假设一个流存在于一个时间间隔 [t0 , tn ] 中并且由 n 个数据包 p1, p2, … ，pn 组成。它的流量模式 P = {(pi , ti）|1&lt;i&lt;n}，其中 t0&lt;t1&lt;t2&lt; … &lt; tn, 表示在时间[t0, tn]内，pi由主机中的应用程序生成，表示第 i 个数据包的字节数。</p><h3 id="无缓存队列的令牌桶"><a href="#无缓存队列的令牌桶" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶是一个非负计数器，它以恒定速率 r 累积令牌，直到计数器达到其容量 b 。到达后，一个数据包将被发送出去，令牌计数器减少了数据包大小（以字节为单位），前提是该数据包有足够的令牌。否则，数据包将被丢弃或排队，直到令牌桶积累了足够的令牌以将数据包发送出去。当流空闲或以较低的速率运行，使得令牌计数器达到上限 b 时，令牌的累积将暂停，直到下一个数据包到达。请注意，令牌桶不是数据包的物理容器，而是用于调度数据包释放时间的令牌数字计数器。令牌桶由其令牌补充率 r 和令牌桶大小 b 参数化。</p><p>&emsp;&emsp;流量表征的一个关键问题是，对于时间间隔 [t0, tn] 中模式 P 的数据流，如何从观察到的流量模式导出合适的令牌桶参数 (r, b) ，以便所有数据包在到达时立即发送出去。在这种情况下，我们说数据流符合由 (r, b) 参数化的令牌桶模型。</p><h3 id="含缓存队列的令牌桶"><a href="#含缓存队列的令牌桶" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶模型可以通过向其添加缓存队列来扩展。该缓存队列用于在数据包流等待足够的令牌以在存储桶中累积时保存数据包流。通过排队，突发流量可以被平滑，因此派生的令牌桶参数变得比无缓存队列情况下的要求更低，从而导致网络中更有效的资源分配。另一方面，通过添加缓存队列，给定的令牌桶模型将能够以牺牲存储空间和数据源的数据包延迟为代价来适应更多变化的流量模式。</p><p>对带有队列的令牌桶有如下问题：</p><ol><li>对于给定的数据流和令牌桶模型，最小队列大小 q 应该为多少才能保证数据流不会丢包？</li><li>如果给定令牌速率r、桶容量b之一和队列大小 q，那么另一个参数的最佳选择是什么？</li><li>对于排队情况下的每个数据包，排队延迟是多少？</li><li>如果指定了最大排队延迟，那么应该如何确定最小队列大小和对应的令牌桶参数？</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="两种模型下的参数求解"><a href="#两种模型下的参数求解" class="headerlink" title="两种模型下的参数求解"></a>两种模型下的参数求解</h2><h3 id="无缓存队列的令牌桶-1"><a href="#无缓存队列的令牌桶-1" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>本文Part 2通过严格的数学证明和有效的算法：</p><ul><li><p>找到了 b 和 r 的下限和上限，以便所有满足无时延和丢包要求的合法 ( r , b ) 对</p></li><li><p>对任何给定有效的 r ，可以确定最优的（即与 r 耦合最小的） b 以便不丢弃任何数据包。这个最优 b 明确表示为 r 的函数，它是单调递减和分段线性的</p></li><li><p>提出了两种有效的算法来计算b(r)函数和相关经验结果</p></li></ul><p>&nbsp;</p><h4 id="r的有效范围"><a href="#r的有效范围" class="headerlink" title="r的有效范围"></a>r的有效范围</h4><p>一方面，如果 r 太小，则无论 b 的容量有多大，桶中都不会为传入的数据包生成足够的令牌。因此满足无延迟要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194837.png" alt="image-20211226194836980" style="zoom:50%;" /><p>c0是t0时刻桶中初始令牌数，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194540.png" alt="image-20211226194540110" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；</p><p>另一方面，也没有必要使 r 无限大，最大 r 恰满足能使一个时间间隔内的所有数据包都被发送即可：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194822.png" alt="image-20211226194822619" style="zoom:50%;" /><p>pk是第k个时间间隔内的数据包流量，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195012.png" alt="image-20211226195012336" style="zoom:50%;" /><p>这是<strong>r的上限</strong>。（文中已证明其必大于r的下限）</p><p>&nbsp;</p><h4 id="b的有效范围"><a href="#b的有效范围" class="headerlink" title="b的有效范围"></a>b的有效范围</h4><p>由上可推出<strong>最大数据速率</strong>为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201839.png" alt="image-20211226201839313" style="zoom:50%;" /><p>当时间间隔k内数据速率p大于rmax且初始令牌数c0时，得到最小桶的容量：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195603.png" alt="image-20211226195603013" style="zoom:50%;" /><p>这是<strong>b的下限</strong>；</p><p>当满足上面r的限定范围时，每个时间间隔k过后内桶中会积累的令牌数量为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195806.png" alt="image-20211226195806153" style="zoom:50%;" /><p>因此桶的大小必须至少能够容下ck的最大值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201417.png" alt="image-20211226201417539" style="zoom:50%;" /><p>这是<strong>b的上限</strong>，可见b的范围是r的函数。</p><p>&nbsp;</p><h4 id="b和r的关系"><a href="#b和r的关系" class="headerlink" title="b和r的关系"></a>b和r的关系</h4><p>给定r，求解满足无时延和丢包前提下的最小b值</p><p>记delta k表示第k个时间间隔大小，ck表示第k个数据包到达前时刻的桶中令牌数量（即上一个时间间隔结尾时刻的），则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224424.png" alt="image-20211226224424621" style="zoom:50%;" /><p>（注意到这里的ck(r,b)不同于前面的ck(r)，ck(r,b)小于等于ck(r)，仅当b大于等于bmax时取等号）</p><p>因为满足无时延和丢包，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224657.png" alt="image-20211226224657804" style="zoom:50%;" /><p>递推得到：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224838.png" alt="image-20211226224838298" style="zoom:50%;" /><p>因此，满足无时延和丢包前提下，给定r时的最优（最小）b为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224920.png" alt="image-20211226224920764" style="zoom:50%;" /><p>若取初始令牌数c0==b，即桶一开始是满的，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226225532.png" alt="image-20211226225532241" style="zoom:50%;" /><p>&nbsp;</p><h4 id="降低b-r-时间复杂度"><a href="#降低b-r-时间复杂度" class="headerlink" title="降低b(r)时间复杂度"></a>降低b(r)时间复杂度</h4><p>&emsp;&emsp;由上可知，求解最优b值是至少要在 n(n-1)/2 个数字中取最大值，评估所有这些 O ( n 2 ) 数的成本太高了。文章中提出了两种有效的算法来计算给定 r 的 最优b值。第一个算法只解析一次输入模式 P ，复杂度为 O ( n ) 。第二个是multi-pass算法，复杂度为 O ( n log n)，但是可以推广到排队情况。</p><h5 id="算法-1-简单数学推导"><a href="#算法-1-简单数学推导" class="headerlink" title="算法 1    简单数学推导"></a>算法 1    简单数学推导</h5><p>&emsp;&emsp;这里省去论文中的推导，直接记录结论。</p><p>&emsp;&emsp;由递推公式  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226231637.png" alt="image-20211226231637615" style="zoom:50%;" /></p><p>&emsp;&emsp;可以计算出以P={(pk,tk) | 1&lt;k&lt;n}为流量模式的情况下，给定r后b的最优值。</p><p>&emsp;&emsp;此算法不仅由于 O(n) 复杂度而具有 CPU 效率，而且在内存方面也很高效。只需要分配两个整数 d 和 b 作为 dk 和 bk 序列的占位符，不需要存储模式数据 P，因为这是一种一次性算法，它可以与到达的数据包流一起实时进行。</p><h5 id="算法-2-二分查找"><a href="#算法-2-二分查找" class="headerlink" title="算法 2    二分查找"></a>算法 2    二分查找</h5><p>&emsp;&emsp;第二种算法没有利用 b(r)的显式解。相反它对其范围内的最小 b 进行二分搜索，使得对所有 k 都有ck(r,b) &gt;= pk。该算法的优点在于它可以推广并激发Part 3中的排队情况解决方案，同时也可以作为我们实验中检查第一个算法的正确性和性能的参考。</p><p>&emsp;&emsp;用 [bl , bu] 表示b 的范围，其中 l 代表下限，u 代表上限。最初设置 bl = bmin、bu=bmax 和 b = 1/2*(bl + bu)。在初始满桶(c0=b)的情况下，选择归纳计算 ck(r,b) 并将其值与 pk 进行比较。如果对任何k都有pk &lt;= ck(r,b)，则设置 bu  = b 和 b = 1/2*(bl + bu) 。否则，当遇到的第一个pk &gt; ck(r,b)的 k 时，我们设置 bl = b 和 b = 1/2*(bl + bu)。重复上述步骤直到 bl = bu。</p><p>&emsp;&emsp;由于用于二分搜索的 b 的初始范围最多为 O ( n ) ，因此 b 上恰好有 O(logn) 次更新。对于 b 的每次更新，最多需要遍历 (pk , tk) 的列表一次。在最坏的情况下也只需要时间 O (n) ，因此二分查找算法的复杂度是 O (n logn) 。</p><h5 id="算法-3-Send-Now算法"><a href="#算法-3-Send-Now算法" class="headerlink" title="算法 3    Send-Now算法"></a>算法 3    Send-Now算法</h5><p>&emsp;&emsp;这是作者提到他们在一个tb程序中看见的算法，可以达到和算法 1相似的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226233525.png" alt="image-20211226233525702" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="含缓存队列的令牌桶-1"><a href="#含缓存队列的令牌桶-1" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>本文Part 3通过严格的数学证明和有效的算法：</p><ul><li>确定了给定缓存队列大小 q 的有效 r 和 b 的边界。发现对于给定的流量模式，在有时延但无丢包情况下，最小缓存队列大小q是 ( r , b ) 对的二元函数，且这个函数 q(r, b ) 是 r 和 b 的减函数</li><li>提出了给定的缓存队列大小 q时最优 b 和 r 之间关系的计算算法。后者实际上是对无缓存队列情况的一般化，如果将缓存队列大小设置为0，则将退化为Part 2中的结果</li><li>明确计算了给定令牌桶模型的数据流中每个数据包的排队延迟。从而推导出数据流的最大和平均排队延迟，以及调整后的排队后流量模式</li><li>提出了在指定最大延迟或平均延迟的上限时确定满足延迟界限的令牌桶模型（r，b）集的算法，并分析了算法的时间复杂度</li></ul><p>&nbsp;</p><h4 id="不考虑容量b的情况"><a href="#不考虑容量b的情况" class="headerlink" title="不考虑容量b的情况"></a>不考虑容量b的情况</h4><h5 id="r的有效范围-1"><a href="#r的有效范围-1" class="headerlink" title="r的有效范围"></a>r的有效范围</h5><p>假定桶容量b无穷大，从而简化推导。记缓存队列大小为q，则满足无丢包要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110252.png" alt="image-20211227110252037" style="zoom:50%;" /><p>其中<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110336.png" alt="image-20211227110336667" style="zoom:50%;" />从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110351.png" alt="image-20211227110351617" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；至于<strong>r的上限</strong>则和上面无缓存队列情况时一致。</p><p>&nbsp;</p><h5 id="b的有效范围-1"><a href="#b的有效范围-1" class="headerlink" title="b的有效范围"></a>b的有效范围</h5><p>注意，在有缓存队列情况下，每个时间间隔内损耗的令牌数不只是时间间隔内新来的数据包pk大小，还包括缓存队列中多个delay的旧数据包。第k个时间间隔内delay的旧数据包大小为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111522.png" alt="image-20211227111522588" style="zoom:50%;" /><p>记 I(k) 为使</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111738.png" alt="image-20211227111738322" style="zoom: 50%;" /><p>成立的最小 k’ 值，即 I(k) 是在pk到达之前令牌桶已经发出的数据包的数量。</p><p>则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111920.png" alt="image-20211227111920444" style="zoom:50%;" /><p>因为有了缓存队列，令牌数不够用时数据包放入缓冲队列，此时的令牌数就是ck。</p><p>数据包pk到达后缓存队列中剩余的字节数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227112321.png" alt="image-20211227112321614" style="zoom:50%;" /><p>即令牌数不够用时放入缓冲队列的数据包总大小。</p><p>（这里文章给出了 “ <em>当r&gt;rmin时，必有qk&lt;q（即缓存队列不会溢出）且无丢包</em> ” 的证明，感兴趣可以自己查阅）</p><p>由上述推导得数据包时延为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124037.png" alt="image-20211227124037294" style="zoom:50%;" /><p><strong>b的下限</strong>和上面无缓存队列情况时一致，<strong>b的上限</strong>则为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124447.png" alt="image-20211227124447620" style="zoom:50%;" /><p>注意其中ck(r)的值有两种情况( I(t) &lt; 或 &gt; pk)，所以用max()函数表述。</p><p>&nbsp;</p><h4 id="考虑桶容量b的情况"><a href="#考虑桶容量b的情况" class="headerlink" title="考虑桶容量b的情况"></a>考虑桶容量b的情况</h4><p>&emsp;&emsp;上面研究了不受 b 限制的排队情况，现在考虑一般情况，即缓存队列q和令牌桶大小 b 都起作用。假设我们给出了位于无延迟 TB 曲线下方的值 ( r , b )，我们想知道这个令牌桶的最小队列大小及其相应的排队后的交通模式P。</p><h5 id="q的有效范围"><a href="#q的有效范围" class="headerlink" title="q的有效范围"></a>q的有效范围</h5><p>I(k) 定义为使得</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125435.png" alt="image-20211227125435320" style="zoom:50%;" /> <p>恒成立的最大 k‘ 值，即在 pk 到达之前已经发出而不是存入缓存队列的数据包的数量</p><p>ck(r, b)定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125547.png" alt="image-20211227125547219" style="zoom:50%;" /><p>qk 定义为需要在 pk到达后立即排队的字节数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125652.png" alt="image-20211227125652836" style="zoom:50%;" /><p>则最小队列长qmin为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125756.png" alt="image-20211227125756422" style="zoom:50%;" /><h5 id="q一定时，求b-r"><a href="#q一定时，求b-r" class="headerlink" title="q一定时，求b(r)"></a>q一定时，求b(r)</h5><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>&emsp;&emsp;同上面类似，只不过搜索时的有效条件改为</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227131254.png" alt="image-20211227131254110" style="zoom:50%;" />，时间复杂度为O(n logn)&gt;</p><h6 id="Send-Smooth算法"><a href="#Send-Smooth算法" class="headerlink" title="Send-Smooth算法"></a>Send-Smooth算法</h6><p>&emsp;这是作者上面提到他们在一个tb程序中看见的算法，可以达到O(n)的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228182254.png" alt="image-20211228182254925" style="zoom:67%;" /><p>&nbsp;</p><h4 id="数据包时延"><a href="#数据包时延" class="headerlink" title="数据包时延"></a>数据包时延</h4><p>这边实在没看懂它这1999年的老论文里说的是什么混乱逻辑，反正项目后面做NSRRM时delay直接测实际值不需要计算获得，不管了。。。</p><hr><p>现在是2022.2.21，最终还是我太年轻了，虽然可以测得实际delay，但是测量通信指标的代价太高了，耗时，做决策时只能通过估算的delay来辅助判断，所以还是得看delay到估算怎么做。。。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
            <tag> Token Bucket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题与启发式算法</title>
      <link href="/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</p><p>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据组合，也许永远不会在现实世界出现。因此现实世界中启发式算法常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。</p><p>有一类的通用启发式策略称为元启发式算法，通常使用乱数搜寻技巧。他们可以应用在非常广泛的问题上，但不能保证效率。</p><span id="more"></span><p>&nbsp;</p><h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><h3 id="多项式时间（polynomial-time）"><a href="#多项式时间（polynomial-time）" class="headerlink" title="多项式时间（polynomial time）"></a>多项式时间（polynomial time）</h3><p>&emsp;&emsp;时间复杂度是指当程序所处理的问题规模扩大后，程序需要的时间长度对应增长得有多快。根据增量的量级划分，可以分为：</p><ul><li>多项式复杂度：O(1)、O(log(n))、O(n^a)等</li><li>非多项式复杂度：O(a^n)、O(n!)等</li></ul><p>&emsp;&emsp;非多项式复杂度的程序当问题规模扩大时，计算机将无法承受运算时间开销，因此通常使用的算法都是多项式级的复杂度。</p><p>&nbsp;</p><h3 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，在算法的整个执行过程中，每一步都能得到一个确定的解，这样的算法就是确定性算法。</p><h3 id="非确定性算法"><a href="#非确定性算法" class="headerlink" title="非确定性算法"></a>非确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，它将问题分解成两部分，分别为猜测阶段和验证阶段，其中</p><ul><li>猜测阶段：对问题的一个特定的输入实例x产生一个任意字符串y，在算法的每一次运行时，y的值可能不同，因此，猜测以一种非确定的形式工作。</li><li>验证阶段：用一个确定性算法（有限时间内）验证。<ul><li>检查在猜测阶段产生的y是否是合适的形式，如果不是，则算法停下来并得到no；</li><li>如果y是合适的形式，则验证它是否是问题的解，如果是，则算法停下来并得到yes，否则算法停下来并得到no。它是验证所猜测的解的正确性。</li></ul></li></ul><p>&nbsp;</p><h3 id="规约-约化"><a href="#规约-约化" class="headerlink" title="规约/约化"></a>规约/约化</h3><p>&emsp;&emsp;问题A可以约化为问题B，称为“问题A可规约为问题B”，可以理解为问题B的解一定就是问题A的解，因此解决A不会难于解决B。由此可知问题B的时间复杂度一定大于等于问题A。</p><p>&emsp;&emsp;从规约的定义中我们看到，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断规约，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。</p><p>&nbsp;</p><h3 id="P-NP-NPC-NP-Hard问题"><a href="#P-NP-NPC-NP-Hard问题" class="headerlink" title="P/NP/NPC/NP-Hard问题"></a>P/NP/NPC/NP-Hard问题</h3><h4 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h4><p>&emsp;&emsp;能在多项式时间内可解的问题</p><h4 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h4><p>&emsp;&emsp;在多项式时间内”可验证“的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。</p><h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p>&emsp;&emsp;存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：</p><ul><li>是一个NP问题</li><li>所有NO问题都能规约到它</li></ul><h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>&emsp;&emsp;满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130636.png" alt="image-20211227130636049" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="启发式算法（Heuristic-algorithm）"><a href="#启发式算法（Heuristic-algorithm）" class="headerlink" title="启发式算法（Heuristic algorithm）"></a>启发式算法（Heuristic algorithm）</h2><p>&emsp;&emsp;实际工程中有许多优化问题是NP-Hard问题，其最优算法通常因为复杂度过高而效率低下，或者就是没有最优化算法可以用。启发式算法是相对于最优化算法提出的基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解（次优解），该可行解与最优解的偏离程度一般不能被预计。</p><ul><li>无法保证得到某优化问题的全局最优解</li><li>为了快速地求解那些不存在或者暂时未找到多项式时间内算法的问题而提出</li></ul><p><strong>元启发式算法（Metaheuristic algorithm）</strong></p><p>&emsp;&emsp;元启发式算法主要指一类通用型的启发式算法，这类算法的优化机理不过分依赖于算法的组织结构信息（不依赖特定问题，而是具有通用性的策略），可以广泛的应用到函数的组合优化和函数计算中。</p><p><strong>超启发算法（Hyper-heuristic algorithm）</strong></p><p>&emsp;&emsp;超启发式算法提供了某种高层策略（High-Level Strategy，HLS），通过操纵或管理一组低层启发式算法（Low-Level Heuristics, LLH），以获得新启发式算法。这些新启发式算法则被运用于求解各类NP-难解问题。</p><p>&nbsp;</p><h3 id="常用的启发式算法"><a href="#常用的启发式算法" class="headerlink" title="常用的启发式算法"></a>常用的启发式算法</h3><h4 id="模拟退火算法（SA）"><a href="#模拟退火算法（SA）" class="headerlink" title="模拟退火算法（SA）"></a>模拟退火算法（SA）</h4><p>&emsp;&emsp;模拟退火算法(Simulated Annealing, SA)的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化温度T(充分大)，温度下限Tmin(充分小)，初始解X，每个T值迭代次数L</span><br><span class="line"></span><br><span class="line">2. 随机生成临域解x_new;</span><br><span class="line"></span><br><span class="line">3. 设f(x)函数来计算用来计算解得好坏，计算出f(x_new)-f(x);</span><br><span class="line"></span><br><span class="line">4. 如果f(x_new)-f(x)&gt;0，说明新解比原来的解好，则无条件接受，如果f(x_new)-f(x)&lt;0，则说明旧解比新解好，则以概率exp((f(xnew)-f(x))/k*T)接受x_new作为解。</span><br><span class="line"></span><br><span class="line">5. 如果当前温度&lt;Tmin时，则退出循环，输出当前结果，否则减少当前温度，回到第2步继续循环，常用的降温方法为T= a*T (0&lt;a&lt;1)，一般a取接近1的值</span><br></pre></td></tr></table></figure><p>实例：求解函数最小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130659.png" alt="image-20211227130659835" style="zoom: 67%;" /><p>其中-100&lt;=x&lt;=100，给定任意y值，求x为多少时，F(x)最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">2000</span>;        <span class="comment">// 初始化温度</span></span><br><span class="line"><span class="keyword">double</span> Tmin = <span class="number">1</span>;     <span class="comment">// 温度的下界</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">100</span>;         <span class="comment">// 迭代的次数</span></span><br><span class="line"><span class="keyword">double</span> delta = <span class="number">0.98</span>; <span class="comment">// 温度的下降率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x取值范围 0~100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span>) / <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评价函数的值,即对应上文中的f(x)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x目标函数中的一个参数</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的另一个参数</span></span><br><span class="line"><span class="comment"> * @return函数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getFuncResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">5</span> * <span class="built_in">pow</span>(x, <span class="number">2</span>) - <span class="built_in">cos</span>(<span class="number">2</span> * x) * y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟退火算法的过程</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的指定的参数</span></span><br><span class="line"><span class="comment"> * @return最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSA</span><span class="params">(<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x_min = <span class="number">0</span>; <span class="comment">// 初始化最优值点</span></span><br><span class="line">    <span class="keyword">double</span> f_x = <span class="number">0</span>;   <span class="comment">// 初始化函数值</span></span><br><span class="line">    <span class="keyword">double</span> *x = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) * k);</span><br><span class="line">    <span class="comment">// 初始化初始解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代的过程</span></span><br><span class="line">    <span class="keyword">while</span> (T &gt; Tmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算此时的函数结果</span></span><br><span class="line">            <span class="keyword">double</span> funTmp = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">            <span class="comment">// 在邻域内产生新的解</span></span><br><span class="line">            <span class="keyword">double</span> x_new = x[i] + (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span> - <span class="number">5000</span>) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 判断新的x不能超出界</span></span><br><span class="line">            <span class="keyword">if</span> (x_new &gt;= <span class="number">-100</span> &amp;&amp; x_new &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug x=%f\n&quot;</span>, x_new);</span><br><span class="line">                <span class="keyword">double</span> funTmp_new = <span class="built_in">getFuncResult</span>(x_new, y);</span><br><span class="line">                <span class="keyword">if</span> (funTmp_new - funTmp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 替换</span></span><br><span class="line">                    x[i] = x_new;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 以概率替换</span></span><br><span class="line">                    <span class="keyword">double</span> p = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-(funTmp_new - funTmp) / T));</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">rand</span>() % <span class="number">100</span>) / <span class="number">100</span> &lt; p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x[i] = x_new;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T = T * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f_x &gt; <span class="built_in">getFuncResult</span>(x[i], y))</span><br><span class="line">        &#123;</span><br><span class="line">            x_min = x[i];</span><br><span class="line">            f_x = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置y的值</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="built_in">getSA</span>(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%4.2f时，有f(x)最小值为 %5.3f\n&quot;</span>, x, <span class="built_in">getFuncResult</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="遗传算法（GA）"><a href="#遗传算法（GA）" class="headerlink" title="遗传算法（GA）"></a>遗传算法（GA）</h4><p>&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 对潜在问题进行编码，初始化基因组，并根据基因组随机初始化种群，并指定繁衍代数。</span><br><span class="line"></span><br><span class="line">2. 计算种群中每个个体的适应度，选择一定数目的留下，其余淘汰。</span><br><span class="line"></span><br><span class="line">3. 在留下的个体中，随机繁衍，对分母基因进行交叉（极小概率变异），产生下一代。</span><br><span class="line"></span><br><span class="line">4. 回到第2步进行循环。直到达到指定的繁衍代数</span><br></pre></td></tr></table></figure><p><strong>相关术语</strong></p><p>编码(coding)：将物体的表现型用编码的方式转为程序可控的基因型</p><blockquote><p>比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给 它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津-&gt;新疆-&gt;北京-&gt;广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。<br>（1）二进制编码，基因用0或1表示（常用于解决01背包问题）</p><p>如：基因A：00100011010 (代表一个个体的染色体)</p><p>（2）互换编码（用于解决排序问题，如旅行商问题和调度问题）</p><p>如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。</p></blockquote><p>解码(decoding)：基因型到表现型的映射</p><p>基因型(genotype)：参数的因子</p><p>表现型(phenotype)：根据不同因子最终展现的形态</p><p>适应度(fitness)：度量某个结果的好坏</p><p>进化(evolution)：不断剔除差的结果，最终逐步留下好的结果</p><p>选择(selection)：以一定的概率从种群中选择若干个个体留下，并繁殖。选择过程是一种基于适应度的优胜劣汰的过程</p><p>复制(reproduction)：将父本、母本的基因复制，以便产生下一代</p><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交</p><blockquote><p>（1）单交叉点法 （用于二进制编码）</p><p>选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。</p><p>如：交叉前：</p><p>00000|01110000000010000</p><p>11100|00000111111000101</p><p>交叉后：</p><p>00000|00000111111000101</p><p>11100|01110000000010000</p><p>（2）双交叉点法 （用于二进制编码）</p><p>选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.</p><p>如：交叉前：</p><p>01 |0010| 11</p><p>11 |0111| 01</p><p>交叉后：</p><p>11 |0010| 01</p><p>01 |0111| 11</p><p>（3）基于“ 与/或 ”交叉法 （用于二进制编码）</p><p>对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .</p><p>如：交叉前：</p><p>01001011</p><p>11011101</p><p>交叉后：</p><p>01001001</p><p>11011111</p><p>（4）单交叉点法 （用于互换编码）</p><p>选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。</p><p>如：交叉前：</p><p>87213 | 09546</p><p>98356 | 71420</p><p>交叉后：</p><p>87213 | 95640</p><p>98356 | 72104</p><p>（5）部分匹配交叉（PMX）法（用于互换编码）</p><p>先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。</p><p>父代A：872 | 130 | 9546</p><p>父代B：983 | 567 | 1420    变为：</p><p>TEMP A: 872 | 567 | 9546</p><p>TEMP B: 983 | 130 | 1420</p><p>对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1&lt;——&gt;５　３&lt;——&gt;６　７&lt;——&gt;０</p><p>子代Ａ：802 | 567 | 9143</p><p>子代Ｂ：986 | 130 | 5427</p><p>（6）顺序交叉法(OX) （用于互换编码）</p><p>从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。</p><p>父代A: 872 | 139 | 0546</p><p>父代B: 983 | 567 | 1420</p><p>交叉后：</p><p>子代A: 856 | 139 | 7420</p><p>子代B: 821 | 567 | 3904</p><p>（7）循环交叉（CX）（用于互换编码）</p><p>CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。</p><p>父代A：1 2 3 4 5 6 7 8 9</p><p>父代B：5 4 6 9 2 3 7 8 1</p><p>可得循环基因：1-&gt;5-&gt;2-&gt;4-&gt;3-&gt;6-&gt;9-&gt;7-&gt;8</p><p>子代Ｂ的编码同理。（循环基因 5-&gt;1-&gt;4-&gt;2-&gt;6-&gt;3-&gt;9-&gt;7-&gt;8）</p></blockquote><p>变异(mutation)：交叉后可能（很小的概率）对染色体进行更改，来防止算法过早收敛而陷入局部最优解中</p><blockquote><p>变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。</p><p>（1）基本位变异算子（用于二进制编码）</p><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。</p><p>变异前：</p><p>000001110000000010000</p><p>变异后：</p><p>000001110001000010000</p><p>（2）逆转变异算子（用于互换编码）（源代码中使用类似此方法）</p><p>在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。</p><p>变异前：</p><p>1346798205</p><p>变异后：</p><p>1246798305</p></blockquote><p>个体（individual）：指染色体带有特征的实体</p><p>种群（population）：个体的集合，该集合内个体数称为种群的大小</p><p>&nbsp;</p><h4 id="蚁群算法（ACO）"><a href="#蚁群算法（ACO）" class="headerlink" title="蚁群算法（ACO）"></a>蚁群算法（ACO）</h4><p>&emsp;&emsp;蚁群优化算法（Ant Colony Optimization, ACO）来源于自然界觅食的最短路径原理。根据昆虫学家的观察，蚂蚁可以在没有任何提示的情况下找到从食物源到巢穴的最短路径，并且能在环境发生变化(如原有路径上有了障碍物)后，自适应地搜索新的最佳路径。这样由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化蚂蚁数量、可行路段、每条路段距离、每条路段的初始信息素大小等信息</span><br><span class="line"></span><br><span class="line">2. 设定蚂蚁的起点、终点。</span><br><span class="line"></span><br><span class="line">3. 蚂蚁从起点出发根据信息素浓度，有一定的概率性选择路段，浓度越高，概率越大，逐步回到终点。</span><br><span class="line"></span><br><span class="line">4. 在蚂蚁走过的路径上，根据每条路段的长度按比例释放信息素，短的路段释放的信息素多，长的路段释放的信息素少。</span><br><span class="line"></span><br><span class="line">5. 对所有路段的信息素进行挥发。</span><br><span class="line"></span><br><span class="line">6. 回到第二步进行循环，直到蚂蚁数量迭代完。</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="粒子群算法（PSO）"><a href="#粒子群算法（PSO）" class="headerlink" title="粒子群算法（PSO）"></a>粒子群算法（PSO）</h4><p>&emsp;&emsp;粒子群优化算法(PSO：Particle swarm optimization) 来源于对鸟群捕食的行为研究。通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化离子的速度和位置</span><br><span class="line"></span><br><span class="line">2. 计算粒子适应度</span><br><span class="line"></span><br><span class="line">3. 获取粒子个体的最优值</span><br><span class="line"></span><br><span class="line">4. 获取全体的历史最优值</span><br><span class="line"></span><br><span class="line">5. 更新速度和位置</span><br><span class="line"></span><br><span class="line">6. 若不满足结束条件，则重复2~5</span><br></pre></td></tr></table></figure><p><strong>参数设定</strong></p><ul><li>种群数量：粒子群算法的最大特点就是速度快，因此初始种群取50-1000都是可以的，虽然初始种群越大收敛性会更好，不过太大了也会影响速度；</li><li>迭代次数：一般取100~4000，太少解不稳定，太多浪费时间。对于复杂问题，进化代数可以相应地提高；</li><li>惯性权重：该参数反映了个体历史成绩对现在的影响，一般取0.5~1；</li><li>学习因子：一般取0~4，此处要根据自变量的取值范围来定，并且学习因子分为个体和群体两种；</li><li>空间维数：粒子搜索的空间维数即为自变量的个数。</li><li>位置限制：限制粒子搜索的空间，即自变量的取值范围，对于无约束问题此处可以省略。</li><li>速度限制：如果粒子飞行速度过快，很可能直接飞过最优解位置，但是如果飞行速度过慢，会使得收敛速度变慢，因此设置合理的速度限制就很有必要了<br>&nbsp;</li></ul><p>实例：求解函数最大值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202937.png" alt="image-20211227130748742" style="zoom:67%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line"><span class="comment">%% 初始化种群</span></span><br><span class="line">f= @(x)x .* <span class="built_in">sin</span>(x) .* <span class="built_in">cos</span>(<span class="number">2</span> * x) - <span class="number">2</span> * x .* <span class="built_in">sin</span>(<span class="number">3</span> * x); <span class="comment">% 函数表达式</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);ezplot(f,[<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">20</span>]);</span><br><span class="line">N = <span class="number">50</span>;                         <span class="comment">% 初始种群个数</span></span><br><span class="line">d = <span class="number">1</span>;                          <span class="comment">% 空间维数</span></span><br><span class="line">ger = <span class="number">100</span>;                      <span class="comment">% 最大迭代次数     </span></span><br><span class="line">limit = [<span class="number">0</span>, <span class="number">20</span>];                <span class="comment">% 设置位置参数限制</span></span><br><span class="line">vlimit = [<span class="number">-1</span>, <span class="number">1</span>];               <span class="comment">% 设置速度限制</span></span><br><span class="line">w = <span class="number">0.8</span>;                        <span class="comment">% 惯性权重</span></span><br><span class="line">c1 = <span class="number">0.5</span>;                       <span class="comment">% 自我学习因子</span></span><br><span class="line">c2 = <span class="number">0.5</span>;                       <span class="comment">% 群体学习因子 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:d</span><br><span class="line">    x = limit(<span class="built_in">i</span>, <span class="number">1</span>) + (limit(<span class="built_in">i</span>, <span class="number">2</span>) - limit(<span class="built_in">i</span>, <span class="number">1</span>)) * <span class="built_in">rand</span>(N, d);<span class="comment">%初始种群的位置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">v = <span class="built_in">rand</span>(N, d);                  <span class="comment">% 初始种群的速度</span></span><br><span class="line">xm = x;                          <span class="comment">% 每个个体的历史最佳位置</span></span><br><span class="line">ym = <span class="built_in">zeros</span>(<span class="number">1</span>, d);                <span class="comment">% 种群的历史最佳位置</span></span><br><span class="line">fxm = <span class="built_in">zeros</span>(N, <span class="number">1</span>);               <span class="comment">% 每个个体的历史最佳适应度</span></span><br><span class="line">fym = -<span class="built_in">inf</span>;                      <span class="comment">% 种群历史最佳适应度</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(xm, f(xm), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;初始状态图&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">%% 群体更新</span></span><br><span class="line">iter = <span class="number">1</span>;</span><br><span class="line">record = <span class="built_in">zeros</span>(ger, <span class="number">1</span>);          <span class="comment">% 记录器</span></span><br><span class="line"><span class="keyword">while</span> iter &lt;= ger</span><br><span class="line">     fx = f(x) ; <span class="comment">% 个体当前适应度   </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N      </span><br><span class="line">        <span class="keyword">if</span> fxm(<span class="built_in">i</span>) &lt; fx(<span class="built_in">i</span>)</span><br><span class="line">            fxm(<span class="built_in">i</span>) = fx(<span class="built_in">i</span>);     <span class="comment">% 更新个体历史最佳适应度</span></span><br><span class="line">            xm(<span class="built_in">i</span>,:) = x(<span class="built_in">i</span>,:);   <span class="comment">% 更新个体历史最佳位置</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> fym &lt; <span class="built_in">max</span>(fxm)</span><br><span class="line">        [fym, nmax] = <span class="built_in">max</span>(fxm);   <span class="comment">% 更新群体历史最佳适应度</span></span><br><span class="line">        ym = xm(nmax, :);      <span class="comment">% 更新群体历史最佳位置</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    v = v * w + c1 * <span class="built_in">rand</span> * (xm - x) + c2 * <span class="built_in">rand</span> * (<span class="built_in">repmat</span>(ym, N, <span class="number">1</span>) - x);<span class="comment">% 速度更新</span></span><br><span class="line">    <span class="comment">% 边界速度处理</span></span><br><span class="line">    v(v &gt; vlimit(<span class="number">2</span>)) = vlimit(<span class="number">2</span>);</span><br><span class="line">    v(v &lt; vlimit(<span class="number">1</span>)) = vlimit(<span class="number">1</span>);</span><br><span class="line">    x = x + v;<span class="comment">% 位置更新</span></span><br><span class="line">    <span class="comment">% 边界位置处理</span></span><br><span class="line">    x(x &gt; limit(<span class="number">2</span>)) = limit(<span class="number">2</span>);</span><br><span class="line">    x(x &lt; limit(<span class="number">1</span>)) = limit(<span class="number">1</span>);</span><br><span class="line">    record(iter) = fym;<span class="comment">%最大值记录</span></span><br><span class="line">     x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;状态位置变化&#x27;</span>)</span><br><span class="line">     pause(<span class="number">0.1</span>)</span><br><span class="line">    iter = iter+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);<span class="built_in">plot</span>(record);title(<span class="string">&#x27;收敛过程&#x27;</span>)</span><br><span class="line">x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);<span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;最终状态位置&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最大值：&#x27;</span>,num2str(fym)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;变量取值：&#x27;</span>,num2str(ym)]);</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;启发式算法其实是一种试探法，相对于梯度下降法等类似方法而言，它更体现了随机性；相对于盲目搜索算法而言，它又具有一定的方向性。</p><p><strong>5个基本要素</strong></p><ul><li>随机初始化可行解</li><li>评价函数或目标函数的确定</li><li>新解的产生机制</li><li>新解的接受机制</li><li>终止准则</li></ul><p><strong>本质</strong></p><p>&emsp;&emsp;试探法的本质是并行、随机、有一定方向的搜索方法。综合试探法的要素和本质可以看出，试探法中新解的产生机制和接受机制对于算法的全局收敛能力十分重要，有助于克服局部最优问题。</p><blockquote><p>并行性的体现：</p><ul><li>遗传算法中每代种群具备一定数量</li><li>蚁群算法中蚂蚁的数量</li><li>模拟退火算法中内循环的体现（要求降温过程足够缓慢）</li><li>粒子群算法中粒子的数量</li></ul><p>随机性的体现：</p><ul><li>遗传算法中新解的产生机制（交叉和变异）</li><li>蚁群算法中新解的产生机制（释放信息素）</li><li>模拟退火算法中新解的产生机制</li><li>粒子群算法中新解的产生机制（自身经验和他人信息前面的随机系数r1和r2）</li></ul><p>方向性的体现（逐渐向最优解逼近）：</p><ul><li>遗传算法中新解的接受机制（精英保留策略、轮盘赌）</li><li>蚁群算法中新解的接受机制（新解的产生来自于所有蚂蚁留下信息素的引导）</li><li>模拟退火算法中新解的接受机制（Metropolis准则：绝对接受更优解，以一定概率接受较差的解，且随着温度的降低，接受较差解的概率降低，即开始降温过程搜索空间大，增强全局收敛能力，接近稳定状态，更不易接受较差解，使局部搜索更为精确）</li><li>粒子群算法中新解的产生机制（新解的产生来自于粒子本身最优解和所有粒子最优解的引导）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 优化问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G网络切片资源分配文献综述</title>
      <link href="/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/"/>
      <url>/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;随着网络需求的快速持续增长，5G网络需要为传统网络运营商、垂直行业、OTT、第三方满足不同服务质量 (QoS)、服务水平协议 (SLA) 和关键绩效指标 (KPI)的要求，在这种情况下，第四代 (4G) 电信网络的“一刀切”和“一网通”类型不再适用。</p><p>&emsp;&emsp;网络切片是一种很有前途的技术，它可以建立包含专用和共享资源的定制端到端逻辑网络，通过利用 SDN 和 NFV，可以定制与资源相关的网络切片，以满足不同的 QoS 和 SLA。网络切片的资源分配在负载均衡、资源利用率和网络性能方面起着举足轻重的作用。</p><p><strong>主要内容</strong></p><ul><li>SDN 和 NFV 的原理及其对网络切片的影响</li><li>网络切片的基本管理和编排（MO）架构</li><li>RAN和CN切片中的资源类型和相应的隔离级别</li><li>5G 网络切片资源分配算法的原理和数学模型</li><li>提出网络切片的几个开放问题以及潜在的解决方案</li></ul><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Resource%20Allocation%20for%20Network%20Slicing%20in%205G%20Telecommunication%20Networks%20A%20Survey%20of%20Principles%20and%20Models.pdf">Resource Allocation for Network Slicing in 5G Telecommunication Networks A Survey of Principles and Models</a></p><span id="more"></span><p>&nbsp;</p><h2 id="网络切片"><a href="#网络切片" class="headerlink" title="网络切片"></a>网络切片</h2><p>&emsp;&emsp;作为 5G 中很有前途的技术之一，网络切片在电信网络基础设施上创建了端到端（即从无线电接入网络 (RAN) 到核心网络 (CN)）逻辑上独立的网络。每个逻辑上独立的网络称为网络切片，是为特定需求而设计的，由从底层通信和网络资源中抽象出来的若干网络功能和资源组成。网络切片的基本思想与云计算中的基础设施（即服务 IaaS） 的基本思想密切相关。 IaaS 在不同租户之间共享计算、存储和网络资源，并提供由软件定义网络 (SDN) 和网络功能虚拟化 (NFV) 支持的全功能虚拟网络。事实上，SDN和NFV被认为是5G背景下网络切片的关键技术。 SDN依靠控制平面和数据平面的分离来增强数据转发效率和网络可编程性，NFV 使虚拟网络功能 (VNF) 能够在通用硬件上运行以降低部署成本。网络切片作为多个 VNF 的组合，不仅可以提供灵活、可扩展和可编程的网络服务，还可以通过高效编排和管理 VNF 来降低资本支出 (CAPEX) 和运营支出 (OPEX)</p><p>&emsp;&emsp;作为5G电信网络的一个主要问题，网络切片的资源分配面临隔离、定制、弹性、端到端协调等诸多挑战。具体而言，在资源隔离方面，由于通信环境的变化，网络切片的共享和隔离资源并不简单。例如，无线电资源的严格隔离可能导致低复用增益。定制化实现网络切片的高效资源利用，满足特定的网络服务需求。如何将网络服务需求有效地转化为所需的网络资源，需要在不同层面进行更多的考虑，包括控制层面、数据平面层面、网络层面。例如，在时变数据流量下无法直接获得具有相应计算、存储和网络资源的虚拟机（VM）的确切数量。共享资源的动态分配可能会影响网络切片的网络性能。端到端资源分配必须跨越不同的域，例如 CN、RAN 和传输网络 (TN)。在不同网络层的异构技术之间实现新的协调并不容易。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="SDN-amp-NFV"><a href="#SDN-amp-NFV" class="headerlink" title="SDN &amp; NFV"></a>SDN &amp; NFV</h2><h4 id="software-defined-networking"><a href="#software-defined-networking" class="headerlink" title="software defined networking"></a>software defined networking</h4><p>&emsp;&emsp;在SDN的框架中，控制平面与数据平面完全分离，数据平面移动到一个由SDN控制器（Controller）实现的集中位置。 SDN控制器根据手头应用的需求，在链路探索、拓扑管理、策略部署、流表下发等方面生成不同的规则并发送给数据平面。数据平面中的转发设备，例如交换机和路由器，只需应用并执行这些规则。</p><h4 id="Network-Function-Virtualization"><a href="#Network-Function-Virtualization" class="headerlink" title="Network Function Virtualization"></a>Network Function Virtualization</h4><p>&emsp;&emsp;与传统电信设备中网络功能和专有硬件之间的紧密耦合不同，NFV 使网络功能能够以软件设备的形式在通用服务器上运行。为了在电信网络中高效灵活地利用虚拟资源和管理 VNF，欧洲电信标准协会 (ETSI) 提出了 NFV 管理和编排器 NFV-MANO，它由 NFV 编排 (NFVO)、VNF管理器 (VNFM) 和虚拟化基础设施管理器 (VIM)组成。 NFV-MANO 通过 VNFM 和 VIM 管理 VNF 的生命周期。 NFVO 负责编排与外部运营/业务支持系统 (BSS/OSS) 相结合的网络服务。</p><p>&emsp;&emsp;由于其可编程性、可扩展性和灵活性，SDN 和 NFV 被认为是网络切片的关键推动因素。例如，受SDN启发，演进分组核心（EPC）实现了控制面和用户面的分离，从而实现了网络功能的灵活部署。此外，因为 NFV-MANO 管理 VM 或容器对网络功能的创建、更新和终止，网络切片可以以低成本进行初始化和修改。 NFVO 可以在不同的网络环境中调整 VNF 与 VNFM 和 VIM 的资源分配，例如数据流量的波动、网络切片中用户的变化等。此外，当某些 VNF 发生故障时，SDN 数据平面中的路由器和交换机可以根据 SDN 控制器配置的流表或调度策略重新路由数据流量。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="MO架构"><a href="#MO架构" class="headerlink" title="MO架构"></a>MO架构</h2><p>&emsp;&emsp;Management and Orchestration Architecture of Network Slicing</p><p>&emsp;&emsp;网络切片的基本问题包括网络切片需求的描述和网络切片的部署及其生命周期管理。为了解决这些问题，第三代合作伙伴计划 (3GPP) 提出了具有相应网络功能的基本 MO 架构，包括通信服务管理功能 (CSMF)、网络切片管理功能 (NSMF) 和网络切片子网管理功能 (NSSMF) ，每个子网都有一个 NSSMF，例如：RAN、CN。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226105342.png" alt="image-20211226105335500" style="zoom: 50%;" /><p>&emsp;&emsp;在这种架构下，特定网络服务的需求由CMSF转换为网络切片的需求（即网络切片需求描述），传递给NSMF。然后，NSMF 将网络切片的需求分解为不同子网的需求。不同子网中的 NSSMF 管理和编排相应子网中的网络切片。例如，CN 中的 NSSMF 可以根据从 NSMF 接收到的网络服务的需求，求解出计算、存储和网络资源（即 VM 的资源）相关联的 VNF 的数量。然后，基本的 VNF 由 NFV-MANO 初始化，如图左侧所示。资源分配依赖于带有NFV-MANO的NSSMF，可以根据网络服务的需求计算所需的资源。此外，带有 NFV-MANO 的 NSSMF 可以通过升级或扩展网络功能来动态调整资源分配，这些功能由流量波动或网络切片需求的变化触发。在网络切片的 MO 架构下，隔离级别和数学模型在资源分配中扮演着重要的角色。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Resouce-Type-and-Isolation"><a href="#Resouce-Type-and-Isolation" class="headerlink" title="Resouce Type and Isolation"></a>Resouce Type and Isolation</h2><h4 id="RAN-Slicing"><a href="#RAN-Slicing" class="headerlink" title="RAN Slicing"></a>RAN Slicing</h4><p>&emsp;&emsp;频谱是 RAN 切片的基本无线资源，在长期演进 (4G LTE) 系统中，频谱资源被提取为资源块 (RB) 或物理资源块 (PRB)。具有专用 PRB 的网络切片严格确保所需的 QoS/SLA，而公共媒体访问控制 (MAC) 调度程序可以分配和管理共享 PRB 以适应弹性流量、变化的信道条件和 QoS 要求，从而增强资源弹性和复用增益。除了频谱资源以外，其他基本物理资源还有：包括传输功率和基站（BS）的缓存空间等。</p><p>&emsp;&emsp;基于 PRB 隔离，数据包调度作为一种高级隔离，负责决定使用空闲 PRB 处理数据流量的时间。最高级别的资源隔离是<strong>准入控制</strong>，它通过估计网络资源使用状态来确定是否在用户和 CN（即无线接入承载）之间建立数据传送服务。更一般地，准入控制还包括确定是否允许用户访问网络或是否接受网络切片请求。此外，<strong>用户关联</strong>是RAN切片中资源分配的重要步骤，它决定了用户是否与特定的BS相关联。用户关联发生在数据传输之前和用户准入控制之后。很难为用户关联确定不同的隔离级别，但值得注意的是它在负载平衡、无线电频谱效率和网络效率方面起着关键作用。</p><p>&emsp;&emsp;与传统的RAN架构相比，Cloud-RAN（C-RAN）将基带过程和远程无线接入分离。集中式基带单元 (BBU) 池、分布式多个远程射频头 (RRH)、通过光链路连接 BBU 池和 RRH 的前传网络以及将 BBU 池连接到 CN 的回程网络是 C-RAN的四个基本部分。 BBU池用于基带处理，建立在具有虚拟化技术的高性能通用硬件上，可以运行在虚拟机或容器上，以提高物理资源（如计算、存储、网络资源）的利用率。由于部署成本低，分布式 RRH 通过天线为用户提供无线接入，以低 CAPEX 和 OPEX 覆盖大面积区域。在设计资源分配算法时，BBU 池和具有前传带宽的 RRH 的容量是重要因素。此外，用户关联和回程容量也会影响资源分配。下图左侧总结了与 RAN 切片的资源类型相关的隔离级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226123601.png" alt="image-20211226123601454" style="zoom:67%;" /><h4 id="CN-Slicing"><a href="#CN-Slicing" class="headerlink" title="CN Slicing"></a>CN Slicing</h4><p>&emsp;&emsp;与4G中的EPC相比，5G核心网采用更加模块化的架构，将网络划分为更细粒度的网络功能。每个网络功能都可以以VM或容器的方式部署在虚拟平台上，由SDN和NFV进行管理和编排，提供灵活、可扩展、可编程的网络服务。CN 切片中的高级资源隔离可以是 VM 或容器，这意味着网络运营商利用 VM 或容器粒度的扩展/扩展操作来初始化或调整资源分配。</p><p>&emsp;&emsp;在NFV-MANO的框架下，一个CN切片由多个VNF组成，形成一个运行在底层网络上的虚拟网络。在这种情况下，CN 切片的资源分配被转换为虚拟网络嵌入 (VNE) 问题。VNE 提出了两个问题：将虚拟节点映射到物理节点，将连接虚拟节点的虚拟链路映射到连接物理节点的路径。物理节点和路径代表计算、存储和网络资源。在我们看来，VNE 可用于对 CN 切片以及 C-RAN 切片的某些部分（例如，BBU 容量的虚拟化）中的资源分配问题进行建模。 </p><p>CN 切片中的隔离级别和资源类型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135025.png" alt="CN 切片中的隔离级别和资源类型" style="zoom: 67%;" /><p>无线资源管理、VNE和网络切片的资源分配之间的关系：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135101.png" alt="image-20211226135101482" style="zoom:50%;" /><p>&nbsp;</p><h2 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h2><h4 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h4><p>&emsp;&emsp;很自然地将网络切片的资源分配问题表述为线性规划 (LP) 问题或非线性规划 (NLP) 问题，优化目标包括网络切片的吞吐量、资源利用率、下一次分配的剩余物理资源等。一般的约束是基站的传输功率、基于服务合同的每个网络切片的最小PRB数量、不同网络切片之间的分配公平性等，这些可能会因网络环境的变化和网络切片的多样化需求而变得复杂。因此，一些一般的优化问题很难在<strong>多项式时间</strong>内解决。采用结合多个隔离级别的<strong>启发式方法</strong>来推导出具有低计算复杂性的近乎最优的解决方案。</p><h5 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h5><blockquote><p>Dynamic Network Slicing for Multitenant Heterogeneous Cloud Radio Access Networks</p><p>“ This paper proposes a dynamic network slicing scheme for multitenant H-CRANs, which takes into account tenants’ priority, baseband resources, fronthaul and backhaul capacities, quality of service (QoS) and interference. The framework of the network slicing scheme consists of an upper-level, which manages admission control, user association and baseband resource allocation; and a lower-level, which performs radio resource allocation among users. ”</p></blockquote><p>如前所述，C-RAN 通过 BBU 池集中基带处理能力，BBU 池通过前传网络连接到多个 RRH，并通过回程网络连接到 CN。因此，BBU 池和前传/回传网络的容量作为新的约束，被用于 C-RAN 切片的一般优化问题的框架中。此文中的作者提出了一种分层资源分配方案，以最大化 C-RAN中所有网络切片的网络吞吐量。分层方案包括准入控制、用户关联、虚拟BBU容量分配作为上层分配，以及相应网络切片中每个用户的PRB和传输功率分配作为下层分配。当上层分配的最佳结果用于下层分配时，计算负担和大的信令开销会显着减轻。</p><p>&nbsp;</p><h5 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h5><blockquote><p>A Service-Oriented Deployment Policy of End-to-End  Network  Slicing  Based  on  Complex  Network  Theory</p><p>“  In this paper, a mathematical model is used to construct network slice requests and map them to the infrastructure network. The mapping process consists of two steps: the placement of virtual network functions and the selection of link paths chaining them. To efficiently utilize the limited physical resources, we pay attention to the service-oriented deployment by offering different deployment policies for three typical slices: eMBB slices, mMTC slices, and uRLLC slices. Furthermore, we adopt complex network theory to obtain the topological information of slices and infrastructure network. With the topological information, we define a node importance metric to rank the nodes in node mapping. To evaluate the performance of deployment policy we proposed, extensive simulations have been conducted.  ”</p></blockquote><p>此文中利用通用数学模型探索了端到端网络切片的资源分配。 RAN、传输网络(TN) 和CN 中的资源被抽象为计算和带宽资源。然后，将资源分配问题转化为VNE问题，根据不同的网络切片类型有不同的目标。例如，优化目标是最小化超可靠和低延迟通信 (uRLLC) 网络切片的数据包延迟。在为海量机器类型通信（mMTC）网络切片分配资源时，应最大化当前网络切片部署后剩余的物理链路数量。</p><p>&nbsp;</p><h4 id="博弈论经济模型"><a href="#博弈论经济模型" class="headerlink" title="博弈论经济模型"></a>博弈论经济模型</h4><blockquote><p>价格差异化是一种基于经济和博弈模型的简单方法，它根据不同的网络切片的特点，如流量模型、资源容量、所需资源数量、网络切片优先级等，为不同的网络切片分配不同的价格。一个典型的优化目标是基础设施提供商的收入。</p></blockquote><p>&emsp;&emsp;网络切片为传统网络运营商、垂直行业和第三方提供了新的商业机会。在5G网络切片的场景中，典型的参与者有3个：网络运营商、网络切片的租户、网络切片的用户。网络运营商（例如基础设施提供商）提供包括物理资源和虚拟资源在内的网络基础设施，并建立网络切片以满足网络服务的要求;网络切片的租户（即网络服务提供商）向网络运营商提出网络服务需求，并为用户提供网络服务;用户（例如，用户设备UE）使用网络切片提供的网络服务。与上面讨论的一般模型相比，经济模型和博弈模型提供了复杂而有效的方法来描述这三个参与者之间的关系，可以制定优化问题，例如网络资源分配的公平性、网络的利润最大化。网络切片的运营商或租户，以及网络切片用户的成本最小化。例如，预算、成本、收入、利润和价格等经济因素对这些玩家在游戏过程中的资源分配有显着影响。经济和博弈模型可以在不牺牲资源分配公平性的前提下，为基础设施提供商的收入或利润最大化提供可行的解决方案。</p><h5 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h5><blockquote><p>Optimising 5G infrastructure markets: The business of network slicing</p><p>“ In this paper, we address this issue by designing an algorithm for the admission and allocation of network slices requests that (i) maximises the infrastructure provider’s revenue and (ii) ensures that the service guarantees provided to tenants are satisfied. Our key contributions include: (i) an analytical model for the admissibility region of a network slicing-capable 5G Network, (ii) the analysis of the system (modelled as a Semi-Markov Decision Process) and the optimisation of the infrastructure provider’s revenue, and (iii) the design of an adaptive algorithm <strong>(based on Q-learning)</strong> that achieves close to optimal performance. ”</p></blockquote><p>网络切片根据其流量模型定价不同，包括<strong>弹性</strong>和<strong>非弹性</strong>数据流量模型 。本文进一步推导出弹性网络切片和非弹性网络切片数量之间的关系，该关系在最大接纳非弹性网络切片数量和非弹性网络切片和弹性网络切片的固定总和的限制下。基于关系和价格差异，提出了一种结合半马尔可夫决策过程（SMDP）的价值迭代算法来搜索网络切片请求的最佳准入控制，以最大化基础设施提供商的收入。</p><p>&nbsp;</p><h5 id="example-4"><a href="#example-4" class="headerlink" title="example 4"></a>example 4</h5><blockquote><p>Network Slicing Games: Enabling Customization in Multi-Tenant Mobile Networks</p><p>“ This paper provides an analysis of a well-known model for resource sharing, the share-constrained proportional allocation mechanism, to realize network slicing. This mechanism enables tenants to reap the performance benefits of sharing, while retaining the ability to customize their own users’ allocation. This results in a network slicing game in which each tenant reacts to the user allocations of the other tenants so as to maximize its own utility. We show that, for elastic traffic, the game associated with such strategic behavior converges to a Nash equilibrium. At the Nash equilibrium, a tenant always achieves the same or better performance than that of a static partitioning of resources, thus providing the same level of protection as static partitioning. We further analyze the efficiency and fairness of the resulting allocations, providing tight bounds for the price of anarchy and envy-freeness. Our analysis and extensive simulation results confirm that the mechanism provides a comprehensive practical solution to realize network slicing. Our theoretical results also fills a gap in the analysis of this resource allocation model under strategic players. ”</p></blockquote><p>费雪（Fisher）市场作为一种著名的经济模型，被用来研究用户和网络切片之间的公平性。 Fisher 市场中预算固定的购买者映射成共享网络资源的网络切片租户、买家的出价被映射成网络切片租户的偏好。在 5G 网络切片场景中，网络切片的租户可以根据资源拥塞情况动态调整其偏好，以最大化自身效用。在这种情况下，资源分配问题转化为如何通过<strong>非合作博弈</strong>共同考虑网络切片的偏好和用户公平性来为网络切片分配资源。</p><p>&nbsp;</p><h5 id="example-5"><a href="#example-5" class="headerlink" title="example 5"></a>example 5</h5><blockquote><p>Coalitional Game for the Creation of Efficient Virtual Core Network Slices in 5G Mobile Systems</p><p>“ Our contribution in this paper is twofold. First, we devise an algorithm that derives the optimal number of virtual instances of 4G (MME, SGW, and PGW) or 5G (AMF, SMF, and AUSF) core network elements to meet the requirements of a specific mobile traffic. Second, we propose an algorithm for the placement of these virtual instances over a federated cloud. While the first algorithm is based on mixed integer linear programming, the second is based on coalition formation game, wherein the aim is to build coalitions of cloud networks to host the virtual instances of the vEPC/5G core elements. ”</p></blockquote><p>与预测和分析非合作博弈中每个玩家的行为不同，<strong>合作博弈</strong>调查由单个玩家或外部强制（例如合同规则）形成的玩家之间的联盟。联盟的组成、联盟产生时的联合行动、联盟已经形成时的集体收益是合作博弈的研究兴趣。以CN切片为例。 VNF放置问题在合作博弈的框架下通过两步解决。首先，在同一个云网络中，制定了一个优化问题，旨在通过调整 VNF 的数量来最小化 VNF 的创建成本。然后讨论如何将这些 VNF 放置在不同的云网络中，以保证 QoS/SLA 并最大化每个云网络的利润。事实上，部署了 VNF 的不同云网络可以形成不同的联盟。</p><p>&nbsp;</p><h4 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h4><p>&emsp;&emsp;预测模型用于根据经验知识或历史信息预测适当或最佳的资源数量。预测对象包括:用户到达率、网络切片中的数据流量、网络切片请求等。简单的预测方法直接使用经验数据或一些众所周知的概率模型。</p><h5 id="example-6"><a href="#example-6" class="headerlink" title="example 6"></a>example 6</h5><blockquote><p>Conformal Mapping  for  Optimal  Network  Slice  Planning  Based  on  Canonical   Domains</p><p>“ This paper addresses this issue by mapping the non-uniform distribution of signaling messages in the physical domain to a new uniform environment (i.e., canonical domain) whereby the placement of core functions is more feasible and efficient by means of Schwartz-Christoffel conformal mappings. The experimentation results, compared to some baseline approaches, have proven the efficiency of the conformal mapping based placement in allocating the virtual resources (i.e., virtual CPU and virtual storage) with regard to the optimal end-to-end delay, cost and activated virtual machines. Another interesting contribution is that all placement decisions are based on a realistic spatio-temporal user-centric model, which defines both the mobility of user equipments and the underlying service usage. “</p></blockquote><p>与使用合作博弈的 VNF 放置不同，VNF 的位置由会话请求到达率的<strong>概率分布</strong>决定。假设会话请求的到达率在物理域中遵循非均匀分布，通过 Schwarz-Christoffel 映射将其转换为规范域中的均匀分布。然后根据会话请求的数量和会话请求的到达率，很容易推导出规范域中 VNF 的最佳数量和位置。而VNFs在物理域中的对应位置可以通过逆空间变换函数得到。</p><p>&nbsp;</p><h5 id="example-7"><a href="#example-7" class="headerlink" title="example 7"></a>example 7</h5><blockquote><p>Mobile Traffic Forecasting for Maximizing 5G Network Slicing Resource Utilization</p><p>“ This paper focuses on the design of three key network slicing building blocks responsible for (i) traffic analysis and prediction per network slice, (ii) admission control decisions for network slice requests, and (iii) adaptive correction of the forecasted load based on measured deviations. Our results show very substantial potential gains in terms of system utilization as well as a trade-off between conservative forecasting configurations versus more aggressive ones (higher gains, SLA risk). ”</p></blockquote><p>基于时间序列的预测模型作为回归预测，根据过去的观察以及<strong>时间序列预测</strong>网络切片中的统计特征。与经验知识相比，基于时间序列的预测模型更实用，适用于不同的网络环境。 Holt-Winters (HW) 模型优于基本模型和双指数平滑模型，作为一种复杂的时间序列模型，不仅可以捕捉数据趋势，还可以捕捉数据季节性。在本文中，当用户数量固定时，HW模型用于分析网络切片中未来的流量请求。此外，当用户在多蜂窝环境中移动时，网络切片的流量模型也由 HW 模型预测。值得注意的是，每个被接纳的网络切片都设计了反馈机制，以提高硬件模型的预测精度。</p><p>&nbsp;</p><h5 id="example-8"><a href="#example-8" class="headerlink" title="example 8"></a>example 8</h5><blockquote><p>Information Prediction and Dynamic Programming Based RAN Slicing for Mobile Edge Computing</p><p>“ In this letter, the work is focused on the RAN slicing between MEC services and traditional services. An information prediction and dynamic programming based RAN slicing algorithm is proposed. It guarantees the inter-slice isolation and realizes the intra-slice customization. Furthermore, it can optimize the network utility with high fairness in polynomial time complexity. ”</p></blockquote><p>机器学习根据历史数据和决策生成最优或次优策略，适用于没有统一概率分布的场景。例如，支持向量回归（SVR）作为机器学习中的典型分类算法，用于预测时分双工(FDD)-OFDMA无线网络中网络切片的统计特征值。更具体地说，本文中的作者针对不同的上行/下行配置实现了移动边缘计算（MEC）和传统网络服务的RAN切片的资源分配。该配置被表述为具有网络切片统计特征的封闭式表达式，包括能量开销、运行时开销以及上下行链路的流量和数据速率。MEC 和传统网络服务的最佳配置是从封闭形式的表达式中导出的，其中包含 SVG 预测的统计特征值。</p><p>&nbsp;</p><h4 id="鲁棒性和故障恢复模型"><a href="#鲁棒性和故障恢复模型" class="headerlink" title="鲁棒性和故障恢复模型"></a>鲁棒性和故障恢复模型</h4><p>&emsp;&emsp;网络切片的资源分配算法不仅要提高资源利用效率，还要处理不可预测的网络事件，以实现电信网络的高可用性。不可预知的网络事件包括网络拥塞（由大量数据流量引起）或网络功能故障（由软件或硬件意外故障引起）。冗余资源预留和网络功能重新映射是两种有效的方法。</p><h5 id="example-9"><a href="#example-9" class="headerlink" title="example 9"></a>example 9</h5><blockquote><p>Optimisation  Models  for  Robust  and Survivable Network Slice Design: A Comparative Analysis</p><p>“ In this work, we first outline a mathematical model for the general network slice design problem and extend it to cope with traffic uncertainties. We employ the Γ-robust uncertainty set [1], [2] to model the uncertainties in the traffic demands. Furthermore, we add survivability aspects to our model by protecting the network slice against single substrate network element (node/link) failures. Finally, both survivability and traffic robustness approaches are considered simultaneously and we present two different optimisation models. A performance evaluation is carried out comparing the different robust and survivable models with their non-robust non-survivable counterpart using network topology examples from SNDlib. ”</p></blockquote><p>冗余资源预留为网络切片提供额外资源，例如多个 VNF 实例，以避免网络功能故障。网络切片的不确定流量由机会约束模型 [14] 表示为对称和随机变量。该变量作为保护级别，分别加入到虚拟节点和虚拟链路的容量约束中，以保证网络切片的鲁棒性。网络功能的重新映射通过将失败的 VNF 映射到好的 VNF 并重新路由失败的虚拟链接来恢复网络服务。</p><p>&nbsp;</p><h5 id="example-10"><a href="#example-10" class="headerlink" title="example 10"></a>example 10</h5><blockquote><p>Protocol Function Block Mapping of Software Defined Protocol for 5G Mobile Networks</p><p>“ In this paper, we propose software-defined protocol (SDP) technique to facilitate flexible service-oriented protocol stack deployment for providing high-throughput, low-latency and elastic mobile services based on platform virtualization and functionality modularization. We first elaborate the principle of SDP and then address one of the most important issues in SDP, namely SDP request mapping (SDPM), where an SDP request is fulfilled by mapping a set of required SDP function blocks and virtual links onto underlying SDP servers. We formulate the SDPM problem as a mixed integer programming (MIP). To address the NP-hardness and scalability of SDPM problem, we propose a decomposition algorithm which breaks down the SDPM problem into inter-block link and block mapping problems to accomplish the upper bound (UB) and lower bound (LB) of the MIP solution, respectively. The optimality can be achieved when the UB and the LB converges by using iterations. We employ LTE Layer-2 data-plane processing as a benchmark for validating the effectiveness of the SDP technique and evaluate the performance of SDPM algorithm. Numerical results show that SDP is effective to provide elastic low-latency mobile services and the proposed SDPM algorithm significantly outperforms the benchmark in stack processing delay, mapping cost, and resource utilization. “</p></blockquote><p>优化目标是在重新映射期间最小化总带宽消耗。</p><p>&nbsp;</p><h3 id="4种模型对比"><a href="#4种模型对比" class="headerlink" title="4种模型对比"></a>4种模型对比</h3><p>图中说明了四种数学模型之间的关系，每个饼图中每种方法的比例代表了相应的研究潜力：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161345.png" alt="image-20211226161345382" style="zoom: 33%;" /><p>表中根据目标、资源类型、场景和关键描述总结了所讨论的算法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161507.png" alt="image-20211226161507843" style="zoom:50%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="网络切片潜力研究方向"><a href="#网络切片潜力研究方向" class="headerlink" title="网络切片潜力研究方向"></a>网络切片潜力研究方向</h3><h4 id="资源分配的更新周期"><a href="#资源分配的更新周期" class="headerlink" title="资源分配的更新周期"></a>资源分配的更新周期</h4><p>&emsp;&emsp;为了尽可能降低资源分配算法的计算复杂度，前面提出了启发式方法以提供具有低计算复杂度的次优解决方案。而<strong>多级资源分配</strong>则是另一种方式，包括准入控制、用户关联等。然而，很少有研究报告或出版物讨论资源分配算法的更新周期。合适的更新间隔不仅可以提高资源利用率，还可以减少信令开销和计算负担。在example1中，作者指出分配PRB的周期不能短于信道条件报告的周期。较长的更新周期在慢变通道中是可行的解决方案，但在快变通道中可能无法实现高性能。此外，在设计资源分配更新周期时，可以综合考虑用户数量的变化、数据流量的波动以及网络功能故障的平均周期。</p><p>&nbsp;</p><h4 id="无线电接入技术-RATs-的异质性"><a href="#无线电接入技术-RATs-的异质性" class="headerlink" title="无线电接入技术 (RATs) 的异质性"></a>无线电接入技术 (RATs) 的异质性</h4><p>&emsp;&emsp;5G 预计将跨越和聚合多种异构 RAT，例如 3G、4G、LTE 和 WiFi。 5G网络切片中不同RAT的协作变得尤为重要，应满足网络切片的多样化需求。例如，车联网 (V2X) 网络切片中的车载信息娱乐应用依赖 LTE 和 WiFi 来提高网络吞吐量。在 mMTC 网络切片上运行的窄带物联网 (NB-IoT) 应用可能需要多种 RAT 来增强网络连接。当前的算法侧重于密集的异构无线网络，并研究宏蜂窝和小蜂窝之间的合作，对于不同的网络切片，可以在无缝切换、流量隔离和网络切片公平性等方面进一步研究多制式的资源分配，以增强用户体验，提高资源利用率。</p><p>&nbsp;</p><h4 id="端到端网络切片的资源分配"><a href="#端到端网络切片的资源分配" class="headerlink" title="端到端网络切片的资源分配"></a>端到端网络切片的资源分配</h4><p>&emsp;&emsp;大多数当前的资源分配算法都集中在单个子网，例如 RAN 或 CN。除了example2中的解决方案，很少有研究人员考虑端到端的网络切片。无线电和虚拟机的资源分别抽象为带宽和计算资源，在为特定的网络切片类型设计资源分配方案时只考虑其中之一。事实上，SLA 分解和多子网协调是端到端网络切片资源分配的主要挑战。由于缺乏基本的通信知识，网络切片的租户可能只向 NSMF 提供端到端的 SLA，而不需要每个子网。因此，如何将端到端的 SLA 分解为各个子网的需求是资源分配的必然步骤。SLA分解不仅要考虑端到端的容量，还要考虑每个子网的容量。多个子网之间的协调也很重要，尤其是在更新资源分配时。每个子网应定期通过 NSSMF 向 NSMF 报告其剩余容量，NSMF 可以实现资源分配的适当调整，以适应不断变化的网络环境。例如，如果某些子网过载，则应向 NSMF 报告，然后允许剩余的子网获得更多资源以保证所需的端到端 SLA。潜在的数学模型应该基于多运营商核心网（MOCN）和网关核心网（GWCN）精心设计，这是不同子网之间资源共享的两种基本架构。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每月歌单</title>
      <link href="/2021/12/09/test/"/>
      <url>/2021/12/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分享每月歌单</p><span id="more"></span><h5 id="2021-12"><a href="#2021-12" class="headerlink" title="2021-12"></a>2021-12</h5><p># 歌曲模板</p>    <div id="aplayer-odznFgkL" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p># 歌单模板</p>    <div id="aplayer-IVgPTxIR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于令牌桶算法的LTE下行链路调度器</title>
      <link href="/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/"/>
      <url>/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;LTE网络支持共享无线接入和核心网络资源的不同类型的服务，包括：尽力而为、延迟敏感和实时（RT）服务。每种服务在比特率、延迟和分组丢失方面都有不同的QoS要求。</p><p>&emsp;&emsp;基站eNB的第一个目标是为UE提供高频谱效率，使更多的活跃用户可以在网络中接收服务。第二个目标是用户对接收的服务质量（QoS）的满意度。为了实现这些目标，eNB中的资源分配必须知道信道条件、UE请求的服务类型和其他参数。</p><p>&emsp;&emsp;eNB将一个小区中的可用无线电资源分配给活动用户（Active UE）。因此需要设计合适的调度算法来支持具有不同QoS要求的业务，尤其是RT业务。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/A%20QoS%20aware%20Downlink%20Packet%20Scheduler%20Using%20Token%20Bucket%20Algorithm%20for%20LTE%20Systems.pdf">A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems</a></p><span id="more"></span><p>&nbsp;</p><h3 id="现有调度算法研究"><a href="#现有调度算法研究" class="headerlink" title="现有调度算法研究"></a>现有调度算法研究</h3><ol><li><p>LTE下行链路中指数/比例公平（EXP/PF）和改进的最大加权延迟优先（M-LDWF）</p><p>都只在一个域中执行调度过程</p><p>带宽为5MHz的系统中，M-LDWF比EXP/PF提供了更多的吞吐量，但是EXP/PF满足了更多用户的QoS要求（RT用户所需的带宽因素所导致）</p><p>建议在低负载网络中使用M-LDWF，在网络负载增加时使用EXP/PF[2]</p></li><li><p>利用CQI反馈发送来自用户的空闲缓冲区值的报告以及实时和非实时服务的QoS需求，比PF具有更高的吞吐量，并且降低了丢包概率。[3]</p></li><li><p>VOIP流量调度的一些算法满足了该服务的QoS要求，并防止了由于优先考虑网络中的VOIP服务引起的不良影响。它通过分组丢弃来调整给予VOIP的优先级的持续时间。[4]</p></li><li><p>有的算法使用了时域和频域两级调度器，在用户之间保证了公平性，时域（TD）调度器提供用户所需的QoS参数，而频域（FD）调度器根据TD调度器给定的输入实现最高的频谱效率。[8]</p><p>该论文的另一个结论是，TD-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></li><li><p>另一个算法也是时域和频域两级调度器，在时域中使用PF算法来实现用户之间的公平性，而在FD中比较不同的算法。结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。[9]</p></li><li><p>还有一个算法也是时域和频域两级调度器，将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。[12]</p></li></ol><p>&emsp;&emsp;在之前的工作中，与GBR相关的流量通常在eNB中处理的优先级最高。虽然保障了GBR业务的时延性能，但是会导致小区的整体性能降低。</p><p>&emsp;&emsp;本论文提出了一种QoS感知的调度方法，包含时域和频域。先使用经典的五元组将不同的流映射到不同的载波。将VOIP和video流量分为GBR类、FTP和HTTP分为nGBR类。在GBR类中利用令牌桶算法来阻止其使用所有资源。这种不仅保证了两个类间资源分配的公平性，还提高了系统的总吞吐量。</p><p>&nbsp;</p><h3 id="LTE下行链路调度器"><a href="#LTE下行链路调度器" class="headerlink" title="LTE下行链路调度器"></a>LTE下行链路调度器</h3><p>&emsp;&emsp;正交频分多址（OFDMA）将分布在整个频谱中的一组子载波专用于用户。带宽被划分为180kHz的子信道，包括12个连续的子载波。时间/频率无线电资源扩展到时域中的两个时隙和频域中的一个子信道上，称为资源块（RB），是LTE中用于资源分配的最小单元。RBs的数量取决于系统带宽，例如，对于5 MHz系统，RBs数量为25，而在10 MHz系统中，RBs数量为50。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220120200737.png" alt="image-20220120200737207" style="zoom:50%;" /><center>RB就是图中的小方块</center><p>&emsp;&emsp;eNB使用信道状态信息获取每个用户链路上的信息。用户在每个TTI中向eNB报告其下行链路流状态。数据包优先级由eNB的调度器根据数据包延迟、下行链路状态、缓冲区状态、流量类型等参数确定。而特定数据包流的专用RB数量取决于调度器中使用的资源分配算法。以前大多数工作中的数据包调度器有两个阶段。先是时域调度器基于调度算法（自行设计）的输入参数选出请求服务的用户，然后频域调度器按照算法（自行设计）将资源分配给时域中选择出的用户。分组调度器使用CQI获取所有rb中的每个信道的质量信息。</p><p>&nbsp;</p><h3 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h3><h5 id="业务分类"><a href="#业务分类" class="headerlink" title="业务分类"></a>业务分类</h5><p>&emsp;&emsp;VOIP、Conversational Video 归为 GBR业务</p><p>&emsp;&emsp;FTP、HTTP 归为 nGBR业务</p><h5 id="时域调度"><a href="#时域调度" class="headerlink" title="时域调度"></a>时域调度</h5><p>&emsp;&emsp;TD调度器最重要的功能是根据QoS参数和信道的当前状态选择请求资源的活动用户（Activate UE）。</p><p>&emsp;&emsp;在没有资源分配给用户的第一阶段，TD调度器确定不同类别的活动Bearer（activate bearers），并根据不同的需求对它们进行优先级排序。由于TD调度器没有关于分配给每个用户的RBs的信息，因此利用所有RBs上的用户cqi的平均值来比较用户的信道条件，获取最大度量值的用户具有最高优先级。TD调度器创建用户和活动Bearer，分为GBR组和nGBR组并按优先级排序，并向FD调度器发送这两个单独的列表。</p><h6 id="GBR"><a href="#GBR" class="headerlink" title="GBR"></a>GBR</h6><p>&emsp;&emsp;GBR Bearer必须保证数据速率，与对延迟敏感的应用相关。本算法中GBR Bearer的QoS参数计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080439.png" alt="image-20211201173407839" style="zoom:50%;" /><p>&emsp;&emsp;注意，在eNB缓冲区中花费更多时间的数据包具有更高的服务交付优先级。</p><h6 id="nGBR"><a href="#nGBR" class="headerlink" title="nGBR"></a>nGBR</h6><p>&emsp;&emsp;nGBR Bearer通常包括尽力而为的服务，对延迟不敏感。nGBR类的不同活动Bearer根据不同的条件进行优先级排序。优先级排序使用nGBR的优先级因子完成，其行为类似于WPF算法，做了一些轻微的修改。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184317.png" alt="image-20211201184317270" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184346.png" alt="image-20211201184346056" style="zoom:50%;" /><p>&emsp;&emsp;参数 r 较大的nGBR用户在资源分配中优先于其他用户。</p><p>&nbsp;</p><h5 id="频域调度"><a href="#频域调度" class="headerlink" title="频域调度"></a>频域调度</h5><p>&emsp;&emsp;FD调度器负责将RBs分配给不同的Active UE。FD调度器根据TD调度器发来的候选列表来确定在特定TTI中必须服务哪些Bearer。FD调度器优先服务于GBR Bearer，然后服务于nGBR Bearer。通过令牌桶算法确定允许分配资源的GBR Bearer，然后使用改进的LWDF、M-LWDFS对这些Bearer进行调度。<strong>（这里与流程图不符，流程图是PF算法调度）</strong></p><p>&emsp;&emsp;当GBR流量或相关令牌分配完后，FD调度器开始将资源分配给nGBR用户。采用了PF算法，在用户公平性和小区整体性能之间取得了较好的平衡。该算法计算用户信道的当前状态和先前接收的服务但是却不考虑QoS，因此PF适合非RT流量而不适合RT流量。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201185426.png" alt="image-20211201185425952" style="zoom:50%;" /><p>&emsp;&emsp;FD完整流程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201191306.png" alt="image-20211201191306507" style="zoom:50%;" /><p>&nbsp;</p><h3 id="仿真比较结果"><a href="#仿真比较结果" class="headerlink" title="仿真比较结果"></a>仿真比较结果</h3><p>&emsp;&emsp;为了研究提出的调度器在RT流量情况下对资源分配系统的影响，文章还模拟了TD-PF/FD-PF算法以及无令牌桶的情况。TD-PF/FD-PF算法虽然依据信道状态和服务质量，但是却并不考虑QoS，因此在RT流量业务的表现不佳。无令牌桶调度虽然考虑了QoS性能，但是由于GBR Bearer的优先级高于nGBR Bearer的优先级，而没有令牌桶对流量进行限制，因此当BGR业务需求较高时，nBGR业务无法顾及导致小区整体吞吐量降低。含令牌桶的调度是二者的折中，即维护了小区整体的吞吐量，又对RT流量业务的时延性能有所保证。</p><h6 id="三种业务情景"><a href="#三种业务情景" class="headerlink" title="三种业务情景"></a>三种业务情景</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192306.png" alt="image-20211201192305975" style="zoom:50%;" /><h6 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080440.png" alt="image-20211201192342289" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192359.png" alt="image-20211201192359425" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192413.png" alt="image-20211201192413873" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192430.png" alt="image-20211201192430785" style="zoom:50%;" /><p>&nbsp;</p><h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>&emsp;&emsp;其实这个令牌桶算法没有什么精巧的地方，无非是限制了对GBR业务资源分配，这样就能发论文，虽然是很多年前的了，但是一下让我觉得发论文也不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
            <tag> Token Bucket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab音频滤波</title>
      <link href="/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Matlab-音频信号处理"><a href="#Matlab-音频信号处理" class="headerlink" title="Matlab 音频信号处理"></a>Matlab 音频信号处理</h2><p>&emsp;&emsp;现有原始音频文件<code>SunshineSquare.wav</code>，后半段音频被人为加上了多频段的噪音，使用matlab工具对其进行分析并消除噪音还原出无噪音频文件。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><span id="more"></span><p>&nbsp;</p><h3 id="Step1：分析原始音频文件"><a href="#Step1：分析原始音频文件" class="headerlink" title="Step1：分析原始音频文件"></a>Step1：分析原始音频文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[audio_data, fs] = audioread(<span class="string">&#x27;../../SunshineSquare.wav&#x27;</span>);</span><br><span class="line">L = <span class="built_in">length</span>(audio_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一听该音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br></pre></td></tr></table></figure><h4 id="绘制时域图"><a href="#绘制时域图" class="headerlink" title="绘制时域图"></a>绘制时域图</h4><p>&emsp;&emsp;从下面时域图中可以看出，源音频文件时长11秒左右，从第8秒左右开始为一段强噪声。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Original&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = (<span class="number">1</span> : L) * <span class="number">1</span>/fs;</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="built_in">plot</span>(tt, audio_data);grid;</span><br><span class="line">title(<span class="string">&#x27;Time Domain&#x27;</span>);xlabel(<span class="string">&#x27;时间（s）&#x27;</span>);ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><h4 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h4><p>&emsp;&emsp;使用快速傅里叶变换FFT对时域信号进行频谱分析，绘制的频域图反映出有四段噪声频段，后续消除噪声工作就是对这四个频段进行滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="number">2</span>^<span class="built_in">nextpow2</span>(L); <span class="comment">% 先从原始信号长度确定下一个 2 次幂的新长度,用尾随零填充信号以改善 fft 的性能</span></span><br><span class="line">Spectrum = fft(audio_data,L); <span class="comment">% 快速傅里叶变换，转换为频域</span></span><br><span class="line">f_x = fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L; <span class="comment">% 定义频域，即变换横坐标量纲为频率</span></span><br><span class="line">mag_FFT_audio_data = <span class="built_in">abs</span>(Spectrum / L); <span class="comment">% 取幅值，并归一化</span></span><br><span class="line">ang_FFT_audio_data = <span class="built_in">angle</span>(Spectrum)*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="built_in">plot</span>(f_x,mag_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="built_in">plot</span>(f_x,ang_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;ang&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143455.png" alt="image-20211128143455368"></p><h4 id="绘制声谱图"><a href="#绘制声谱图" class="headerlink" title="绘制声谱图"></a>绘制声谱图</h4><p>&emsp;&emsp;声谱图能够以颜色反映各频段信号强度随时间的变化和分布情况，如图所示，从第8秒左右开始有4个频段的强度持续较高，这就是上面频域分析出的4个噪声频段。但需要注意到，在噪声的开始和结束时刻，所有频段的强度都很高，在图中显示为两条垂直的黄线，这两条线仅靠滤波无法消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">spectrogram(audio_data,hann(<span class="number">256</span>),<span class="number">250</span>,<span class="number">256</span>,fs,<span class="string">&#x27;yaxis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143558.png" alt="image-20211128143558882"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step2：滤波"><a href="#Step2：滤波" class="headerlink" title="Step2：滤波"></a>Step2：滤波</h3><h4 id="滤波法1——手动衰减"><a href="#滤波法1——手动衰减" class="headerlink" title="滤波法1——手动衰减"></a>滤波法1——手动衰减</h4><p>&emsp;&emsp;手动衰减各个噪声频段的幅度，注意FFT变换后的频谱图为偶对称，所以共有4对（8个）频段，逐一消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第一个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第二个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第三个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第四个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第五个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第六个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第七个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第八个噪声频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆fft获得处理后的音频</span></span><br><span class="line">ifft_data = <span class="built_in">real</span>(ifft(Spectrum, L));</span><br><span class="line">audio_data = ifft_data(<span class="number">1</span>:<span class="built_in">length</span>(audio_data));</span><br></pre></td></tr></table></figure><h5 id="滤波效果"><a href="#滤波效果" class="headerlink" title="滤波效果"></a>滤波效果</h5><p>&emsp;&emsp;绘制滤波后音频信号的时域图、频域图、声谱图，可看见时域图上噪声被消除，频谱图上4个频段的信号全部被消除，声谱图有四条水平的消磨痕迹。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211130213111.png" alt="image-20211130213111056"></p><p>&nbsp;</p><h4 id="滤波法2——数字滤波器"><a href="#滤波法2——数字滤波器" class="headerlink" title="滤波法2——数字滤波器"></a>滤波法2——数字滤波器</h4><p>&emsp;&emsp;设计梳状滤波器，因为有4个噪声频段，所以设计4个带阻滤波器逐一滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%h1[n] = [1,-2,1];</span></span><br><span class="line">h1 = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>];</span><br><span class="line">h2 = [<span class="number">1</span>,<span class="number">-1.24698</span>,<span class="number">1</span>];</span><br><span class="line">h3 = [<span class="number">1</span>,<span class="number">0.44504</span>,<span class="number">1</span>];</span><br><span class="line">h4 = [<span class="number">1</span>,<span class="number">1.80194</span>,<span class="number">1</span>];</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波过程</span></span><br><span class="line">audio_data_h1 = filter(h1,a,audio_data);</span><br><span class="line">audio_data_h2 = filter(h2,a,audio_data_h1);</span><br><span class="line">audio_data_h3 = filter(h3,a,audio_data_h2);</span><br><span class="line">audio_data_h4 = filter(h4,a,audio_data_h3);</span><br><span class="line"></span><br><span class="line">audio_data = audio_data_h4;</span><br></pre></td></tr></table></figure><h6 id="滤波器分析"><a href="#滤波器分析" class="headerlink" title="滤波器分析"></a>滤波器分析</h6><p>&emsp;&emsp;绘制4个滤波器的幅频、相频、衰减及每次滤波后的信号时域图。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145815.png" alt="image-20211128145815600" style="zoom: 25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145835.png" alt="image-20211128145835590" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128153455.png" alt="image-20211128145856791" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145920.png" alt="image-20211128145920683" style="zoom:25%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step3：后续处理"><a href="#Step3：后续处理" class="headerlink" title="Step3：后续处理"></a>Step3：后续处理</h3><p>&emsp;&emsp;上面已分析，在噪声开始和结束时刻都有全频段的高强度信号，不是滤波能消除的，这里采用时域衰减，即在时域采用同第一种滤波方法相同的思想，手动衰减这两个时刻的信号强度。随后输出处理过的音频文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第一个高音时段</span></span><br><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第二个高音频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一下处理后的音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出音频文件</span></span><br><span class="line">audiowrite(<span class="string">&#x27;SunshineSquare_Processed.wav&#x27;</span>,audio_data,fs); </span><br></pre></td></tr></table></figure><p>使用滤波法2的最终输出信号的分析如下：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128150059.png" alt="image-20211128150059309"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="对数字信号处理的认识"><a href="#对数字信号处理的认识" class="headerlink" title="对数字信号处理的认识"></a>对数字信号处理的认识</h2><p>&emsp;&emsp;《数字信号处理》这门课我觉得其实是两大主题，第一是信号分析，第二是信号处理。</p><p>&emsp;&emsp;信号分析在《信号与线性系统》中有所讲解，但是那时所研究的是连续时间信号的傅里叶级数或傅里叶变换，离散时间信号的傅里叶变换，它们的特点都是：信号无限长，导致计算机无法处理。而为了使用计算机工具帮助对信号进行分析，《数字信号处理》这门课引入了采样、增/减采样和离散傅里叶变换DFT的概念。后续考虑到DFT算法的时间复杂度太高，因此又提出快速傅里叶变换FFT来代替之。</p><p>&emsp;&emsp;信号处理在这门课中主要指滤波。低通、高通、带通、带阻、全通，《信号与线性系统》中共提出过五种模拟滤波器，如何根据所需指标将其转化为对应的数字滤波器来在计算机上使用，是这门课的第二个重点。</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>&emsp;&emsp;模拟信号经过采样、抽取（减采样）后成为计算机可以处理的有限长离散信号。采样后，仍是连续时间信号，但频域上是原始模拟信号频域的周期延拓和幅度放缩。抽取后，变为有限长离散信号，频域点数和时域相同，但横坐标频率被按比例压缩在 0~2pi 范围内，幅值和采样后的一样。</p><h5 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h5><p>&emsp;&emsp;在傅里叶变换中，离散/连续 和 周期/非周期 相对偶，离散周期序列的傅里叶变换仍是离散周期序列。因为计算机容量有限，其处理的信号长度有限，因此从离散周期信号中取一个周期来代替整个信号分析是一种行之有效的方法。DFT也正是在这种思想下被引出，重点在于循环卷积、旋转因子、各种变换性质。</p><p>&emsp;&emsp;但是，用定义计算DFT的时间复杂度太高，计算机效率低。借助公式中“旋转因子”的周期性，长序列的DFT可以不断分解至一组组两点DFT的组合，大大减少了计算量，这就是FFT算法。</p><h5 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h5><p>&emsp;&emsp;数字滤波器有很多值得关注的地方，首先是截止频率、纹波幅度等性能指标，然后是幅频特性、相频特性，还有系统函数的极零点、信号流图等。根据冲激响应长度可分为有限脉冲响应滤波器FIR和无限脉冲响应滤波器IIR。从模拟滤波器转换为数字滤波器的方法有冲激响应不变法、双线性变换法。常用的滤波器有巴特沃斯滤波器、切比雪夫滤波器、椭圆滤波器等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大二一年</title>
      <link href="/2021/12/02/%E3%80%90%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/"/>
      <url>/2021/12/02/%E3%80%90%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在华科度过了两年时间里，我看过东九楼前路边的银杏一夜间被北风吹去满树黄叶，也曾在凌晨五点的晨雾中从百景园自习区一路徒步走回韵苑。回想大一大二的时光，涌上我心头的并不是特别的成就感，亦不是其他大喜大悲，而是平淡与坦然。如果要用一句话概括这一年，我想用大物老师曾提到过的——看山不是山。</p><span id="more"></span><p>&emsp;&emsp;现在看来，大一一年里我只做了两件对现在仍有影响的事，一是熟悉了大学的学习方式，把加权拉得很高；二是认识到，每天都在自习室度过，这样和高中没太大区别，我不喜欢只是这样的大学生活。大二开学那阵，我因为加权高并且也有一些课外的成绩所以拿到了国奖，有些自傲，那是心里总觉得大学生活怎么和高中没什么区别呀，无非是可以用iPad记笔记、带手机上课罢了。禅宗里描述有三种境界，“看山是山，看山不是山，看山还是山。”第一次听到这句话是在大物老师的课上，我发觉自己对华科这所学校和大学本身的认识也只是在“看山是山”的层面上，我还没有发现它真正的精彩。</p><p>&emsp;&emsp;大一下学期因为疫情所以一学期都在家，期间不能出门，所以从高中坚持到大学的夜跑习惯也丢掉了，但是也恰好喜欢上了室内健身，大二来到学校后，在一位朋友的影响下去了一学期的健身房，每周会有三四天专门去锻炼。一整天没课时会和这位朋友专门去主图自习，中午步行穿过青年园到百景园或西边小吃城用餐，吃完回来会在图书馆外草地边讨论一些很有意思的话题，时间似乎都变得慢了下来。大一的每天是做不完的事情，时间匆匆流过，却总觉得自己什么都没做，而大二上就这样以一种比较悠闲的节奏度过，虽然加权没有大一时那么高，但那相差的那几点几分换来了我对大学、对自己的另一种认识。</p><p>&emsp;&emsp;大二上的国奖答辩期间认识了不少优秀的同学，寒假我和其中两位同学组队参加了美赛，比赛期间我们异地合作，每天都连麦从天还没亮肝到晚上凌晨，最后一晚通宵修改论文，没有人是在划水摸鱼。对比其他许多队伍我发现，能够遇到值得信任的靠谱队友是多么重要。我们虽然都是第一次接触数模，但是扎实的功底和高效的合作帮助我们出乎意料地最终取得了特等奖提名，其实奖项只是次要的，弥足珍贵的是经历和友谊。</p><p>&emsp;&emsp;大二下在两位队友的建议下，我加入了电信学院大名鼎鼎的科创团队——Dian团队。其实大一就知道Dian团队，但是当时一心只读圣贤书，两耳不闻东九窗外事，没有想过加入这样的团队，算是一个小小的遗憾。不过悟已往之不谏，知来者之可追，加入团队的半年里认识了许多优秀的同学，也学到了好玩并实用的项目知识和技能。在智慧交通项目组我接触到了计算机视觉与实际应用的结合，我们组与萍乡市警方合作设计了用于重点车辆检测的软件，申请到了国家版权局的软件著作权。虽然到了大二下期末，我的总成绩从半年前刚分完专业时的专业第一掉到了第二，学年成绩更是滑落不少，但想象中的懊悔与失落并没有如期而至，倒不如说是现在的我看开了，有些东西和成绩一样重要。</p><p>&emsp;&emsp;代表大二学年尾声的暑假对我而言也是一段不平凡的记忆。七月基本上是在团队中度过的，原本AI组的项目已经结题了，我转到团队与Intel亚太研发有限公司合作的项目中，一直在补习无线通信方面的知识。七月末我本着走入社会、感悟基层的初衷，又一次参与到了暑期社会实践当中，我们到河南洛阳的一家养老院展开调研，却碰上了百年难得一遇的暴雨，火车高铁停运，我也被困回不到郑州的家或学校。后续终于返校，但是因为河南疫情爆发，我被学校组织隔离了28天。被放出来后的第一件事就是去当疫苗接种志愿者，毕竟自己是一名预备党员，只是可惜没能给涝疫同至的家乡献一份力。</p><p>&emsp;&emsp;最后一个比较有意义的事就是去火车站迎新了，以前高中课上老师激励我们说，每年开学期间各个城市的大学都会在火车站设迎新点，越是有名的大学迎新点也越大。虽然最后一句在我当时来到武汉站看见华科的迎新点后就不信了，但是它带给我的归属感却一直萦绕在我心头，所以今年我也要把这种关怀传承下去。</p><p>&emsp;&emsp;其实大二这一年还经历过好多事情，我心里明白自己和一年前不一样了。再一次走向国奖答辩的讲台，我已不再是一年前那患得患失、喜忧参半的心态。既然我的成绩支持我站在这里，那么我所走过的路、感悟到的事情足够让我自信地向台下展示出自己。因为没有刻意把国奖当作目标，也不需要用它来证明什么，毕竟身边有许多同样如此的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> 心得感悟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Love actually is all around</title>
      <link href="/2021/12/01/hello-world/"/>
      <url>/2021/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hello World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
