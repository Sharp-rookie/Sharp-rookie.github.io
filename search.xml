<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【强化学习】A3C：多重影分身一起学习</title>
      <link href="/2022/02/09/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91A3C%EF%BC%9A%E5%A4%9A%E9%87%8D%E5%BD%B1%E5%88%86%E8%BA%AB%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/09/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91A3C%EF%BC%9A%E5%A4%9A%E9%87%8D%E5%BD%B1%E5%88%86%E8%BA%AB%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;如果我能有一个超能力，我希望能够使用火影忍者里鸣人的多重影分身之术，许多个分身同时学习，然后学到的东西汇总到我脑子里 ヾ(≧▽≦*)o~~</p><p>&emsp;&emsp;受益于计算机的多进程或多线程功能，A3C 理念帮助强化学习的 Agent 替我实现了这个梦想。不愧是DeepMind，轻易就做到了我做不到的事 ( •̀ ω •́ )✧</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209161905.png" alt="image-20220209161905574" style="zoom: 40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><p>&emsp;&emsp;A3C算法是DeepMind在2016年发表在ICML上的论文 <a href="https://lrk612.com/resources/Asynchronous%20Methods%20for%20Deep%20Reinforcement%20Learning.pdf">Asynchronous Methods for Deep Reinforcement Learning</a> 中提出的，其理念是通过多个进程或线程的Agent在不同策略的指导下不断与环境交互，然后收集动作和奖励，最终博采众长。</p><h3 id="异步训练框架"><a href="#异步训练框架" class="headerlink" title="异步训练框架"></a>异步训练框架</h3><p>&emsp;&emsp;上图中上部的Global Network就是共享的公共部分，主要是一个公共的神经网络模型，这个神经网络包括Actor网络和Critic网络两部分的功能。下面有n个worker线程，每个线程里有和公共的神经网络一样的网络结构，每个线程会独立的和环境进行交互得到经验数据，这些线程之间互不干扰，独立运行。</p><p>&emsp;&emsp;每个线程和环境交互到一定量的数据后，就计算在自己线程里的神经网络损失函数的梯度，但是这些梯度却并不更新自己线程里的神经网络，而是去更新公共的神经网络。也就是n个线程会独立的使用累积的梯度分别更新公共部分的神经网络模型参数。每隔一段时间，线程会将自己的神经网络的参数更新为公共神经网络的参数，进而指导后面的环境交互。</p><p>&emsp;&emsp;可见，公共部分的网络模型就是待训练的模型，而线程里的网络模型主要是用于和环境交互使用的，这些线程里的模型可以帮助线程更好的和环境交互，拿到高质量的数据帮助模型更快收敛。</p><p>&nbsp;</p><h2 id="A3C：DQN"><a href="#A3C：DQN" class="headerlink" title="A3C：DQN"></a>A3C：DQN</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>并行性</strong></p><p>&emsp;&emsp;A3C是第一个以显示方式表示可以使用并行化的强化学习算法，由此，在线学习可以成倍地提高样本手机效率，拿CPU计算资源换取时间效率。不过要注意，多线程异步并行Agent与环境的交互过程只能通过CPU来计算，GPU这时帮不上忙，GPU只在定期更新网络参数时起到加速的作用，因此CPU的处理速度和线程数量显得额外重要。</p><p><strong>异步更新</strong></p><p>&emsp;&emsp;A3C中有两处网络参数更新，一个是当前Q网络（估计Q值）更新，另一个是目标Q网络（计算目标Q值）。这两步都是周期更新，所有线程维护两个公共计数器，当计数器到达时，当前所处的线程就更新对应网络。由此可见两个网络的更新都是异步的，而由经验可知，异步的间隔越大，就越像离线学习，估值就越稳定、收敛越平稳，因此两个计数器的计数阈值的大小会影响Agent所表现出来的进步效率和收敛稳定性之间的平衡。一般建议这两个值设的大一些。</p><p><strong>取消Replay Memory</strong></p><p>&emsp;&emsp;在DQN算法族中大部分算法都是用经验回放来消除样本之间的关联性，从而帮助网络更好地收敛，但是在A3C算法中不再需要使用这个方法来消除关联性，因为本身多个Agent就是异步并行地对环境进行交互试探，得到的经验是不相关的，而网络的更新是各个Agent的经验按周期一同使用，所以数据的相关性通过这种并行性就已经消除了。关于这点，论文中也有给出专门的论述。</p><p>&emsp;&emsp;并且由于不再需要使用经验回放，计算机的内存资源也得到了释放，这使得在线学习算法的执行效率得到了提高。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125452.png" alt="image-20220113125452328" style="zoom:50%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络结构，对应参数位θ、w，全局共享的迭代轮数T，全局最大迭代次数Tmax，w更新周期Iw，θ更新周期Iθ，状态特征维度n, 动作集A，衰减因子γ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络参数θ、w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>更新时间序列 t=0</p></li><li><p>重置Actor和Critic的梯度更新量：<code>dθ=0</code></p></li><li><p><code>tstart = t</code>，初始化状态st</p></li><li><p>if ( T &lt;= Tmax )：</p><ul><li><p>基于策略 <code>π(at|st;θ)</code> 选择出动作at</p></li><li><p>执行动作at得到奖励 <code>rt</code> 和新状态 <code>st+1</code></p></li><li><p>计算目标Q值：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209182402.png" alt="image-20220209182402662" style="zoom: 33%;" /></li><li><p>累积需要更新的梯度：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209182501.png" alt="image-20220209182501797" style="zoom: 33%;" /></li><li><p>执行一步，进入状态 <code>st+1</code></p></li><li><p>t = t+1、T = T+1</p></li><li><p>if ( T % Iw == 0 )：</p><ul><li>复制更新目标Q网络的参数：w = θ</li></ul></li><li><p>if ( t % Iθ == 0 )：</p><ul><li>更新当前Q网络的参数：<ul><li>θ = θ - dθ</li><li>dθ = 0</li></ul></li></ul></li><li><p>进入步骤4</p></li></ul><p> else：算法结束，输出公共部分的A3C神经网络参数 θ、w</p></li></ol><p>注意：从第4步开始就是每个线程的Agent要做的内容，各个线程共享进程资源和变量，即：θ、w、dθ 是”全局“变量，线程共享。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;Gym 的 Pong-v0 游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> config.net <span class="keyword">import</span> AtariNet</span><br><span class="line"><span class="keyword">from</span> config.util <span class="keyword">import</span> preprocess</span><br><span class="line"></span><br><span class="line">LR = <span class="number">0.001</span></span><br><span class="line">EXPLORE = <span class="number">1000000</span></span><br><span class="line">GAMMA = <span class="number">0.99</span></span><br><span class="line">N_STEP = <span class="number">4</span></span><br><span class="line">ENV = <span class="string">&#x27;Pong-v0&#x27;</span></span><br><span class="line">ACTIONS_SIZE = gym.make(ENV).action_space.n</span><br><span class="line">PROCESSES = <span class="number">1</span></span><br><span class="line">SEED = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, action_size</span>):</span></span><br><span class="line">        self.action_size = action_size</span><br><span class="line">        self.EPSILON = <span class="number">1.0</span></span><br><span class="line">        self.network = AtariNet(action_size)</span><br><span class="line">        self.memory = deque()</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.network.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state, israndom</span>):</span></span><br><span class="line">        <span class="keyword">if</span> israndom <span class="keyword">and</span> random.random() &lt; self.EPSILON:</span><br><span class="line">            <span class="keyword">return</span> np.random.randint(<span class="number">0</span>, self.action_size)</span><br><span class="line">        state = torch.unsqueeze(torch.FloatTensor(state), <span class="number">0</span>)</span><br><span class="line">        actions_value = self.network.forward(state)</span><br><span class="line">        <span class="keyword">return</span> torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            self.memory.append((state, action, reward, next_state, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.memory.append((state, action, reward, next_state, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, shared_optimizer, shared_model</span>):</span></span><br><span class="line">        batch_size = <span class="built_in">len</span>(self.memory)</span><br><span class="line">        batch = random.sample(self.memory, batch_size)</span><br><span class="line">        state = torch.FloatTensor([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        action = torch.LongTensor([[x[<span class="number">1</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        reward = torch.FloatTensor([[x[<span class="number">2</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        next_state = torch.FloatTensor([x[<span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line">        done = torch.FloatTensor([[x[<span class="number">4</span>]] <span class="keyword">for</span> x <span class="keyword">in</span> batch])</span><br><span class="line"></span><br><span class="line">        eval_q = self.network.forward(state).gather(<span class="number">1</span>, action)</span><br><span class="line">        next_q = self.network(next_state).detach()</span><br><span class="line">        target_q = reward + GAMMA * next_q.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(batch_size, <span class="number">1</span>) * done</span><br><span class="line">        loss = self.loss_func(eval_q, target_q)</span><br><span class="line"></span><br><span class="line">        shared_optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="keyword">for</span> param, shared_param <span class="keyword">in</span> <span class="built_in">zip</span>(self.network.parameters(), shared_model.parameters()):</span><br><span class="line">            <span class="keyword">if</span> shared_param.grad <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                shared_param._grad = param.grad</span><br><span class="line">        shared_optimizer.step()</span><br><span class="line"></span><br><span class="line">        self.memory = deque()</span><br><span class="line">        <span class="keyword">if</span> self.EPSILON &gt; <span class="number">0.1</span>:</span><br><span class="line">            self.EPSILON -= (<span class="number">1.0</span> - <span class="number">0.1</span>) / EXPLORE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedAdam</span>(<span class="params">torch.optim.Adam</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, params, lr=<span class="number">1e-3</span>, betas=(<span class="params"><span class="number">0.9</span>, <span class="number">0.999</span></span>), eps=<span class="number">1e-8</span>, weight_decay=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(SharedAdam, self).__init__(params, lr, betas, eps, weight_decay)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> self.param_groups:</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> group[<span class="string">&#x27;params&#x27;</span>]:</span><br><span class="line">                state = self.state[p]</span><br><span class="line">                state[<span class="string">&#x27;shared_steps&#x27;</span>], state[<span class="string">&#x27;step&#x27;</span>] = torch.zeros(</span><br><span class="line">                    <span class="number">1</span>).share_memory_(), <span class="number">0</span></span><br><span class="line">                state[<span class="string">&#x27;exp_avg&#x27;</span>] = p.data.new().resize_as_(</span><br><span class="line">                    p.data).zero_().share_memory_()</span><br><span class="line">                state[<span class="string">&#x27;exp_avg_sq&#x27;</span>] = p.data.new().resize_as_(</span><br><span class="line">                    p.data).zero_().share_memory_()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">shared_model, shared_optimizer, rank, info</span>):</span></span><br><span class="line">    env = gym.make(ENV)</span><br><span class="line">    env.seed(SEED + rank)</span><br><span class="line">    torch.manual_seed(SEED + rank)</span><br><span class="line">    agent = Agent(ACTIONS_SIZE)</span><br><span class="line"></span><br><span class="line">    start_time = last_disp_time = time.time()</span><br><span class="line">    episode_length, epr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    state = env.reset()</span><br><span class="line">    state = preprocess(state)</span><br><span class="line">    <span class="keyword">while</span> info[<span class="string">&#x27;frames&#x27;</span>][<span class="number">0</span>] &lt;= <span class="number">4e7</span>:</span><br><span class="line">        agent.network.load_state_dict(shared_model.state_dict())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N_STEP):</span><br><span class="line">            <span class="comment"># env.render()</span></span><br><span class="line">            episode_length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            action = agent.action(state, <span class="literal">True</span>)</span><br><span class="line">            next_state, reward, done, ext = env.step(action)</span><br><span class="line">            epr += reward</span><br><span class="line">            done = done <span class="keyword">or</span> episode_length &gt;= <span class="number">1e4</span></span><br><span class="line">            info[<span class="string">&#x27;frames&#x27;</span>].add_(<span class="number">1</span>)</span><br><span class="line">            num_frames = <span class="built_in">int</span>(info[<span class="string">&#x27;frames&#x27;</span>].item())</span><br><span class="line"></span><br><span class="line">            next_state = preprocess(next_state)</span><br><span class="line">            agent.add(state, action, reward, next_state, done)</span><br><span class="line"></span><br><span class="line">            state = next_state</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                info[<span class="string">&#x27;episodes&#x27;</span>] += <span class="number">1</span></span><br><span class="line">                interp = <span class="number">1</span> <span class="keyword">if</span> info[<span class="string">&#x27;episodes&#x27;</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.01</span></span><br><span class="line">                info[<span class="string">&#x27;run_epr&#x27;</span>].mul_(<span class="number">1</span> - interp).add_(interp * epr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rank == <span class="number">0</span> <span class="keyword">and</span> time.time() - last_disp_time &gt; <span class="number">60</span>:</span><br><span class="line">                elapsed = time.strftime(</span><br><span class="line">                    <span class="string">&quot;%Hh %Mm %Ss&quot;</span>, time.gmtime(time.time() - start_time))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;time &#123;&#125;, episodes &#123;:.0f&#125;, frames &#123;:.1f&#125;M, mean epr &#123;:.2f&#125;&#x27;</span></span><br><span class="line">                      .<span class="built_in">format</span>(elapsed, info[<span class="string">&#x27;episodes&#x27;</span>].item(), num_frames / <span class="number">1e6</span>,</span><br><span class="line">                              info[<span class="string">&#x27;run_epr&#x27;</span>].item()))</span><br><span class="line">                last_disp_time = time.time()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                episode_length, epr, eploss = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                state = env.reset()</span><br><span class="line">                state = preprocess(state)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        agent.learn(shared_optimizer, shared_model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.version_info[<span class="number">0</span>] &gt; <span class="number">2</span>:</span><br><span class="line">        mp.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.platform == <span class="string">&#x27;linux&#x27;</span> <span class="keyword">or</span> sys.platform == <span class="string">&#x27;linux2&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;Must be using Python 3 with linux! Or else you get a deadlock in conv2d&quot;</span></span><br><span class="line"></span><br><span class="line">    torch.manual_seed(SEED)</span><br><span class="line">    shared_model = AtariNet(ACTIONS_SIZE).share_memory()</span><br><span class="line">    shared_optimizer = SharedAdam(shared_model.parameters(), lr=LR)</span><br><span class="line"></span><br><span class="line">    info = &#123;k: torch.DoubleTensor([<span class="number">0</span>]).share_memory_()</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">&#x27;run_epr&#x27;</span>, <span class="string">&#x27;episodes&#x27;</span>, <span class="string">&#x27;frames&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="built_in">range</span>(PROCESSES):</span><br><span class="line">        p = mp.Process(target=worker, args=(</span><br><span class="line">            shared_model, shared_optimizer, rank, info))</span><br><span class="line">        p.start()</span><br><span class="line">        processes.append(p)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="A3C-DDPG"><a href="#A3C-DDPG" class="headerlink" title="A3C DDPG"></a>A3C DDPG</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;和上面A3C DQN算法略有不同，A3C DDPG算法中不仅有全局共享的网络参数 θ、w，同时每个线程都有独占的变量，即 θ‘、w’。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>网络结构优化</strong></p><p>&emsp;&emsp;A3C把两个网络放到了一起，即输入状态S，可以输出状态价值V和对应的策略π。不过仍然可以把Actor和Critic看做独立的两块，分别处理：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112094415.png" alt="image-20220112094415642" style="zoom: 25%;" /><p><strong>Critic选择的优化</strong></p><p>&emsp;&emsp;在A3C中Critic选择为优势函数的近似，省略<a href="extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=http%3A%2F%2Fproceedings.mlr.press%2Fv48%2Fmniha16.pdf">A3C论文</a>中的推导，直接给出其计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112095035.png" alt="image-20220112095035246" style="zoom:40%;" /><p><strong>损失函数优化</strong></p><p>&emsp;&emsp;在Actor的损失函数中加入了策略π的熵项，系数为c：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112095453.png" alt="image-20220112095453116" style="zoom:40%;" /><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209183724.png" alt="image-20220209183724280" style="zoom: 60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络结构，对应参数位θ、w，当前线程的A3C神经网络结构，对应参数θ′、w′，全局共享的迭代轮数T，全局最大迭代次数Tmax，线程内单次迭代时间序列最大长度tmax，状态特征维度n, 动作集A，步长α、β，熵系数c，衰减因子γ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公共部分的A3C神经网络参数θ、w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>更新时间序列 t=1</p></li><li><p>if (T &lt;= Tmax )：</p><ul><li><p>重置Actor和Critic的梯度更新量：<code>dθ=0、dw=0</code></p></li><li><p>从公共部分的A3C神经网络同步参数到本线程的神经网络：<code>θ’=θ、w’=w</code></p></li><li><p><code>tstart = t</code>，初始化状态st</p></li><li><p>if ( st不是终止状态 且 t - tstart != tmax )：</p><ol><li>基于策略 <code>π(at|st;θ)</code> 选择出动作at</li><li>执行动作at得到奖励rt和新状态st+1</li><li>t = t+1、T = T+1</li><li>返回步骤 2.4</li></ol><p>  else：进入步骤 3</p></li></ul></li><li><p>计算最后一个时间序列位置st的Q(s,t)：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112101419.png" alt="image-20220112101419222" style="zoom:40%;" /> <center>注意，这里和DQN、DDOG都不一样，游戏结束的奖励是0</center></li><li><p>for i in [t-1, tstart]：</p><ul><li><p>计算每个时刻的Q(s, i)：<code>Q(s, i) = ri + γQ(s, i+1)</code></p></li><li><p>累计Actor网络的梯度更新：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112102319.png" alt="image-20220112102319176" style="zoom:40%;" /></li><li><p>累计Critic网络的梯度更新：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112102707.png" alt="image-20220112102707754" style="zoom:40%;" /></li></ul></li><li><p>更新全局神经网络的参数：<code>θ=θ-αdθ、w=w-βdw</code></p></li><li><p>if ( T&gt;Tmax )：算法结束，输出公共部分的A3C神经网络参数 θ、w；</p><p> else：进入步骤 2</p></li></ol><p>（可以看出，A3C DDPG中，每个线程的Agent会从头到尾”玩”一个episode，期间只更新本线程的网络参数θ‘、w’，一轮游戏结束后才将学到的所有东西更新到全局共享网络 θ、w 中，全局共享网络参数θ、w更新是以episode为周期进行的）</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">OUTPUT_GRAPH = <span class="literal">True</span></span><br><span class="line">LOG_DIR = <span class="string">&#x27;./log&#x27;</span></span><br><span class="line">N_WORKERS = <span class="number">3</span></span><br><span class="line">MAX_GLOBAL_EP = <span class="number">3000</span></span><br><span class="line">GLOBAL_NET_SCOPE = <span class="string">&#x27;Global_Net&#x27;</span></span><br><span class="line">UPDATE_GLOBAL_ITER = <span class="number">100</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">ENTROPY_BETA = <span class="number">0.001</span></span><br><span class="line">LR_A = <span class="number">0.001</span>    <span class="comment"># learning rate for actor</span></span><br><span class="line">LR_C = <span class="number">0.001</span>    <span class="comment"># learning rate for critic</span></span><br><span class="line">GLOBAL_RUNNING_R = []</span><br><span class="line">GLOBAL_EP = <span class="number">0</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line">env = gym.make(GAME)</span><br><span class="line">N_S = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">N_A = env.action_space.n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACNet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, scope, globalAC=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> scope == GLOBAL_NET_SCOPE:   <span class="comment"># get global network</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">                self.s = tf.placeholder(tf.float32, [<span class="literal">None</span>, N_S], <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                self.a_params, self.c_params = self._build_net(scope)[-<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># local net, calculate losses</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">                self.s = tf.placeholder(tf.float32, [<span class="literal">None</span>, N_S], <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                self.a_his = tf.placeholder(tf.int32, [<span class="literal">None</span>, ], <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                self.v_target = tf.placeholder(</span><br><span class="line">                    tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], <span class="string">&#x27;Vtarget&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                self.a_prob, self.v, self.a_params, self.c_params = self._build_net(</span><br><span class="line">                    scope)</span><br><span class="line"></span><br><span class="line">                td = tf.subtract(self.v_target, self.v, name=<span class="string">&#x27;TD_error&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;c_loss&#x27;</span>):</span><br><span class="line">                    self.c_loss = tf.reduce_mean(tf.square(td))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;a_loss&#x27;</span>):</span><br><span class="line">                    log_prob = tf.reduce_sum(tf.log(self.a_prob + <span class="number">1e-5</span>) * tf.one_hot(</span><br><span class="line">                        self.a_his, N_A, dtype=tf.float32), axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>)</span><br><span class="line">                    exp_v = log_prob * tf.stop_gradient(td)</span><br><span class="line">                    entropy = -tf.reduce_sum(self.a_prob * tf.log(self.a_prob + <span class="number">1e-5</span>),</span><br><span class="line">                                             axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>)  <span class="comment"># encourage exploration</span></span><br><span class="line">                    self.exp_v = ENTROPY_BETA * entropy + exp_v</span><br><span class="line">                    self.a_loss = tf.reduce_mean(-self.exp_v)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;local_grad&#x27;</span>):</span><br><span class="line">                    self.a_grads = tf.gradients(self.a_loss, self.a_params)</span><br><span class="line">                    self.c_grads = tf.gradients(self.c_loss, self.c_params)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;sync&#x27;</span>):</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;pull&#x27;</span>):</span><br><span class="line">                    self.pull_a_params_op = [l_p.assign(g_p) <span class="keyword">for</span> l_p, g_p <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                        self.a_params, globalAC.a_params)]</span><br><span class="line">                    self.pull_c_params_op = [l_p.assign(g_p) <span class="keyword">for</span> l_p, g_p <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                        self.c_params, globalAC.c_params)]</span><br><span class="line">                <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;push&#x27;</span>):</span><br><span class="line">                    self.update_a_op = OPT_A.apply_gradients(</span><br><span class="line">                        <span class="built_in">zip</span>(self.a_grads, globalAC.a_params))</span><br><span class="line">                    self.update_c_op = OPT_C.apply_gradients(</span><br><span class="line">                        <span class="built_in">zip</span>(self.c_grads, globalAC.c_params))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_net</span>(<span class="params">self, scope</span>):</span></span><br><span class="line">        w_init = tf.random_normal_initializer(<span class="number">0.</span>, <span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;actor&#x27;</span>):</span><br><span class="line">            l_a = tf.layers.dense(self.s, <span class="number">200</span>, tf.nn.relu6,</span><br><span class="line">                                  kernel_initializer=w_init, name=<span class="string">&#x27;la&#x27;</span>)</span><br><span class="line">            a_prob = tf.layers.dense(</span><br><span class="line">                l_a, N_A, tf.nn.softmax, kernel_initializer=w_init, name=<span class="string">&#x27;ap&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;critic&#x27;</span>):</span><br><span class="line">            l_c = tf.layers.dense(self.s, <span class="number">100</span>, tf.nn.relu6,</span><br><span class="line">                                  kernel_initializer=w_init, name=<span class="string">&#x27;lc&#x27;</span>)</span><br><span class="line">            v = tf.layers.dense(</span><br><span class="line">                l_c, <span class="number">1</span>, kernel_initializer=w_init, name=<span class="string">&#x27;v&#x27;</span>)  <span class="comment"># state value</span></span><br><span class="line">        a_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.TRAINABLE_VARIABLES, scope=scope + <span class="string">&#x27;/actor&#x27;</span>)</span><br><span class="line">        c_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.TRAINABLE_VARIABLES, scope=scope + <span class="string">&#x27;/critic&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> a_prob, v, a_params, c_params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_global</span>(<span class="params">self, feed_dict</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        <span class="comment"># local grads applies to global net</span></span><br><span class="line">        SESS.run([self.update_a_op, self.update_c_op], feed_dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull_global</span>(<span class="params">self</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        SESS.run([self.pull_a_params_op, self.pull_c_params_op])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, s</span>):</span>  <span class="comment"># run by a local</span></span><br><span class="line">        prob_weights = SESS.run(self.a_prob, feed_dict=&#123;</span><br><span class="line">                                self.s: s[np.newaxis, :]&#125;)</span><br><span class="line">        action = np.random.choice(<span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]),</span><br><span class="line">                                  p=prob_weights.ravel())  <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, globalAC</span>):</span></span><br><span class="line">        self.env = gym.make(GAME).unwrapped</span><br><span class="line">        self.name = name</span><br><span class="line">        self.AC = ACNet(name, globalAC)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> GLOBAL_RUNNING_R, GLOBAL_EP</span><br><span class="line">        total_step = <span class="number">1</span></span><br><span class="line">        buffer_s, buffer_a, buffer_r = [], [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> COORD.should_stop() <span class="keyword">and</span> GLOBAL_EP &lt; MAX_GLOBAL_EP:</span><br><span class="line">            s = self.env.reset()</span><br><span class="line">            ep_r = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># if self.name == &#x27;W_0&#x27;:</span></span><br><span class="line">                <span class="comment">#     self.env.render()</span></span><br><span class="line">                a = self.AC.choose_action(s)</span><br><span class="line">                s_, r, done, info = self.env.step(a)</span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    r = -<span class="number">5</span></span><br><span class="line">                ep_r += r</span><br><span class="line">                buffer_s.append(s)</span><br><span class="line">                buffer_a.append(a)</span><br><span class="line">                buffer_r.append(r)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total_step % UPDATE_GLOBAL_ITER == <span class="number">0</span> <span class="keyword">or</span> done:   <span class="comment"># update global and assign to local net</span></span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        v_s_ = <span class="number">0</span>   <span class="comment"># terminal</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        v_s_ = SESS.run(</span><br><span class="line">                            self.AC.v, &#123;self.AC.s: s_[np.newaxis, :]&#125;)[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">                    buffer_v_target = []</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> buffer_r[::-<span class="number">1</span>]:    <span class="comment"># reverse buffer r</span></span><br><span class="line">                        v_s_ = r + GAMMA * v_s_</span><br><span class="line">                        buffer_v_target.append(v_s_)</span><br><span class="line">                    buffer_v_target.reverse()</span><br><span class="line"></span><br><span class="line">                    buffer_s, buffer_a, buffer_v_target = np.vstack(</span><br><span class="line">                        buffer_s), np.array(buffer_a), np.vstack(buffer_v_target)</span><br><span class="line">                    feed_dict = &#123;</span><br><span class="line">                        self.AC.s: buffer_s,</span><br><span class="line">                        self.AC.a_his: buffer_a,</span><br><span class="line">                        self.AC.v_target: buffer_v_target,</span><br><span class="line">                    &#125;</span><br><span class="line">                    self.AC.update_global(feed_dict)</span><br><span class="line"></span><br><span class="line">                    buffer_s, buffer_a, buffer_r = [], [], []</span><br><span class="line">                    self.AC.pull_global()</span><br><span class="line"></span><br><span class="line">                s = s_</span><br><span class="line">                total_step += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(GLOBAL_RUNNING_R) == <span class="number">0</span>:  <span class="comment"># record running episode reward</span></span><br><span class="line">                        GLOBAL_RUNNING_R.append(ep_r)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        GLOBAL_RUNNING_R.append(</span><br><span class="line">                            <span class="number">0.99</span> * GLOBAL_RUNNING_R[-<span class="number">1</span>] + <span class="number">0.01</span> * ep_r)</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        self.name,</span><br><span class="line">                        <span class="string">&quot;Ep:&quot;</span>, GLOBAL_EP,</span><br><span class="line">                        <span class="string">&quot;| Ep_r: %i&quot;</span> % GLOBAL_RUNNING_R[-<span class="number">1</span>],</span><br><span class="line">                    )</span><br><span class="line">                    GLOBAL_EP += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    SESS = tf.Session()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:0&quot;</span>):</span><br><span class="line">        OPT_A = tf.train.RMSPropOptimizer(LR_A, name=<span class="string">&#x27;RMSPropA&#x27;</span>)</span><br><span class="line">        OPT_C = tf.train.RMSPropOptimizer(LR_C, name=<span class="string">&#x27;RMSPropC&#x27;</span>)</span><br><span class="line">        GLOBAL_AC = ACNet(GLOBAL_NET_SCOPE)  <span class="comment"># we only need its params</span></span><br><span class="line">        workers = []</span><br><span class="line">        <span class="comment"># Create worker</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N_WORKERS):</span><br><span class="line">            i_name = <span class="string">&#x27;W_%i&#x27;</span> % i   <span class="comment"># worker name</span></span><br><span class="line">            workers.append(Worker(i_name, GLOBAL_AC))</span><br><span class="line"></span><br><span class="line">    COORD = tf.train.Coordinator()</span><br><span class="line">    SESS.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> OUTPUT_GRAPH:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(LOG_DIR):</span><br><span class="line">            shutil.rmtree(LOG_DIR)</span><br><span class="line">        tf.summary.FileWriter(LOG_DIR, SESS.graph)</span><br><span class="line"></span><br><span class="line">    worker_threads = []</span><br><span class="line">    <span class="keyword">for</span> worker <span class="keyword">in</span> workers:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">job</span>():</span> <span class="keyword">return</span> worker.work()</span><br><span class="line">        t = threading.Thread(target=job)</span><br><span class="line">        t.start()</span><br><span class="line">        worker_threads.append(t)</span><br><span class="line">    COORD.join(worker_threads)</span><br><span class="line"></span><br><span class="line">    testWorker = Worker(<span class="string">&quot;test&quot;</span>, GLOBAL_AC)</span><br><span class="line">    testWorker.AC.pull_global()</span><br><span class="line"></span><br><span class="line">    total_reward = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            env.render()</span><br><span class="line">            action = testWorker.AC.choose_action(</span><br><span class="line">                state)  <span class="comment"># direct action for test</span></span><br><span class="line">            state, reward, done, _ = env.step(action)</span><br><span class="line">            total_reward += reward</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    ave_reward = total_reward / TEST</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, GLOBAL_EP, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line">    plt.plot(np.arange(<span class="built_in">len</span>(GLOBAL_RUNNING_R)), GLOBAL_RUNNING_R)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;step&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Total moving reward&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118130134.png" alt="image-20220118105654323" style="zoom: 35%;" /><p>&nbsp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;A3C提供了一种通用的异步的并发的强化学习框架，就像是多个影分身同时学习，然后把学会的汇总在一起。A3C并发框架不光可以用于DQN、DDPG，还可以用于其他的强化学习算法，这是A3C最大的贡献。目前已经有基于GPU的A3C框架，这样A3C的框架训练速度就更快了。</p><p>&emsp;&emsp;但是有一点需要注意，多线程之间访问共享资源时不可避免地要考虑通信和同步问题，最简单的方法就是添加互斥锁，在Python中是通过GIL库来实现的。但是GIL库设计上存在缺陷，效率存在严重问题且属于历史遗留问题无法解决。因此在Python中使用A3C进行训练的话，最好使用多进程+多协程的方式。</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境配置 &amp; 问题记录</title>
      <link href="/2022/02/08/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/02/08/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;记录一下配置环境遇到的奇奇怪怪的bug，特别是软件版本前后不互相支持、官方文档不够全面的问题（痛苦面具＞﹏＜）</p><span id="more"></span><p>&nbsp;</p><h3 id="Gym安装正常，但atari游戏无法使用"><a href="#Gym安装正常，但atari游戏无法使用" class="headerlink" title="Gym安装正常，但atari游戏无法使用"></a>Gym安装正常，但atari游戏无法使用</h3><h4 id="Part1：安装"><a href="#Part1：安装" class="headerlink" title="Part1：安装"></a>Part1：安装</h4><p>（正确步骤总结在最后）</p><hr><p>按照官方文档安装gym：</p><p><code>pip install gym</code></p><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    env.render()</span><br><span class="line">    env.step(env.action_space.sample()) <span class="comment"># take a random action</span></span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure><p>代码运行正常</p><hr><p>跑强化学习代码，用gym作为环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&#x27;Pong-v0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>出现报错，提示gym库中没有挂载 <code>‘Pong-v0’</code> 这个游戏</p><hr><p>按照stackoverflow上帖子：<a href="https://stackoverflow.com/questions/69442971/error-in-importing-environment-openai-gym">Error in importing environment OpenAI Gym</a> 建议，操作如下：</p><p><code>pip install --upgrade gym==0.19.0</code></p><p><code>pip install gym[atari]</code></p><hr><p>此时跑强化学习程序，出现另一种报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileNotFoundError: Could <span class="keyword">not</span> find module <span class="string">&#x27;D:\anaconda3\lib\site-packages\atari_py\ale_interface\ale_c.dll&#x27;</span> (<span class="keyword">or</span> one of its dependencies). Try using </span><br><span class="line">the full path <span class="keyword">with</span> constructor syntax.</span><br></pre></td></tr></table></figure><p>提示位置没有 <code>ale_c.dll</code> 文件，故上网下载了一个（<a href="https://drive.google.com/file/d/1WQrEBliYbASwNDyyVIlPFSZHRwAa7sPp/view?usp=sharing">网址</a>），放到对应位置，但是依然报同样的错误</p><hr><p>按照 github 论坛 <a href="https://github.com/openai/gym/issues/1726">module could not be found’ when running gym.make for atari environment</a> 建议，操作如下：</p><ol><li><p><code>pip uninstall atari-py</code></p><p> <code>pip uninstall gym[atari]</code></p></li><li><p>下载 VS build tools：<a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16">网址</a> （科学上网）</p></li><li><p>安装VS build，注意选择 C++ build tools</p><p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110252.png" alt="68347704-afadcf80-00ac-11ea-8da0-446c390556f9"></p></li><li><p>重启电脑</p></li><li><p>安装 cmake, atari-py and gym<br> <code>pip install cmake</code><br> <code>pip install atari-py</code><br> <code>pip install gym[atari]</code></p></li><li><p>测试：<br> <code>import atari_py</code><br> <code>print(atari_py.list_games())</code></p></li><li><p>理论效果：</p><p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110358.png" alt="image-20220208110358251"></p><p> 实际效果：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220208110523.png" alt="image-20220208110523047" style="zoom:50%;" /></li></ol><hr><p>再运行强化学习程序，工作正常（喜</p><hr><p>经过在服务器和虚拟机的多次测试，安装gym的正确过程总结如下：</p><p><code>pip install cmake</code><br><code>pip install atari-py</code><br><code>pip install gym[atari]</code><br><code>pip install gym[accept-rom-license]</code></p><h4 id="Part2：判断版本"><a href="#Part2：判断版本" class="headerlink" title="Part2：判断版本"></a>Part2：判断版本</h4><p>本来按照上面安装好了，<code>Pong-v0</code> 游戏已经可以使用了，但是在我写一个ddpg算法中使用 <code>Pendulum-v0 </code>游戏时又出错了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) PS C:\Users\lrk\Desktop\Learn\DRL&gt; python .\ddpg.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 158, <span class="keyword">in</span> spec</span><br><span class="line">    <span class="built_in">return</span> self.env_specs[id]</span><br><span class="line">KeyError: <span class="string">&#x27;Pendulum-v0&#x27;</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;.\ddpg.py&quot;</span>, line 142, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    env = gym.make(args.env_name)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 235, <span class="keyword">in</span> make</span><br><span class="line">    <span class="built_in">return</span> registry.make(id, **kwargs)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 128, <span class="keyword">in</span> make</span><br><span class="line">    spec = self.spec(path)</span><br><span class="line">  File <span class="string">&quot;D:\anaconda3\lib\site-packages\gym\envs\registration.py&quot;</span>, line 185, <span class="keyword">in</span> spec</span><br><span class="line">    raise error.DeprecatedEnv(</span><br><span class="line">gym.error.DeprecatedEnv: Env Pendulum-v0 not found (valid versions include [<span class="string">&#x27;Pendulum-v1&#x27;</span>])</span><br></pre></td></tr></table></figure><p>看样子又没找到这个游戏，不过似乎是版本的问题，于是按照网上帖子学会了gym内注册游戏的代码位置：</p><p><code>D:\anaconda3\lib\site-packages\gym\__init__.py</code>，注意这是目前我电脑上gym的安装目录，自己的目录位置可以通过报错内容来查看。</p><p>可以看见gym内注册的游戏都在这里（截出部分）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209154944.png" alt="image-20220209154944060" style="zoom:50%;" /><p>自行查看可以用版本即可。</p><p>&nbsp;</p><p>&nbsp;</p><hr><h3 id="Windows文件传到Linux后去除-M"><a href="#Windows文件传到Linux后去除-M" class="headerlink" title="Windows文件传到Linux后去除^M"></a>Windows文件传到Linux后去除^M</h3><p>在Windows环境下编辑的文件，上传到Linux后会在文件中产生 <code>^M</code>字符。尤其是对sh脚本的运行产生影响：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#!coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x = <span class="string">&quot;abc123&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x[<span class="number">2</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>WSL下的执行结果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220210212409.png" alt="image-20220210212409708" style="zoom: 67%;" /><p><strong>原因</strong></p><p>&emsp;&emsp;CRLF(\r\n)是Windows环境下的行尾结束符，LF(\n)Linux环境下的行尾结束符，在Linux环境下，无法识别Windows环境下文件的行尾结束符引起。</p><p><strong>处理</strong></p><p>查看方法：<code>cat -A &lt;filename&gt;</code></p><p>消除方法（4种）：</p><ul><li><code>sed -i &#39;s/^M$//g&#39; &lt;filename&gt;</code></li><li><code>cat &lt;filename1&gt; | tr -d &#39;\r&#39; &gt; &lt;filename&gt;</code></li><li><code>dos2unix &lt;filename&gt;</code></li><li><code>vim &lt;filename&gt; </code> + 输入 <code>: set ff=unix</code> + 输入 <code>:wq</code> 退出</li></ul><p>&nbsp;</p><p>&nbsp;</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】决策树&amp;随机森林——回归问题</title>
      <link href="/2022/02/06/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/06/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在监督学习中，分类问题通常是指预测离散类的标签，而回归问题则是预测连续类的值。分类并没有逼近的概念，最终正确结果只有一个，错误的就是错误的，不会有相近的概念；而回归则是使预测值不断逼近理论值，会存在误差。</p><p>&emsp;&emsp;本文记录如何使用决策树和随机森林求解回归问题。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206110710.png" alt="image-20220206110710194" style="zoom:40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><p>&emsp;&emsp;决策树模型既能用于解决分类问题，又能用于处理回归问题，在处理回归问题时，决策树就成为了回归树。不过要注意，回归树与分类时的决策树的不同之处在于，回归树对输入空间的划分采用一种启发式的方法，会遍历所有输入变量，找到最优的切分变量（特征）和最优的切分点（阈值）。在这一步中，回归树不使用熵或者Gini指数表示的不纯度来作为判断依据，而是改用类似损失函数的思想，对不同切分变量和切分点带来的模型误差进行定量计算，取带来最小误差损失的切分变量和切分点。</p><h3 id="回归树的建立"><a href="#回归树的建立" class="headerlink" title="回归树的建立"></a>回归树的建立</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>分叉特征的选择</strong></p><p>对特征空间的划分采用启发式方法，每次划分逐一考察当前集合中所有特征的所有取值，根据平方误差最小化准则选择其中最优的一个作为切分点，平方误差表达式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206105908.png" alt="image-20220205222348334" style="zoom: 67%;" /><p>其中，<code>f(xi)</code> 是每个划分单元的预测值，这个预测值是该单元内每个样本点的值的均值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220205222452.png" alt="image-20220205222452942" style="zoom:67%;" /><p>（这里将输入空间划分为M个单元：R1,R2,…,Rm）</p><p>也就是说，切分变量 <code>j</code> 及切分点 <code>s</code> 的选择必须满下式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102520.png" alt="image-20220206102520423" style="zoom: 60%;" /><p>其中，c1、c2为划分后两个区域内固定的输出值，方括号内的两个min意为使用的是最优值，而最优值对应就是两个区域内各自Y的平均值，故上式可写成：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102747.png" alt="image-20220206102746971" style="zoom:60%;" /><p>其中，c1、c2分别为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102838.png" alt="image-20220206102838239" style="zoom:67%;" /><p>找到最优的切分点(j,s)后，依次将输入空间划分为两个区域，接着对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成了一棵回归树，这样的回归树通常称为<strong>最小二乘回归树</strong>。</p><p><strong>输出值</strong></p><p>通过上面分叉过程，得到的最小二乘回归树的每个叶子节点对应一个分类，该节点内Y的平均值就是这个分类的样本的回归预测值，分叉使已经满足该预测值的最小二乘误差达到最低。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>输入：训练数据集 D</p><p>输出：回归树 f(x)</p><p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p><ol><li><p>选择最优切分变量 <code>j</code> 与切分点 <code>s</code>，求解</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206102520.png" alt="image-20220206102520423" style="zoom: 60%;" /><p> 遍历变量 <code>j</code>，对固定的切分变量 <code>j</code> 扫描切分点 <code>s</code>，选出使上式取最小值的对 <code>(j,s)</code></p></li><li><p>用选定的对 <code>(j,s)</code> 划分区域并决定相应的输出值：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206103448.png" alt="image-20220206103448102" style="zoom: 67%;" /><p> 其中，R1、R2分别表示切分出的两个区间</p></li><li><p>继续对两个子区域调用步骤(1),(2)，直至满足停止条件</p></li><li><p>将输入空间划分为M个区域：R1、R2……Rm，生成决策树：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206103610.png" alt="image-20220206103610660" style="zoom:67%;" /><p> 其中 <code>I</code> 为指示函数</p></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>训练数据集如下，简单起见，特征向量只有一维。根据此数据表建立回归决策树：</p><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>y</td><td>5.56</td><td>5.7</td><td>5.91</td><td>6.4</td><td>6.8</td><td>7.05</td><td>8.9</td><td>8.7</td><td>9</td><td>9.05</td></tr></tbody></table><ol><li><p>选择最优切分变量 <code>j</code> 与最优切分点 <code>s</code>：</p><p> 在本数据集中，只有一个特征变量，最优切分变量自然是x。接下来考虑9个切分点：</p><ul><li><p>计算子区域输出值</p><p>  当s=1.5时，两个子区域：R1={1}、R2={2，3，4，5，6，7，8，9，10}</p><p>  对应子区域输出值：c1=5.56、 c2=7.5</p><p>  同理得其他切分点子区域的输出值如下：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>c1</td><td>5.56</td><td>5.63</td><td>5.72</td><td>5.89</td><td>6.07</td><td>6.24</td><td>6.62</td><td>6.88</td><td>7.11</td></tr><tr><td>c2</td><td>7.5</td><td>7.73</td><td>7.99</td><td>8.25</td><td>8.54</td><td>8.91</td><td>8.92</td><td>9.03</td><td>9.05</td></tr></tbody></table></li><li><p>计算最小二乘误差，找出最优切分点</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>L</td><td>15.72</td><td>12.07</td><td>8.36</td><td>5.78</td><td>3.91</td><td>1.93</td><td>8.01</td><td>11.73</td><td>15.74</td></tr></tbody></table><p>  显然，最有切分点为：s=6.5</p></li></ul></li><li><p>用选定的对 <code>(j,s)</code> 划分区域并决定相应的输出值：</p><p> 划分区域为：R1={1，2，3，4，5，6}、R2={7，8，9，10}</p><p> 对应输出值：c1=6.24、c2=8.91</p></li><li><p>调用步骤(1)、(2)，继续划分：</p><p> 对R1，取切分点{1.5，2.5，3.5，4.5，5.5}，对应输出值为：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th></tr></thead><tbody><tr><td>c1</td><td>5.56</td><td>5.63</td><td>5.72</td><td>5.89</td><td>6.07</td></tr><tr><td>c2</td><td>6.37</td><td>6.54</td><td>6.75</td><td>6.93</td><td>7.05</td></tr></tbody></table><p> 最小二乘误差为：</p><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th></tr></thead><tbody><tr><td>L</td><td>1.3087</td><td>0.754</td><td>0.2771</td><td>0.4368</td><td>1.0644</td></tr></tbody></table><p> 故取切分点为：s=3.5</p><p> 后面同理</p></li><li><p>生成回归树：</p><p> 假设两次划分后即停止，则最终生成的回归树为：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206105253.png" alt="image-20220206105253300" style="zoom:67%;" /></li></ol><p>&nbsp;</p><h3 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h3><h4 id="DecisionTreeRegressor"><a href="#DecisionTreeRegressor" class="headerlink" title="DecisionTreeRegressor"></a>DecisionTreeRegressor</h4><p>&emsp;&emsp;sklearn中已经封装好了回归树的对象<a href="https://scikit-learn.org.cn/view/785.html">sklearn.tree.DecisionTreeRegressor</a>，使用时注意参数和接口的定义即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">tree</span>.<span class="title">DecisionTreeRegressor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    *, </span></span></span><br><span class="line"><span class="params"><span class="class">criterion=<span class="string">&#x27;mse&#x27;</span>, <span class="comment"># 特征选择时的误差计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    splitter=<span class="string">&#x27;best&#x27;</span>, <span class="comment"># 特征选择的策略</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 决策树最大深度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 决策树分叉时的最小信息增益的阀值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶子节点最少的样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶子节点最小的样本权重和</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="literal">None</span>, <span class="comment"># 最大特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小误差值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    presort=<span class="string">&#x27;deprecated&#x27;</span>, <span class="comment"># 数据是否预排序</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span><span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树回归器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回预测的确定系数<span class="title">R</span>^2</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>利用决策树对正弦曲线进行加噪观测拟合，学习近似正弦曲线的局部线性回归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sklearn.tree <span class="keyword">as</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a random dataset</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">X = np.sort(<span class="number">5</span> * rng.rand(<span class="number">80</span>, <span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line">y = np.sin(X).ravel()</span><br><span class="line">y[::<span class="number">5</span>] += <span class="number">3</span> * (<span class="number">0.5</span> - rng.rand(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit regression model</span></span><br><span class="line">regr = DecisionTreeRegressor(max_depth=<span class="number">2</span>)</span><br><span class="line">regr.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predict</span></span><br><span class="line">X_test = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.01</span>)[:, np.newaxis]</span><br><span class="line">y_test = regr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualize the tree</span></span><br><span class="line">dot_data = tree.export_graphviz(</span><br><span class="line">    regr,</span><br><span class="line">    out_file=<span class="literal">None</span>,</span><br><span class="line">    filled=<span class="literal">True</span>,</span><br><span class="line">    rounded=<span class="literal">True</span>,</span><br><span class="line">    special_characters=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">&quot;regression&quot;</span>, view=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the results</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, s=<span class="number">20</span>, edgecolor=<span class="string">&quot;black&quot;</span>,</span><br><span class="line">            c=<span class="string">&quot;darkorange&quot;</span>, label=<span class="string">&quot;original data&quot;</span>)</span><br><span class="line">plt.plot(X_test, y_test, color=<span class="string">&quot;cornflowerblue&quot;</span>,</span><br><span class="line">         label=<span class="string">&quot;regression&quot;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;target&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Decision Tree Regression&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>回归树结构：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206111245.png" alt="image-20220206111245582" style="zoom: 45%;" /><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220206110710.png" alt="image-20220206110710194" style="zoom:40%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="随机森林回归器"><a href="#随机森林回归器" class="headerlink" title="随机森林回归器"></a>随机森林回归器</h2><p>&emsp;&emsp;思想和随机森林分类器基本一致，区别在于决策树变为回归树。sklearn模型中所有的参数，属性与接口，全部和随机森林分类器一致。仅有的不同就是回归树与分类树的不同，不纯度的指标，参数Criterion不一致。详见：<a href="https://scikit-learn.org.cn/view/650.html">sklearn.ensemble.RandomForestRegressor</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">RandomForestRegressor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>, <span class="comment"># 森林中树木的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    *, </span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;mse&#x27;</span>, <span class="comment"># 特征选择时的误差计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 树的最大深度，如果为None，则自由生长</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 拆分内部节点所需的最少样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶节点的最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶节点上所需的(所有输入样本的)总权重的最小加权分数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>, <span class="comment"># 寻找最佳分割特征时可选择的特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">True</span>, <span class="comment"># 是否使用有放回重复采样</span></span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>, <span class="comment"># 是否使用袋外样本估计泛化精度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>, <span class="comment"># 要并行运行的作业的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>, <span class="comment"># 在拟合和预测时控制冗余程度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>, <span class="comment"># 热启动，将现有的拟合模型属性用于在随后的拟合调用中初始化新模型</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>, <span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span><span class="comment"># 绘制样本的方式</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regression </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】集成学习 &amp; 随机森林</title>
      <link href="/2022/02/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
      <url>/2022/02/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;随机森林是将多棵决策树集成的一种算法，其基本单元是决策树，而本质则属于机器学习的一大分支——集成学习（Ensemble Learning）方法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142616.png" alt="image-20220203142616059" style="zoom: 40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>&emsp;&emsp;集成学习（Ensemble learning）通过构建并结合多个学习器来完成学习任务。将已有的分类或回归算法通过一定方式组合起来，形成一个性能更加强大的分类器，更准确的说这是一种分类算法的组装方法，即将弱分类器组装成强分类器的方法。可以说是集百家之所长，能在机器学习算法中拥有较高的准确率，不足之处就是模型的训练过程可能比较复杂，效率不是很高。</p><p>根据个体学习器的生成方式，目前的集成学习方法大致可以分为2类：</p><ul><li><p>基于Bagging</p><blockquote><p>个体学习器间不存在强依赖关系、可同时生成的并行化方法。</p><p>例：随机森林</p></blockquote></li><li><p>基于Boosting</p><blockquote><p>个体学习器间存在强依赖关系、必须串行生成的序列化方法，除了训练第一个之外，其他的学习器学习都需要依赖于前面生成的学习的结果。</p><p>例：AdaBoost、GBDT、XGBoost</p></blockquote></li></ul><p>&nbsp;</p><h3 id="Bagging算法"><a href="#Bagging算法" class="headerlink" title="Bagging算法"></a>Bagging算法</h3><p>&emsp;&emsp;Bagging（bootstrap aggregating）在原始训练集的随机子集上建立几个黑箱估计器的实例，然后将它们的个体预测聚合起来，形成最终的预测。这些方法通过在基本估计器(例如决策树)的构造过程中引入随机化，然后将其集成起来，从而降低单个基本估计器(如决策树)的方差。在许多情况下，bagging方法是一个非常简单的方法可以用来改进相对单一模型，而不需要调整底层。体现了<strong>并联</strong>的思想。</p><p><strong>算法流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）</span><br><span class="line">2. k个训练集，训练对应k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）</span><br><span class="line">3. 对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）</span><br></pre></td></tr></table></figure><p><strong>sklearn 使用示例</strong></p><p>使用 <code>breast_cancer</code> 数据集，用单个决策树和多个决策树集成的模型进行对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT</span>():</span></span><br><span class="line">    dt = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = dt.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;单个决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT_Bagging</span>():</span></span><br><span class="line">    bagging = BaggingClassifier(DecisionTreeClassifier(</span><br><span class="line">        criterion=<span class="string">&quot;entropy&quot;</span>), max_samples=<span class="number">0.5</span>, max_features=<span class="number">0.5</span>)</span><br><span class="line">    clf = bagging.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;多个决策树集成后的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    DT()</span><br><span class="line">    DT_Bagging()</span><br></pre></td></tr></table></figure><p>结果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142249.png" alt="image-20220203130737004" style="zoom:60%;" /><p>&nbsp;</p><h3 id="Boosting算法"><a href="#Boosting算法" class="headerlink" title="Boosting算法"></a>Boosting算法</h3><p>&emsp;&emsp;Boosting是一簇可将弱学习器提升为强学习器的算法。其工作机制为：先从初始训练集训练出一个基学习器，再根据基学习器的表现对样本分布进行调整，使得先前的基学习器做错的训练样本在后续收到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到实现指定的值T，或整个集成结果达到退出条件，然后将这些学习器进行加权结合，体现了<strong>串联</strong>的思想。</p><p><strong>算法流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对于训练集中的每个样本建立权值wi，表示对每个样本的关注度。当某个样本被误分类的概率很高时，需要加大对该样本的权值。</span><br><span class="line">2. 进行迭代的过程中，每一步迭代都是一个弱分类器。我们需要用某种策略将其组合，作为最终模型。（例如AdaBoost给每个弱分类器一个权值，将其线性组合最为最终分类器。误差越小的弱分类器，权值越大）</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><table><thead><tr><th>关注点</th><th>区别</th></tr></thead><tbody><tr><td>样本选择</td><td>Bagging采用的是Bootstrap随机有放回抽样；而Boosting每一轮的训练集是不变的，改变的只是每一个样本的权重</td></tr><tr><td>样本权重</td><td>Bagging使用的是均匀取样，每个样本权重相等；Boosting根据错误率调整样本权重，错误率越大的样本权重越大</td></tr><tr><td>预测函数</td><td>Bagging所有的预测函数的权重相等；Boosting中误差越小的预测函数其权重越大</td></tr><tr><td>并行计算</td><td>Bagging各个预测函数可以并行生成；Boosting各个预测函数必须按顺序迭代生成</td></tr></tbody></table><p>&emsp;&emsp;从偏差-方差的角度来说，Boosting主要关注减小偏差，而Bagging主要关注降低方差，也就说明Boosting在弱学习器上表现更好，而降低方差可以减小过拟合的风险，所以Bagging通常在强分类和复杂模型上表现得很好。</p><p>举个例子：Bagging在不减枝决策树、神经网络等易受样本扰动的学习器上效果更为明显。</p><p>&nbsp;</p><h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>  简单来说，集成算法就是训练一堆基学习器，然后通过某种策略把各个基学习器的结果进行合成，从而得到集成学习器的结果。常见的结合策略有：平均法、投票法、学习法</p><h4 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h4><p>  评价法包括简单平均法和加权平均法。加权平均法的权重一般从训练数据中学习而得，对规模比较大额集成来说，要学习的权重比较多，较容易导致过拟合，因此加权平均法不一定优于简单平均法。一般而言，在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法。</p><h4 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h4><p>  投票的思想是每个分类器都列出预测对象每个分类结果都概率值，然后多个分类器的分类概率累加在一起。之后的投票分为三种：绝对多数投票、相对多数投票、加权投票。绝对多数投票要求对某个类别预测的概率大于一半则标记，否则不计；相对投票则只计概率最高的类别结果；加权投票思想同加权平均。</p><h4 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h4><p>  当数据很多时，一种更为强大的结合策略是使用学习法，即通过另一个学习器来结合。其中典型代表为Stacking，在Stacking中把个体学习器称为初级学习器，用于结合的学习器称为次学习器或者元学习器。</p><p>（Stacking本身就是一种出名的集成学习方法，且有不少集成学习方法可以认为是其变体或者特例，周志华的西瓜书中把Stacking认为是一种结合策略）</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><h3 id="一般随机森林"><a href="#一般随机森林" class="headerlink" title="一般随机森林"></a>一般随机森林</h3><p>&emsp;&emsp;随机森林（Random Forest）从原始训练样本集N中有放回地重复随机抽取k个样本（bootstrap）生成新的训练样本集合，然后根据自助样本集生成k个分类树组成随机森林，新数据的分类结果按分类树投票多少形成的分数而定。其实质是对决策树算法的一种改进，将多个决策树合并在一起，每棵树的建立依赖于一个独立抽取的样品，森林中的每棵树具有相同的分布，分类误差取决于每一棵树的分类能力和它们之间的相关性。特征选择采用随机的方法去分裂每一个节点，然后比较不同情况下产生的误差。能够检测到的内在估计误差、分类能力和相关性决定选择特征的数目。单棵树的分类能力可能很小，但在随机产生大量的决策树后，一个测试样品可以通过每一棵树的分类结果经统计后选择最可能的分类。</p><p>&nbsp;</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.从训练数据中选取n个数据作为训练数据输入，一般情况下n是远小于整体的训练数据N的。</span><br><span class="line">2.选取了输入的训练数据的之后，需要构建决策树，具体方法是每一个分裂结点从整体的特征集M中选取m个特征构建，一般情况下m远小于M。</span><br><span class="line">3.按照选取最小的基尼指数分裂节点、构造每棵决策树。</span><br><span class="line">4.重复第2步和第3步多次，每一次输入数据对应一颗决策树，从而得到随机森林。</span><br><span class="line">5.对待预测数据进行预测，可以采用多数投票的方式或者平均的方式。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出，随机森林的随机性体现在2点：<strong>有放回抽取样本</strong>、<strong>特征变量选择范围</strong>。这两种随机的目的是降低森林估计器的方差。事实上，单个决策树通常表现出很高的方差，并且往往会过拟合。在森林中注入随机性产生的决策树具有一定的解耦预测误差（decoupled prediction errors）。通过取这些预测的平均值，可以抵消掉一些误差。随机森林通过组合不同的树来减少方差，有时以增加一点点偏差为代价。在实践中，方差减少通常是值得关注的，因此产生了一个整体更好的模型。</p><p>&nbsp;</p><h4 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h4><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">RandomForestClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>, <span class="comment"># 森林中树木的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    *,</span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;gini&#x27;</span>, <span class="comment"># 衡量分割质量的值，可选：gini、entropy</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 树的最大深度，如果为None，则自由生长</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 拆分内部节点所需的最少样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶节点的最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶节点上所需的(所有输入样本的)总权重的最小加权分数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>, <span class="comment"># 寻找最佳分割特征时可选择的特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">True</span>, <span class="comment"># 是否使用有放回重复采样</span></span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>, <span class="comment"># 是否使用袋外样本估计泛化精度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>, <span class="comment"># 要并行运行的作业的数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>, <span class="comment"># 在拟合和预测时控制冗余程度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>, <span class="comment"># 热启动，将现有的拟合模型属性用于在随后的拟合调用中初始化新模型</span></span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>, <span class="comment"># 类的权重</span></span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>, <span class="comment"># 剪枝时的最大代价复杂度阈值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span> <span class="comment"># 绘制样本的方式</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict_proba</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测输入样本<span class="title">X</span>的类别概率</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/633.html">sklearn.ensemble.RandomForestClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>breast_cancer</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DT</span>():</span></span><br><span class="line">    dt = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = dt.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;单个决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RF</span>():</span></span><br><span class="line">    rf = RandomForestClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = rf.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;随机森林的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    DT()</span><br><span class="line">    RF()</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203141011.png" alt="image-20220203141011334" style="zoom:60%;" /><p>&nbsp;</p><h3 id="极端随机森林"><a href="#极端随机森林" class="headerlink" title="极端随机森林"></a>极端随机森林</h3><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p>极端随机森林和一般随机森林的区别主要在于：</p><ul><li><p>样本的选择</p><blockquote><p>对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra tree的每个决策树采用原始训练集。RandomForest应用的是Bagging模型，ExtraTree使用的所有的样本，只是特征是随机选取的，因为分裂是随机的，所以在某种程度上比随机森林得到的结果更加好</p></blockquote></li><li><p>分叉特征的选择</p><blockquote><p>在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，和传统的决策树相同。但是Extra tree比较激进，会随机的选择一个特征值来划分决策树</p></blockquote></li></ul><h4 id="sklearn使用-1"><a href="#sklearn使用-1" class="headerlink" title="sklearn使用"></a>sklearn使用</h4><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">ExtraTreesClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    n_estimators=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    *,</span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=<span class="string">&#x27;gini&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="string">&#x27;auto&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    bootstrap=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    oob_score=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    n_jobs=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    verbose=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    warm_start=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    ccp_alpha=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    max_samples=<span class="literal">None</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/626.html">sklearn.ensemble.ExtraTreesClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>breast_cancer</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dataset = load_breast_cancer()</span><br><span class="line">x = dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ET</span>():</span></span><br><span class="line">    et = ExtraTreesClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = et.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;极端决策树准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RF</span>():</span></span><br><span class="line">    rf = RandomForestClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    clf = rf.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;随机森林的准确率: <span class="subst">&#123;clf.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ET()</span><br><span class="line">    RF()</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203142217.png" alt="image-20220203142217266" style="zoom:60%;" />]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Classifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】决策树——分类问题</title>
      <link href="/2022/01/30/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/30/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;<strong>决策树</strong>是一种用于分类和回归的非参数有监督学习方法。其目标是创建一个模型，通过学习从数据特性中推断出的简单决策规则来预测目标变量的值。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130183526.png" alt="image-20220130183526893" style="zoom: 45%;" /><span id="more"></span><p>&nbsp;</p><h2 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p>&emsp;&emsp;决策树（Dicision Tree）是一个类似于流程图的树形结构，树内部的每一个节点代表的是对一个特征的测试，树的分支代表该特征的每一个测试结果，而树的每一个叶子节点代表一个类别，树的最高层是就是根节点。其决策过程就好像问几个问题，只需要回答是或不是，最后推出被提问者的某个信息。决策树构建过程就好似“选择问什么问题”、“问几个问题”。</p><p>例：判断一个人是否有能力偿还信用卡开销</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130183557.png" alt="image-20220129205930153" style="zoom: 33%;" /><center>随便举个例子，此决策树不一定准确</center><h4 id="决策过程"><a href="#决策过程" class="headerlink" title="决策过程"></a>决策过程</h4><ol><li>利用不纯度（比如：熵）将整个数据集进行分割</li><li>使得分割后数据集的不纯度最小</li><li>不断对子数据集进行递归</li><li>直至无法进一步分割或者子数据集里数据的标签都一致时递归结束</li><li>分割的过程会形成一棵决策树</li><li>利用决策树将输入的数据归类到某一分割后的数据集中</li><li>该数据集所带有的标签就是决策的结果</li></ol><h4 id="对比线性分类模型"><a href="#对比线性分类模型" class="headerlink" title="对比线性分类模型"></a>对比线性分类模型</h4><p>&emsp;&emsp;树形模型是一个一个特征进行处理，之前线性模型是所有特征给予权重相加得到一个新的值。决策树与逻辑回归的分类区别也在于此，逻辑回归是将所有特征变换为概率后，通过大于某一概率阈值的划分为一类，小于某一概率阈值的为另一类；而决策树是对每一个特征做一个划分。</p><h4 id="节点的不纯度-impurity"><a href="#节点的不纯度-impurity" class="headerlink" title="节点的不纯度(impurity)"></a>节点的不纯度(impurity)</h4><p>&emsp;&emsp;由于决策树解决的是分类问题，因此希望一个节点代表一个类，即节点内的样本都是同一类数据。而构造决策树的过程也正是通过一个个非叶子节点的判断分叉，从而向下产生一个个仅含一个类（理想情况）的叶子结点。因此，节点的不纯度（描述内部数据的类别异同情况）是决策树的重要参数。不同的决策树算法对节点不纯度的描述也不同，但主要分为：<strong>熵</strong>和<strong>Gini指数</strong>两种。</p><h5 id="熵-entropy"><a href="#熵-entropy" class="headerlink" title="熵(entropy)"></a>熵(entropy)</h5><p>&emsp;&emsp;关于熵的定义可以从两个角度来解读，第一是物理学中的熵，第二是信息学。物理学中的熵出现在热力学第二定律中，描述物体的混乱度；而信息学中的熵常指信息熵，表征信息量。但总而言之，熵的共同含义是：“物质的内在的混乱程度”，熵越大，混乱度越高，也意味着节点内样本的类别差异越大。决策树算法中，节点熵的计算公式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129212919.png" alt="image-20220129212919431" style="zoom:60%;" /><h5 id="Gini指数"><a href="#Gini指数" class="headerlink" title="Gini指数"></a>Gini指数</h5><p>&emsp;&emsp;Gini指数表示在样本集合中一个随机选中的样本被分错的概率。Gini指数越小表示集合中被选中的样本被参错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。当集合中所有样本为一个类时，基尼指数为0。计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129212306.png" alt="image-20220129212306723" style="zoom:60%;" /><p>&nbsp;</p><h3 id="构造决策树"><a href="#构造决策树" class="headerlink" title="构造决策树"></a>构造决策树</h3><p>一棵决策树的生成过程主要分为3步：</p><ul><li><p>特征选择：</p><p>  从训练数据中众多的特征中选择一个特征作为当前节点的分叉标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法</p></li><li><p>生成决策树：</p><p>  根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分时停止决策树的生长</p></li><li><p>剪枝：</p><p>  决策树容易过拟合（分支太多），一般来需要剪枝，缩小树结构规模以缓解过拟合。剪枝分为：预剪枝、后剪枝两种</p></li></ul><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;因为在决策树中，分类是通过从根节点开始的一个个非叶子节点逐层分叉实现的，因此每个非叶子节点的分叉依据是决策树进行分类判断的本质。每个分叉都是通过对样本数据特征的不同而展开的。但是考虑到样本数据一般会有很多个特征都可以用作分类的参考依据，究竟每一层用哪个特征作为分叉依据，这是不同决策树算法的主要区别。</p><p>&emsp;&emsp;注意：在决策树中，所有的特征均为离散值。如果某个特征的值为连续值，那么需要通过分段等方法先将其离散化。</p><h5 id="基于信息增量"><a href="#基于信息增量" class="headerlink" title="基于信息增量"></a>基于信息增量</h5><p>&emsp;&emsp;从根节点向下，每层分叉的特征选择能带来最大信息增量（分叉后熵的减少量）的特征作为判断对象。具体而言，就是选择使分叉后的节点不纯度最低的那个特征作为本层的分叉依据。信息增量计算公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129225236.png" alt="image-20220129225236915" style="zoom:60%;" /><center>H(X|A)是按特征A分叉后的熵</center><h5 id="基于信息增量率"><a href="#基于信息增量率" class="headerlink" title="基于信息增量率"></a>基于信息增量率</h5><p>&emsp;&emsp;提出信息增量率是为了消除信息增量的一个弊端，即信息增量法趋向于选择值较多的特征，而未必是分类效果最好的特征。这其实是信息增量的表达式决定的，特征可选的值越多，分叉后的子集就越精细，熵越低，信息增量自然越高。因此采用信息增量率来归一化，客观比较：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129230143.png" alt="image-20220129230143683" style="zoom:60%;" /><h5 id="基于Gini指数"><a href="#基于Gini指数" class="headerlink" title="基于Gini指数"></a>基于Gini指数</h5><p>&emsp;&emsp;与信息增量类似，不过换成Gini指数作为不同特征的性能评估指标：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129230637.png" alt="image-20220129230637874" style="zoom:60%;" /><center>p(x|a)是条件概率</center><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从根节点出发，根节点包括所有的训练样本，递归下面的过程：</span><br><span class="line"></span><br><span class="line">if 当前节点内所有样本均属于同一类别:</span><br><span class="line">那么将该节点就成为叶节点，并将该节点标记为样本个数最多的类别</span><br><span class="line">else</span><br><span class="line">利用指定方法（例如信息增量法）选择对样本进行划分的最好特征</span><br><span class="line">按特征的几个值划分出几个子节点</span><br><span class="line"></span><br><span class="line">递归停止条件：</span><br><span class="line">1. 当前节点中所有的样本均为同一类别，那么产生叶节点 </span><br><span class="line">2. 已经没有特征可用于对当前节点样本行划分，即：attribute_list=null。此时强制产生叶节点，类别为数量最多的样本的类别</span><br><span class="line">3. 没有样本能满足剩余特征的取值，即：test_attribute=null。此时也强制产生叶节点，该节点的类别为数量最多的样本的类别</span><br></pre></td></tr></table></figure><h4 id="剪枝（泛化）"><a href="#剪枝（泛化）" class="headerlink" title="剪枝（泛化）"></a>剪枝（泛化）</h4><p>&emsp;&emsp;由于噪声等因素的影响，样本某些特征的取值与样本自身的类别可能不相匹配，基于这种数据生成的决策树的某些枝叶会产生一些错误；尤其是在决策树靠近枝叶的末端，由于样本变少，这种无关因素的干扰就会突显出来；由此产生的决策树可能存在过拟合的现象。剪枝就是通过统计学的方法删除不可靠的分支，使得整个决策树的分类速度和分类精度得到提高，避免过拟合，提高泛化能力。</p><p>剪枝分为：预剪枝、后剪枝</p><h5 id="预剪枝-Pre-Pruning"><a href="#预剪枝-Pre-Pruning" class="headerlink" title="预剪枝(Pre-Pruning)"></a>预剪枝(Pre-Pruning)</h5><p>简而言之，边建立决策树边进行剪枝的操作，设定一些规则来避免决策树的过度分支：</p><ul><li>信息增益（率）低于阈值则不分枝</li><li>节点的样本数少于阈值则不分枝</li><li>分叉后叶子结点样本数少于阈值则不分枝</li><li>树的深度大于阈值则不分枝</li><li>……</li></ul><p>（以上各种规则中，阈值的选取很大地影响决策树的性能，是关键的超参数之一）</p><h5 id="后剪枝-Post-Pruning"><a href="#后剪枝-Post-Pruning" class="headerlink" title="后剪枝(Post-Pruning)"></a>后剪枝(Post-Pruning)</h5><p>在决策树充分生长（过拟合）后，修剪掉多余的分支。这里要给出决策树的性能效果评价损失函数，从下向上剪枝以实现损失函数值最小。</p><p>评价函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129234252.png" alt="image-20220129234252614" style="zoom:60%;" /><p>其中，<code>C(T)</code> 是决策树对训练数据的预测误差，即模型与数据的拟合度：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220129234608.png" alt="image-20220129234608798" style="zoom:60%;" /><p><code>|T|</code> 是决策树的叶子结点; <code>α</code> 是衡量 <code>C(T)</code> 和 <code>|T|</code> 权重的因子，<code>α</code> 越大，要求决策树越简单，即叶子结点越少，分类越粗。</p><p>&nbsp;</p><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><h3 id="三钟常用算法"><a href="#三钟常用算法" class="headerlink" title="三钟常用算法"></a>三钟常用算法</h3><p>&emsp;&emsp;决策树的生成大致如上所述，特征选择的评估有不同的方法，对应不同的决策树实现算法，其中主要包括：ID3、C4.5、CART 三个算法。</p><table><thead><tr><th>算法</th><th>特征选择依据</th><th>特点</th></tr></thead><tbody><tr><td>ID3</td><td>信息增益</td><td>仅能够处理离散特征，且信息增益偏向选择取值较多特征</td></tr><tr><td>C4.5</td><td>信息增益率</td><td>能够分段处理连续特征，且克服了信息增益的弊端</td></tr><tr><td>CART</td><td>Gini指数</td><td>生成的决策树只能是二叉树</td></tr></tbody></table><p>&nbsp;</p><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><h4 id="手写实现决策树（以ID3为例）"><a href="#手写实现决策树（以ID3为例）" class="headerlink" title="手写实现决策树（以ID3为例）"></a>手写实现决策树（以ID3为例）</h4><p><strong>问题</strong></p><p>给出：年龄、有无工作、有无房子这3个特征，判断是否适合放贷</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 计算给定数据集的经验熵（香农熵）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    shannonEnt: 经验熵</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="comment"># 返回数据集行数</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 保存每个标签（label）出现次数的字典</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]  <span class="comment"># 提取标签信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签没有放入统计次数的字典，添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># label计数</span></span><br><span class="line"></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵</span></span><br><span class="line">    <span class="comment"># 计算经验熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries  <span class="comment"># 选择该标签的概率</span></span><br><span class="line">        shannonEnt -= prob*log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 创建测试数据集</span></span><br><span class="line"><span class="string">Parameters: 无</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">    labels: 分类属性</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span>():</span></span><br><span class="line">    <span class="comment"># 数据集</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">    <span class="comment"># 分类属性</span></span><br><span class="line">    labels = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;有工作&#x27;</span>, <span class="string">&#x27;有自己的房子&#x27;</span>, <span class="string">&#x27;信贷情况&#x27;</span>]</span><br><span class="line">    <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet:待划分的数据集</span></span><br><span class="line"><span class="string">    axis: 划分数据集的特征</span></span><br><span class="line"><span class="string">    value: 需要返回的特征值</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span></span><br><span class="line">    <span class="comment"># 创建返回的数据集列表</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="comment"># 遍历数据集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 将符合条件的添加到返回的数据集</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            <span class="comment"># 去掉axis特征</span></span><br><span class="line">            reduceFeatVec = featVec[:axis]</span><br><span class="line">            reduceFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">            retDataSet.append(reduceFeatVec)</span><br><span class="line">    <span class="comment"># 返回划分后的数据集</span></span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 计算给定数据集的经验熵（香农熵）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    dataSet: 数据集</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    shannonEnt: 信息增益最大特征的索引值</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="comment"># 特征数量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计数数据集的香农熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    <span class="comment"># 信息增益</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 最优特征的索引值</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历所有特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取dataSet的第i个所有特征</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 创建set集合&#123;&#125;，元素不可重复</span></span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        <span class="comment"># 经验条件熵</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># subDataSet划分后的子集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算子集的概率</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            <span class="comment"># 根据公式计算经验条件熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt((subDataSet))</span><br><span class="line">        <span class="comment"># 信息增益</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="comment"># 打印每个特征的信息增益</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第%d个特征的增益: %.3f&quot;</span> % (i, infoGain))</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            <span class="comment"># 更新信息增益，找到最大的信息增益</span></span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            <span class="comment"># 记录信息增益最大的特征的索引值</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">            <span class="comment"># 返回信息增益最大特征的索引值</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 统计classList中出现次数最多的元素（类标签）</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    classList: 类标签列表</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    sortedClassCount[0][0]: 出现次数最多的元素（类标签）</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span>(<span class="params">classList</span>):</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="comment"># 统计classList中每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">            classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 根据字典的值降序排列</span></span><br><span class="line">        sortedClassCount = <span class="built_in">sorted</span>(</span><br><span class="line">            classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明: 从根节点向下递归创建决策树</span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet: 训练数据集</span></span><br><span class="line"><span class="string">    labels: 分类属性标签</span></span><br><span class="line"><span class="string">    featLabels: 存储选择的最优特征标签</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    myTree: 决策树</span></span><br><span class="line"><span class="string">Modify: </span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">dataSet, labels, featLabels</span>):</span></span><br><span class="line">    <span class="comment"># 取分类标签（是否放贷: yes or no）</span></span><br><span class="line">    classList = [item[-<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 如果类别完全相同，则停止继续划分</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历完所有特征时停止分叉，返回出现次数最多的类标签</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择最优特征</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 最优特征的标签</span></span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    featLabels.append(bestFeatLabel)</span><br><span class="line">    <span class="comment"># 根据最优特征的标签生成树</span></span><br><span class="line">    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="comment"># 删除已经使用的特征标签</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">    <span class="comment"># 得到训练集中所有最优特征的属性值</span></span><br><span class="line">    featValues = [item[bestFeat] <span class="keyword">for</span> item <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 去掉重复的属性值</span></span><br><span class="line">    uniqueVls = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="comment"># 遍历特征，创建决策树</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVls:</span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),</span><br><span class="line">                                                  labels, featLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用决策树进行分类</span></span><br><span class="line"><span class="string">Parameters: </span></span><br><span class="line"><span class="string">    inputTree；已经生成的决策树</span></span><br><span class="line"><span class="string">    featLabels: 存储选择的最优特征标签</span></span><br><span class="line"><span class="string">    testVec: 测试数据列表，顺序对应最优特征标签</span></span><br><span class="line"><span class="string">Returns: </span></span><br><span class="line"><span class="string">    classLabel: 分类结果</span></span><br><span class="line"><span class="string">Modify: 2018-03-13</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span></span><br><span class="line">    <span class="comment"># 获取决策树节点</span></span><br><span class="line">    firstStr = <span class="built_in">next</span>(<span class="built_in">iter</span>(inputTree))</span><br><span class="line">    <span class="comment"># 下一个字典</span></span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">                classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                classLabel = secondDict[key]</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;构造决策树: &quot;</span>)</span><br><span class="line">    dataSet, labels = createDataSet()</span><br><span class="line">    featLabels = []</span><br><span class="line">    myTree = createTree(dataSet, labels, featLabels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;有效特征: <span class="subst">&#123;featLabels&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;决策树: <span class="subst">&#123;myTree&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试数据</span></span><br><span class="line">    testVec = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;测试: <span class="subst">&#123;testVec&#125;</span>&quot;</span>)</span><br><span class="line">    result = classify(myTree, featLabels, testVec)</span><br><span class="line">    <span class="keyword">if</span> result == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果: 放贷&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> result == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果: 不放贷&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130163735.png" alt="image-20220130163735362" style="zoom:60%;" /><h4 id="储存与导入"><a href="#储存与导入" class="headerlink" title="储存与导入"></a>储存与导入</h4><p>&emsp;&emsp;避免每次使用决策树都要从头开始拟合决策树，在一次构造后直接用 <code>pickle</code> 把决策树的参数 <code>dump</code> 到本地保存，下次使用时直接 <code>load</code> 出来使用显然效率更高。</p><p><strong>接上面的例子</strong></p><p>储存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明：存储决策树</span></span><br><span class="line"><span class="string">Parameters：</span></span><br><span class="line"><span class="string">    inputTree：已经生成的决策树</span></span><br><span class="line"><span class="string">    filename：决策树的存储文件名</span></span><br><span class="line"><span class="string">Returns：</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Modify：</span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span>(<span class="params">inputTree,filename</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        pickle.dump(inputTree,fw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    myTree=&#123;<span class="string">&#x27;有自己的房子&#x27;</span>:&#123;<span class="number">0</span>:&#123;<span class="string">&#x27;有工作&#x27;</span>:&#123;<span class="number">0</span>:<span class="string">&#x27;no&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;yes&#x27;</span>&#125;&#125;,<span class="number">1</span>:<span class="string">&#x27;yes&#x27;</span>&#125;&#125;</span><br><span class="line">    storeTree(myTree,<span class="string">&#x27;classifierStorage.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明:读取决策树</span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    filename：决策树的存储文件名</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    pickle.load(fr)：决策树字典</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2022-1-30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span>(<span class="params">filename</span>):</span></span><br><span class="line">    fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    myTree = grabTree(<span class="string">&#x27;classifierStorage.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(myTree)</span><br></pre></td></tr></table></figure><h4 id="sklearn库调用决策树"><a href="#sklearn库调用决策树" class="headerlink" title="sklearn库调用决策树"></a>sklearn库调用决策树</h4><p>&emsp;&emsp;Scikit-Learn 是基于 Python 的机器学习工具，建立在 NumPy、SciPy、Pandas 和 Matplotlib 之上，里面的 API 的设计非常好，所有对象的接口简单。具有：分类、回归、聚类、降维、模型选择和预处理的现成模块可以使用。</p><p>scikit-learn：<a href="https://scikit-learn.org.cn/">中文社区</a></p><p><strong>使用步骤</strong></p><ul><li><p>准备数据集</p></li><li><p>数据预处理：填补空白值，处理脏数据</p></li><li><p>分析数据集：快速检查数据，并使用createPlot()函数绘制最终的树形图</p></li><li><p>拟合决策树：使用createTree()函数拟合决策树，并存储其参数</p></li><li><p>使用决策树：导入参数，进行分类预测</p></li></ul><p><strong>分类器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">tree</span>.<span class="title">DecisionTreeClassifier</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    criterion=’gini’, <span class="comment"># 特征选择时的节点不纯度计算方式</span></span></span></span><br><span class="line"><span class="params"><span class="class">    splitter=’best’, <span class="comment"># 特征选择的策略</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_depth=<span class="literal">None</span>, <span class="comment"># 决策树最大深度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_split=<span class="number">2</span>, <span class="comment"># 决策树分叉时的最小信息增益的阀值</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_samples_leaf=<span class="number">1</span>, <span class="comment"># 叶子节点最少的样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_weight_fraction_leaf=<span class="number">0.0</span>, <span class="comment"># 叶子节点最小的样本权重和</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_features=<span class="literal">None</span>, <span class="comment"># 最大特征数量</span></span></span></span><br><span class="line"><span class="params"><span class="class">    random_state=<span class="literal">None</span>, <span class="comment"># 随机数种子</span></span></span></span><br><span class="line"><span class="params"><span class="class">    max_leaf_nodes=<span class="literal">None</span>, <span class="comment"># 最大叶子节点数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_decrease=<span class="number">0.0</span>, <span class="comment"># 内部节点再划分所需最小样本数</span></span></span></span><br><span class="line"><span class="params"><span class="class">    min_impurity_split=<span class="number">1e-7</span>, <span class="comment"># 节点划分最小不纯度</span></span></span></span><br><span class="line"><span class="params"><span class="class">    class_weight=<span class="literal">None</span>, <span class="comment"># 样本各类别的的权重</span></span></span></span><br><span class="line"><span class="params"><span class="class">    presort=<span class="literal">False</span> <span class="comment"># 数据是否预排序</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fit</span>(<span class="params">X, y[, sample_weight, check_input, …]</span>)</span></span><br><span class="line"><span class="class"># 根据训练集（<span class="title">X</span>，<span class="title">y</span>）建立决策树分类器</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测<span class="title">X</span>的类别或回归值</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">predict_proba</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 预测输入样本<span class="title">X</span>的类别概率</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">apply</span>(<span class="params">X[, check_input]</span>)</span></span><br><span class="line"><span class="class"># 返回每个叶子节点上被预测样本的索引</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">score</span>(<span class="params">X, y[, sample_weight]</span>)</span></span><br><span class="line"><span class="class"># 返回给定测试数据和标签上的平均准确度</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><p>详见：<a href="https://scikit-learn.org.cn/view/784.html">sklearn.tree.DecisionTreeClassifier</a></p><p><strong>示例</strong></p><p>使用 <code>sklearn.datasets</code> 中的 <code>iris</code> 数据集进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_class_tree</span>():</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    x = iris[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    y = iris[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">    dtc = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line">    clf = dtc.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;预测: <span class="subst">&#123;clf.predict(x_test)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;实际: <span class="subst">&#123;y_test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_class_tree()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130180210.png" alt="image-20220130180210088" style="zoom:60%;" /><h4 id="决策树可视化"><a href="#决策树可视化" class="headerlink" title="决策树可视化"></a>决策树可视化</h4><p>&emsp;&emsp;把构造好的决策树可视化出来能方便剪枝或理解，用 <a href="https://scikit-learn.org.cn/view/788.html">sklearn.tree.export_graphviz-scikit-learn</a> 先以Graphviz格式导出决策树 <code>tree_data</code>，然后用 <code>graphviz.Source(tree_data).render(“name”)</code> 即可把决策树绘制并保存到 <code>name.pdf</code> 文件。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_class_tree</span>():</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    x = iris[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    y = iris[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">    dtc = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.1</span>)</span><br><span class="line">    clf = dtc.fit(x_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;预测: <span class="subst">&#123;clf.predict(x_test)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;实际: <span class="subst">&#123;y_test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制决策树</span></span><br><span class="line">    dot_data = tree.export_graphviz(</span><br><span class="line">        clf, </span><br><span class="line">        out_file=<span class="literal">None</span>, </span><br><span class="line">        filled=<span class="literal">True</span>, <span class="comment"># 绘制彩色图</span></span><br><span class="line">        rounded=<span class="literal">True</span>, <span class="comment"># 方框设为圆角</span></span><br><span class="line">        special_characters=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    graph = graphviz.Source(dot_data)</span><br><span class="line">    graph.render(<span class="string">&quot;iris&quot;</span>, view=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_class_tree()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130180928.png" alt="image-20220130180928785" style="zoom:50%;" /><p>&nbsp;</p><p>或者也可以使用 <a href="https://scikit-learn.org.cn/view/789.html">sklearn.tree.export_text </a>来以文本格式导出树，示例如下：</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export_tree 绘制决策树</span></span><br><span class="line">r = tree.export_text(clf, feature_names=iris[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220130181718.png" alt="image-20220130181718835" style="zoom:60%;" />]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Classifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用画图工具/方法</title>
      <link href="/2022/01/26/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/01/26/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为经常用到画流程图、时序图等，所以就总结一下常用的画图工具/方法：</p><ul><li>VSCode+PlantUML</li><li>Typora</li><li>神经网络结构图</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203174821.png" alt="image-20220203174227516" style="zoom:40%;" /><span id="more"></span><p>&nbsp;</p><h2 id="MarkDown绘图"><a href="#MarkDown绘图" class="headerlink" title="MarkDown绘图"></a>MarkDown绘图</h2><p>&emsp;&emsp;Mermaid是一种简单的类似 Markdown 的脚本语言，通过 JavaScript 编程语言，将文本转换为图片。实现画图功能的并不是 Typora 本身，而是它内置的对 Mermaid 的支持。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title:example</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232624.png" alt="image-20220128232614051" style="zoom:50%;" /><p>&nbsp;</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><code>[*]</code> 表示开始或者结束，如果在箭头右边则表示结束。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">    [*] --&gt; s1</span><br><span class="line">    s1 --&gt; [*]</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232634.png" alt="image-20220128232634737" style="zoom:50%;" /><p>&nbsp;</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p>语法解释：<code>&lt;|--</code> 表示继承，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，学过 Java 的应该都知道。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Animal &lt;|-- Duck</span><br><span class="line">      Animal &lt;|-- Fish</span><br><span class="line">      Animal &lt;|-- Zebra</span><br><span class="line">      Animal : +int age</span><br><span class="line">      Animal : +String gender</span><br><span class="line">      Animal: +isMammal()</span><br><span class="line">      Animal: +mate()</span><br><span class="line">      class Duck&#123;</span><br><span class="line">          +String beakColor</span><br><span class="line">          +swim()</span><br><span class="line">          +quack()</span><br><span class="line">      &#125;</span><br><span class="line">      class Fish&#123;</span><br><span class="line">          -int sizeInFeet</span><br><span class="line">          -canEat()</span><br><span class="line">      &#125;</span><br><span class="line">      class Zebra&#123;</span><br><span class="line">          +bool is_wild</span><br><span class="line">          +run()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232652.png" alt="image-20220128232652835" style="zoom:50%;" /><p>&nbsp;</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong>方向</strong></p><table><thead><tr><th>字母表示</th><th>含义</th></tr></thead><tbody><tr><td>TB</td><td>从上到下</td></tr><tr><td>BT</td><td>从下到上</td></tr><tr><td>LR</td><td>从左到右</td></tr><tr><td>RL</td><td>从右到左</td></tr></tbody></table><p><strong>节点</strong></p><table><thead><tr><th>表述</th><th>说明</th><th>含义</th></tr></thead><tbody><tr><td>id[文字]</td><td>矩形节点</td><td>表示过程</td></tr><tr><td>id(文字)</td><td>圆角矩形节点</td><td>表示开始与结束</td></tr><tr><td>id((文字))</td><td>圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开成对</td></tr><tr><td>id{文字}</td><td>菱形节点</td><td>表示判断、决策</td></tr><tr><td>id&gt;文字 ]</td><td>右向旗帜节点</td><td></td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">subgraph 分情况</span><br><span class="line">A(开始)--&gt;B&#123;判断&#125;</span><br><span class="line">end</span><br><span class="line">B--第一种情况--&gt;C[第一种方案]</span><br><span class="line">B--第二种情况--&gt;D[第二种方案]</span><br><span class="line">B--第三种情况--&gt;F&#123;第三种方案&#125;</span><br><span class="line">subgraph 分种类</span><br><span class="line">F-.第1个.-&gt;J((测试圆形))</span><br><span class="line">F-.第2个.-&gt;H&gt;右向旗帜形]</span><br><span class="line">end</span><br><span class="line">H---I(测试完毕)</span><br><span class="line">C--票数100---I(测试完毕)</span><br><span class="line">D---I(测试完毕)</span><br><span class="line">J---I(测试完毕)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232710.png" alt="image-20220128232710479" style="zoom:50%;" /><p>&nbsp;</p><h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><p>序列图共有5个部分，分别是：<strong>参与者、消息线、循环、选择、可选、并行、注解</strong></p><p><strong>消息线</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>-&gt;</td><td>无箭头的实线</td></tr><tr><td>–&gt;</td><td>无箭头的虚线</td></tr><tr><td>-&gt;&gt;</td><td>有箭头的实线(主动发出消息)</td></tr><tr><td>–&gt;&gt;</td><td>有箭头的虚线(响应)</td></tr><tr><td>-x</td><td>末端为X的实线(主动发出异步消息)</td></tr><tr><td>–x</td><td>有箭头的实线(以异步形式响应消息)</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title: 小明买书</span><br><span class="line"></span><br><span class="line">participant consumer as 小明</span><br><span class="line">participant store as 书店</span><br><span class="line">participant publisher as 出版社</span><br><span class="line"></span><br><span class="line">consumer -&gt;&gt; store: 想买一本限量版书籍</span><br><span class="line">store --&gt;&gt; consumer: 缺货</span><br><span class="line">consumer -&gt;&gt; store: 隔一个月再次询问</span><br><span class="line">store --&gt;&gt; consumer: 抢完了</span><br><span class="line">loop 一个星期一次</span><br><span class="line">consumer -x +store: 有货了吗</span><br><span class="line">store --x -consumer: 正在订,有货马上通知你</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">store -&gt;&gt; publisher: 我要订购一批货</span><br><span class="line">publisher --x store: 返回所有书籍的类别信息</span><br><span class="line"></span><br><span class="line">alt 书籍类别符合要求</span><br><span class="line">store -&gt;&gt; publisher: 请求书单信息</span><br><span class="line">publisher --x store: 返回该类别书单信息</span><br><span class="line"><span class="keyword">else</span> 书单里的书有市场需求</span><br><span class="line">store -&gt;&gt; publisher: 购买指定数据</span><br><span class="line">publisher --x store: 确认订单</span><br><span class="line"><span class="keyword">else</span> 书籍不符合要求</span><br><span class="line">store --&gt;&gt; publisher: 暂时不购买</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">par 并行执行</span><br><span class="line">publisher -&gt;&gt; publisher : 生产</span><br><span class="line">publisher -&gt;&gt; publisher : 销售</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">opt 书籍购买量&gt;=500 &amp;&amp; 库存&gt;=50</span><br><span class="line">publisher -&gt;&gt; store : 出货</span><br><span class="line">store --x publisher : 确认收货</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Note left of consumer : 图书收藏家</span><br><span class="line">Note over consumer,store : 去书店购买书籍</span><br><span class="line">Note left of store : 全国知名书店</span><br><span class="line">Note over store,publisher : 去出版社进货</span><br><span class="line">Note left of publisher : 持有版权的出版社</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line"> title Pie Chart</span><br><span class="line"> <span class="string">&quot;Dogs&quot;</span> : 386</span><br><span class="line"> <span class="string">&quot;cats&quot;</span> : 567</span><br><span class="line"> <span class="string">&quot;rabbit&quot;</span> : 700</span><br><span class="line"> <span class="string">&quot;pig&quot;</span>:365</span><br><span class="line"> <span class="string">&quot;tiger&quot;</span> : 15</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232805.png" alt="image-20220128232805096" style="zoom:50%;" /><p>&nbsp;</p><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><p>甘特图一般用来表示项目的计划排期，目前在工作中经常会用到,语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。</p><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 工作计划</span><br><span class="line">    dateFormat  YYYY-MM-DD//底部的时间格式</span><br><span class="line">    </span><br><span class="line">    section Section</span><br><span class="line">    task1:a1, 2020-01-01, 30d</span><br><span class="line">    task2:des3, 2020-03-01, 15d</span><br><span class="line"> task3:crit, <span class="keyword">done</span>, 2020-02-30, 24h</span><br><span class="line">    Another task:after a1, 20d</span><br><span class="line">    </span><br><span class="line">    section Another</span><br><span class="line">    Task <span class="keyword">in</span> sec:2020-01-12, 12d</span><br><span class="line">    another task:24d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232832.png" alt="image-20220128232832655"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><p>&emsp;&emsp;时序图（Sequence Diagram），又名序列图、循序图、顺序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。</p><p>参考：<a href="https://blog.csdn.net/zh_weir/article/details/72675013?ops_request_misc=%7B%22request_id%22:%22164319070816780274150424%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319070816780274150424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-72675013.pc_search_insert_es_download&utm_term=plantuml&spm=1018.2226.3001.4187">PlantUML时序图</a></p><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>实、虚线</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232625.png" alt="image-20220126181332755" style="zoom:45%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123356.png" alt="image-20210825105656559" width="20%" /></td></tr><tr><td>加上消息序号</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126184441.png" alt="image-20220126184441218" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126184412.png" alt="image-20220126184412284" style="zoom:25%;" /></td></tr><tr><td>加上消息注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182343.png" alt="image-20220126182343867" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123358.png" alt="image-20210825112152648" width="50%" /></td></tr><tr><td>使用html标签</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182609.png" alt="image-20220126182609565" style="zoom: 50%;" /></td><td><img src="https://img-blog.csdnimg.cn/img_convert/e7e45fb167a8bdca3bbd15db36200413.png" alt="image-20210825120605218" style="zoom: 50%;" /></td></tr><tr><td>划分阶段</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182758.png" alt="image-20220126182757973" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123401.png" alt="image-20210825120927516" width="25%" /></td></tr><tr><td>延时</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182842.png" alt="image-20220126182842660" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123402.png" alt="image-20210825121326063" width="25%" /></td></tr><tr><td>加入间隔</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126182914.png" alt="image-20220126182914287" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123403.png" alt="image-20210825122232668" width="25%" /></td></tr><tr><td>消息者组合</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183011.png" alt="image-20220126183011477" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123404.png" alt="image-20210825122610329" width="35%" /></td></tr><tr><td>加入时序图说明</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183107.png" alt="image-20220126183107261" style="zoom:40%;" /></td><td><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20210826125958845.png" width="25%" /></td></tr><tr><td>加入标题和隐藏底部对象</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126183139.png" alt="image-20220126183139774" style="zoom:40%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123405.png" alt="image-20210825122941222" width="25%" /></td></tr><tr><td>不同消息者图案</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220128232626.png" alt="image-20220126183216677" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210825123406.png" alt="image-20210825110640942" width="60%" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p>参考：<a href="https://blog.csdn.net/zhangjikuan/article/details/53484558?ops_request_misc=%7B%22request_id%22:%22164319070816780274150424%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319070816780274150424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-53484558.pc_search_insert_es_download&utm_term=plantuml&spm=1018.2226.3001.4187">PlantUML流程图</a></p><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>基本</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185758.png" alt="image-20220126185758399" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185426.png" alt="image-20220126185426351" style="zoom: 60%;" /></td></tr><tr><td>if 判断</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185820.png" alt="image-20220126185820699" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185859.png" alt="image-20220126185859311" style="zoom:50%;" /></td></tr><tr><td>if-else 分支</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126185937.png" alt="image-20220126185937281" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190005.png" alt="image-20220126190005635" style="zoom:50%;" /></td></tr><tr><td>while 循环A</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190401.png" alt="image-20220126190401364" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190056.png" alt="image-20220126190056722" style="zoom:50%;" /></td></tr><tr><td>while 循环B</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190421.png" alt="image-20220126190421580" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190432.png" alt="image-20220126190432003" style="zoom:50%;" /></td></tr><tr><td>并行分支</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190516.png" alt="image-20220126190516615" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190535.png" alt="image-20220126190535053" style="zoom:50%;" /></td></tr><tr><td>注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190606.png" alt="image-20220126190606694" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190652.png" alt="image-20220126190652905" style="zoom:50%;" /></td></tr><tr><td>箭头类型</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190723.png" alt="image-20220126190723569" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190751.png" alt="image-20220126190751147" style="zoom:50%;" /></td></tr><tr><td>加框</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190824.png" alt="image-20220126190824440" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190908.png" alt="image-20220126190908480" style="zoom:50%;" /></td></tr><tr><td>分类</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126190941.png" alt="image-20220126190941323" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191010.png" alt="image-20220126191010243" style="zoom:50%;" /></td></tr><tr><td>分离</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191345.png" alt="image-20220126191345064" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191414.png" alt="image-20220126191414944" style="zoom:50%;" /></td></tr><tr><td>示例一</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191545.png" alt="image-20220126191545310" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191454.png" alt="image-20220126191454204" style="zoom:50%;" /></td></tr><tr><td>示例二</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191628.png" alt="image-20220126191628012" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126191655.png" alt="image-20220126191655656" style="zoom:50%;" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p>类图显示了系统的静态结构<br>类：类图中的主要元素，用矩形表示。矩形的上层表示类名、中层表示属性、下层表示方法。<br>类之间的关系：关联、依赖、聚集、泛化和实现五种。</p><p>五种类间关系的图形表示介绍：</p><table><thead><tr><th>关联</th><th>依赖</th><th>聚集</th><th>泛化 extends</th><th>实现 implements</th></tr></thead><tbody><tr><td>带实线的箭头</td><td>带虚线的箭头</td><td>菱形箭头</td><td>带实线的三角形箭头</td><td>带虚线的三角形箭头</td></tr></tbody></table><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126192936.png" alt="image-20220126192936034" style="zoom: 67%;" /><p>参考：<a href="https://blog.csdn.net/junhuahouse/article/details/80767632?ops_request_misc=%7B%22request_id%22:%22164319596516780265433006%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164319596516780265433006&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80767632.pc_search_insert_es_download&utm_term=plantuml%E7%B1%BB%E5%9B%BE&spm=1018.2226.3001.4187">PlantUML类图</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam packageStyle rect/&#x27; 加入这行代码，样式纯矩形&#x27;/</span><br><span class="line">interface Set&lt;&lt;接口&gt;&gt;&#123;</span><br><span class="line">boolean add (Object o)</span><br><span class="line">boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace com.ztman.org #green&#123;</span><br><span class="line">class HashSet&#123;</span><br><span class="line">+boolean add (Object o)</span><br><span class="line">+boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line">interface IntSet&#123;</span><br><span class="line">boolean add (int i)</span><br><span class="line">boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line">class IntHashSet&#123;</span><br><span class="line">+boolean add (int i)</span><br><span class="line">+boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Set &lt;|.. HashSet</span><br><span class="line">HashSet &lt;|-- IntHashSet</span><br><span class="line">IntSet &lt;|.. IntHashSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace cn #orange&#123;</span><br><span class="line">class TreeSet &#123;</span><br><span class="line">+boolean add (Object o)</span><br><span class="line">+boolean remove(Object o)</span><br><span class="line">&#125;</span><br><span class="line">class IntTreeSet&#123;</span><br><span class="line">+boolean add (int i)</span><br><span class="line">+boolean remove(int i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">com.ztman.org.IntSet &lt;|.. IntTreeSet</span><br><span class="line">TreeSet &lt;|-- IntTreeSet</span><br><span class="line">.Set &lt;|.. TreeSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><table><thead><tr><th>功能</th><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>定义一个类（上层-类名、中层-属性、下层-方法）</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193208.png" alt="image-20220126193208462" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193221.png" alt="image-20220126193221888" style="zoom:60%;" /></td></tr><tr><td>多样定义</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193308.png" alt="image-20220126193308095" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193329.png" alt="image-20220126193329644" style="zoom:50%;" /></td></tr><tr><td>静态属性+抽象方法</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193444.png" alt="image-20220126193444427" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193459.png" alt="image-20220126193459834" style="zoom:50%;" /></td></tr><tr><td>自定义类主题</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193549.png" alt="image-20220126193549745" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193609.png" alt="image-20220126193609454" style="zoom:50%;" /></td></tr><tr><td>注释</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193650.png" alt="image-20220126193650671" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126193720.png" alt="image-20220126193720778" style="zoom: 70%;" /></td></tr><tr><td>类及衍生类之间的关系逻辑</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126194153.png" alt="image-20220126194153706" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126194207.png" alt="image-20220126194207216" style="zoom:50%;" /></td></tr><tr><td>以命名空间分割，并在不同空间内类之间建立关系</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126195117.png" alt="image-20220126195117872" style="zoom:50%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126195133.png" alt="image-20220126195133029" style="zoom: 70%;" /></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h2 id="神经网络结构图"><a href="#神经网络结构图" class="headerlink" title="神经网络结构图"></a>神经网络结构图</h2><h3 id="PlotNeuralNet"><a href="#PlotNeuralNet" class="headerlink" title="PlotNeuralNet"></a>PlotNeuralNet</h3><p>这是github上一个开源的用Latex转换为PDF来绘制神经网络结构图的工具，<a href="https://github.com/HarisIqbal88/PlotNeuralNet">地址</a>，使用方法如下：</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:HarisIqbal88/PlotNeuralNet.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开linux终端，按照所需依赖</span></span><br><span class="line">sudo apt-get install texlive-latex-base</span><br><span class="line">sudo apt-get install texlive-fonts-recommended</span><br><span class="line">sudo apt-get install texlive-latex-extra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line"><span class="built_in">cd</span> pyexamples/</span><br><span class="line">bash ../tikzmake.sh test_simple</span><br></pre></td></tr></table></figure><p>如果出现报错：$‘\r‘: command not found，是因为Shell脚本在Windows系统编写时，每行结尾是\r\n，而在Linux系统中行每行结尾是\n，所以在Linux系统中运行脚本时，会认为\r是一个字符，此时使用指令：<code>sed -i &#39;s/\r//&#39; ../tikzmake.sh</code> 来去除脚本中的\r字符，然后再次执行 <code>bash ../tikzmake.sh test_simple</code> ，效果是生成一个神经网络结果图的pdf文件。</p><p><strong>绘制自己的神经网络</strong></p><p>&emsp;&emsp;经过尝试，本以为可以自己建一个文件夹然后写python程序，然后通过示例中的方法用 <code>tikzmake.sh</code> 脚本生成pdf，但失败了，所以以后使用时就把 <code>pyexamples/</code> 目录下的python文件中的网络结构部分代码改成自己的，然后像上一步运行示例一样使用。</p><p>&emsp;&emsp; <code>pycore/</code> 目录下有各种神经网络组件的python转换latex接口</p><p>神经网络部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改过的</span></span><br><span class="line">arch = [</span><br><span class="line">    to_head(<span class="string">&#x27;..&#x27;</span>),</span><br><span class="line">    to_cor(),</span><br><span class="line">    to_begin(),</span><br><span class="line">    to_Conv(<span class="string">&quot;conv1&quot;</span>, <span class="number">512</span>, <span class="number">64</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>,</span><br><span class="line">            to=<span class="string">&quot;(0,0,0)&quot;</span>, height=<span class="number">64</span>, depth=<span class="number">64</span>, width=<span class="number">2</span>),</span><br><span class="line">    to_Pool(<span class="string">&quot;pool1&quot;</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>, to=<span class="string">&quot;(conv1-east)&quot;</span>),</span><br><span class="line">    to_Conv(<span class="string">&quot;conv2&quot;</span>, <span class="number">128</span>, <span class="number">64</span>, offset=<span class="string">&quot;(1,0,0)&quot;</span>,</span><br><span class="line">            to=<span class="string">&quot;(pool1-east)&quot;</span>, height=<span class="number">32</span>, depth=<span class="number">32</span>, width=<span class="number">2</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;pool1&quot;</span>, <span class="string">&quot;conv2&quot;</span>),</span><br><span class="line">    to_Pool(<span class="string">&quot;pool2&quot;</span>, offset=<span class="string">&quot;(0,0,0)&quot;</span>, to=<span class="string">&quot;(conv2-east)&quot;</span>,</span><br><span class="line">            height=<span class="number">28</span>, depth=<span class="number">28</span>, width=<span class="number">1</span>),</span><br><span class="line">    to_SoftMax(<span class="string">&quot;soft1&quot;</span>, <span class="number">10</span>, <span class="string">&quot;(3,0,0)&quot;</span>, <span class="string">&quot;(pool1-east)&quot;</span>, caption=<span class="string">&quot;SOFT&quot;</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;pool2&quot;</span>, <span class="string">&quot;soft1&quot;</span>),</span><br><span class="line">    to_Sum(<span class="string">&quot;sum1&quot;</span>, offset=<span class="string">&quot;(1.5,0,0)&quot;</span>,</span><br><span class="line">           to=<span class="string">&quot;(soft1-east)&quot;</span>, radius=<span class="number">2.5</span>, opacity=<span class="number">0.6</span>),</span><br><span class="line">    to_connection(<span class="string">&quot;soft1&quot;</span>, <span class="string">&quot;sum1&quot;</span>),</span><br><span class="line">    to_end()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ../tikzmake.sh test_simple</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203172520.png" alt="image-20220203172520176" style="zoom: 33%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="NN-SVG"><a href="#NN-SVG" class="headerlink" title="NN-SVG"></a>NN-SVG</h3><p><a href="http://alexlenail.me/NN-SVG/LeNet.html">NN SVG</a> 是一个在线绘制神经网络结构体结构图的网站，可自定义网络层参数，十分方便</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203173138.png" alt="image-20220203173138234" style="zoom: 35%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="donets"><a href="#donets" class="headerlink" title="donets"></a>donets</h3><p>&emsp;&emsp;这是我无意间在github发现的一个轻量级绘制神经网络的开源python仓库：<a href="https://github.com/martisak/dotnets">dotnets</a>，使用 Python 和 Graphviz 生成前馈神经网络的图片。使用时更改 <code>dotnets.py</code> 中的网络结构即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">layers = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">layers_str = [<span class="string">&quot;Status&quot;</span>] + [<span class="string">&quot;Linear&quot;</span>] + [<span class="string">&quot;Relu&quot;</span>] + [<span class="string">&quot;Linear&quot;</span>] + [<span class="string">&quot;Beta&quot;</span>]</span><br><span class="line">layers_col = [<span class="string">&quot;none&quot;</span>] + [<span class="string">&quot;none&quot;</span>] * (<span class="built_in">len</span>(layers) - <span class="number">2</span>) + [<span class="string">&quot;none&quot;</span>]</span><br><span class="line">layers_fill = [<span class="string">&quot;black&quot;</span>] + [<span class="string">&quot;gray&quot;</span>] * (<span class="built_in">len</span>(layers) - <span class="number">2</span>) + [<span class="string">&quot;black&quot;</span>]</span><br><span class="line"></span><br><span class="line">penwidth = <span class="number">15</span></span><br><span class="line">font = <span class="string">&quot;Hilda 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;digraph G &#123;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tfontname = \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(font))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\trankdir=LR&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tsplines=line&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tnodesep=.08;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tranksep=1;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tedge [color=black, arrowsize=.5];&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tnode [fixedsize=true,label=\&quot;\&quot;,style=filled,&quot;</span> +</span><br><span class="line">      <span class="string">&quot;color=none,fillcolor=gray,shape=circle]\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clusters</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(layers)):</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\tsubgraph cluster_&#123;&#125; &#123;&#123;&quot;</span>.<span class="built_in">format</span>(i)))</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tcolor=&#123;&#125;;&quot;</span>.<span class="built_in">format</span>(layers_col[i])))</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tnode [style=filled, color=white, penwidth=&#123;&#125;,&quot;</span></span><br><span class="line">          <span class="string">&quot;fillcolor=&#123;&#125; shape=circle];&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">              penwidth,</span><br><span class="line">              layers_fill[i])))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\t&quot;</span>), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(layers[i]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;l&#123;&#125;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>, a), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;\t\tlabel = &#123;&#125;;&quot;</span>.<span class="built_in">format</span>(layers_str[i])))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nodes</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(layers)):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(layers[i - <span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(layers[i]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\tl&#123;&#125;&#123;&#125; -&gt; l&#123;&#125;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, a, i + <span class="number">1</span>, b))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><p><code>python3 dotnets.py | dot -Tpdf &gt; test.pdf</code></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220203174821.png" alt="image-20220203174227516" style="zoom:40%;" />]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高效工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于强化学习的5G无线接入网络切片动态资源优化</title>
      <link href="/2022/01/24/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing/"/>
      <url>/2022/01/24/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;文章提出了一种针对 5G 无线接入网络切片的动态资源分配的强化学习解决方案。每个随机到达的网络切片请求到达时都有优先级（权重）、吞吐量、计算资源和延迟要求，如果可行，它会在其请求的持续时间内分配可用的通信和计算资源。由于每个资源分配决策都会使某些资源暂时不可用，所以只能优化当前资源分配的短视解决方案对于网络切片变得无效。基于此背景，文章提出了一种 Q-Learning 解决方案，以根据受通信和计算约束的时间范围内授予的网络切片请求的总权重来最大化网络效用。结果表明，相对于短视、随机和先到先得的解决方案，强化学习在 5G 网络效用方面提供了重大改进。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Reinforcement%20Learning%20for%20Dynamic%20Resource%20Optimization%20in%205G%20Radio%20Access%20Network%20Slicing.pdf">Reinforcement Learning for Dynamic Resource Optimization in 5G Radio Access Network Slicing</a></p><span id="more"></span><p>&nbsp;</p><h2 id="研究内容及现有研究"><a href="#研究内容及现有研究" class="headerlink" title="研究内容及现有研究"></a>研究内容及现有研究</h2><h3 id="研究导向"><a href="#研究导向" class="headerlink" title="研究导向"></a>研究导向</h3><p>&emsp;&emsp;由于当前的资源分配将使某些资源在未来不可用，仅考虑给定时刻的资源和需求的短视解决方案无法有效地在时间范围内优化资源。基于此，文章提出了基于 Q-learning 算法的 RL 方案为 5G 网络切片动态分配资源，考虑动态分配资源块 (RB)、发射功率和计算资源，以支持从 5G 基站 gNodeB 到用户设备 (UE) 的下行链路通信。来自 UE 的每个网络切片请求都与优先级、吞吐量、CPU 使用率和延迟（截止日期）要求相关联，并且在特定的持续时间内得到服务。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><table><thead><tr><th>论文</th><th>内容</th></tr></thead><tbody><tr><td>[5]</td><td>考虑了网络切片和移动边缘计算 (MEC) 技术中的网络优化问题，并证明为最小化不同移动虚拟网络运营商之间的干扰而制定的资源分配问题是 NP-hard问题</td></tr><tr><td>[6]</td><td>表明网络内深度学习对于应用程序和设备特定的识别和流量分类问题很有前景</td></tr><tr><td>[7]</td><td>使用深度学习来管理网络负载效率</td></tr><tr><td>[8]</td><td>将RL和静态/循环调度方法进行了比较</td></tr><tr><td>[9]</td><td>考虑了带宽和计算资源</td></tr><tr><td>[10]</td><td>将使用 RL 的资源分配与启发式、尽力而为和随机方法进行了比较</td></tr><tr><td>[11]</td><td>在端到端移动网络系统上实现了网络切片的原型</td></tr><tr><td>[12]</td><td>将RL应用于云 RAN 中的节能资源分配，通过考虑相同频率的多个发射器和接收器（而不是 5G 时频块）</td></tr><tr><td>[13]</td><td>通过利用对通信请求的预测来研究 RL 的资源分配</td></tr><tr><td>[14]-[16]</td><td>将RL 用于无线应用中的资源分配</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h2 id="无线资源和网络切片请求"><a href="#无线资源和网络切片请求" class="headerlink" title="无线资源和网络切片请求"></a>无线资源和网络切片请求</h2><p>&emsp;&emsp;系统模型如图1所示。假设5G网络中有一个gNodeB，有N个UE。每个 UE 都需要连接到 gNodeB 才能对其应用程序进行网络访问。 5G网络支持三种流量：eMBB、URLLC和mMTC，因此UE 请求的下行链路通信服务（从 gNodeB 到 UE）具有关于不同吞吐量、CPU 使用和延迟（截止日期）要求以及不同优先级（相对重要性）的动态 QoE 级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214250.png" alt="image-20220122214250256" style="zoom: 33%;" /><center>图 1</center><p>&emsp;&emsp;请求由 gNodeB 处理，然后将具有相应资源块的适当网络切片分配给请求。如果一个请求还没有得到答复，它会留在队列中，直到它的最后期限（从请求到达到服务启动的时间限制）到期。这么做的目的是最大化支持请求的加权数量或提供的服务总量，其中权重代表这些请求的优先级。作为网络资源，考虑带宽、通信（传输）功率和 CPU 使用率。在时间 t，有一组活动请求 A(t)，其中包括刚刚到达的请求或等待列表中的请求（即尚未满足且其截止日期尚未到期的请求）。 QoE 可以用不同的形式来衡量，其中考虑了吞吐量、CPU 使用率和延迟要求。 UE i 对其网络切片请求 j 的 CPU 使用要求为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122213945.png" alt="image-20220122213945523" style="zoom: 37%;" /><p>其中 P Cij 是分配的计算资源（由 CPU 使用率衡量），pCij 是所需的最小资源。对于吞吐量，UE i 对其请求 j 的 QoE 要求为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214004.png" alt="image-20220122214004535" style="zoom:37%;" /><p>其中 Dij 是实现的数据速率，dij 是最低要求速率。 Dij 由分配的带宽 Fij 、分配的 gNodeB 发射功率 P Tij （用于下行链路业务）、用于 gNodeB 和 UE i 之间通信的调制编码方案以及包括干扰和路径损耗在内的信道效应确定。请注意，gNodeB 的每个天线通过空间复用服务于不同的用户。对于 5G NR，频带或频带组合中给定数量的聚合载波的近似数据速率 (bps) 计算如下 [18]：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214052.png" alt="image-20220122214052828" style="zoom:37%;" /><p>其中 K 是频段或频段组合中聚合的分量载波 (CC) 的数量，Rmax = 948/1024。对于第 k 个 CC，v(k) Layers 是支持的最大层数，Q(k)m 是最大支持的调制阶数，f (k) 是可以取值 1、0.8、0.75 或 0.4 的缩放因子， μ 是[19]中定义的参数，T μs 是子帧中的平均 OFDM 符号持续时间，其中 T μs = 10−3 14·2μ 对于正常循环前缀，N BW (k),μ P RB 是最大资源在给定频带（或组合）中 UE 支持的最大带宽 BW (k) 中的块分配，并且 O(k) 是开销（对于频率范围 1 中的上行链路，等于 0.08）。假设具有 QPSK 调制、60 kHz 子载波间隔和 10 MHz 带宽的单天线 UE，(3) 变为 r = c ·K，其中常数 c 约为 12.59 ×106。</p><p>&emsp;&emsp;假设使用 LDPC 编码作为前向纠错，相应的误码率 (BER) 进一步降低了实现的数据速率 r。为了计算不同 SNR 水平的 BER，文章使用 LPDC 编码模拟了 AWGN 信道中 QPSK 信号的性能（见图 2）。对于高于 -1 dB 的 SNR 值，BER 值为 0。数据速率 r 基于给定 SNR 下的 BER 性能进行缩放。因此，当 Kij 是聚合 CC 的数量并且 BERij 是 UE i 对其请求 j 的 BER 时，QoE 要求变为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122214208.png" alt="image-20220122214208479" style="zoom:37%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="动态资源分配的优化问题及Q-Learning模型"><a href="#动态资源分配的优化问题及Q-Learning模型" class="headerlink" title="动态资源分配的优化问题及Q-Learning模型"></a>动态资源分配的优化问题及Q-Learning模型</h2><h3 id="优化问题建模"><a href="#优化问题建模" class="headerlink" title="优化问题建模"></a>优化问题建模</h3><h4 id="短期分配优化"><a href="#短期分配优化" class="headerlink" title="短期分配优化"></a>短期分配优化</h4><p>设 <code>xij (t)</code> 表示在时间 t 是否满足 UE i 的请求 j 的二进制指示符（布尔值）。资源分配给网络切片的约束如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215408.png" alt="image-20220122215408681" style="zoom:50%;" /><p>其中 <code>F (t)</code>、<code>P C (t)</code> 和 <code>P T (t)</code> 分别是 gNodeB 在时间 t 的可用PRB、CPU计算资源和传输功率资源。 gNodeB 的某些资源可能已经分配给某些请求，这些请求尚未终止，因此某些资源可能不可用。</p><p>仅在时间 t 优化资源分配的短视目标是选择 Fij (t)、P Cij (t) 和 P Tij (t)，满足：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215439.png" alt="image-20220122215439619" style="zoom:50%;" /><p>其中 <code>wij</code> 是 UE i 的请求 j 反映其优先级的权重。上式也是网络切片分配优化的奖励。</p><h4 id="长期分配优化"><a href="#长期分配优化" class="headerlink" title="长期分配优化"></a>长期分配优化</h4><p>接下来考虑一定时间范围内的优化问题。资源从时间 t -1 更新到时间 t 如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215618.png" alt="image-20220122215618091" style="zoom:50%;" /><p>其中 <code>Fr(t - 1)</code>、<code>P Cr (t - 1)</code> 和 <code>P Tr (t - 1)</code> 是在时间 t -1 的PRB、CPU 使用率和传输能量，<code>Fa(t)</code>、<code>P Ca (t)</code> 和 <code>P Ta (t)</code> 分别是时间 t 内分配的PRB、CPU 使用率和传输功率资源。每个请求都有一个生命周期，如果在时间 t 满足（即服务在时间 t 开始），则该请求将在时间 t + lij 结束。将 R(t) 表示为在时间 t 结束（完成或过期）的请求集。在时间 t 释放和分配的资源由下式给出：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215745.png" alt="image-20220122215745803" style="zoom:50%;" /><p>和</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215758.png" alt="image-20220122215758606" style="zoom:50%;" /><p>然后，优化目标变为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215820.png" alt="image-20220122215820955" style="zoom:50%;" /><p>上式也是网络切片分配在长期优化时的奖励。</p><h3 id="强化学习算法"><a href="#强化学习算法" class="headerlink" title="强化学习算法"></a>强化学习算法</h3><p>&emsp;&emsp;文章使用 Q-learning 作为 Model-free RL 算法来学习确定在给定 State（可用资源和请求）下为 gNodeB 采取何种 Action（资源分配）的策略。 gNodeB 应用 Q-Learning 来计算函数 <code>Q : S × A → R</code> 来评估在状态 S 产生奖励 R 的动作 A 的质量，并维护为 Q 表。在每个时间 t，gNodeB 选择一个动作 at，观察一个奖励 rt，并从当前状态 st 转换到新状态 st+1（这个转换取决于当前状态 st 和动作 at），并更新 Q。</p><p>将 Q 初始化为随机矩阵开始，使用旧值和新信息的加权平均对 Q表 执行价值迭代更新，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122220114.png" alt="image-20220122220113981" style="zoom: 40%;" /><p>其中 <code>α</code> 是学习率 (0 &lt; α ≤ 1)，<code>γ</code> 是随着时间的推移奖励的折扣因子 (0 ≤ γ ≤ 1)，<code>maxa Q(st+1, a)</code> 是指Q的最优未来值的估计。</p><table><thead><tr><th>算法因子</th><th>对应值</th></tr></thead><tbody><tr><td>State</td><td><code>&#123;F(t)，PC (t)，PT (t)&#125;</code>，即gNodeB在时刻 t 的可用资源</td></tr><tr><td>Action</td><td>分配资源给请求</td></tr><tr><td>Reward</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122215820.png" alt="image-20220122215820955" style="zoom:50%;" /></td></tr></tbody></table><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>为了比较，文章还考虑了三种基本算法：</p><ul><li><p><strong>Random algorithm</strong></p><p>  可用资源被分配给统一随机选择的网络切片请求</p></li><li><p><strong>FCFS algorithm</strong></p><p>  可用资源根据请求的到达时间分配给网络切片请求，即在任何给定时间，如果可用资源足以批准该请求，则首先回答最旧的网络切片请求</p></li><li><p><strong>Myopic algorithm</strong></p><p>  只有通过解决优化问题（8）才能分配可用资源以最大化当前效用</p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p>&emsp;&emsp;先假设 gNodeB 接收到可能来自三个 UE 的请求，然后扩展到了更多 UE。对于每个 UE，请求以每个时隙 0.5 的速率到达。一个时隙对应于每个时间块，长度为 0.23 ms，子载波间隔为 60 kHz。 CPU 使用率增加 2%（总共 50 个级别）。对于每个请求，权重是 [1,5] 中的随机整数，生命周期在 [1,10] 插槽中随机分配，期限在 [1,20] 插槽中随机分配。发射功率可以有 5 个级别，最大接收 SNR 在 [1.5,3] 中随机选择。总频率为 10 MHz，分为 11 个频段。运行超过 1000 个时隙的相同场景来测试不同的算法： Q-learning、随机、FCFS 和Myopic算法。其中 Q-learning的折扣因子设置为 γ = 0.95、学习率设置为 α = 0.1。</p><p>&emsp;&emsp;表 I 给出了 Q-learning 和基本算法的性能比较，该表显示了每种算法实现的网络效用以及 Q-learning 相对于其他算法的网络效用改进的比率。结果表明，Q-learning 相较其他算法实现了更大的效用（满足请求的总权重）。另一方面，Myopic算法在不考虑未来的情况下选择当前的最佳决策，性能优于 FCFS 和随机资源分配，但远远落后于 Q-learning。Q-learning 的效用范围为 [1731, 1831]，Myopic算法的效用范围为 [1359, 1466]。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111009.png" alt="image-20220124111002730" style="zoom:50%;" /><center>表 1</center><p>&emsp;&emsp;接下来增加向 gNodeB 发送网络切片请求的 UE 数量，并改变 UE 的到达率。图 2 显示了网络实用程序规模如何随使用 Q-learning 时的 UE 数量变化。注意，随着对固定资源的需求增加，网络效用随着 UE 数量的增加而下降。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111209.png" alt="image-20220124111209039" style="zoom:50%;" /><center>图 2</center><p>&emsp;&emsp;在长期优化问题中，权重 <code>wij</code> 作为优先级分配给 UE i 的请求 j。接下来评估权重对优化结果的影响。为此，文章固定了一个 UE 的所有请求的权重。第一种情况为[1,1,1]，即所有请求的权重为1。第二种情况为[1,3,5]，即UE 1的所有请求的权重为1，UE 2的所有请求的权重为3 ，并且所有UE 3的请求权重为5。第三种情况是[5,3,1]。即，所有 UE 1 的请求权重为 5，所有 UE 2 的请求权重为 3，所有 UE 3 的请求权重为 1。表 II 中显示了每个 UE 的服务请求数。结果表明，如果 UE 的权重增加并且大于其他 UE，则该 UE 的服务请求数量相对于其他 UE 增加。另一方面，在对网络效用的影响方面，权重的实际值并没有权重的顺序发挥那么大的作用，即权重[1,2,3]与权重[1,3,5]获得相同的结果。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111436.png" alt="image-20220124111436388" style="zoom:50%;" /><center>表 2</center><p>&emsp;&emsp;接下来考虑 5G 雷达频谱共存场景，其中雷达信号可能随着时间的推移占据多个频率块。考虑雷达信号的两种到达模式：第一个模式对应于独立同分布（i.i.d.）到达，雷达信号出现在任何时间（时隙），概率为 <code>pI</code>。第二种模式对应于会话（突发）到达，会话的生命周期是从 [10,50] 个插槽中均匀随机选择的。然后调整会话的到达以获得作为现有占用概率的 <code>pI</code>。假设雷达信号被可靠地检测到。在 [22] 中，研究表明，当应用深度学习时，检测雷达信号的潜在误差会变低。</p><p>&emsp;&emsp;图 3 中展示了当改变现有用户的两种（i.i.d.和突发）到达类型的 <code>pI</code> 时，Q-learning 实现的网络效用。 Q-learning成功地适应了现有用户的频谱占用模式，并有效地利用了现有用户的频谱占用留下的网络资源。正如预期的那样，通过 Q 学习实现的网络效用随着 <code>pI</code> 的增加而下降，但这种下降与 <code>pI</code> 呈次线性关系。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220124111839.png" alt="image-20220124111839174" style="zoom:50%;" /><center>图 3</center>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信的资源调度器</title>
      <link href="/2022/01/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/22/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>无线通信资源调度论文</strong></p><ul><li><p>Joint Time-Frequency Domain Proportional Fair Scheduler with HARQ for 3GPP LTE Systems</p><blockquote><p>时/频调度器</p><p>TD：PF</p><p>FD：比较了不同算法（无、RR、MAX、PF、DA）</p><p>结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。</p></blockquote></li><li><p>Multi-QoS-Aware Fair Scheduling for LTE</p><blockquote><p>时/频调度器</p><p>TD：PF</p><p>FD：GBR用RR、nGBR用优先级分配</p><p>将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。</p></blockquote></li><li><p>HARQ Aware Frequency Domain Packet Scheduler with Different Degrees of Fairness for the UTRAN Long Term Evolution</p><blockquote><p>时/频调度器</p><p>TD：提供用户所需的QoS参数</p><p>FD：根据TD调度器给定的输入实现最高的频谱效率</p><p>另一个结论：D-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></blockquote></li></ul><span id="more"></span><p>&nbsp;</p><h1 id="论文-1"><a href="#论文-1" class="headerlink" title="论文 1"></a>论文 1</h1><p>&emsp;&emsp;文章利用了联合时域和频域调度的潜在分集增益。其中时域 (TD) 调度器实现公平性约束，使用了比例公平（PF）调度算法，在吞吐量和公平性之间维持平衡。然后频域 (FD) 调度器中提高吞吐量，在选定用户的先验 TD 调度的约束下优化多用户频率分集的增益。</p><p>原文：<a href="https://lrk612.com/resources/Joint%20Time-Frequency%20Domain%20Proportional%20Fair%20Scheduler%20with%20HARQ%20for%203GPP%20LTE%20Systems.pdf">Joint Time-Frequency Domain Proportional Fair Scheduler with HARQ for 3GPP LTE Systems</a></p><p>&nbsp;</p><h2 id="OFDMA-系统和信道模型"><a href="#OFDMA-系统和信道模型" class="headerlink" title="OFDMA 系统和信道模型"></a>OFDMA 系统和信道模型</h2><p>&emsp;&emsp;OFDMA 是一种基于 OFDM 的多址接入方案，数据在不同的子载波上传输给不同的用户。OFDMA 凭借其较高的频谱效率、对多径衰落的良好免疫能力而适用于LTE系统。文章假设的LTE OFDMA下行系统的关键参数如表1所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152003.png" alt="image-20220121151835454" style="zoom: 33%;" /><center>表 1</center><p>&emsp;&emsp;对于LTE系统中的频率复用用户，总带宽被划分为子信道，表示为物理资源块（PRB）。 PRB 是频域调度的最小分辨率。 10MHz 系统中有 50 个 PRB，每个 PRB 由 12 个相邻的子载波组成。子载波带宽为 15kHz，PRB 带宽为 180kHz。图 1 显示了如何对子载波进行分组和分配的示例。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152005.png" alt="image-20220121151909967" style="zoom: 50%;" /><center>图 1</center><p>&emsp;&emsp;如图 2 所示，可以为每个 PRB 反馈单个信道质量指标 (CQI)（根据 12 个子载波的平均质量计算得出）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152004.png" alt="image-20220121151854348" style="zoom: 50%;" /><center>图 2</center><h2 id="时频调度器"><a href="#时频调度器" class="headerlink" title="时频调度器"></a>时频调度器</h2><p>&emsp;&emsp;在时频调度器中，第一层调度在时域（TD）中实现，第二层在频域（FD）中实现。 TD调度器旨在选择信道相对较好的用户，同时保持对所有用户的公平。结合这一点，文章对比了不同的FD调度器。图 3 显示了信息如何输入调度程序以及时域和频域调度程序之间的交互。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152208.png" alt="image-20220121152208509" style="zoom:55%;" /><center>图 3</center><h3 id="时域调度器"><a href="#时域调度器" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;时域中使用 PF 算法。该算法的本质是为所有用户分配大约相同数量的资源（在一段时间内平均），并尝试在任何给定的调度间隔内挑选出信道条件接近其峰值的用户作为Active UE。用户优先级评价指标计算方法如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152549.png" alt="image-20220121152549563" style="zoom: 33%;" /><p>其中 <code>Rk(t)</code> 表示当前请求的传输速率，通常是根据用户的 <code>SINR</code> 反馈从一组可用的 <code>MCS</code> 中选择的。 <code>Tk(t)</code> 表示用户在过去一个窗口期内的平均吞吐量，由下式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152648.png" alt="image-20220121152648092" style="zoom: 40%;" /><p>其中 <code>tc</code> 是平均吞吐量的窗口期时长。文章中 <code>tc</code> 设置为 500。<code>Tk(t)</code>初始值默认取为第一次报告的 <code>CQI</code>，并基于链路自适应 (LA) 中用户选择的 <code>MCS</code>。</p><p>&emsp;&emsp;在 OFDMA 的上下文中选择具有最高优先级的用户子集，其数量称为“复用用户”并表示为 <code>k</code>，用于后续的 FD 调度。考虑单元内的所有用户，包括具有新数据的用户以及等待重传的用户。由于混合 ARQ 的增益，重传的用户将被优先考虑，因为他们的重传将有更高的成功传输机会。等待重传的用户的有效率根据以下公式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121152850.png" alt="image-20220121152850014" style="zoom: 40%;" /><p>其中 SNR_CC 是 Chase Combining 中重传的累积 SNR。</p><p>&nbsp;</p><h3 id="频域调度器"><a href="#频域调度器" class="headerlink" title="频域调度器"></a>频域调度器</h3><h4 id="No-Frequency-Domain-Scheduling-TD-PF）"><a href="#No-Frequency-Domain-Scheduling-TD-PF）" class="headerlink" title="No Frequency Domain Scheduling (TD-PF）"></a>No Frequency Domain Scheduling (TD-PF）</h4><p>&emsp;&emsp;频域不调度，意味着只在时域使用PF算法调度</p><h4 id="Round-Robin-FD-RR"><a href="#Round-Robin-FD-RR" class="headerlink" title="Round Robin (FD-RR)"></a>Round Robin (FD-RR)</h4><p>&emsp;&emsp;假设所有用户都需要相同的 QoS，以循环方式为TD中选出的Active UE进行分配。在重新分配给同一个用户之前，必须为所有用户分配一个 PRB。</p><h4 id="Max-C-I-（FD-MAX）"><a href="#Max-C-I-（FD-MAX）" class="headerlink" title="Max C/I （FD-MAX）"></a>Max C/I （FD-MAX）</h4><p>&emsp;&emsp;所有Active UE按SNR顺序排优先级进行PRB分配：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121162428.png" alt="image-20220121162428188" style="zoom:40%;" /><h4 id="Proportional-Fair-FD-PF"><a href="#Proportional-Fair-FD-PF" class="headerlink" title="Proportional Fair (FD-PF)"></a>Proportional Fair (FD-PF)</h4><p>&emsp;&emsp;优先级计算公式和上面时域的类似，按照优先级分配PRB：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121162434.png" alt="image-20220121162434640" style="zoom:40%;" /><p>其中 <code>Rk,j(t)</code> 表示 PRB j 处的瞬时可实现速率，<code>Tk(t)</code> 表示用户的平均吞吐量。为排名最高的用户 k 分配PRB j 以传输。</p><p>有两种 FD-PF 策略： </p><ul><li>每个新时间间隔（在分配所有 PRB 之后）都更新平均吞吐量 Tk(t)，记为 <code>FD PFⅠ</code></li><li>在每个 PRB 都被分配之后更新平均吞吐量 Tk(t) ，记为 <code>FD PFⅡ</code></li></ul><h4 id="Dynamic-Allocation-FD-DA"><a href="#Dynamic-Allocation-FD-DA" class="headerlink" title="Dynamic Allocation (FD-DA)"></a>Dynamic Allocation (FD-DA)</h4><p>&emsp;&emsp;上面所提出的算法确保选定用户之间的 PRB 份额相等，但容量不公平。DA算法具有较低复杂度，在同等资源约束下能给出近似最大化容量。在该算法中，N 表示从 1 到 50 的所有可用 PRB，k 表示每个时隙中要复用的用户数。算法如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121163036.png" alt="image-20220121163036592" style="zoom: 33%;" /><p>&nbsp;</p><h2 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h2><p>&emsp;&emsp;文章首先研究了随着小区中用户数量的增加，各种调度器的容量性能。</p><ul><li><p><code>FD-PF I</code> 和 <code>FD-PF II</code> 实现了几乎相同的性能，明显优于 <code>TD-PF</code>。</p></li><li><p>随着用户数量的增加，<code>FD-PF</code> 可以利用更多的多样性增益，从而提高性能增益，在资源分配相等的情况下明显优于 <code>FD-RR</code>。</p></li><li><p>当小区中有足够数量的用户时，<code>FD-DA</code> 调度器可以实现比 <code>TD-PF</code> 更高的吞吐量，其性能曲线的轻微振荡性质可归因于其当 PRB 的数量略超过用户数量的整数倍时，能够为强用户分配额外资源的能力。</p></li><li><p><code>FD-MAX</code> 调度器显然在容量方面提供了最好的性能，但在公平性方面预计不会达到良好的性能。</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121164713.png" alt="image-20220121164713673" style="zoom:38%;" /></li></ul><center>图 4 吞吐量随用户数量的变化</center><p>&emsp;&emsp;对于图 4 中的结果，每个时隙可能的复用用户数是固定的，并且等于小区中的用户数。但是，由于某些调度程序的性质，并非所有用户实际上都按时隙进行调度。图 5 显示了实际调度的数量。</p><ul><li><p>对于 <code>FD-RR</code> 和 <code>FD-DA</code> 调度算法，调度用户的数量始终等于复用用户的数量，因为这些算法确保所有用户之间的资源共享。 </p></li><li><p><code>FD-Max</code> 算法只偏爱具有高 SNR 的用户，这些用户取决于位置。</p></li><li><p>在 <code>FD-PF</code> 的结果中，策略 II 的平均调度用户数远高于策略 I。这是因为在策略 I 中，每个 PRB 之后的平均吞吐量没有瞬时更新，因此用户PF 排名较低的优先级将不会被选中。</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121165201.png" alt="image-20220121165201823" style="zoom:34%;" />  <center>图 5 复用用户数量对比调度的用户数量</center></li></ul><p>&emsp;&emsp;如果在频域中调度所有复用用户，多用户分集可能会被最大化，但时域中固有的多用户分集并没有被利用，特别是在等资源分配算法的情况下。图 6 显示了 <code>FD-PF I</code>、<code>FD-PF II</code> 和 <code>FD-DA</code> 调度器如何随着每个时隙中可能的多路复用用户数量的增加而执行。由于频域中的机会调度，这些调度器都受益于每个时隙中不断增加的复用用户数量。然而当大约 70% 的用户被复用时，增益会饱和，而当更多用户被复用时，增益会减小。这是因为资源分配给了所有用户，包括那些处于深度衰减中的用户，因此性能不佳。从这些结果可以得出结论，为了平衡时域和频域的分集增益，应该选择大约 50-70% 的所有用户作为可能的复用用户在每个时间实例中传输，以实现良好的交易-离开。特别是，<code>FD-DA</code> 在此范围内的性能明显优于两种 <code>FD-PF</code> 调度器。一旦由于将资源分配给所有可能的多路复用用户的约束，可能的多路复用用户的数量增加到超过此范围，<code>FD-DA</code> 性能就会更快地下降。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121173912.png" alt="image-20220121173912610" style="zoom:37%;" /><center>图 6 调度器性能随复用用户数量的变化</center><p>&emsp;&emsp;然后在图 7 中考虑了可能的多路复用用户数量等于所有用户的 50% 时的吞吐量性能（还显示了 100% 情况下的性能作为参考）。可以看出，当小区中有足够数量的用户时，<code>FD-DA</code> 优于所有除了 <code>TD-MAX</code> 之外其他的方案。还可以看出，<code>FD-PF</code> 策略对复用用户数量的敏感度远低于 <code>FD-DA</code>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121174323.png" alt="image-20220121174323663" style="zoom:37%;" /><center>图 7 选择50%复用用户时吞吐量表现</center><p>&emsp;&emsp;通常，吞吐量的增加是通过某种公平的妥协来实现的，反之亦然。因此，这里研究调度程序的公平性能。众所周知，按比例公平的调度程序应该最大化对数平均用户率的总和 [7]。文章采用了基于 [8] 的公平度量：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121174508.png" alt="image-20220121174508164" style="zoom:33%;" /><p>&emsp;&emsp;基于前面的结果，在一个 20 个用户的小区中，在每个时隙中选择 10 个（50%）复用用户进行 FD 调度取得了较好的结果。图 8 显示了各种调度器的公平性能，每个时隙中固定值为 10 个多路复用用户，以实现的公平度量的 cdf 的形式。 <code>FD-MAX</code> 在吞吐量方面是最佳的，但在公平性方面表现不如预期。 <code>FD-RR</code> 和 <code>TD-PF</code> 比 <code>FD-MAX</code> 实现了更好的公平性。通过利用时域和频域的多样性，可以更公平地为所有用户分配资源。因此，两种 <code>FD-PF</code> 策略都比 <code>TD-PF</code> 调度器实现了更好的公平性，<code>FD-PF II</code> 由于其更频繁地更新 Tk(t) 而更胜一筹。 <code>FD-DA</code> 试图在频域中最大化吞吐量，但通过分配相等的资源来保持公平元素，也表现良好，实现了比 <code>TD-PF</code> 和 <code>FD-PF I</code> 更好的公平性，与 <code>FD-PF II</code> 相似。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220121175554.png" alt="image-20220121175554030" style="zoom:38%;" /><center>图 8</center><p>&nbsp;</p><p>&nbsp;</p><h1 id="论文-2"><a href="#论文-2" class="headerlink" title="论文 2"></a>论文 2</h1><p>&emsp;&emsp;文章提出了一种服务感知 MAC 调度器算法，该算法在 MAC 层内定义了五个新的 QoS 类别。考虑到不同的QoS等级以及不同的信道条件来执行调度。目标是执行公平的 QoS 感知调度以及小区吞吐量优化。</p><p>原文：<a href="https://lrk612.com/resources/Multi-QoS-Aware%20Fair%20Scheduling%20for%20LTE.pdf">Multi-QoS-Aware Fair Scheduling for LTE</a></p><p>&nbsp;</p><h2 id="LTE协议分层"><a href="#LTE协议分层" class="headerlink" title="LTE协议分层"></a>LTE协议分层</h2><h3 id="UE-Node"><a href="#UE-Node" class="headerlink" title="UE Node"></a>UE Node</h3><p>&emsp;&emsp;UE高级节点模型的分层层次结构如图所示，它包括两组协议：LTE空中接口相关协议和终端用户应用协议。 LTE Uu 协议包括 PDCP、RLC、MAC 和 PHY 层。除 PHY 层协议外，所有其他协议均按照 3GPP 规范 [10] 实现。给物理层建模只是为了在 eNB 和 UE 实体之间传输用户数据的传输块。增强型 MAC 调度器旨在模拟 PHY 层特性。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125547.png" alt="image-20220122125547704" style="zoom: 30%;" /><center>图 9</center><h3 id="eNB-Node"><a href="#eNB-Node" class="headerlink" title="eNB Node"></a>eNB Node</h3><p>&emsp;&emsp;eNB 高级节点模型的协议层如图所示。节点模型 PDCP、RLC 和 MAC 的右侧协议代表了与 Uu 相关的功能。而节点模型 GTP、UDP、IP 和以太网的左侧协议代表与传输相关的功能。 MAC 调度器位于 eNB 的 MAC 层。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20220122125605813.png" alt="image-20220122125605813" style="zoom:30%;" /><center>图 10</center><p>&nbsp;</p><h2 id="MAC层调度器"><a href="#MAC层调度器" class="headerlink" title="MAC层调度器"></a>MAC层调度器</h2><p>&emsp;&emsp;MAC调度器负责在下行链路和上行链路的用户之间调度空口资源。由于 LTE 中使用了 OFDM 技术，调度器可以时域和频域中分配无线电资源。最小的调度资源单元称为物理资源块（PRB）。为了简化 LTE MAC 调度，定义了两个阶段：时域 (TD) 和频域 (FD) 调度器。TD 调度器用于根据用户的 QoS 特性来区分用户。 FD调度器负责在优先用户之间分配无线电资源（即PRB）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125657.png" alt="image-20220122125657578" style="zoom: 33%;" /><center>图 11</center><p>&emsp;&emsp;本文的 MAC 调度器考虑了两种主要类型的 QoS Bearer：保证比特率 (GBR) 和非保证比特率 (non-GBR)。如表 2所示，基于 QoS 类别标识符 (QCI)，传入的数据包按其优先级顺序分为五个不同的 MAC QoS 类别，这些类别由 MAC 调度程序定义。两个最高的 MAC QoS 等级（1 和 2）代表 GBR 承载，而其他三个代表 nGBR 承载。 MAC 调度器对所有 GBR 承载执行严格的优先级调度（即首先服务），然后调度 nGBR 承载。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125719.png" alt="image-20220122125719413" style="zoom:50%;" /><center>表 2</center><h3 id="时域调度器-1"><a href="#时域调度器-1" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;TD 调度程序创建两个候选列表（一个用于 GBR，另一个用于 nGBR）。 GBR 候选列表将 MAC-QoS1 类中的所有Bearer添加到候选列表顶部，然后添加 MAC-QoS2 类的Bearer。对于 nGBR 承载列表，TD 调度器将整个 nGBR MAC-QoS 类承载加入候选列表，然后根据它们的优先级因子对其进行优先级排序：</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20220122125727993.png" alt="image-20220122125727993" style="zoom:45%;" /><p>这里 <code>PF0</code> 是第 0 次迭代的优先级因子，<code>M-QoSweight</code> 是 MAC QoS 类的权重，<code>Raccum</code> 是该承载过去的累积数据速率。 <code>Raccum</code> 计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125738.png" alt="image-20220122125738674" style="zoom:50%;" /><p>这里 <code>Rinst(n)</code> 是第 n 个 TTI 的累积承载数据速率，<code>α</code> 是平滑因子，<code>Rinst</code> 是第 n 个 TTI 的瞬时承载数据速率。</p><h3 id="频域调度器-1"><a href="#频域调度器-1" class="headerlink" title="频域调度器"></a>频域调度器</h3><p>&emsp;&emsp;FD调度器从TD调度器提供的GBR候选列表开始。 PRB 的分配是迭代完成的，每次迭代为一个承载分配一个具有最高 SINR 值的 PRB。候选列表中的承载按序（基于其优先级）根据最高 SINR 值选择下一个最佳 PRB，此 PRB 分配过程继续进行，直到候选列表中的所有承载都获得一个 PRB。在每次迭代结束时，计算每个承载实现的数据速率，并检查承载缓冲区中是否有足够的数据可用，或者是否为该特定承载实现了足够的保证速率。如果满足上述条件之一，则将承载从候选列表中删除并调度。</p><p>&emsp;&emsp;每个承载的数据速率是通过分配的 PRB 的 SINR 计算的，其中所有分配的 PRB 的有效 SINR 值可以通过使用有效指数 SINR 映射 (EESM) [11] 来计算。然后将其与根据加性高斯白噪声 (AWGN) 块误码率 (BLER) 曲线计算的目标 SINR 值进行比较（通过设置目标 BLER 值，例如 10%）。如果有效 SINR 低于目标值，则降低调制和编码方案 (MCS)，并重新计算有效 SINR。否则，使用 [12] 中定义的 3GPP 表，确定传输块大小 (TBS)，它表示该 TTI 的承载数据速率。一旦调度了所有的 GBR 承载，FD 调度器就开始调度 nGBR 承载。 FD 调度器从 nGBR 候选列表中挑选最高的 N 个 nGBR 承载来服务于该 TTI。这里也使用了 GBR 调度中使用的相同迭代过程，但有一个例外：在每次迭代之后，使用新计算的优先级因子重新确定 nGBR 承载的优先级，如下所示：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122125959.png" alt="image-20220122125959106" style="zoom:50%;" /><p>其中 <code>PFj</code> 是第 j 次迭代的优先级因子，<code>TBSj</code> 是第 j 次迭代的传输块大小。</p><p>&emsp;&emsp;之所以在迭代之间重新对 nGBR 承载进行优先级排序，主要是为了让信道条件比其他承载更好的 nGBR 承载有更多机会优先选择其最佳PRB。</p><p>&nbsp;</p><h2 id="仿真结果-1"><a href="#仿真结果-1" class="headerlink" title="仿真结果"></a>仿真结果</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>&emsp;&emsp;为了展示 LTE MAC 调度程序如何服务和处理不同 QoS 服务的混合，文章研究了三种不同的场景，如表 3 所示，定义了具有四种不同 QoS 服务（VoIP、视频、HTTP 和 FTP）的用户。由于它们的实时性，它们中的一些必须具有更高的优先级。文章研究如果在一个 QoS 类中混合所有这些服务而不区分 GBR 和 nGBR 会发生什么，以及如果将它们分开会发生什么。其余仿真配置如表 4 所示。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122134943.png" alt="image-20220122134943929" style="zoom:50%;" /><center>表 3</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122134953.png" alt="image-20220122134953849" style="zoom:50%;" /><center>表 4</center><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>&emsp;&emsp;VoIP 用户的平均空中接口吞吐量如图 12 所示。结果表明，即使与 nGBR 承载映射在一起，VoIP 用户在所有不同场景下的吞吐量都相同。原因是时域调度中中的 <code>Raccum</code> 值表示的比例公平特性。由于 VoIP 承载具有相对较小的累积数据速率，它往往会获得更高的优先级因子，并且总是首先被调度。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145556.png" alt="image-20220122145556521" style="zoom:50%;" /><center>图 12</center><p>&emsp;&emsp;VoIP 的平均端到端延迟如图 13 所示。可以注意到，Sc2 和 Sc3 的端到端延迟比 Sc1 略好，这是因为前面的场景将 VoIP 承载映射到更高的 MAC QoS 等级（M-QoS2 和 M-QoS1）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145644.png" alt="image-20220122145644012" style="zoom:50%;" /><center>图 13</center><p>&emsp;&emsp;图 14 显示了视频承载的平均空中接口吞吐量。结果表明，与视频承载映射到 GBR MAC 类的其他两个场景相比，视频承载在 Sc1 场景中的性能更差。在 Sc1 场景中，视频承载与 VoIP、HTTP 和 FTP 承载共享相同的 nGBR MAC QoS 类。由于视频承载的累积数据速率非常高（~ 300 kbps），它们不会一直得到服务。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145725.png" alt="image-20220122145725333" style="zoom:50%;" /><center>图 14</center><p>&emsp;&emsp;Sc1 场景中视频承载的性能下降可以在图 15 中清楚地看到，平均端到端延迟。与视频承载获得更严格优先级的其他两种情况相比，视频承载遭受明显更高的端到端延迟。查看图 16 和图 17 所示的 HTTP 承载结果，可以注意到当 HTTP 承载被分配到更高的 MAC QoS 类时，它们具有更好的应用程序性能。主要是当它没有与 FTP 承载混合并且被分配到比 FTP 更高的 MAC QoS 类时。这是因为时域调度中的 M-QoS 权重被设置为比其他场景高十倍。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145804.png" alt="image-20220122145804733" style="zoom:50%;" /><center>图 15</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145839.png" alt="image-20220122145839311" style="zoom:50%;" /><center>图 16</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145906.png" alt="image-20220122145906349" style="zoom:50%;" /><center>图 17</center><p>&emsp;&emsp;最后，FTP 承载结果如图 18 和图 19 所示。从完全混合场景 Sc1 到完全分离场景 Sc3 时，FTP 性能降低。平均吞吐量减少，平均文件下载时间增加。这是因为 FTP 承载映射到最低的 MAC QoS 类别，并且与其他服务相比，其服务的优先级较低。然而，给 FTP 承载较低的优先级是现实的，因为 FTP 不是实时应用程序，FTP 用户可以等待几秒钟来下载他们的文件，而对于像 VoIP 这样的应用程序则不能这样说。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122145950.png" alt="image-20220122145950136" style="zoom:50%;" /><center>图 18</center><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122150003.png" alt="image-20220122150003682" style="zoom:50%;" /><center>图 19</center><p>&nbsp;</p><p>&nbsp;</p><h1 id="论文-3"><a href="#论文-3" class="headerlink" title="论文 3"></a>论文 3</h1><p>&emsp;&emsp;文章开发了一个两层调度框架，由一个时域 (TD) 调度器和一个频域 (FD) 调度器组成。结果表明这种方法可以有效地包含 HARQ 调度约束以及控制用户之间的公平性。</p><p>原文：<a href="https://lrk612.com/resources/HARQ%20Aware%20Frequency%20Domain%20Packet%20Scheduler%20with%20Different%20Degrees%20of%20Fairness%20for%20the%20UTRAN%20Long%20Term%20Evolution.pdf">HARQ Aware Frequency Domain Packet Scheduler with Different Degrees of Fairness for the UTRAN Long Term Evolution</a></p><p>&nbsp;</p><h2 id="调度器框架"><a href="#调度器框架" class="headerlink" title="调度器框架"></a>调度器框架</h2><p>&emsp;&emsp;调度中的实体：分组调度器、链路自适应（LA）和 HARQ 管理器之间的交互如图 20 所示。这些实体位于基站（eNode-B），以支持快速适应无线电频道条件。控制实体是包调度器。频域调度的最小单元是一个物理资源块（PRB），其带宽等于 375 kHz [1]。10 MHz 带宽中有24 个 PRB可用，每个 PRB 由 25 个相邻子载波组成。分组调度器可以咨询链路自适应，以获得小区中某些用户的支持数据速率的估计，用于不同的 PRB 分配。链路自适应基于来自用户的信道质量指示 (CQI) 反馈，以及来自过去传输的 Ack/Nack，以确保支持的数据速率的估计对应于某个块错误率 (BLER)第一次传输的目标。外环链路自适应用于稳定BLER性能[5]。 HARQ 管理器提供缓冲区状态信息以及未决 HARQ 重传的传输格式。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122152415.png" alt="image-20220122152415150" style="zoom:50%;" /><center>图 20</center><p>&emsp;&emsp;整个数据包调度框架如图 21 所示，其中提出了一个简单的两步算法。在步骤#1中，TD调度器选择在步骤#2中由FD调度器频率复用的N个用户。这个框架的复杂性较低，因为 FD 调度器只需要考虑每个 TTI 最多 N 个用户的频率复用。N的值是根据潜在的信令约束以及调度带宽中PRB的数量来设置的。假设小区中的用户数 D 大于 N (D &gt;N)，TD 调度器提供了控制用户 QoS 的主要机制，而 FD 调度器在给定来自 TD 调度程序的输入后，主要尝试优化每个 TTI 的频谱效率。由于 FD 调度器的用户多样性顺序有限，整体调度器性能将不是最佳的。值得注意的是，尽管调度框架由两个连续的步骤组成，但在许多情况下，TD 调度程序和 FD 调度程序之间存在依赖关系。 TD 调度器尤其如此，它依赖于过去交付给用户的平均吞吐量（即依赖于 FD 调度器）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122152712.png" alt="image-20220122152712124" style="zoom: 45%;" /><center>图 21</center><h3 id="时域调度器-2"><a href="#时域调度器-2" class="headerlink" title="时域调度器"></a>时域调度器</h3><p>&emsp;&emsp;图 21 中的TD调度器选择调度优先级最高的N个用户进行后续FD调度，其中N是TD调度器的参数。设用户 m 的瞬时支持吞吐量为 <code>rm[n]</code>，由假设简单的全带宽传输的链路适配单元获得，其中 eNode-B 传输功率在 PRB 之间平均分配。在不同的时域调度器算法中，都有为用户 m 定义了优先级度量，调度器选择在调度时具有该度量最高值的 N 个用户。例如：</p><table><thead><tr><th align="center">TD算法</th><th>优先级因子</th><th>备注</th></tr></thead><tbody><tr><td align="center">TD-PF</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122153543.png" alt="image-20220122153543916" style="zoom:50%;" /></td><td>Tm[n] 表示过去的平均交付用户吞吐量，通过 [7] 中概述的递归方法计算，n 表示当前调度间隔</td></tr><tr><td align="center">TD-MT</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122153619.png" alt="image-20220122153619747" style="zoom:50%;" /></td><td>此调度程序优先考虑靠近 eNode-B 的用户（即取吞吐量大小作为优先级）</td></tr><tr><td align="center">TD-BET</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164635.png" alt="image-20220122153706045" style="zoom:50%;" /></td><td>该调度程序旨在保持相同的用户吞吐量，而与用户位置无关，不需要无线电信道的先验知识</td></tr></tbody></table><p>&emsp;&emsp;TD 调度程序考虑的用户集包括具有新数据的用户以及具有未决重传的用户。此外，TD 调度程序不会优先考虑具有未决重传的用户。</p><h3 id="HARQ-感知的频域调度器"><a href="#HARQ-感知的频域调度器" class="headerlink" title="HARQ 感知的频域调度器"></a>HARQ 感知的频域调度器</h3><p>&emsp;&emsp;FD 调度器负责将 M 个可用的 PRB 分配给 N 个选定的用户。为了从多用户频率分集调度中获益，希望将用户映射到他们体验相对良好信道质量的那些 PRB。这是一个较复杂的优化问题：由于附加的约束条件使未决的 HARQ 重传必须在与原始传输相同数量的 PRB 上传输，从而导致问题更加复杂。但是FD 调度器仍然可以自由选择 PRB来重传，只要 PRB 的数量与原始传输相同（自适应 HARQ）。HARQ 管理中涉及的步骤如图 22 所示。为了限制 HARQ 重传延迟，我们选择在 FD 调度器中优先处理未决的 HARQ 重传。因此，假设 N 个用户中的 Q 个有未决的重传，需要分配 K 个 PRB，这留下 Y =M - K 个 PRB 用于从剩余的 L 个用户传输新数据（图 22 中的步骤 A）。首先将最多 Y 个 PRB 分配给 L 个用户以传输新数据（步骤 B）。这在为信道质量相对较高的用户选择 PRB 时提供了最大的灵活性，并往往会使新数据的传输吞吐量最大化。随后将剩余的 K 个 PRB 分配给 Q 个等待重传的用户（步骤 C）。这意味着与新数据相比，选择好的 PRB 进行重传的自由度较小。采用这种方法是因为重传并不需要信道质量特别良好，因为由于 HARQ 组合增益，重传更容易被正确接收。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122154054.png" alt="image-20220122154054412" style="zoom:40%;" /><center>图 22</center><p>&emsp;&emsp;用 <code>rm,b[n]</code> 表示用户 m 在 PRB b 上的瞬时吞吐量，该吞吐量估计取自链路自适应，并基于特定 PRB 的 CQI 报告，且假设每个 PRB 的功率相等。基于此，文章研究了以下 FD 调度器的性能：</p><table><thead><tr><th>TD算法</th><th>优化目标</th><th>备注</th></tr></thead><tbody><tr><td>FD-EQ (Equal Resource)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155752.png" alt="image-20220122155752811" style="zoom:50%;" /></td><td>m‘是被选择分配PRB的用户</td></tr><tr><td>FD-PF (Proportional Fair)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155802.png" alt="image-20220122155802095" style="zoom:50%;" /></td><td></td></tr><tr><td>FD-TA (Throughput-to-Average)</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122155813.png" alt="image-20220122155813461" style="zoom:50%;" /></td><td>其中 <code>rm[n]</code> 表示基于使用单一优化 MCS 格式的全 BW 传输的瞬时支持吞吐量</td></tr></tbody></table><p>&nbsp;</p><h2 id="仿真结果-2"><a href="#仿真结果-2" class="headerlink" title="仿真结果"></a>仿真结果</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122163138.png" alt="image-20220122163138727" style="zoom: 67%;" /><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164123.png" alt="image-20220122164123780" style="zoom: 67%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220122164244.png" alt="image-20220122164244820" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度强化学习在网络切片资源管理的应用</title>
      <link href="/2022/01/19/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Deep%20Reinforcement%20Learning%20for%20Resource%20Management%20in%20Network%20Slicing/"/>
      <url>/2022/01/19/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Deep%20Reinforcement%20Learning%20for%20Resource%20Management%20in%20Network%20Slicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;深度强化学习 (DRL) 侧重于如何通过尝试替代动作和强化产生更有益结果的倾向动作来与环境交互，是网络切片资源管理问题的一个有前途的解决方案。本文在简要回顾了 DRL 的基本概念后，研究了 DRL 在解决网络切片场景中一些典型资源管理的应用，包括<strong>无线资源切片</strong>和<strong>基于优先级的核心网络切片</strong>。最后还从一般的角度讨论了在网络切片中应用 DRL 可能面临的挑战。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119150855.png" alt="image-20220118210056206" style="zoom: 40%;" /><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Deep_Reinforcement_Learning_for_Resource_Management_in_Network_Slicing.pdf">Deep Reinforcement Learning for Resource Management in Network Slicing</a></p><span id="more"></span><p>&nbsp;</p><h2 id="问题导向及现有研究"><a href="#问题导向及现有研究" class="headerlink" title="问题导向及现有研究"></a>问题导向及现有研究</h2><p>为了提供更好的性能和成本效益的服务，切片上的实时资源管理主要面对如下问题：</p><ul><li><p>对于无线电接入网络，频谱是一种稀缺资源，保证频谱效率（SE）具有重要意义[8]；而对于核心网络，虚拟化功能受到计算资源的限制</p></li><li><p>切片租户的服务水平协议 (SLA) 通常对用户感知的体验质量 (QoE) 有着严格的要求 [9]</p></li><li><p>每个切片的实际需求很大程度上取决于移动用户的请求模式</p></li></ul><p>&emsp;&emsp;在 5G 时代，研究如何智能响应移动用户的服务请求动态至关重要 [7]，从而以可接受的频谱或计算资源为代价在每个切片中获得令人满意的 QoE [4]。网络切片的资源管理方向已经有一些相关工作，特别是在边缘计算 [10] 和物联网 [11] 等特定场景中。但是，这些工作都聚焦于特定场景而缺乏一般场景的考虑。[12] 建议采用遗传算法作为一般场景下切片间资源管理的进化手段，但是它并没有反映切片的 SLA 和所需资源量之间的关系。</p><p>&emsp;&emsp;AlphaGo [14] 的成功以及应用 DRL 在某些特定领域的资源分配问题中的应用，如功率控制 [16]、绿色通信 [17]、云无线接入网络 [18]、移动边缘计算和缓存 [19]-[21] 引起了将 DRL 应用于网络切片领域的研究兴趣。鉴于现有切片资源管理中具有挑战性的技术问题，仔细研究在以下方面应用 DRL 的性能至关重要：</p><ul><li><p>DRL的可行性</p><p>  DRL 是否在消耗可接受的网络资源（例如频谱）的同时产生令人满意的 QoE 结果？</p></li><li><p>对比现有资源管理方案</p><p>  例如，资源管理可以通过遵循精心设计的预测算法进行，也可以通过将可用资源等分到每个切片中来进行。前者意味着一个合理的选择，而后者则节省了大量的计算成本。因此，DRL 和方案之间的比较也很重要</p></li></ul><table><thead><tr><th>论文</th><th>相关内容</th></tr></thead><tbody><tr><td>[1]~[4]</td><td>5G相关概念</td></tr><tr><td>[5]~[7]</td><td>网络切片相关概念</td></tr><tr><td>[4]</td><td>QoE的含义，频谱资源与QoE的关系</td></tr><tr><td>[8]</td><td>频谱资源与频谱效率</td></tr><tr><td>[9]</td><td>服务水平协议 (SLA)  与 用户感知的体验质量 (QoE)  的关系</td></tr><tr><td>[10]</td><td>边缘计算中的网络切片资源管理</td></tr><tr><td>[11]</td><td>物联网中的网络切片资源管理</td></tr><tr><td>[12]</td><td>遗传算法应用于一般场景下的网络切片资源管理，但未反映SLA要求与所需资源量的关系</td></tr><tr><td>[13]~[15]</td><td>强化学习相关论文</td></tr><tr><td>[16]</td><td>强化学习求解功率控制中的资源分配问题</td></tr><tr><td>[17]</td><td>强化学习求解绿色通信中的资源分配问题</td></tr><tr><td>[18]</td><td>强化学习求解云无线接入网络中的资源分配问题</td></tr><tr><td>[19]~[21]</td><td>强化学习求解移动边缘计算和缓存中的资源分配问题</td></tr></tbody></table><p>&nbsp;</p><h2 id="网络切片资源管理"><a href="#网络切片资源管理" class="headerlink" title="网络切片资源管理"></a>网络切片资源管理</h2><h3 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h3><p>&emsp;&emsp;在无线通信的发展过程中，资源管理是一个永恒的话题。网络切片的资源管理可以从以下几个不同的角度来考虑：</p><ol><li><p><strong>无线资源和虚拟化网络功能</strong></p><p> &emsp;&emsp;如图所示，网络切片的资源管理涉及<strong>无线接入部分</strong>和<strong>核心网络部分</strong>，优化目标略有不同。</p><p> &emsp;&emsp;由于频谱资源有限，无线接入的资源管理关注如何为切片分配资源块（RB）以保持可接受的频谱效率(SE)，同时兼顾通信速率和低延迟。</p><p> &emsp;&emsp;核心网络中广泛采用的光传输将核心网络的优化方向转移到设计通用或专用的虚拟网络功能（VNF），以便以最小的调度延迟适当地转发来自特定切片的数据包。</p><p> &emsp;&emsp;通过平衡资源利用率（如 SE）和 QoE 满意度的权重，资源管理目标可以表示为 <code>R =ζ·SE+β·QoE</code>，其中 <code>ζ</code> 和 <code>β</code> 表示 SE 和 QoE 的权重</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118211133.png" alt="image-20220118211133807" style="zoom:50%;" /> <center>图2</center></li><li><p><strong>平等或优先调度</strong></p><p> &emsp;&emsp;作为控制平面的一部分，IETF [23] 已经为所有或多个切片定义了公共控制网络功能（CCNF）。 CCNF包括接入和移动管理功能（AMF）以及网络切片选择功能（NSSF），负责选择核心网络切片实例。因此，除了同等对待来自不同切片的流外，CCNF 还可能区分流。例如，来自超可靠低延迟通信 (URLLC) 服务的流可以以更高的优先级进行调度和配置，以便体验尽可能少的延迟。在这种情况下，为了平衡流的资源利用率（RU）和等待时间（WT），调度目标可以类似地写为RU和WT的加权和</p></li></ol><p>&emsp;&emsp;基于上述讨论可以得出结论：网络切片的资源管理目标应该考虑：频谱利用率(SE)、QoE 满意度、等待时间(WT)等因素，它们的加权总和作为强化学习Agent的Reward。</p><p>&nbsp;</p><h3 id="接入网：无线资源分配"><a href="#接入网：无线资源分配" class="headerlink" title="接入网：无线资源分配"></a>接入网：无线资源分配</h3><h4 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h4><p>&emsp;&emsp;在这一部分中，我们将讨论如何将 DRL 应用于无线电资源切片。在数学上，给定现有切片列表 <code>1,···,N</code> 共享聚合带宽 <code>W</code> 并具有波动需求 <code>d = (d1,···,dN )</code>，目标是给出带宽共享解决方案 <code>w = (w1,· ·· ,wN )</code>，从而使长期回报期望 <code>E&#123;R(w,d)&#125;</code> 最大化，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225751.png" alt="image-20220118225751473" style="zoom:67%;" /><p>&emsp;&emsp;求解这个优化问题的难点在于由于流量模型的波动性需求变化没有先验知识。因此，Model-Free的DQN模型正适用于此问题的求解。</p><h4 id="通信场景"><a href="#通信场景" class="headerlink" title="通信场景"></a>通信场景</h4><p>&emsp;&emsp;下文通过模拟一个场景来评估采用 DQN 解决此问题的性能，该场景包含一个具有三种业务（ VoIP、视频、URLLC）的单基站(BS)。在基站周围40米半径范围内随机分布有100个注册用户。这些订阅用户生成下表中的服务模型。VoIP 和视频服务完全采用 VoLTE 和视频流模型的参数设置，而 URLLC 服务采用 FTP 2 模型 [24] 的参数设置。从表(b)可以看出，URLLC 的数据包频率较低，而 VoLTE 对其数据包的带宽要求最小。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225918.png" alt="image-20220118225918334" style="zoom: 67%;" /><center>表(b)</center><h4 id="DQN建模"><a href="#DQN建模" class="headerlink" title="DQN建模"></a>DQN建模</h4><p>&emsp;&emsp;DQN相关参数如下表所示，Reward是系统 SE 和 切片 QoE。具体而言，DQN 代理每秒更新其 Q 值神经网络，并调整每个切片的带宽分配比例。每秒内以 0.5 ms 的粒度在每个切片内执行循环调度（Round-Robin）方法来分配频域资源，即每隔 0.5 ms 将每个 slice 的带宽顺序分配给每个 slice 内的活跃用户（Active UE）。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118225906.png" alt="image-20220118225906764" style="zoom:67%;" /><center>表(a)</center><h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>&emsp;&emsp;除了用 DQN 动态调整每秒的切片资源分配方案外，文章还列举了另外三种资源分配算法：</p><h5 id="基于需求预测的方法"><a href="#基于需求预测的方法" class="headerlink" title="基于需求预测的方法"></a>基于需求预测的方法</h5><p>先用<strong>长短期记忆（LSTM）</strong>来预测需求，即：VoIP、视频、URLLC 业务的活跃用户数量。根据预测结果，有两种方式来各切片分配带宽： </p><ul><li><p><strong>DP-No</strong> </p><p>  &emsp;&emsp;总带宽按各业务预测数据包数量比例分配。假设总带宽为 B，VoIP、视频、URLLC 的预测数据包数为 NVoIP、NVideo 和 NURLLC，则分配给这三个切片（即 VoIP、视频和 URLLC）的带宽分别为： </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118230416.png" alt="image-20220118230416930" style="zoom: 50%;" /></li><li><p><strong>DP-BW</strong> </p><p>  &emsp;&emsp;总带宽按（各业务预测数据包数量×该业务最低要求速率）的比例分配。假设三个切片所需的速率为 RVoIP、RVideo 和 RURLLC，则分配给 VoIP、视频和 URLLC 的带宽分别为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118230644.png" alt="image-20220118230644957" style="zoom:0%;" /></li></ul><p>然后各切片内部再使用Round-Robin方式为活跃用户分配带宽资源。</p><h5 id="硬切片法"><a href="#硬切片法" class="headerlink" title="硬切片法"></a>硬切片法</h5><p>总带宽平均分给三个业务的切片，然后各切片内部使用Round-Robin方式为活跃用户分配带宽资源。</p><h4 id="算法效果"><a href="#算法效果" class="headerlink" title="算法效果"></a>算法效果</h4><h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5><ul><li><p>系统频谱效率 SE </p><p>  每单位带宽每秒传输的比特数，其中从 基站(BS) 到用户的速率由香农容量公式得出。</p><p>  如果部分带宽已经分配给一个分片，但该分片在一个时隙没有业务活动，那么这部分带宽就被浪费了，从而降低了系统SE</p></li><li><p>QoE 满意率</p><p>  完全传输的满足速率和延迟要求的数据包数除以到达数据包的总数</p></li></ul><h5 id="DQN算法效果"><a href="#DQN算法效果" class="headerlink" title="DQN算法效果"></a>DQN算法效果</h5><p>&emsp;&emsp;下图展示了 DQN（γ = 0.9时）在无线资源管理中的学习过程。图 (a)∼(f) 给出了当 QoE 权重为 5000 且 SE 权重为 0.1 时 DQN 的初始性能。图 (g)∼(l) 提供了 50000 次学习更新中最后 50 次的性能。从这些子图中可以看出，DQN 一开始并不能很好地了解用户活动，分配的带宽波动很大。但是经过近 50000 次更新后，DQN 已经更加了解用户活动规律，并产生了一个状态带宽分配策略。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119143034.png" alt="image-20220119143034248"></p><center>图3.1</center><p>&emsp;&emsp;图 (m) 和图 (n) 显示了 SE 和 QoE 随每个学习时期的变化。从这两个子图中看出，较大的 QoE 权重会产生具有出色 QoE 性能的策略，同时会在系统 SE 性能上带来一定的损失。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119143057.png" alt="image-20220119143057419"></p><center>图3.2</center><h5 id="与其他算法对比"><a href="#与其他算法对比" class="headerlink" title="与其他算法对比"></a>与其他算法对比</h5><p>&emsp;&emsp;下面展示DQN与DP-No、DP-BW、硬切片和无切片4种的详细性能比较，其中 DQN 的Reward中QoE权重分次设为1、50、5000，且 DQN 的结果取 50000 次学习更新后的。</p><p>&emsp;&emsp;图 4(a)∼4(f) 使用饼图给出了分配给每个切片的总带宽的百分比，并在旁边标注了了 QoE 满意度。从图 4(a)∼4(b) 可以看出，传输天线从 64 个减少到 16 个（网络能力的下降和跨切片的潜在冲突的增加）时，网络带宽的重新分配倾向于消耗带宽但活动受限的 URLLC 切片。此外，从图 4(f) 可以看出，当下行传输使用 64 根天线时，“无切片”表现最好，因为传输能力足够，调度周期为 0.5 ms，而带宽分配给每个切片的速度每秒调整一次，因此捕捉需求变化的速度较慢。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144047.png" alt="image-20220119144047352"></p><center>图4.1    (a)DQN    (b)DQN    (c)DQN</center><p>&emsp;&emsp;当下行天线数量达到 32 根时，DQN 驱动方案对 URLLC 的 QoE 满意率为 81%，而“无切片”和“硬切片”方案分别仅提供 15% 和 41% 的 URLLC 满意率数据包。显然，应用 DQN 主要带来 URLLC 的 QoE 增益。原因在于，如表 (b) 所示，URLLC 的数据包大小的分布遵循截断的对数正态分布，平均值为 2 MByte，远大于 VoLTE 和视频服务。考虑到更大的传输量和严格的低延迟要求，要满足 URLLC 的 QoE 难度要大得多。在这种情况下，DQN 优于其他竞争方案，以略微降低频谱效率 (SE) 的代价提供 URLLC 的更高 QoE 增益。同时，图 4(d) 和图 4(e) 展示了基于需求预测的方案的分配结果，并显示出其明显较差的性能，因为图 3(a)∼3(c) 和图 3(g) )∼3(i) 表明视频数据包的数量在传输中占主导地位，简单的基于数据包数的预测无法捕捉需求和 QoE 之间的复杂关系。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144109.png" alt="image-20220119144109034"></p><center>图4.2    (d)DP-BW    (e)DP-No    (f)No Sliicing</center><p>&emsp;&emsp;图 4(g) 说明 DQN 的这种 QoE 优势是以降低 SE 为代价的。回顾 DQN 中奖励的定义，如果我们将 QoE 权重从 5000 降低到 1，DQN 可以学习另一种带宽分配策略（图 4(c)），从而产生更大的 SE 但更低的 QoE。图 4(g) ∼ 4(j) 进一步总结了 SE 或 QoE 满意度方面的性能比较，其中垂直误差条显示标准推导。这些子图验证了 DQN 在资源有限的场景中的灵活性和优势，以确保每个用户的 QoE。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220119144124.png" alt="image-20220119144124792"></p><center>图4.3    (g)System SE    (h)VolTE QoE    (i)Video QoE    (j)URLLC QoE</center><p>&nbsp;</p><h3 id="核心网：基于优先级的公共VNFS调度"><a href="#核心网：基于优先级的公共VNFS调度" class="headerlink" title="核心网：基于优先级的公共VNFS调度"></a>核心网：基于优先级的公共VNFS调度</h3><p>&emsp;&emsp;上节讨论了如何在接入网部分应用 DRL 到无线电资源切片中。类似地，如果将计算资源虚拟化为每个切片的 VNF，则可以解决核心网部分为每个 VNF 分配计算资源的问题。这一部分讨论针对普通 VNF 的基于优先级的核心网络切片。</p><h4 id="通信场景-1"><a href="#通信场景-1" class="headerlink" title="通信场景"></a>通信场景</h4><p>&emsp;&emsp;文章模拟了一个场景，其中存在 3 个服务功能链 (SFC)，它们具有相同的基本能力，但以不同的计算处理单元 (CPU) 为代价工作，并产生不同的配置结果（例如，等待时间）。基于商业价值或相关的 SLA，可以将流分为 3 类（例如，A 类、B 类和 C 类），优先级从 A 类到 C 类递减，并且基于优先级的调度规则定义：</p><ul><li>SFC I：将 A 类流量优先于其他流量</li><li>SFC II：同等对待 A 类和 B 类用户，但服务于 C 类流量的优先级较低</li><li>SFC III：平等对待所有流程</li></ul><p>SFC 的流程根据到达时间具有相同的优先级。每个 SFC 最终使用的 CPU 取决于其处理流的数量。此外，SFC I、II 和 III 需要 2、1.5 和 1 个 CPU，但无论流量大小如何，都会分别产生 10、15 和 20 毫秒时延。因此，受限于 CPU 数量的限制，每种类型的流将被调度到适当的 SFC，从而产生可接受的等待时间。因此，流的调度应该匹配和学习三类流的到达顾规律，DQN正派上用场。</p><h4 id="DQN建模-1"><a href="#DQN建模-1" class="headerlink" title="DQN建模"></a>DQN建模</h4><p>&emsp;&emsp;首先是DQN模型输入、输出和参数的具体设置。文章将 DQN 的State抽象为最近 5 个流的类别和到达时间以及新到达流的类别的汇总，而Reward定义为该流的处理和排队时间的加权总和，其中在这个总和中采用较大的权重来反映具有较高优先级的流的重要性。此外，文章还事先通过模拟来自三个类别用户的对数正态分布到达间隔时间的一些流来预训练其 NN。</p><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p>&emsp;&emsp;下面将 DQN 方案与直观的“无优先级”解决方案（将流量分配给 SFC，从而产生最短的等待时间）进行比较。图 5 通过随机生成 10000 个流并相应地提供相关性能，其中纵轴和横轴分别表示使用的 CPU 数量和流的等待时间。二维底纹颜色反映了具体等待时间和 CPU 利用率对应的流数。颜色越深意味着数值越大。 与“无优先级”解决方案相比，基于 DQN 的切片结果提供流程具有更短的平均等待时间（即比“无优先级”低 10.5%）和更充足的 CPU 使用率。也就是说，DQN 可以支持替代解决方案，通过首先为具有更高商业价值的用户服务来利用计算资源并减少等待时间。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118231408.png" alt="image-20220118231408140"></p><center>图5</center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;从本文的讨论中发现，将分配的资源与用户的活动需求相匹配将是有效实现网络切片的最关键挑战，而 DRL 可能是一个很有前途的解决方案。文章解释了 DQN 解决此问题的工作机制和应用动机，通过广泛的模拟进一步证明了 DQN 在两种典型切片场景中管理这种需求感知资源分配的优势，包括无线电资源切片和基于优先级的核心网络切片。结果表明，与基于需求预测和其他一些直观的解决方案相比，DQN 可以在资源受限的场景中隐含地包含需求（即用户活动）和供应（即资源分配）之间更深层次的关系，并提高网络切片的有效性和敏捷性。</p><p>&emsp;&emsp;然而，网络切片涉及许多方面，DQN 的应用需要仔细考虑：</p><ul><li><p>对新切片的接纳控制</p><p>  &emsp;&emsp;网络切片的成功意味着动态和敏捷的切片管理方案。因此，如果出现对新切片的请求，如何应用 DQN 及时调整策略也是一个有问题，因为定义的状态和动作空间需要适应切片空间的变化。</p></li><li><p>State和Reward的抽象</p><p>  &emsp;&emsp;第三部分提供了两个问题下的抽象状态和动作的方法。这两种方法在相关场景中听起来都很实用，并体现了 DQN 的灵活性。</p></li><li><p>获取奖励的延迟和准确性</p><p>  &emsp;&emsp;第三部分中，状态-动作的奖励是假设即时和准确的。但是这种假设在实际复杂的无线环境中不再成立，因为用户设备报告信息需要时间，网络可能无法成功接收反馈。</p></li><li><p>策略学习成本</p><p>  &emsp;&emsp;无线信道和用户活动的时变特性需要快速的策略学习方案。然而，目前的策略训练速度较慢。例如，文章作者在英特尔酷睿 i7-4712MQ 处理器中对基于优先级的网络切片策略的预训练需要两天时间才能收敛 Q 值函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2022/01/17/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/17/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;作为Unix操作系统的重要概念，进程和线程相关知识在程序设计中关键且重要。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117234703.png" alt="image-20220117233440701" style="zoom: 27%;" /><span id="more"></span><p>&nbsp;</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;进程是资源（CPU时间、内存等）分配的基本单位，程序运行时系统就会创建一个进程并为它分配资源，然后该进程进入就绪队列，进程调度器选中就绪的进程并为它分配CPU时间使该进程的程序开始运行。在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>&emsp;&emsp;Linux进程结构可由三部分组成：代码段、数据段、堆栈段，也就是程序、数据、进程控制块PCB（Process Control Block）组成。进程控制块是进程存在的惟一标识，系统通过PCB的存在而感知进程的存在。<br>&emsp;&emsp;系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行程序、退出进程以及改变进程的优先级等。而进程中的PCB用一个名为 <code>task_struct</code> 的结构体来表示，定义在 <code>include/linux/sched.h</code> 中，每当创建一新进程时，便在内存中申请一个空的 <code>task_struct</code> 结构，填入所需信息，同时，指向该结构的指针也被加入到task数组中，所有进程控制块都存储在task[]数组中。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：进程序只是指令集合，进程是被赋予了时间概念的指令，具有生命周期和不同状态</li><li>并发性：多个进程可以在单个CPU上并发执行，不会互相影响</li><li>独立性：每个进程拥有私有的地址空间，不同进程的信息无法相互直接使用，可以通过进程间通信来传输信息</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推 进</li><li>结构特征：进程由程序、数据和进程控制块三部分组成</li></ul><p>&emsp;&emsp;多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变。</p><h3 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h3><p>程序：完成特定任务的一系列指令集合 </p><blockquote><p>代码段+数据段</p><p>放在磁盘中的程序</p></blockquote><p>进程：进行就是正在进行中的程序</p><blockquote><p>用户角度： 进程是程序的一次动态执行过程</p><p>操作系统： 进程是操作系统分配资源的基本单位，也是最小单位</p></blockquote><p><strong>具体区别</strong></p><ul><li>程序是指令和数据的有序集合，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个 动态的概念</li><li>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的</li><li>进程是由进程控制块、程序段、数据段三部分组成</li><li>进程具有创建其他进程的功能，而程序没有</li><li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程</li><li>在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单元都是进程</li></ul><p><strong>CPU执行程序过程</strong></p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117233010.png" alt="image-20220117233010543"></p><h3 id="进程的3种基本状态"><a href="#进程的3种基本状态" class="headerlink" title="进程的3种基本状态"></a>进程的3种基本状态</h3><p>&emsp;&emsp;CPU一次只能处理一个程序，CPU速度很快而内存很慢，所以CPU会有大量的时间都是空闲的。而CPU又是很昂贵的，为了解决浪费CPU的情况，就出现了中断处理，将程序分成一小片一小片的，这个进程执行一点，那个进程执行一点。虽然在内部进程的执行是一段一段的，但是CPU的速度很快的（速度都是纳秒级别的），所以我们是感受不到进程执行过程中的停顿的。</p><p>&emsp;&emsp;既然是一段一段执行，CPU在执行一个进程时，其他的进程就处于等待状态，为什么执行当前的这个进程而不是其他进程呢？这就要分情况讨论了，有可能是因为轮到它们的时间片用完了，也可能是它在等待某种资源等，所以在内存中每个进程的状态可能是不同的，进程的3种基本状态为：</p><table><thead><tr><th>状态</th><th align="left">说明</th></tr></thead><tbody><tr><td>就绪状态</td><td align="left">进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列</td></tr><tr><td>运行状态</td><td align="left">进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以 执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程</td></tr><tr><td>阻塞状态</td><td align="left">由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生 前即使把处理机分配给该进程，也无法运行</td></tr></tbody></table><p>再细分的话，可以分为7种状态：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117233202.png" alt="image-20220117233202038" style="zoom: 45%;" /><h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p>使用 <code>ps</code> 命令查看当前终端的进程：</p><blockquote><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117195333.png" alt="image-20220117195333110" style="zoom:50%;" /></blockquote><p>使用 <code>ps -ef</code> 命令查看系统全部进程：</p><blockquote><p>UID：启动进程的操作系统用户</p><p>PID：进程编号（用来kill）</p><p>PPID：进程的父进程编号</p><p>C：CPU使用的资源百分比</p><p>STIME：进程启动时间</p><p>TTY：进程所属的终端</p><p>TIME：使用掉的CPU时间</p><p>CMD：进程所执行的指令</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117195450.png" alt="image-20220117195450631" style="zoom:50%;" /></blockquote><p>如果进程太多，可以使用 <code>ps -ef | more</code> 命令使结果分页显示。</p><p>使用 <code>top</code> 查看进程</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118112901.png" alt="image-20220118112901440" style="zoom:45%;" /></blockquote><p>使用 <code>kill</code> 中止进程：</p><blockquote><p>killall &lt;进程名&gt;</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117215326.png" alt="image-20220117215326524" style="zoom:50%;" /><p>kill &lt;进程编号&gt;</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117215406.png" alt="image-20220117215406374" style="zoom:50%;" /></blockquote><p>获取本程序运行时的进程编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid()</span><br><span class="line">// 返回值即为进程编号</span><br></pre></td></tr></table></figure><p>注意，进程的编号是系统动态分配的，相同程序在不同时间执行时进程编号不同；进程编号会循环使用，但操作系统会保证同一时间进程编号不重复。</p><p>&nbsp;</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>&emsp;&emsp;进程的数据空间是独立、私有的，不能互相访问，但是在某些情况下进程间需要通信来实现某功能或交换数据，包括：</p><ol><li>数据传输：一个进程需要将它的数据发送给另一个进程</li><li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如通知进程退出）</li><li>进程控制：一个进程希望控制另一个进程的运行</li></ol><p>进程通信的方式大致分为六种：</p><table><thead><tr><th>方式</th><th>介绍</th></tr></thead><tbody><tr><td>管道(pipe)</td><td>包括无名管道、命名管道，无名管道可用于具有父进程和子进程之间的通信，命名管道则克服了管道没有名字的限制，故除了具有管道所具有的功能外，还支持无亲缘关系进程间的通信</td></tr><tr><td>消息队列(message)</td><td>进程可以向队列中添加消息，其他进程则可以读取队列中的消息</td></tr><tr><td>信号(signal)</td><td>信号用于通知其他进程有某种事件发生</td></tr><tr><td>共享内存(shared memory)</td><td>多个进程可以访问同一块内存空间</td></tr><tr><td>信号量(semaphore)</td><td>又称为信号灯，用于进程间对共享资源进行加锁</td></tr><tr><td>套接字(socket)</td><td>可用于不同计算机之间的进程间通信</td></tr></tbody></table><p>&emsp;&emsp;Socket可以完全替代只能在同一系统中进程之间通信的管道和消息队列；信号的应用场景非常多，主要用于进程的控制，例如通知正在运行中的后台服务程序退出；同一系统中，进程间采用共享内存交换数据的效率是最高的，为了避免对共享内存访问的冲突，一般会同信号量加锁一起使用。</p><p>&nbsp;</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;软中断信号（signal，又简称为信号）是Linux下用来在进程间传递消息的方式之一，也是进程间唯一的异步通信方式。从命名中可以看出信号的实质很像中断。进程间可以通过调用kill库函数发送软中断信号，Linux内核也可能给进程发送信号，用以告知该进程发生了某个异步事件。</p><p>&emsp;&emsp;注意，信号只用来告知进程发生了某个异步事件，并不用来传递数据。进程收到信号后会有三种处理方式：</p><ul><li>忽略，不做任何处理</li><li>执行预先设置的处理函数（就像中断服务程序一样）</li><li>采用系统的默认操作，大部分是终止进程</li></ul><h4 id="信号的来源"><a href="#信号的来源" class="headerlink" title="信号的来源"></a>信号的来源</h4><ol><li><p>用户</p><p>一般是键盘的输入会作为信号发送给进程，比如：<code>Ctrl + C</code> 发送SIGINT信号给进程，默认动作为终止进程；<code>Ctrl + \</code> 发送SIGQUIT信号给进程，默认动作为终止进程并进行内核映像转储（core dump）</p></li><li><p>内核</p><p>当进程执行出错时，内核给进程发送一个对应信号，例如：非法内存引用、浮点数溢出、执行非法指令</p></li><li><p>进程</p><p>C++的kill库函数用于进程间发送信号</p></li></ol><h4 id="信号的类型"><a href="#信号的类型" class="headerlink" title="信号的类型"></a>信号的类型</h4><table><thead><tr><th>信号名</th><th>信号值</th><th>默认处理动作</th><th>发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>A</td><td>终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td><strong>2</strong></td><td><strong>A</strong></td><td><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td>3</td><td>C</td><td>键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td>4</td><td>C</td><td>非法指令</td></tr><tr><td>SIGABRT</td><td>6</td><td>C</td><td>由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td>8</td><td>C</td><td>浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td><strong>9</strong></td><td><strong>AEF</strong></td><td><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td></tr><tr><td><strong>SIGSEGV</strong></td><td><strong>11</strong></td><td><strong>C</strong></td><td><strong>无效的内存引用</strong></td></tr><tr><td>SIGPIPE</td><td>13</td><td>A</td><td>管道破裂:写一个没有读端口的管道</td></tr><tr><td>SIGALRM</td><td>14</td><td>A</td><td>由alarm(2)发出的信号</td></tr><tr><td><strong>SIGTERM</strong></td><td><strong>15</strong></td><td><strong>A</strong></td><td><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>A</td><td>用户自定义信号1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>A</td><td>用户自定义信号2</td></tr><tr><td><strong>SIGCHLD</strong></td><td><strong>20,17,18</strong></td><td><strong>B</strong></td><td><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td></td><td>进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>DEF</td><td>终止进程</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>D</td><td>控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>D</td><td>后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>D</td><td>后台进程企图从控制终端写</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><ul><li>A：缺省的动作是终止进程</li><li>B：缺省的动作是忽略此信号，将该信号丢弃，不做处理</li><li>C：缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是可以得到进程当时执行时的数据值，方便确定转储的原因，并且调试程序</li><li>D：缺省的动作是停止进程，进入停止状况以后还能重新进行下去</li><li>E：信号不能被捕获</li><li>F：信号不能被忽略</li></ul><h4 id="信号的捕获处理"><a href="#信号的捕获处理" class="headerlink" title="信号的捕获处理"></a>信号的捕获处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">// signum: 表示信号的编号  </span></span></span><br><span class="line"><span class="function"><span class="comment">// handler: 表示信号的处理方式，有三种：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    1. SIG_IGN：忽略改信号，不作为</span></span></span><br><span class="line"><span class="function"><span class="comment">//    2. SIG_DFL：恢复该信号的默认处理方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//    3. 自定义处理函数，注意函数参数为 (int signum)</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"><span class="comment">// pid: 目标进程号，有三种情况：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    1. pid&gt;0 将信号sig传给号为pid的进程</span></span></span><br><span class="line"><span class="function"><span class="comment">//    2. pid=0 将信号sig传给同进程组的所有进程（包括自己），常用于父进程给子进程发送信号</span></span></span><br><span class="line"><span class="function"><span class="comment">//    3. pid=-1 将信号广播到系统内所有进程，例如系统关机时向所有登录窗口广播关机信息</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// sig: 被发送的信号编号</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的应用"><a href="#信号的应用" class="headerlink" title="信号的应用"></a>信号的应用</h4><p>&emsp;&emsp;程序运行在后台，如果想让中止它，直接 Ctrl C 或者 kill 掉并不是好办法，因为程序被杀的时候，程序突然死亡没有释放资源，会影响系统的稳定。如果能捕获Ctrl C 或者 kill向后台程序发送的信号，并且修改其对应的处理函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。除此之外，信号还可以用于网络服务程序抓包等。</p><h5 id="屏蔽信号"><a href="#屏蔽信号" class="headerlink" title="屏蔽信号"></a>屏蔽信号</h5><p>&emsp;&emsp;通常为了程序不被干扰，程序开头通常会屏蔽所有信号，然后再用signal函数对关心的信号设置相应的处理方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) <span class="built_in">signal</span>(i, SIG_IGN);</span><br></pre></td></tr></table></figure><h5 id="搞点好玩的"><a href="#搞点好玩的" class="headerlink" title="搞点好玩的"></a>搞点好玩的</h5><p>&emsp;&emsp;改变信号 <code>SIGINT</code> 和 <code>SIGTERM</code>的捕获处理，设计一个 <code>ctrl+C</code> 和 <code>kill</code> 都杀不掉的进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b杀不死，哈哈哈哈。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGTERM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;还是杀不死，哈哈哈哈。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">100</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, func); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>使用<code>Ctrl+C</code> 尝试关掉进程：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215258482.png" alt="image-20211023215258482" style="zoom: 67%;" /><p>用 <code>ps -ef | grep signal</code> 找到其进程号，尝试用 kill 直接干掉：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215522014.png" alt="image-20211023215522014" style="zoom: 50%;" /><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215427407.png" alt="image-20211023215427407" style="zoom:67%;" /><p>可以看见，<code>kill + 进程号</code> 或 <code>killall + 进程名</code> 对它都无效，那改怎么杀死这个进程呢？如图，用 <code>kill -9 进程号</code>：</p><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215647601.png" alt="image-20211023215647601" style="zoom:50%;" /><img src="https://gitee.com/Lrk612/md_picture2/raw/master/img/image-20211023215658471.png" alt="image-20211023215658471" style="zoom: 67%;" /><p>因为<code>kill -9 进程号</code> 发送的信号是 <strong>SIGKILL</strong>，这个信号无法被捕获或忽略，能够快准狠杀掉进程</p><h5 id="使系统休眠"><a href="#使系统休眠" class="headerlink" title="使系统休眠"></a>使系统休眠</h5><p>&emsp;&emsp;这个是我尝试用 kill() 函数向系统所有进程发送 SIGKILL 信号后发现的，当然是在虚拟机上，我可不敢在主机上这样搞：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">kill</span>(<span class="number">-1</span>, SIGKILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是虚拟机进入休眠，输入密码后能再进入，原以为会直接关机呢……</p><p>&nbsp;</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>&emsp;&emsp;共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>&emsp;&emsp;共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号灯。</p><p>使用 <code>ipcs -m</code> 查看系统的共享内存：</p><blockquote><p>key：键值</p><p>shmid：共享内存编号</p><p>owner：创建者</p><p>perms：权限</p><p>bytes：大小</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224820.png" alt="image-20220117224820387" style="zoom:60%;" /></blockquote><p>使用 <code>ipcrm -m &lt;&gt;</code> 查看系统的共享内存：</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224912.png" alt="image-20220117224912685" style="zoom:60%;" /></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="C-封装函数"><a href="#C-封装函数" class="headerlink" title="C++封装函数"></a>C++封装函数</h5><p>Linux在c++头文件中提供了封装的函数用于操作共享内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取或创建"><a href="#获取或创建" class="headerlink" title="获取或创建"></a>获取或创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// key：共享内存的键值，是共享内存在系统中的编号，由程序员保证不同共享内存的编号不重复，通常用十六进制表示</span></span><br><span class="line"><span class="comment">// size：待创建的共享内存的大小，以字节为单位</span></span><br><span class="line"><span class="comment">// shmflg：共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存</span></span><br></pre></td></tr></table></figure><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">// 把共享内存连接到当前进程的地址空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shm_id：由shmget函数返回的共享内存标识</span></span><br><span class="line"><span class="comment">// shm_addr：定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line"><span class="comment">// shm_flg：一组标志位，通常为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1</span></span><br></pre></td></tr></table></figure><h5 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="comment">// 该将共享内存从当前进程中分离，相当于shmat函数的反操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shmaddr：shmat函数返回的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure><h5 id="控制与删除"><a href="#控制与删除" class="headerlink" title="控制与删除"></a>控制与删除</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">// shm_id：shmget函数返回的共享内存标识符</span></span><br><span class="line"><span class="comment">// command：填IPC_RMID</span></span><br><span class="line"><span class="comment">// buf：填0</span></span><br><span class="line"><span class="comment">// shmctl()其实是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用。注意，用root创建的共享内存，不管创建的权限是什么，普通用户都无法删除</span></span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input the mode [1——Send / 2——Receive]: &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mode != <span class="number">1</span> &amp;&amp; mode != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Wrong mode!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input the shared memory key[hexadecimal]: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = <span class="built_in">shmget</span>((<span class="keyword">key_t</span>)key, <span class="number">1024</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">    <span class="keyword">char</span> *ptext = (<span class="keyword">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 写入内容</span></span><br><span class="line">        string text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (text != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;you&gt; &quot;</span>);</span><br><span class="line">            <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;%s&quot;</span>, text.<span class="built_in">c_str</span>());</span><br><span class="line">            cin &gt;&gt; text;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//读取内容</span></span><br><span class="line">        string text = ptext;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;player: %s\n&quot;</span>, text.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">while</span> (text != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text == ptext)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;player: %s\n&quot;</span>, ptext);</span><br><span class="line">            text = ptext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;shmctl(%d) failed\n&quot;</span>, key);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>写入端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224620.png" alt="image-20220117224620056" style="zoom:60%;" /></li><li><p>读取端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117224639.png" alt="image-20220117224639270" style="zoom:60%;" /></li></ul><p>&nbsp;</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>&emsp;&emsp;信号量又称为信号灯，本质是一个计数器，用于协调多个进程或线程对共享数据对象的读写，防止冲突发生。它与信号（signal）一样不以传输数据为目的，而是向进程传到某个事件的发生。进程根据收到的信号量来判断是否对共享数据进行读写。从而保护共享资源（共享内存、消息队列、socket连接池等），保证同一时间只有一个进程占用。</p><p>&emsp;&emsp;信号量只允许进程除了创建和销毁外，对它做<strong>等待信号</strong>和<strong>发送信号</strong>两种操作。二进制信号量取值只有0、1，是最为常见的类型；通用信号量取值可以为多个整数值。</p><p>使用 <code>ipcs -s</code> 查看系统的信号量：</p><blockquote><p>key：键值</p><p>semid：信号量编号</p><p>owner：创建者</p><p>perms：权限</p><p>nsems：信号量数</p><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117221648.png" alt="image-20220117221648853" style="zoom: 60%;" /></blockquote><p>使用 <code>ipcrm sem &lt;semid&gt;</code>手动删除信号量</p><blockquote><p> 例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117221918.png" alt="image-20220117221918899" style="zoom:60%;" /></blockquote><h4 id="共享资源调度"><a href="#共享资源调度" class="headerlink" title="共享资源调度"></a>共享资源调度</h4><p>&emsp;&emsp;<strong>临界区</strong>是指一个访问公共资源的程序代码段，而这些公共资源无法同时被多个进程或线程访问。</p><p>程序进入临界区的调度原则：</p><ul><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入临界区，则应让出CPU，避免进程出现”忙等”现象。</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="C-封装函数-1"><a href="#C-封装函数-1" class="headerlink" title="C++封装函数"></a>C++封装函数</h5><p>Linux在c++头文件中提供了封装的函数用于操作信号量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux信号量函数都是针对成组的通用信号量进行操作，而不是只能针对一个二进制信号量。在一个进程要锁定多个资源的复杂情况下，这种方法比较快捷。</p><h5 id="获取或创建-1"><a href="#获取或创建-1" class="headerlink" title="获取或创建"></a>获取或创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// key：信号量的键值，是信号量在系统中的编号，需要保证唯一性，通常为16进制</span></span></span><br><span class="line"><span class="function"><span class="comment">// nsems：创建信号量集中信号量的个数，二进制信号量时设为1</span></span></span><br><span class="line"><span class="function"><span class="comment">// semflg：标志值，若要在信号量不存在时创建该信号量，则与 IPC_CREAT 按位取或作为参数；否则若信号量不存在就返回错误，errno=2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回值为semid，即信号量集的标识符，供程序后续访问此信号量；失败返回-1</span></span></span><br></pre></td></tr></table></figure><h5 id="初始化与删除"><a href="#初始化与删除" class="headerlink" title="初始化与删除"></a>初始化与删除</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span></span><br><span class="line"><span class="function"><span class="comment">// semctl()函数用于控制信号量，可设置其初始值或销毁信号量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// semid：信号量的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// sem_num：信号量集数组的下标</span></span></span><br><span class="line"><span class="function"><span class="comment">// command：是对信号量操作的命令种类：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    IPC_RMID：销毁信号量，不需要第四个参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//    SETVAL：初始化信号量的值，初始值由第四个参数决定</span></span></span><br><span class="line"><span class="function"><span class="comment">// 第四个参数是个联合体：</span></span></span><br><span class="line"><span class="function"><span class="comment">//    union semun</span></span></span><br><span class="line"><span class="function"><span class="comment">//  &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">//    int val; // 初始值</span></span></span><br><span class="line"><span class="function"><span class="comment">//      struct semid_ds *buf;</span></span></span><br><span class="line"><span class="function"><span class="comment">//      unsigned short *arry;</span></span></span><br><span class="line"><span class="function"><span class="comment">//  &#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br><span class="line"><span class="comment">// semid：信号量的标识符</span></span><br><span class="line"><span class="comment">// nsops：操作信号量的个数，即sops的个数</span></span><br><span class="line"><span class="comment">// sops：一个结构体</span></span><br><span class="line"><span class="comment">// struct sembuf</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//       short sem_num; // 信号量集的个数</span></span><br><span class="line"><span class="comment">//       short sem_op; // 信号量的操作：-1——等待，1——发送（释放）</span></span><br><span class="line"><span class="comment">//       short sem_flg; // 设置为SEM_UNDO，表示操作系统将跟踪这个信号量</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure><h5 id="示例：二进制信号灯控制共享内存操作"><a href="#示例：二进制信号灯控制共享内存操作" class="headerlink" title="示例：二进制信号灯控制共享内存操作"></a>示例：二进制信号灯控制共享内存操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> // 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sem_id;           <span class="comment">// 信号灯描述符。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;          <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;          <span class="comment">// 挂出信号灯。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">destroy</span><span class="params">()</span></span>;       <span class="comment">// 销毁信号灯。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line">    CSEM sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始信号灯。</span></span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = <span class="built_in">shmget</span>((<span class="keyword">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">    <span class="keyword">char</span> *ptext = (<span class="keyword">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d等待其他进程释放%d号共享内存的操作权\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">wait</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d获得%d号共享内存\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作本程序的ptext指针，就是操作共享内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d操作%d号共享内存中…………\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line">    <span class="built_in">sprintf</span>(ptext, <span class="string">&quot;本程序的进程号---%d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">    <span class="keyword">if</span> (sem.<span class="built_in">post</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程%d释放%d号共享内存的操作权\n&quot;</span>, <span class="built_in">getpid</span>(), shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    <span class="comment">// if (shmctl(shmid, IPC_RMID, 0) == -1)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;shmctl(0x5005) failed\n&quot;);</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取信号灯。</span></span><br><span class="line">    <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, <span class="number">0640</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, <span class="number">0640</span> | IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;init 1 semget()&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">            sem_union.val = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_union) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;init semctl()&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;init 2 semget()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;destroy semctl()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;wait semop()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;post semop()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>依次开3个进程访问同一个共享内存，可以看见后来的进程等待前面进程释放锁后才能访问：</p><ul><li><p>进程1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222609.png" alt="image-20220117222609226" style="zoom: 60%;" /></li><li><p>进程2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222630.png" alt="image-20220117222630209" style="zoom:60%;" /></li><li><p>进程3</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117222642.png" alt="image-20220117222642482" style="zoom:60%;" /></li></ul><p>&nbsp;</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h4 id="网络通信-Socket"><a href="#网络通信-Socket" class="headerlink" title="网络通信 Socket"></a>网络通信 Socket</h4><p>&emsp;&emsp;实现网络应用时要先从网络提供的接口开始，几乎所有计算机系统都将网络协议的软件实现作为操作系统的一部分，因此网络应用程序编程接口（API）一般都是操作系统提供的。套接字接口Socket是大部分操作系统都支持的一种流行接口，为计算机本地应用提供接入网络的功能。</p><p>&emsp;&emsp;Socket(套接字)可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的API，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 Socket中，该 Socket通过与网卡(NIC)相连的传输介质将这段信息送到另外一台主机的 Socket中，使对方能够接收到这段信息。 Socket是由IP地址和端口结合的，提供向应用层进程传送数据包的机制。socket把复杂的TCP/IP协议封装了起来，只要用好socket相关的函数即可完成网络通信。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826191343.png" alt="image-20210826190452059" width="30%" /><p><strong>Socket 类型</strong></p><p>&emsp;&emsp;socket主要提供了流（stream）和数据报（datagram）两种通信机制，即流socket和数据报socket。</p><p>&emsp;&emsp;流socket基于TCP协议，是一个有序、可靠、双向字节流的通道，传输数据不会丢失、不会重复、顺序也不会错乱。</p><p>&emsp;&emsp;数据报socket基于UDP协议，不需要建立和维持连接，可能会丢失或错乱。UDP不是一个可靠的协议，对数据的长度有限制，但是它的速度比较高。</p><h4 id="流Socket-工作流程"><a href="#流Socket-工作流程" class="headerlink" title="流Socket 工作流程"></a>流Socket 工作流程</h4><p>&emsp;&emsp;Socket在工作中分为客户端（Client）和服务端（Server）两部分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826191344.png" alt="image-20210826190900700" width="60%" /><p>&nbsp;</p><p><strong>服务端工作流程</strong></p><ol><li><p>创建socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"><span class="comment">// domain：将要使用的协议族，例如：AF_INET表示因特网协议族</span></span></span><br><span class="line"><span class="function"><span class="comment">// type：通信的语义，例如：SOCK_STREAM表示字节流、SOCK_DGRAM表示面向消息</span></span></span><br><span class="line"><span class="function"><span class="comment">// protocol：将要用到的特定协议，下面统一用0</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回值是该套接字的句柄（handle），即引用该套接字时使用的标识符</span></span></span><br></pre></td></tr></table></figure></li><li><p>把IP地址和端口绑定到socket上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含本地服务器IP地址和TCP端口号的结构体</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 绑定成功返回0</span></span></span><br></pre></td></tr></table></figure></li><li><p>设置socket为监听模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socket, backlog)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// backlog：该套接字允许连接的数量</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置成功返回0</span></span></span><br></pre></td></tr></table></figure></li><li><p>接受客户端的连接请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> *addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含服务器IP地址和TCP端口号的结构体，建立连接后会被写入客户端的对应信息</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 此函数是个阻塞操作，当建立连接时才返回，返回值是远程客户端的socket标识符</span></span></span><br></pre></td></tr></table></figure></li><li><p>与客户端重复通信，直到客户端断开连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">char</span> *message, <span class="keyword">int</span> msg_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 把message信息发送给对应socket的远程端，message长度为msg_len，flags统一为0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> buf_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从对应socket的远程端接收最大size为buf_len的信息到buffer，flags统一为0</span></span></span><br></pre></td></tr></table></figure></li><li><p>关闭socket，释放资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> socket)</span></span></span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;</p><p><strong>客户端工作流程</strong></p><ol><li><p>创建socket（方法同上）</p></li><li><p>向服务端发起连接请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr *address, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// socket：被绑定套接字的标识符</span></span></span><br><span class="line"><span class="function"><span class="comment">// address：包含服务端服务器IP地址和TCP端口号的结构体</span></span></span><br><span class="line"><span class="function"><span class="comment">// addr_len：address的size</span></span></span><br><span class="line"><span class="function"><span class="comment">// 此函数也是个阻塞操作，当建立连接时才返回，返回值是远程服务器的socket描述符</span></span></span><br></pre></td></tr></table></figure></li><li><p>与服务端通信，数据发送完后断开连接（方法同上）</p></li><li><p>关闭socket，释放资源（方法同上）</p></li></ol><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入端口号！\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第1步：创建服务端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> listenfd;</span><br><span class="line">    <span class="keyword">if</span> ((listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2步：把服务端用于通信的地址和端口绑定到socket上。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 使用任意ip地址。</span></span><br><span class="line">    <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.190.134&quot;); // 使用指定ip地址。</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// 指定通信端口。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3步：把socket设置为监听模式。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：接受客户端的连接。</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;                             <span class="comment">// 客户端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> socklen = <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span>            <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">    clientfd = <span class="built_in">accept</span>(listenfd, (struct sockaddr *)&amp;clientaddr, (<span class="keyword">socklen_t</span> *)&amp;socklen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>, <span class="built_in">inet_ntoa</span>(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iret;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">recv</span>(clientfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对方：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">send</span>(clientfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败，通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入ip地址和端口！\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第1步：创建客户端的socket。</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2步：向服务器发起连接请求。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">h</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span>) <span class="comment">// 指定服务端的ip地址。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 指定服务端的通信端口。</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>) <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> iret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, buffer);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">send</span>(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n发送失败，通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> ((iret = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n接收失败，通信结束\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对方：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;拜拜&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n通信结束！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><ul><li><p>Server<br><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826203958.png" alt="image-20210826203841945"></p></li><li><p>Client</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210826203959.png" alt="image-20210826203901839"></p></li></ul><p>&nbsp;</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>&emsp;&emsp;使用 <code>fork()</code> 函数可以产生一个新的进程，<code>fork()</code>的返回值用于区分父子进程，在父进程中其返回值为子进程编号，子进程中其返回值为0。子进程和父进程使用相同的代码段，子进程拷贝父进程的堆栈段和数据段，因此子进程拥有父进程的功能和其诞生时刻父进程的一切变量，但此后彼此之间没有相互影响，数据不互通。</p><h3 id="应用：并发的服务端"><a href="#应用：并发的服务端" class="headerlink" title="应用：并发的服务端"></a>应用：并发的服务端</h3><p>&emsp;&emsp;使用socket可以实现两个进程间的数据通信，两个进程分别充当服务端和客户端。如果想要一个服务端同时与多个客户端进行通信，可以使用多进程服务端（也有其他方法，比如多线程等）实现，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket服务端改为多进程，在每次accept到一个客户端的连接后生成一个子进程，让子进程负责和这个客户端通信，父进程继续accept客户端的连接。由此，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信，从而实现并发。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了服务端多进程实现并发以外，下面程序中还使用了多进程来实现服务端、客户端收发同步进行的功能，如果只是一个进程，那么无论是接收消息还是发送消息等待用户输入，都是阻塞性的，无法进行，因此又一次使用<code>fork()</code>开启一个进程，原进程负责接收消息，新进程负责发送消息等待用户输入。</p><p><strong>服务端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">同时又通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">        <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> subforkid = fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (subforkid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;服务端：&quot;</span>);</span><br><span class="line">                <span class="built_in">fflush</span>(stdin);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (subforkid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\r客户端：%s\n服务端：&quot;</span>, strbuffer);</span><br><span class="line">                <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpClient</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *serverip, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;127.0.0.1&quot;</span>, port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;127.0.0.1\&quot;,%d) failed,exit...\n&quot;</span>, port);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> forkid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (forkid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">        <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (forkid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r服务端：%s\n客户端：&quot;</span>, strbuffer);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与服务端断开连接。\n&quot;</span>);</span><br><span class="line">    TcpClient.~<span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_sockfd = <span class="number">0</span>; <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_sockfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd); <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *serverip, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">h</span>;</span> <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> ((h = <span class="built_in">gethostbyname</span>(serverip)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>服务端</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117205918.png" alt="image-20220117205918084" style="zoom:55%;" /></li><li><p>客户端1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117204949.png" alt="image-20220117204949140" style="zoom: 55%;" /></li><li><p>客户端2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117205002.png" alt="image-20220117205002282" style="zoom: 55%;" /></li></ul><p>&emsp;&emsp;但是程序现在有一个问题，就是同一个窗口下开启多个进程时，多个进程都等待用户输入消息然后发送，但是如果两个进程同时申请在终端打印输入请求时，谁先打印并接收，谁后打印接收，这是个冲突，目前操作系统的处理看来是把二者排位一个队列，先后顺序执行，但其实应该由用户自己决定要把消息发给谁，以后再填这个坑。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>&emsp;&emsp;一个子进程在调用 <code>return</code> 或 <code>exit(0)</code> 结束生命时，其实并没有被真正销毁，而是留下一个僵尸进程。比如上面并发服务端在子进程使用 <code>return</code> 结束后，父进程并未回收子进程占用的资源，子进程成为僵尸进程，使用 <code>ps -ef</code> 查看可以看见僵尸进程被标记为 <code>&lt;defunct&gt;</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117211135.png" alt="1" style="zoom:50%;" /><p>&emsp;&emsp;若父进程先结束，子进程会被系统接管，此后子进程结束后系统会自动回收资源，不会形成僵尸进程。</p><p><strong>解决方法</strong></p><p>方法一：</p><p>&emsp;&emsp;子进程退出前会向父进程发送一个信号，父进程调用 <code>wait()</code> 函数等待该信号，等到之后就不会产生僵尸进程，父进程会回收子进程占用的资源。但其实在并发的服务程序中这是不现实的，因为父进程有其他的工作，不可能一直阻塞着等待子进程的结束信号。</p><p>方法二：</p><p>&emsp;&emsp;父进程忽视子进程的退出信号：<code>signal(SIGCHLD,SIG_IGN);</code></p><p>&nbsp;</p><p>&nbsp;</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;线程是一条执行路径，是程序执行时的最小单位，即进程的一个执行流，是CPU调度和分派的基本单位。一个进程可以由多个线程组成，线程间共享进程的所有资源，但也有自己的堆栈和局部变量。线程由CPU独立调度执行，在D多CPU环境下允许多个线程同时进行。</p><ul><li>对于单核CPU而言：多线程就是一个CPU在来回的切换，在交替执行。</li><li>对于多核CPU而言：多线程就是同时有多条执行路径在同时(并行)执行，每个核执行一个线程，多个核就有可能是一块同时执行的。</li></ul><p>使用 <code>top -H</code> 查看线程</p><blockquote><p>例：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118130206.png" alt="image-20220118113211331" style="zoom:45%;" /></blockquote><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>&emsp;&emsp;一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，又是调度运行的基本单位，亦即执行处理机调度的基本单位。</p><ul><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p></li><li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量，即每个线程都有自己的堆栈和局部变量。</p></li><li><p>处理机分给线程，即真正在处理机上运行的是线程。</p></li><li><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p></li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>创建</td><td>准备好了一个多线程对象</td></tr><tr><td>就绪</td><td>等待CPU调度执行</td></tr><tr><td>运行</td><td>执行程序</td></tr><tr><td>阻塞</td><td>放弃CPU使用权，暂停执行线程，将线程挂起，将资源交给其他线程使用</td></tr></tbody></table><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>&emsp;&emsp;和多进程相比，多线程是一种比较节省资源的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进程间通信的方式进行。在同一个进程中，可以运行多个线程，运行于同一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享全局变量和对象，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。</p><p>&emsp;&emsp;不过Linux没有真正意义上的线程，它的实现是由进程来模拟，属于用户级线程。所以，在Linux系统下，进程与线程在性能和资源消耗方面没有本质的差别。但是进程不能共享全局数据，线程可以共享全局数据。</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><h4 id="C-封装函数-2"><a href="#C-封装函数-2" class="headerlink" title="C++封装函数"></a>C++封装函数</h4><p>Linux在c++头文件中提供了封装的函数用于操作线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意：编译时必须带上 <code>-pthread</code> 以调用静态链接库，因为pthread并不是Linux系统的默认库</p><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// thread: 指向线程标识符的地址。</span></span><br><span class="line"><span class="comment">// attr: 用于设置线程属性，一般为空，表示使用默认属性。</span></span><br><span class="line"><span class="comment">// start_routine: 线程运行函数的地址，填函数名就可以了。</span></span><br><span class="line"><span class="comment">// arg: 线程运行函数的参数。</span></span><br><span class="line"><span class="comment">// 新创建的线程从start_routine函数的地址开始运行，该函数只有一个无类型指针参数arg。若要向start_routine传递多个参数，可以将多个参数放在一个结构体中，然后把结构体的地址作为arg参数传入</span></span><br></pre></td></tr></table></figure><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>&emsp;&emsp;如果进程中的任一线程调用了exit，则整个进程会终止，所以，在线程的start_routine函数中，不能采用exit或return。</p><p>线程的终止有三种方式：</p><p>1）线程的 <code>start_routine()</code> 函数代码结束，自然消亡</p><p>2）线程的 <code>start_routine()</code> 函数调用 <code>pthread_exit()</code> 结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">// retval：填0</span></span><br></pre></td></tr></table></figure><p>3）被主进程或其它线程中止</p><h4 id="线程资源回收"><a href="#线程资源回收" class="headerlink" title="线程资源回收"></a>线程资源回收</h4><p>&emsp;&emsp;线程有<code>joinable</code>和<code>unjoinable</code>两种状态，如果线程是<code>joinable</code>状态，当线程主函数终止时（自己退出或调用<code>pthread_exit()</code>退出）不会释放线程所占用内存资源和其它资源，这种线程被称为“<strong>僵尸线程</strong>”。创建线程时默认是非分离的，或者称为可连接的（<code>joinable</code>）。可以通过将线程设置为<code>detached</code>状态来避免僵尸线程。</p><p><strong>方法一</strong></p><p>&emsp;&emsp;创建线程前，调用<code>pthread_attr_setdetachstate()</code>将线程设为<code>detached</code>，这样线程退出时，系统自动回收线程资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);  <span class="comment">// 设置线程的属性。</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pthid, &amp;attr, pth_main, (<span class="keyword">void</span>*)((<span class="keyword">long</span>)TcpServer.m_clientfd);</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>&emsp;&emsp;创建线程后，在创建线程的程序中调用<code>pthread_detach()</code>将新创建的线程设置为<code>detached</code>状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(pthid);</span><br></pre></td></tr></table></figure><p><strong>方法三</strong></p><p>&emsp;&emsp;在线程主函数中调用<code>pthread_detach()</code>改变自己的状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br></pre></td></tr></table></figure><p><strong>方法四</strong></p><p>&emsp;&emsp;创建线程后，在创建线程的程序中调用<code>pthread_join()</code>等待线程退出，一般不会采用这种方法，因为<code>pthread_join()</code>会发生阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span>(pthid, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>&emsp;&emsp;如果想要一个服务端同时与多个客户端进行通信，前面使用了多进程服务端，这里改用多线程实现，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket服务端改为多线程，在每次accept到一个客户端的连接后创建一个线程，把监听到的客户端地址和对应编号构造为结构体后作为参数传输给新线程，让这个线程负责和这个客户端通信，原线程继续accept客户端的连接。由此，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信，从而实现并发。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多线程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">但是未实现通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void CloseClient();    // 关闭客户端的socket，多线程服务端不需要这个函数。</span></span><br><span class="line">    <span class="comment">// void CloseListen();    // 关闭用于监听的socket，多线程服务端不需要这个函数。</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(TcpServer.m_listenfd); <span class="comment">// 手动关闭m_listenfd，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">int</span> clientid;</span><br><span class="line">&#125; _arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">pth_main</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 忽略全部的信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, EXIT);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> pthid; <span class="comment">// 创建一线程，与新连接上来的客户端通信</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> clientid = <span class="number">0</span>;</span><br><span class="line">        clientid++;</span><br><span class="line">        _arg *arg = (_arg *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_arg));</span><br><span class="line">        arg-&gt;clientfd = (<span class="keyword">long</span>)TcpServer.m_clientfd;</span><br><span class="line">        arg-&gt;clientid = clientid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid, <span class="literal">NULL</span>, pth_main, (<span class="keyword">void</span> *)arg) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败，程序退出。n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_detach</span>(pthid); <span class="comment">//将新创建的线程设置为detached状态，线程退出时，系统自动回收线程资源</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;与客户端%d通信的线程已创建。\n&quot;</span>, clientid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_main</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _arg *n = (_arg *)arg;</span><br><span class="line">    <span class="keyword">int</span> clientfd = (<span class="keyword">long</span>)n-&gt;clientfd; <span class="comment">// arg参数为新客户端的socket。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd, strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户%d：%s\n&quot;</span>, n-&gt;clientid, strbuffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(strbuffer, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd, strbuffer, <span class="built_in">strlen</span>(strbuffer), <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>, strbuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, n-&gt;clientid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clientfd); <span class="comment">// 关闭客户端的连接。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li><p>服务端</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145222.png" alt="image-20220118145222454" style="zoom:50%;" /></li><li><p>客户端1</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145241.png" alt="image-20220118145241350" style="zoom:50%;" /></li><li><p>客户端2</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118145255.png" alt="image-20220118145255493" style="zoom:50%;" /></li></ul><p>&emsp;&emsp;注意到，这里的程序并没有同前面多进程示例中一样，在子进程内又采用了多进程实现服务端、客户端收发同步进行的功能。因为开一个进程占用的资源远多于线程，子进程其实可以开两个线程分别负责收/发，但这又涉及线程间对共享资源的使用冲突问题，解决方法之一就是下面的线程锁。</p><h3 id="线程同步与互斥锁"><a href="#线程同步与互斥锁" class="headerlink" title="线程同步与互斥锁"></a>线程同步与互斥锁</h3><p>&emsp;&emsp;多线程可以共享进程的资源（变量和对象），对编程带来了方便，但是某些对象虽然可以共享，但在同一个时间只能由一个线程使用，多个线程同时使用会产生冲突，例如socket连接，数据库连接池。互斥锁机制是同一时刻只允许一个线程占有共享的资源。</p><h4 id="初始化锁"><a href="#初始化锁" class="headerlink" title="初始化锁"></a>初始化锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="comment">// mutexattr：用于指定锁的属性（见下），如果为NULL则使用缺省属性</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_TIMED_NP</td><td>缺省值，即普通锁，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE_NP</td><td>嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK_NP</td><td>检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同</td></tr><tr><td>PTHREAD_MUTEX_ADAPTIVE_NP</td><td>适应锁，动作最简单的锁类型，等待解锁后重新竞争</td></tr></tbody></table><h4 id="阻塞加锁"><a href="#阻塞加锁" class="headerlink" title="阻塞加锁"></a>阻塞加锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 如果是锁是空闲状态，本线程将获得这个锁；如果锁已经被占据，本线程将排队等待，直到成功的获取锁</span></span><br></pre></td></tr></table></figure><h4 id="非阻塞加锁"><a href="#非阻塞加锁" class="headerlink" title="非阻塞加锁"></a>非阻塞加锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回 EBUSY，不是挂起等待</span></span><br></pre></td></tr></table></figure><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 线程把自己持有的锁释放</span></span><br></pre></td></tr></table></figure><h4 id="销毁锁"><a href="#销毁锁" class="headerlink" title="销毁锁"></a>销毁锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 销毁锁之前，锁必需是空闲状态（unlock），否则返回EBUSY</span></span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>&emsp;&emsp;实际使用后意识到，即使是用两个线程分别负责收/发，二者交换互斥锁的所有权时也是以时间为周期的，并且当其中一个线程阻塞时，另一个线程就一直无法获得锁的所有权，也阻塞了，因此多线程无法真正实现收/发同步。目前的效果是收/发依次执行：</p><p><strong>服务端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">又通过多线程和互斥锁实现了通信中收发依次进行（其实没必要多线程，就代码一上一下也能实现）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>; <span class="comment">//通信端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 申明一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(TcpServer.m_listenfd); <span class="comment">// 手动关闭m_listenfd，释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_send</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forkid = (<span class="keyword">int</span>)arg; <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//将本线程设置为detached状态来避免成为僵尸线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 与服务端交互</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端%d：&quot;</span>, forkid);</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);                  <span class="comment">// usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_recv</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forkid = (<span class="keyword">long</span>)arg; <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//将本线程设置为detached状态来避免成为僵尸线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 与服务端交互</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d：%s\n服务端%d：&quot;</span>, forkid, strbuffer, forkid);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);                  <span class="comment">// usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 忽略全部的信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ii++)</span><br><span class="line">        <span class="built_in">signal</span>(ii, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, EXIT);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="number">0</span>); <span class="comment">// 创建锁</span></span><br><span class="line">        <span class="keyword">pthread_t</span> pthid1, pthid2;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pthid1, <span class="literal">NULL</span>, pth_send, (<span class="keyword">void</span> *)forkid); <span class="comment">// 创建第一个线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pthid1, <span class="literal">NULL</span>, pth_recv, (<span class="keyword">void</span> *)forkid); <span class="comment">// 创建第二个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_join</span>(pthid1, <span class="literal">NULL</span>); <span class="comment">// 等待线程 1退出。</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(pthid2, <span class="literal">NULL</span>); <span class="comment">// 等待线程 2退出。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 销毁锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过多进程实现与多个客户端通信</span></span><br><span class="line"><span class="comment">同时又通过多进程实现了通信中收发同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">5051</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_listenfd; <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">    <span class="keyword">int</span> m_clientfd; <span class="comment">// 与客户端通信的服务端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>; <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对端发送报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line">    <span class="comment">// 接收对端的报文</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>; <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>; <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> forkid = <span class="number">0</span>; <span class="comment">//客户端编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(port) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        forkid++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TcpServer.<span class="built_in">CloseClient</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">        TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d已连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">        <span class="keyword">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> subforkid = fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (subforkid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;服务端%d：&quot;</span>, forkid);</span><br><span class="line">                <span class="built_in">fflush</span>(stdin);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, strbuffer);</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer, <span class="built_in">strlen</span>(strbuffer)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;发送失败\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (subforkid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(strbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">                <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer)) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\r客户端%d：%s\n服务端%d：&quot;</span>, forkid, strbuffer, forkid);</span><br><span class="line">                <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端%d已断开连接。\n&quot;</span>, forkid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">    m_listenfd = m_clientfd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd); <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端的socket</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;                <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);              <span class="comment">// 绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_clientfd = <span class="built_in">accept</span>(m_listenfd, <span class="number">0</span>, <span class="number">0</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">const</span> <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd, buf, buflen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span> <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_clientfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_clientfd);</span><br><span class="line">        m_clientfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span> <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_listenfd != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">        m_listenfd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】策略梯度：PG算法族</title>
      <link href="/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%EF%BC%9APG%E7%AE%97%E6%B3%95%E6%97%8F/"/>
      <url>/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%EF%BC%9APG%E7%AE%97%E6%B3%95%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;Q-Learning、Sarsa、DQN都是基于价值函数的学习方式，但在强化学习的领域中还有另一种优化流派：基于策略学习（策略梯度）</p><p>&emsp;&emsp;在我看来，基于价值的优化算法都是在固定的策略（例如：贪婪策略、ε-greedy策略等）下，尽可能地准确估计出状态或动作的价值，从而让策略能够准确地选出最佳动作。但是基于策略的优化算法更加直接，不再使用固定的策略，而是对策略不断优化，不需要先算出状态价值再判断，而是根据环境的状态直接给出最佳动作。</p><p>&emsp;&emsp;策略梯度算法族包括：DPG、Actor-Critic、DDPQ等</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112085053.png" alt="image-20220112085053424" style="zoom: 33%;" /><span id="more"></span><p>&nbsp;</p><h2 id="策略梯度（Policy-Gradient）"><a href="#策略梯度（Policy-Gradient）" class="headerlink" title="策略梯度（Policy-Gradient）"></a>策略梯度（Policy-Gradient）</h2><h3 id="Value-based-强化学习方法的不足"><a href="#Value-based-强化学习方法的不足" class="headerlink" title="Value-based 强化学习方法的不足"></a>Value-based 强化学习方法的不足</h3><ol><li><p>对连续动作的处理能力不足</p><p>DQN等算法只处理离散动作，无法处理连续动作，例如：力的方向和大小</p></li><li><p>对受限状态下的问题处理能力不足</p><p>使用特征来描述状态空间中某一个状态时，有可能因为个体观测的限制或者建模的限制导致真实环境下不同的状态具有相同的特征描述</p></li><li><p>无法解决随机策略问题</p><p>Value Based强化学习方法对应的最优策略通常是确定性策略，因为其是从众多行为价值中选择一个最大价值的行为，而有些问题的最优策略却是随机策略，这种情况下同样是无法通过基于价值的学习来求解的</p></li></ol><h3 id="Policy-based-强化学习方法的引入"><a href="#Policy-based-强化学习方法的引入" class="headerlink" title="Policy-based 强化学习方法的引入"></a>Policy-based 强化学习方法的引入</h3><p>&emsp;&emsp;回顾Value-Based方法，无论是Sarsa还是DQN算法族，其所做的工作都是通过某种方法对状态的价值进行计算，然后根据计算结果采用贪婪策略或者ε-greedy策略选择出对应的动作，以此来实现对最佳动作的选择。在Policy-Based方法中，同样是为了选择出每个状态下的最佳动作，但是却更加直接。这里不再采用固定不变的策略思想，而是将策略不断优化，不断改变得到更新更优的策略。此时策略π可以被被描述为一个包含参数θ的函数，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111162846.png" alt="image-20220111162846573" style="zoom: 45%;" /><p>&emsp;&emsp;将策略表示成一个连续的函数后就可以用连续函数的优化方法来寻找最优的策略了，策略可以是一个一般函数，也可以是一个神经网络。为了评估策略的优劣，需要引入评价目标，也就是优化目标。然后采用类似梯度下降的优化方法，对优化目标做策略的”梯度上升“，收敛后即可得到最佳策略。</p><h3 id="策略梯度的优化目标"><a href="#策略梯度的优化目标" class="headerlink" title="策略梯度的优化目标"></a>策略梯度的优化目标</h3><table><thead><tr><th>优化目标</th><th>定义式</th></tr></thead><tbody><tr><td>初始状态收获的期望</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111163508.png" alt="image-20220111163508366" style="zoom: 33%;" /></td></tr><tr><td>平均价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117182507.png" alt="image-20220111163740877" style="zoom:33%;" /></td></tr><tr><td>每一时间步的平均奖励</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164026.png" alt="image-20220111164026634" style="zoom:33%;" /></td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>无论哪种优化目标，其梯度都可以表示为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164440.png" alt="image-20220111164439961" style="zoom: 45%;" /><p>不同优化目标只有 <code>Qπ(s,a)</code> 部分不同，策略部分不改变，称为<strong>分值函数</strong>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111164711.png" alt="image-20220111164710941" style="zoom: 45%;" /><h3 id="策略函数的设计"><a href="#策略函数的设计" class="headerlink" title="策略函数的设计"></a>策略函数的设计</h3><h4 id="Softmax策略函数"><a href="#Softmax策略函数" class="headerlink" title="Softmax策略函数"></a>Softmax策略函数</h4><p>&emsp;&emsp;主要应用于离散空间中，使用描述状态和行为的特征 <code>ϕ(s,a)</code> 与参数 <code>θ </code>的线性组合来权衡一个行为发生的几率，即：   </p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165453.png" alt="image-20220111165453539" style="zoom:45%;" /><p>则通过求导求出对应的分值函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165244.png" alt="image-20220111165244127" style="zoom: 45%;" /><h4 id="Gauss策略函数"><a href="#Gauss策略函数" class="headerlink" title="Gauss策略函数"></a>Gauss策略函数</h4><p>&emsp;&emsp;主要应用于连续行为空间，对应的行为从高斯分布 <code>N(ϕ(s)^T θ,σ^2)</code> 中产生。对应的分值函数通过对策略求导可以得到：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111165543.png" alt="image-20220111165543029" style="zoom:45%;" /><p>&nbsp;</p><h2 id="蒙特卡罗策略梯度算法"><a href="#蒙特卡罗策略梯度算法" class="headerlink" title="蒙特卡罗策略梯度算法"></a>蒙特卡罗策略梯度算法</h2><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112085002.png" alt="image-20220112085002544"></p><p>&emsp;&emsp;蒙特卡罗策略梯度是最简单的策略梯度算法，使用价值函数 v(s) 来近似代替策略梯度公式里面的 Qπ(s,a)。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N个蒙特卡罗完整序列，训练步长α</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略函数的参数θ</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>for 每个蒙特卡罗序列：</p><ul><li><p>用蒙特卡罗法计算序列每个时间位置t的状态价值 vt</p></li><li><p>对序列每个时间位置t，使用梯度上升法更新策略函数的参数θ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112084515.png" alt="image-20220112084515658" style="zoom:50%;" /></li></ul></li><li><p>返回策略函数的参数θ（策略函数可以是Softmax策略，高斯策略或者其他策略 ）</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p><strong>问题</strong></p><p>&emsp;&emsp;以OpenAI Gym中的CartPole-v0游戏为例，介绍参见<a href="https://github.com/openai/gym/wiki/CartPole-v0">这里</a>。它的基本要求就是控制下面的cart移动使连接在上面的pole保持垂直不倒。这个任务只有两个离散动作，要么向左用力，要么向右用力。而state状态就是这个cart的位置和速度， pole的角度和角速度，4维的特征。坚持到200分的奖励则为过关。</p><p><strong>代码</strong></p><p>&emsp;&emsp;这里采用somftmax策略函数，用三层softmax神经网络表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">GAMMA = <span class="number">0.95</span>  <span class="comment"># discount factor</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy_Gradient</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.ep_obs, self.ep_as, self.ep_rs = [], [], []</span><br><span class="line">        self.create_softmax_network()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_softmax_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.tf_acts = tf.placeholder(tf.int32, [<span class="literal">None</span>, ], name=<span class="string">&quot;actions_num&quot;</span>)</span><br><span class="line">        self.tf_vt = tf.placeholder(tf.float32, [<span class="literal">None</span>, ], name=<span class="string">&quot;actions_value&quot;</span>)</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># softmax layer</span></span><br><span class="line">        self.softmax_input = tf.matmul(h_layer, W2) + b2</span><br><span class="line">        <span class="comment"># softmax output</span></span><br><span class="line">        self.all_act_prob = tf.nn.softmax(self.softmax_input, name=<span class="string">&#x27;act_prob&#x27;</span>)</span><br><span class="line">        self.neg_log_prob = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.softmax_input,</span><br><span class="line">                                                                           labels=self.tf_acts)</span><br><span class="line">        self.loss = tf.reduce_mean(</span><br><span class="line">            self.neg_log_prob * self.tf_vt)  <span class="comment"># reward guided loss</span></span><br><span class="line"></span><br><span class="line">        self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">            LEARNING_RATE).minimize(self.loss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, observation</span>):</span></span><br><span class="line">        prob_weights = self.session.run(self.all_act_prob, feed_dict=&#123;</span><br><span class="line">                                        self.state_input: observation[np.newaxis, :]&#125;)</span><br><span class="line">        <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        action = np.random.choice(</span><br><span class="line">            <span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]), p=prob_weights.ravel())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r</span>):</span></span><br><span class="line">        self.ep_obs.append(s)</span><br><span class="line">        self.ep_as.append(a)</span><br><span class="line">        self.ep_rs.append(r)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        discounted_ep_rs = np.zeros_like(self.ep_rs)</span><br><span class="line">        running_add = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.ep_rs))):</span><br><span class="line">            running_add = running_add * GAMMA + self.ep_rs[t]</span><br><span class="line">            discounted_ep_rs[t] = running_add</span><br><span class="line"></span><br><span class="line">        discounted_ep_rs -= np.mean(discounted_ep_rs)</span><br><span class="line">        discounted_ep_rs /= np.std(discounted_ep_rs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train on episode</span></span><br><span class="line">        self.session.run(self.train_op, feed_dict=&#123;</span><br><span class="line">            self.state_input: np.vstack(self.ep_obs),</span><br><span class="line">            self.tf_acts: np.array(self.ep_as),</span><br><span class="line">            self.tf_vt: discounted_ep_rs,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        self.ep_obs, self.ep_as, self.ep_rs = [], [], []    <span class="comment"># empty episode data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = Policy_Gradient(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.choose_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            agent.store_transition(state, action, reward)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="comment">#print(&quot;stick for &quot;,step, &quot; steps&quot;)</span></span><br><span class="line">                agent.learn()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.choose_action(</span><br><span class="line">                        state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;400轮左右收敛，但是并不稳定，平均Reward在200附近浮动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118104115.png" alt="image-20220118104115127" style="zoom: 40%;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;策略梯度提供了和 DQN 之类的方法不同的新思路，但是简单的蒙特卡罗策略梯度reinforce算法却并不完美。蒙特卡罗法需要完全的序列样本才能做算法迭代，同时蒙特卡罗法使用收获的期望来计算状态价值，会导致行为有较多的变异性，参数更新的方向很可能不是策略梯度的最优方向。因此，Policy-based的强化学习方法还需要改进，例如 Policy-based与Value-based结合的策略梯度方法Actor-Critic。</p><p>&nbsp;</p><h2 id="Actor-Critic算法"><a href="#Actor-Critic算法" class="headerlink" title="Actor-Critic算法"></a>Actor-Critic算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Actor-Critic 是2000年在NIPS上发表的一篇名为 <a href="https://lrk612.com/resources/Actor-Critic%20Algorithms.pdf">Actor-Critic Algorithms</a> 的论文中提出的，是一种训练模型的模式或技巧。</p><p>&emsp;&emsp;Actor-Critic包括两部分：演员(Actor)、评价者(Critic)。其中Actor使用策略函数，负责生成动作(Action)并和环境交互，而Critic使用价值函数，负责评估Actor的表现，并指导Actor下一阶段的动作。在Policy-Gradient中，策略函数就是Actor，但是那里没有Critic，而是使用了蒙特卡罗法来计算每一步的价值部分从而替代了Critic的功能，但是场景比较受限。因此现在使用类似DQN中用的价值近似来替代蒙特卡罗法，作为一个比较通用的Critic。</p><p>&emsp;&emsp;Actor-Critic算法中做了两组近似：</p><h4 id="策略函数的近似"><a href="#策略函数的近似" class="headerlink" title="策略函数的近似"></a>策略函数的近似</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090509.png" alt="image-20220112090509167" style="zoom:45%;" /><h4 id="价值函数的近似"><a href="#价值函数的近似" class="headerlink" title="价值函数的近似"></a>价值函数的近似</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090441.png" alt="image-20220112090441163" style="zoom: 45%;" /><p>&emsp;&emsp;也就是说，蒙特卡罗reinforce算法参数的参数更新公式（如下）中，vt的求取不再用蒙特卡罗法那样采样平均而是用DQN的近似价值函数求取，而分值函数部分∇θlogπθ(s,a)不变。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090613.png" alt="image-20220112090613113" style="zoom:45%;" /><p>&emsp;&emsp;通常使用Q网络来近似价值函数，所以汇总来说，就是Critic通过Q网络计算状态的最优价值vt，而Actor利用vt这个最优价值迭代更新策略函数的参数θ，进而选择动作，并得到反馈和新的状态，Critic使用反馈和新的状态更新Q网络参数w，在后面Critic会使用新的网络参数w来帮Actor计算状态的最优价值vt。</p><h4 id="可选形式"><a href="#可选形式" class="headerlink" title="可选形式"></a>可选形式</h4><p>&emsp;&emsp;Critic有多种选择，其网络输出作为Actor的优化目标，对应Actor多种策略梯度更新方法：</p><table><thead><tr><th>Critic</th><th>对应Actor更新方法</th><th>备注</th></tr></thead><tbody><tr><td>状态价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112090936.png" alt="image-20220112090936577" style="zoom:33%;" /></td><td></td></tr><tr><td>动作价值</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091001.png" alt="image-20220112091001498" style="zoom:33%;" /></td><td></td></tr><tr><td>TD误差</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091050.png" alt="image-20220112091050308" style="zoom:33%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091237.png" alt="image-20220112091237744" style="zoom:33%;" /></td></tr><tr><td>优势函数</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091536.png" alt="image-20220112091536610" style="zoom: 33%;" /></td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091703.png" alt="image-20220112091703913" style="zoom:33%;" /></td></tr><tr><td>TD(λ)误差</td><td><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112092148.png" alt="image-20220112092148003" style="zoom:33%;" /></td><td>基于后向TD(λ)误差，是TD误差和效用迹的乘积</td></tr></tbody></table><p>&emsp;&emsp;对于Critic本身的网络参数w，一般都是使用 <code>均方误差损失函数</code> 来做迭代更新，类似DQN系列中的迭代方法。</p><h3 id="算法流程（基于TD误差）"><a href="#算法流程（基于TD误差）" class="headerlink" title="算法流程（基于TD误差）"></a>算法流程（基于TD误差）</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112092450.png" alt="image-20220112092450135"></p><p>（评估点基于TD误差，Critic使用神经网络来计算TD误差并更新网络参数，Actor也使用Critic神经网络的结果来更新网络参数）</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、β、衰减因子γ、探索率ϵ、Critic网络结构、Actor网络结构</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Actor网络参数θ、Critic网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有的状态和动作对应的价值Q</p></li><li><p>for i in [ 1, T ]：</p><ol><li>初始化S为当前状态序列的第一个状态，拿到其特征向量Φ(S)</li><li>把Φ(S)输入Actor网络，得到输出动作A，并由环境获得新状态S’、奖励R</li><li>把Φ(S)、Φ(S‘ )分别输入Critic网络，分别得到输出的Q值V(S)、V(S’ )</li><li>计算TD误差 δ = R + γV(S′ ) − V(S)</li><li>计算均方差损失函数 ∑(R+γV(S′)−V(S,w))^2，梯度反向传播更新Critic网络参数w</li><li>更新Actor网络参数：</li></ol></li></ol><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112091050.png" alt="image-20220112091050308" style="zoom:45%;" /><p>（这里以TD误差为评估点， 分值函数∇θlogπθ(St,A)可以选择softmax或者高斯分值函数 )</p><p>对应模型结构：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220112103230.png" alt="image-20220112103230292" style="zoom:50%;" /><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;代码分为Actor和Critic两部分，Actor部分和上面策略梯度的代码差别不大，主要是梯度更新方法不同，策略梯度使用蒙特卡洛法计算出价值，这里Actor使用的是TD误差。Critic部分类似于之前的DQN的三层神经网络，但是输出只有一维，并且没有经验回放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">GAMMA = <span class="number">0.95</span>  <span class="comment"># discount factor</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env, sess</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.create_softmax_network()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = sess</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_softmax_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.tf_acts = tf.placeholder(tf.int32, [<span class="literal">None</span>, <span class="number">2</span>], name=<span class="string">&quot;actions_num&quot;</span>)</span><br><span class="line">        self.td_error = tf.placeholder(</span><br><span class="line">            tf.float32, <span class="literal">None</span>, <span class="string">&quot;td_error&quot;</span>)  <span class="comment"># TD_error</span></span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># softmax layer</span></span><br><span class="line">        self.softmax_input = tf.matmul(h_layer, W2) + b2</span><br><span class="line">        <span class="comment"># softmax output</span></span><br><span class="line">        self.all_act_prob = tf.nn.softmax(self.softmax_input, name=<span class="string">&#x27;act_prob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.neg_log_prob = tf.nn.softmax_cross_entropy_with_logits(logits=self.softmax_input,</span><br><span class="line">                                                                    labels=self.tf_acts)</span><br><span class="line">        self.exp = tf.reduce_mean(self.neg_log_prob * self.td_error)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里需要最大化当前策略的价值，因此需要最大化self.exp,即最小化-self.exp</span></span><br><span class="line">        self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">            LEARNING_RATE).minimize(-self.exp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, observation</span>):</span></span><br><span class="line">        prob_weights = self.session.run(self.all_act_prob, feed_dict=&#123;</span><br><span class="line">                                        self.state_input: observation[np.newaxis, :]&#125;)</span><br><span class="line">        <span class="comment"># select action w.r.t the actions prob</span></span><br><span class="line">        action = np.random.choice(</span><br><span class="line">            <span class="built_in">range</span>(prob_weights.shape[<span class="number">1</span>]), p=prob_weights.ravel())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, state, action, td_error</span>):</span></span><br><span class="line">        s = state[np.newaxis, :]</span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        a = one_hot_action[np.newaxis, :]</span><br><span class="line">        <span class="comment"># train on episode</span></span><br><span class="line">        self.session.run(self.train_op, feed_dict=&#123;</span><br><span class="line">            self.state_input: s,</span><br><span class="line">            self.tf_acts: a,</span><br><span class="line">            self.td_error: td_error,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Critic</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env, sess</span>):</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = sess</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1q = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1q = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2q = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">        b2q = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">        self.state_input = tf.placeholder(</span><br><span class="line">            tf.float32, [<span class="number">1</span>, self.state_dim], <span class="string">&quot;state&quot;</span>)</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layerq = tf.nn.relu(tf.matmul(self.state_input, W1q) + b1q)</span><br><span class="line">        <span class="comment"># Q Value layer</span></span><br><span class="line">        self.Q_value = tf.matmul(h_layerq, W2q) + b2q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.next_value = tf.placeholder(tf.float32, [<span class="number">1</span>, <span class="number">1</span>], <span class="string">&quot;v_next&quot;</span>)</span><br><span class="line">        self.reward = tf.placeholder(tf.float32, <span class="literal">None</span>, <span class="string">&#x27;reward&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;squared_TD_error&#x27;</span>):</span><br><span class="line">            self.td_error = self.reward + GAMMA * self.next_value - self.Q_value</span><br><span class="line">            self.loss = tf.square(self.td_error)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">            self.train_op = tf.train.AdamOptimizer(</span><br><span class="line">                self.epsilon).minimize(self.loss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self, state, reward, next_state</span>):</span></span><br><span class="line">        s, s_ = state[np.newaxis, :], next_state[np.newaxis, :]</span><br><span class="line">        v_ = self.session.run(self.Q_value, &#123;self.state_input: s_&#125;)</span><br><span class="line">        td_error, _ = self.session.run([self.td_error, self.train_op],</span><br><span class="line">                                       &#123;self.state_input: s, self.next_value: v_, self.reward: reward&#125;)</span><br><span class="line">        <span class="keyword">return</span> td_error</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">3000</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    sess = tf.InteractiveSession()</span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    actor = Actor(env, sess)</span><br><span class="line">    critic = Critic(env, sess)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = actor.choose_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># gradient = grad[r + gamma * V(s_) - V(s)]</span></span><br><span class="line">            td_error = critic.train_Q_network(state, reward, next_state)</span><br><span class="line">            <span class="comment"># true_gradient = grad[logPi(s,a) * td_error]</span></span><br><span class="line">            actor.learn(state, action, td_error)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = actor.choose_action(</span><br><span class="line">                        state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;很明显，这个算法很难收敛，平均Reward总是很低</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220118105019.png" alt="image-20220118105019197" style="zoom:50%;" /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Actor-Critic的优点是可以单步更新，比蒙特卡洛法的更新反馈更好、方差更小、稳定性更高。不过虽然基本版的Actor-Critic算法已经是一个很好的算法框架，但是离实际应用还比较远。主要原因是这里有两个神经网络，都需要梯度更新，而且互相依赖，所以难以收敛。</p><p>&emsp;&emsp;目前改进的比较好的有两个经典算法，一个是DDPG算法，使用了双Actor神经网络和双Critic神经网络的方法来改善收敛性。这个方法在从DQN到Nature DQN的过程中用过。另一个是A3C算法，使用了多线程的方式，一个主线程负责更新Actor和Critic的参数，多个辅线程负责分别和环境交互，得到梯度更新值，汇总更新主线程的参数。而所有的辅线程会定期从主线程更新网络参数。这些辅线程起到了类似DQN中经验回放的作用，但是效果更好。</p><p>&nbsp;</p><h2 id="DDPG"><a href="#DDPG" class="headerlink" title="DDPG"></a>DDPG</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="针对问题"><a href="#针对问题" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;对于某一些动作集合来说，它可能是连续值，或者非常高维的离散值，这样动作的空间维度极大。如果使用随机策略，即像DQN一样研究它所有的可能动作的概率，并计算各个可能的动作的价值的话，那需要的样本量是非常大才可行的。</p><h4 id="优化：DPG（确定性策略）"><a href="#优化：DPG（确定性策略）" class="headerlink" title="优化：DPG（确定性策略）"></a>优化：DPG（确定性策略）</h4><p>&emsp;&emsp;2014年，David Sliver发表了一篇名为 <a href="https://lrk612.com/resources/Deterministic%20Policy%20Gradient%20Algorithms.pdf">Deterministic Policy Gradient Algorithms</a> 的论文，文中证明了确定性策略梯度的存在，并给出了详细的计算方法。同一个随机策略在同一个状态处采用的动作基于一个概率分布，依概率取动作值，即不确定。而确定性策略则在不同概率的动作中取概率最大者，同一个状态的动作是唯一确定的，此时策略为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116163325.png" alt="image-20220113100808659" style="zoom:45%;" /><p>基于Q值的随机性策略梯度的梯度计算公式为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113101331.png" alt="image-20220113101331271" style="zoom:45%;" /><p>其中状态的采样空间为ρπ，可见随机性策略梯度需要在整个动作的空间πθπθ进行采样。</p><p>而基于Q值的确定性策略梯度的梯度计算公式是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113101501.png" alt="image-20220113101501314" style="zoom:45%;" /><p>跟随机策略梯度的式子相比，少了对动作的积分，多了回报Q函数对动作的导数。</p><h4 id="DDPG原理"><a href="#DDPG原理" class="headerlink" title="DDPG原理"></a>DDPG原理</h4><p>&emsp;&emsp;从DPG到DDPG的过程，完全可以类比DQN到DDQN的过程。除了经验回放外还有双网络，即当前网络和目标网络。Actor双网络和Critic双网络总共四个网络结构。</p><h5 id="回顾DDQN的双网络模型"><a href="#回顾DDQN的双网络模型" class="headerlink" title="回顾DDQN的双网络模型"></a>回顾DDQN的双网络模型</h5><p>&emsp;&emsp;DDQN的当前网络负责对当前状态<code>S</code>使用<code>ε-greedy</code>法选择动作<code>A</code>，执行动作<code>A</code>获得新状态<code>S‘</code>和奖励<code>R</code>，将此样本放入经验池。对经验池中采样的下一状态<code>S’</code>使用贪婪<code>greedy</code>法选择动作<code>A’</code>，供目标网络计算目标Q值，然后当前网络反向传播更新参数，并定期把最新的网络参数复制到目标网络。</p><p>&emsp;&emsp;DDQN的目标网络基于经验回放计算目标Q值，供当前网络计算损失函数然后反向传播。</p><h5 id="DDPG工作原理"><a href="#DDPG工作原理" class="headerlink" title="DDPG工作原理"></a>DDPG工作原理</h5><p>&emsp;&emsp;与DDQN相比较，DDPG的Critic的当前网络/目标网络同DDQN相似，但是因为DDPG还有Actor双网络，因此DDPG用Actor当前网络代替DDQN中的<code>ε-greedy</code>法选择动作<code>A</code>、用Actor目标网络代替DDQN中的贪婪<code>greedy</code>法选择动作<code>A’</code>。</p><p>&emsp;&emsp;基于经验回放池和目标Actor网络提供的<code>S′</code>、<code>A′</code>计算目标Q值的一部分，这部分由于是评估，因此还是放到Critic目标网络完成。而Critic目标网络计算出目标Q值一部分后，Critic当前网络会计算目标Q值，进行网络参数的反向传播更新，并定期将当前网络参数复制到Critic目标网络。</p><h5 id="DDPG-4个网络的功能"><a href="#DDPG-4个网络的功能" class="headerlink" title="DDPG 4个网络的功能"></a>DDPG 4个网络的功能</h5><table><thead><tr><th>网络</th><th>功能</th></tr></thead><tbody><tr><td>Critic当前网络</td><td>负责价值网络参数w的更新，计算当前Q(S,A,w)，目标Q值yi=R+γQ’(S’,A’,w’)</td></tr><tr><td>Critic目标网络</td><td>计算目标Q值中的Q’(S’,A’,w’)部分，网络参数w’定期从w软更新</td></tr><tr><td>Actor当前网络</td><td>负责策略网络参数θ的迭代更新，根据当前状态S选择当前动作A，与环境交互生成S‘、R</td></tr><tr><td>Actor目标网络</td><td>根据经验池中采样的下一状态S’选择最优下一动作A‘，网络参数θ’定期从θ软更新</td></tr></tbody></table><h5 id="网络参数的软更新"><a href="#网络参数的软更新" class="headerlink" title="网络参数的软更新"></a>网络参数的软更新</h5><p>&emsp;&emsp;DDPG中网络参数的赋值并不是和DQN一样直接全部复制（硬更新），而是每次都只更新一点点（软更新）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113122829.png" alt="image-20220113122829564" style="zoom:45%;" /><p>（其中，τ是更新系数，典型值为0.01~0.1）</p><h5 id="动作噪声"><a href="#动作噪声" class="headerlink" title="动作噪声"></a>动作噪声</h5><p>&emsp;&emsp;为了学习过程增加一些随机性，从而增加学习的覆盖，DDPG对选择出来的动作<code>A</code>会增加一定的噪声<code>N</code>，即最终和环境交互的动作<code>A</code>为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123143.png" alt="image-20220113123143564" style="zoom:45%;" /><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><h6 id="Critic当前网络："><a href="#Critic当前网络：" class="headerlink" title="Critic当前网络："></a>Critic当前网络：</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123425.png" alt="image-20220113123425768" style="zoom:45%;" /><h6 id="Actor当前网络"><a href="#Actor当前网络" class="headerlink" title="Actor当前网络"></a>Actor当前网络</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123623.png" alt="image-20220113123623061" style="zoom:45%;" /><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125412.png" alt="image-20220113125412297" style="zoom:50%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Actor当前/目标网络，Critic当前/目标网络，参数分别为θ、θ′、w、w′，衰减因子γ、软更新系数τ、批量梯度下降的样本数m、目标Q网络参数更新频率C、最大迭代次数T、随机噪音函数N</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最优Actor当前网络参数θ、Critic当前网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化<code>θ</code>、<code>w</code>、<code>w′=w</code>、<code>θ′=θ</code>，清空经验池 D</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化<code>S</code>为当前状态序列的第一个状态，拿到其特征向量<code>Φ(S)</code></p></li><li><p>把状态<code>S</code>输入<strong>Actor当前网络</strong>得到输出动作：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113125013.png" alt="image-20220113125013515" style="zoom:45%;" /></li><li><p>执行动作<code>A</code>，由环境得到新状态<code>S‘</code>、奖励 <code>R</code>、终止标志 <code>is_end</code></p></li><li><p>将 <code>&#123; ϕ(S)、A、R、ϕ(S′)、is_end &#125;</code> 这个五元组存入经验池 <code>D</code></p></li><li><p>前进一步：<code>S = S’</code></p></li><li><p>从经验池<code>D</code>中采样<code>m</code>个样本 <code>&#123; ϕ(Sj)、Aj、Rj、ϕ(S′j)、is_endj &#125; ，j=1,2...m</code> ， 用<strong>目标Critic网络</strong>结合公式计算当前目标Q值<code>yj</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113124619.png" alt="image-20220113124619535" style="zoom:45%;" /><p>（注意：<code>πθ′(ϕ(S′j))</code>是通过<strong>Actor目标网络</strong>得到 ）</p></li><li><p>用<strong>当前Critic网络</strong>计算Q估计值，梯度反向传播更新Critic当前网络参数 <code>w</code>，损失函数为均方误差：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123425.png" alt="image-20220113123425768" style="zoom:45%;" /></li><li><p>梯度反向传播更新Actor当前网络参数 <code>θ</code>，损失函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113123623.png" alt="image-20220113123623061" style="zoom:45%;" /></li><li><p>if <code>i % C == 0</code>，则更新Critic目标网络和Actor目标网络参数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220113122829.png" alt="image-20220113122829564" style="zoom:45%;" /></li><li><p>if  <code>S’ </code>是终止状态，break；else 跳回步骤 2.2</p></li></ol></li></ol><p>（注意，上面πθ由Actor目标网络得到，Q‘由Critic目标网络得到）</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;这里不用之前的CartPole游戏，因为它不是连续动作，而是使用Pendulum-v1游戏为例。目的是用最小的力矩使棒子竖起来，这个游戏的详细介绍参见<a href="https://github.com/openai/gym/wiki/Pendulum-v0">这里</a>。输入状态是角度的sin，cos值，以及角速度，一共三个值。动作是一个连续的力矩值。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################  hyper parameters  ####################</span></span><br><span class="line"></span><br><span class="line">MAX_EPISODES = <span class="number">2000</span></span><br><span class="line">MAX_EP_STEPS = <span class="number">200</span></span><br><span class="line">LR_A = <span class="number">0.001</span>    <span class="comment"># learning rate for actor</span></span><br><span class="line">LR_C = <span class="number">0.002</span>    <span class="comment"># learning rate for critic</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>     <span class="comment"># reward discount</span></span><br><span class="line">TAU = <span class="number">0.01</span>      <span class="comment"># soft replacement</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">10000</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">RENDER = <span class="literal">False</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;Pendulum-v1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################  DDPG  ####################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDPG</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a_dim, s_dim, a_bound,</span>):</span></span><br><span class="line">        self.memory = np.zeros(</span><br><span class="line">            (MEMORY_CAPACITY, s_dim * <span class="number">2</span> + a_dim + <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">        self.pointer = <span class="number">0</span></span><br><span class="line">        self.sess = tf.Session()</span><br><span class="line"></span><br><span class="line">        self.a_dim, self.s_dim, self.a_bound = a_dim, s_dim, a_bound,</span><br><span class="line">        self.S = tf.placeholder(tf.float32, [<span class="literal">None</span>, s_dim], <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">        self.S_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, s_dim], <span class="string">&#x27;s_&#x27;</span>)</span><br><span class="line">        self.R = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Actor&#x27;</span>):</span><br><span class="line">            self.a = self._build_a(self.S, scope=<span class="string">&#x27;eval&#x27;</span>, trainable=<span class="literal">True</span>)</span><br><span class="line">            a_ = self._build_a(self.S_, scope=<span class="string">&#x27;target&#x27;</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Critic&#x27;</span>):</span><br><span class="line">            <span class="comment"># assign self.a = a in memory when calculating q for td_error,</span></span><br><span class="line">            <span class="comment"># otherwise the self.a is from Actor when updating Actor</span></span><br><span class="line">            q = self._build_c(self.S, self.a, scope=<span class="string">&#x27;eval&#x27;</span>, trainable=<span class="literal">True</span>)</span><br><span class="line">            q_ = self._build_c(self.S_, a_, scope=<span class="string">&#x27;target&#x27;</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># networks parameters</span></span><br><span class="line">        self.ae_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Actor/eval&#x27;</span>)</span><br><span class="line">        self.at_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Actor/target&#x27;</span>)</span><br><span class="line">        self.ce_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Critic/eval&#x27;</span>)</span><br><span class="line">        self.ct_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;Critic/target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># target net replacement</span></span><br><span class="line">        self.soft_replace = [tf.assign(t, (<span class="number">1</span> - TAU) * t + TAU * e)</span><br><span class="line">                             <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(self.at_params + self.ct_params, self.ae_params + self.ce_params)]</span><br><span class="line"></span><br><span class="line">        q_target = self.R + GAMMA * q_</span><br><span class="line">        <span class="comment"># in the feed_dic for the td_error, the self.a should change to actions in memory</span></span><br><span class="line">        td_error = tf.losses.mean_squared_error(labels=q_target, predictions=q)</span><br><span class="line">        self.ctrain = tf.train.AdamOptimizer(LR_C).minimize(</span><br><span class="line">            td_error, var_list=self.ce_params)</span><br><span class="line"></span><br><span class="line">        a_loss = - tf.reduce_mean(q)    <span class="comment"># maximize the q</span></span><br><span class="line">        self.atrain = tf.train.AdamOptimizer(</span><br><span class="line">            LR_A).minimize(a_loss, var_list=self.ae_params)</span><br><span class="line"></span><br><span class="line">        self.sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.a, &#123;self.S: s[np.newaxis, :]&#125;)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># soft target replacement</span></span><br><span class="line">        self.sess.run(self.soft_replace)</span><br><span class="line"></span><br><span class="line">        indices = np.random.choice(MEMORY_CAPACITY, size=BATCH_SIZE)</span><br><span class="line">        bt = self.memory[indices, :]</span><br><span class="line">        bs = bt[:, :self.s_dim]</span><br><span class="line">        ba = bt[:, self.s_dim: self.s_dim + self.a_dim]</span><br><span class="line">        br = bt[:, -self.s_dim - <span class="number">1</span>: -self.s_dim]</span><br><span class="line">        bs_ = bt[:, -self.s_dim:]</span><br><span class="line"></span><br><span class="line">        self.sess.run(self.atrain, &#123;self.S: bs&#125;)</span><br><span class="line">        self.sess.run(self.ctrain, &#123;self.S: bs,</span><br><span class="line">                      self.a: ba, self.R: br, self.S_: bs_&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_</span>):</span></span><br><span class="line">        transition = np.hstack((s, a, [r], s_))</span><br><span class="line">        <span class="comment"># replace the old memory with new memory</span></span><br><span class="line">        index = self.pointer % MEMORY_CAPACITY</span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_a</span>(<span class="params">self, s, scope, trainable</span>):</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">            net = tf.layers.dense(</span><br><span class="line">                s, <span class="number">30</span>, activation=tf.nn.relu, name=<span class="string">&#x27;l1&#x27;</span>, trainable=trainable)</span><br><span class="line">            a = tf.layers.dense(</span><br><span class="line">                net, self.a_dim, activation=tf.nn.tanh, name=<span class="string">&#x27;a&#x27;</span>, trainable=trainable)</span><br><span class="line">            <span class="keyword">return</span> tf.multiply(a, self.a_bound, name=<span class="string">&#x27;scaled_a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_c</span>(<span class="params">self, s, a, scope, trainable</span>):</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">            n_l1 = <span class="number">30</span></span><br><span class="line">            w1_s = tf.get_variable(</span><br><span class="line">                <span class="string">&#x27;w1_s&#x27;</span>, [self.s_dim, n_l1], trainable=trainable)</span><br><span class="line">            w1_a = tf.get_variable(</span><br><span class="line">                <span class="string">&#x27;w1_a&#x27;</span>, [self.a_dim, n_l1], trainable=trainable)</span><br><span class="line">            b1 = tf.get_variable(<span class="string">&#x27;b1&#x27;</span>, [<span class="number">1</span>, n_l1], trainable=trainable)</span><br><span class="line">            net = tf.nn.relu(tf.matmul(s, w1_s) + tf.matmul(a, w1_a) + b1)</span><br><span class="line">            <span class="keyword">return</span> tf.layers.dense(net, <span class="number">1</span>, trainable=trainable)  <span class="comment"># Q(s,a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################  training  ####################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env = gym.make(ENV_NAME)</span><br><span class="line">env = env.unwrapped</span><br><span class="line">env.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">a_dim = env.action_space.shape[<span class="number">0</span>]</span><br><span class="line">a_bound = env.action_space.high</span><br><span class="line"></span><br><span class="line">ddpg = DDPG(a_dim, s_dim, a_bound)</span><br><span class="line"></span><br><span class="line">var = <span class="number">3</span>  <span class="comment"># control exploration</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EPISODES):</span><br><span class="line">    s = env.reset()</span><br><span class="line">    ep_reward = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EP_STEPS):</span><br><span class="line">        <span class="keyword">if</span> RENDER:</span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add exploration noise</span></span><br><span class="line">        a = ddpg.choose_action(s)</span><br><span class="line">        <span class="comment"># add randomness to action selection for exploration</span></span><br><span class="line">        a = np.clip(np.random.normal(a, var), -<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        s_, r, done, info = env.step(a)</span><br><span class="line"></span><br><span class="line">        ddpg.store_transition(s, a, r / <span class="number">10</span>, s_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ddpg.pointer &gt; MEMORY_CAPACITY:</span><br><span class="line">            var *= <span class="number">.9995</span>    <span class="comment"># decay the action randomness</span></span><br><span class="line">            ddpg.learn()</span><br><span class="line"></span><br><span class="line">        s = s_</span><br><span class="line">        ep_reward += r</span><br><span class="line">        <span class="keyword">if</span> j == MAX_EP_STEPS-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Episode:&#x27;</span>, episode, <span class="string">&#x27; Reward: %i&#x27;</span> %</span><br><span class="line">                  <span class="built_in">int</span>(ep_reward), <span class="string">&#x27;Explore: %.2f&#x27;</span> % var, )</span><br><span class="line">            <span class="comment"># if ep_reward &gt; -300:RENDER = True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        total_reward = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            state = env.reset()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EP_STEPS):</span><br><span class="line">                env.render()</span><br><span class="line">                action = ddpg.choose_action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                state, reward, done, _ = env.step(action)</span><br><span class="line">                total_reward += reward</span><br><span class="line">                <span class="keyword">if</span> done:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        ave_reward = total_reward/<span class="number">300</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Running time: &#x27;</span>, time.time() - t1)</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;DDPG参考了DDQN的算法思想，通过双网络和经验回放，加一些其他的优化，比较好的解决了Actor-Critic难收敛的问题。因此在实际产品中尤其是自动化相关的产品中用的比较多，是一个比较成熟的Actor-Critic算法。</p><p>&emsp;&emsp;以上就是Policy Based RL系列算法，算上前面的Value Based RL系列算法，还剩下Model Based RL系列算法没研究，后面再说。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】深度强化学习：DQN算法族</title>
      <link href="/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADQN%E7%AE%97%E6%B3%95%E6%97%8F/"/>
      <url>/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADQN%E7%AE%97%E6%B3%95%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;动态规划DP、蒙特卡罗MC、时序差分TD这些求解MDP问题的算法，使用的状态都是有限个离散状态，问题规模小时易求解。而当问题规模庞大，或者状态是连续的且离散化后依然规模庞大时，无法将Q表存在有限的内存中。因此用价值函数的近似表示来修改模型。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117234446.png" alt="image-20220117234446365" style="zoom:67%;" /><span id="more"></span><p>&nbsp;</p><h2 id="价值函数的近似表示"><a href="#价值函数的近似表示" class="headerlink" title="价值函数的近似表示"></a>价值函数的近似表示</h2><h4 id="状态价值函数"><a href="#状态价值函数" class="headerlink" title="状态价值函数"></a>状态价值函数</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162045.png" alt="image-20220116162045244" style="zoom: 67%;" /><h4 id="动作价值函数"><a href="#动作价值函数" class="headerlink" title="动作价值函数"></a>动作价值函数</h4><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109095934.png" alt="image-20220109095934523" style="zoom: 33%;" /><p>&emsp;&emsp;具体的近似方法有很多，比如：线性表示法、决策树、最近邻、傅里叶变换等，但是最常用的是神经网络（DNN、CNN、RNN）</p><p>&emsp;&emsp;对于状态价值函数，神经网络的输入是状态s的特征向量，输出是状态价值v(s,w)。</p><p>&emsp;&emsp;对于动作价值函数，有两种方法，一种是输入状态s的特征向量和动作a，输出对应的动作价值q(s,a,w)，另一种是只输入状态s的特征向量，动作集合有多少个动作就有多少个输出q(s,a,w)（这里隐示了动作是有限个的离散动作）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109100417.png" alt="image-20220109100417543" style="zoom: 33%;" /><p>&nbsp;</p><h2 id="NIPS-DQN算法"><a href="#NIPS-DQN算法" class="headerlink" title="NIPS DQN算法"></a>NIPS DQN算法</h2><p>&emsp;&emsp;NIPS DQN是2013年由 DeepMind 在NIPS上发表的一篇论文中提出的，也是DQN算法族的第一位成员，是最原始的DQN算法。论文：<a href="https://lrk612.com/resources/Playing%20Atari%20with%20Deep%20Reinforcement%20Learning.pdf">Playing Atari with Deep Reinforcement Learning</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;基本思路来源于Q-Learning，但是和Q-Learning不同的地方在于，它Q值不是直接通过状态值S和动作A来计算，而是通过上面讲到的Q网络来计算，这个Q网络是一个神经网络。</p><h3 id="经验回放（experience-replay）"><a href="#经验回放（experience-replay）" class="headerlink" title="经验回放（experience replay）"></a><strong>经验回放（experience replay）</strong></h3><p>&emsp;&emsp;将每次和环境交互得到的奖励与状态更新情况都保存在经验池中，用于后面目标Q值的更新。Q-Learning有一张Q表来保存所有的Q值的当前结果的，而DQN在做动作价值函数更新时靠的就是经验回放。从通过经验回放得到的目标Q值和通过Q网络直接计算得到的Q估计值肯定是不等的，二者的差别构成神经网络的损失函数Loss Function，然后通过梯度的反向传播来更新神经网络的参数w，当w收敛后就得到的近似的Q值计算方法，进而贪婪策略也就求出来了。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220207145830.png" alt="image-20220207145830293" style="zoom:60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、Q网络结构、批量梯度下降的样本数m</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q网络参数w</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化Q网络的所有参数w，基于w初始化所有的状态和动作对应的价值Q，清空经验池D</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，拿到其特征向量ϕ(S)</p></li><li><p>把ϕ(S)输入Q网络，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作A</p></li><li><p>执行动作A，由环境得到新状态S‘ 对应的特征向量ϕ(S‘)、奖励R’、终止标志is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，把S‘  和A’ 输入神经网络结合贪婪策略计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109102614.png" alt="image-20220109102614326" style="zoom: 33%;" /></li><li><p>把S  和A 输入Q网络直接求Q估计值，由上一步从经验池回放得到的 yj 和此步得到的Q估计值，求出损失函数 Loss Function，梯度反向传播更新Q网络参数w。这里使用的是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，f步目标Q值和g步Q估计值的计算都用了同一个Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代的进行而变小）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;以OpenAI Gym中的CartPole-v0游戏为例，介绍参见<a href="https://github.com/openai/gym/wiki/CartPole-v0">这里</a>。它的基本要求就是控制下面的cart移动使连接在上面的pole保持垂直不倒。这个任务只有两个离散动作，要么向左用力，要么向右用力。而state状态就是这个cart的位置和速度， pole的角度和角速度，4维的特征。坚持到200分的奖励则为过关。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">        b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">        W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">        b2 = self.bias_variable([self.action_dim])</span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># hidden layers</span></span><br><span class="line">        h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">        <span class="comment"># Q Value layer</span></span><br><span class="line">        self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create training method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">10</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;800轮左右收敛，但是并不稳定，平均Reward在200附近浮动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151404.png" alt="image-20220117151357691" style="zoom:50%;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;DQN由于对价值函数Q做了近似表示，因此有了解决大规模强化学习问题的能力。但是DQN有个问题，就是它并不一定能保证Q网络的收敛，也就是说不一定可以得到收敛后的Q网络参数。这会导致训练出的模型效果很差。针对这个问题衍生出了DQN的很多变种，比如Nature DQN(NIPS 2015)、Double DQN、Dueling DQN等。</p><p>&nbsp;</p><h2 id="Nature-DQN算法"><a href="#Nature-DQN算法" class="headerlink" title="Nature DQN算法"></a>Nature DQN算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;2015年，DeepMind对NIPS DQN进行了一次重大改造，并在Nature上披露了这个模型，即：Nature DQN。论文：<a href="https://lrk612.com/resources/Human-level%20control%20through%20deep%20reinforcement%20learning.pdf">Human-level control through deep reinforcement learning</a></p><h4 id="针对问题"><a href="#针对问题" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;注意到上面DQN算法其实在实际应用时存在一些问题，其中一个就是目标Q值的计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109102614.png" alt="image-20220109102614326" style="zoom: 33%;" /><p>&emsp;&emsp;使用到了当前待训练网络的参数，而计算的结果 yj 又被用于反向传播更新网络的参数，二者循环依赖，相关性太强不利于算法收敛。</p><h4 id="优化：双网络结构"><a href="#优化：双网络结构" class="headerlink" title="优化：双网络结构"></a>优化：双网络结构</h4><p>&emsp;&emsp;Nature DQN尝试用两个Q网络来减少 <code>目标Q值的计算 </code>和 <code>待更新Q网络参数 </code>之间的依赖关系。</p><p>&emsp;&emsp;<strong>当前Q网络</strong>计算Q估计值用于选择动作，更新模型参数，<strong>目标Q网络</strong>用于计算目标Q值。目标Q网络的网络参数不需要迭代更新，而是每隔一段时间从当前Q网络复制过来，即延时更新，这样可以减少目标Q值和当前Q值的相关性。二者其余部分基本是完全相同的。（要注意的是，两个Q网络的结构是一模一样的。这样才可以复制网络参数 ）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220210140232.png" alt="image-20220210140117411" style="zoom:30%;" /><center>图片 via 18级种子班 zyh</center><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220207145618.png" alt="image-20220207145618398" style="zoom:60%;" /><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、当前Q网络Q、目标Q网络Q′、批量梯度下降的样本数m、目标Q网络参数更新频率C</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数（目标Q网络只是辅助工具）</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w，清空经验池D</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前序列的第一个状态，求其特征向量 ϕ(S)</p></li><li><p>把 ϕ(S) 输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出（Q估计值），用 ε-greedy 策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池 D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，把S‘  和A’ 输入<strong>目标Q网络</strong>结合贪婪策略计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162500.png" alt="image-20220116162500661" style="zoom: 67%;" /><p>（注意：公式里的是Q’ 不是Q )</p></li><li><p>把S‘  和A’ 输入<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求损失函数Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数w。这里使用的仍是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /></li><li><p>if i%C == 0：更新<strong>目标Q网络</strong>参数w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，6步用目标Q网络计算目标Q值、2、7步用的是当前Q网络计算Q估计值。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;比起上面普通DQN的代码，这里有两个三层神经网络，一个是当前Q网络，一个是目标Q网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;1000轮左右收敛，比DQN更稳定，平均Reward基本固定在200</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151545.png" alt="image-20220117151545443" style="zoom:50%;" /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Nature DQN 对 普通DQN 做了相关性方面的改进，这个改进虽然不错，但是仍然没有解决DQN的 很多问题，比如：</p><ul><li>目标Q值的计算是否准确？全部通过max Q来计算有没有问题？</li><li>从经验池随机采样的方法好吗？按道理不同样本的重要性是不一样的。</li><li>Q值代表状态动作的价值，那么单独动作价值的评估会不会更准确？</li></ul><p>&emsp;&emsp;第一个问题对应的改进是Double DQN, 第二个问题的改进是Prioritised Replay DQN，第三个问题的改进是Dueling DQN。</p><p>&nbsp;</p><h2 id="Double-DQN算法"><a href="#Double-DQN算法" class="headerlink" title="Double DQN算法"></a>Double DQN算法</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Double DQN 是由DeepMind团队在2015年提出来的，由Double Q-Learning迁移而来，是传统机器学习的思路，即不一定非要有神经网络结构才能训练，只要有两个一模一样的Q-Learning或DQN网络就可以构成Double模型。论文：<a href="https://lrk612.com/resources/Deep%20Reinforcement%20Learning%20with%20Double%20Q-learning.pdf">Deep Reinforcement Learning with Double Q-learning</a></p><h4 id="针对问题-1"><a href="#针对问题-1" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;在DDQN之前，基本上所有的目标Q值都是通过贪婪法直接得到的，无论是Q-Learning、普通DQN 还是 Nature DQN。比如对于Nature DQN，虽然用了两个Q网络并使用目标Q网络计算目标Q值，其第 j 个样本的目标Q值的计算还是贪婪法得到的：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162500.png" alt="image-20220116162500661" style="zoom: 67%;" /><p>&emsp;&emsp;使用max虽然可以快速让Q值向可能的优化目标靠拢，但是很容易过犹不及，导致过度估计(Over Estimation)。所谓过度估计就是最终得到的算法模型有很大的偏差(bias)。而DDQN通过解耦 <code>目标Q值动作的选择</code> 和 <code>目标Q值的估计</code> 这两步，来达到消除过度估计的问题。</p><h4 id="优化：Q值与动作解耦"><a href="#优化：Q值与动作解耦" class="headerlink" title="优化：Q值与动作解耦"></a>优化：Q值与动作解耦</h4><p>Nature DQN对于非终止状态，其目标Q值的计算式子是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162949.png" alt="image-20220116162627124" style="zoom: 67%;" /><hr><p>但是在DDQN里，不再是直接把S‘ 输入目标Q网络然后按贪婪策略找最大Q值，而是先把S‘ 输入当前Q网络（用于估计Q值，需要被更新的那个网络）中找出最大Q值对应的动作amax(S′,j,w)，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192104.png" alt="image-20220110192104796" style="zoom:33%;" /><p>然后利用这个选择出来的动作amax(S′j,w)在目标网络里面去计算目标Q值。即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192330.png" alt="image-20220110192330730" style="zoom:33%;" /><p>综合起来写就是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110192450.png" alt="image-20220110192450277" style="zoom:33%;" /><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、衰减因子γ、探索率ϵ、当前Q网络、目标Q网络、批量梯度下降的样本数m、目标Q网络参数更新频率C</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w，清空经验池D</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前状态序列的第一个状态, 拿到其特征向量 ϕ(S)</p></li><li><p>把ϕ(S)输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入经验池 D</p></li><li><p>前进一步：S = S’</p></li><li><p>从经验池中采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，用<strong>Q值与动作解耦的思想</strong>计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110193225.png" alt="image-20220110193225013" style="zoom:33%;" /></li><li><p>用<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求损失函数 Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数 w</p></li><li><p>if i%C == 0：更新<strong>目标Q网络</strong>参数 w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤2.2</p></li></ol></li></ol><p>（注意，f步两个网络都用了、g步只用到了当前Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;与Nature DQN代码只有在目标Q值的计算处不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        current_Q_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        max_action_next = np.argmax(current_Q_batch, axis=<span class="number">1</span>)</span><br><span class="line">        target_Q_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target_Q_value = target_Q_batch[i, max_action_next[i]]</span><br><span class="line">                y_batch.append(reward_batch[i] + GAMMA * target_Q_value)</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;1000轮左右收敛，比较稳定，但是平均Reward后期有抖动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117151914.png" alt="image-20220117151914056" style="zoom:50%;" /><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;过估计问题是Q-Learning算法与生俱来的，并遗传给了后代”DQN“。从统计学的角度来看，如果在输出端对每个动作的估值Q的过估计幅度都一样，那么和没有过估计效果是一样的。但是如果过估计是不均匀的，那么这样学到的策略未必是最优解，此时Double DQN就派上用场了。</p><p>&nbsp;</p><h2 id="Prioritized-Replay-DQN算法"><a href="#Prioritized-Replay-DQN算法" class="headerlink" title="Prioritized Replay DQN算法"></a>Prioritized Replay DQN算法</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;优先回放的概念最早在2016年由发表于ICLR的论文：<a href="https://lrk612.com/resources/Prioritized%20experience%20%20replay.pdf">Prioritized experience  replay</a></p><h4 id="针对问题-2"><a href="#针对问题-2" class="headerlink" title="针对问题"></a>针对问题</h4><p>&emsp;&emsp;普通DQN、Nature DQN、DDQN等都是通过经验回放来采样，进而做目标Q值的计算的。在采样时经验池里的所有样本都有相同的被采样概率。但是注意到在经验池里面的不同的样本由于TD误差的不同，对反向传播的作用是不一样的。TD误差越大，对反向传播的作用越大。而TD误差小的样本对反向梯度的计算影响不大。在Q网络中，TD误差就是目标Q网络计算的目标Q值和当前Q网络计算的Q值之间的差距。这样如果TD误差的绝对值|δ(t)|较大的样本更容易被采样，则算法会比较容易收敛。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="经验池优化"><a href="#经验池优化" class="headerlink" title="经验池优化"></a>经验池优化</h5><p>&emsp;&emsp;Prioritized Replay DQN的经验池中每个样本的优先级正比于TD误差绝对值|δ(t)|。由于引入了经验回放的优先级，Prioritized Replay DQN的经验池和之前的其他DQN算法的经验池不一样，因为这个优先级大小会影响它被采样的概率。在实际使用中，通常使用SumTree这样的二叉树结构来做带优先级的经验回放池样本的存储：</p><p>​                                                                    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210718214249.png" alt="image-20210717092213437" style="zoom: 33%;" /></p><p>&emsp;&emsp;所有的经验回放样本只保存在最下面的叶子节点上面，一个节点一个样本，内部节点不保存样本数据。叶子节点除了保存数据以外，还要保存该样本的优先级数值（TD误差）。对于内部节点每个节点只保存自己的儿子节点的优先级值之和。以上面的树结构为例，根节点是42，如果要采样一个样本，可以在[0, 42]之间做均匀采样，采样到哪个区间，就是哪个样本。</p><p>（注意：当Q网络参数进行了梯度更新后，需要重新计算TD误差，并将TD误差更新到SunTree上面）</p><h5 id="Loss-Function优化"><a href="#Loss-Function优化" class="headerlink" title="Loss Function优化"></a>Loss Function优化</h5><p>&emsp;&emsp;上面使用的损失函数都是均方损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220109103107.png" alt="image-20220109103107567" style="zoom: 33%;" /><p>&emsp;&emsp;考虑了样本优先级的损失函数要加上优先权重因子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162911.png" alt="image-20220116162911599" style="zoom:67%;" /><p>&emsp;&emsp;( 其中wj是第j个样本的优先级权重，由TD误差|δ(t)|归一化得到 )</p><h3 id="算法流程（集成了DDQN）"><a href="#算法流程（集成了DDQN）" class="headerlink" title="算法流程（集成了DDQN）"></a>算法流程（集成了DDQN）</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态特征维度n、动作集A、步长α、采样权重系数β、衰减因子γ、探索率ϵ、当前Q网络、目标Q网络、批量梯度下降的样本数m、目标Q网络参数更新频率C、SumTree的叶子节点数S</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Q网络参数</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，随机初始化当前Q网络的所有参数w，初始化目标Q网络Q′的参数w′=w</p></li><li><p>初始化经验池SumTree的默认数据结构，SumTree的S个叶子节点的优先级pj都初始化为1</p></li><li><p>for i in [ 1, T ]:</p><ol><li><p>初始化S为当前状态序列的第一个状态, 拿到其特征向量 ϕ(S)</p></li><li><p>把ϕ(S)输入<strong>当前Q网络</strong>，得到所有动作对应的Q值输出，用ε-greedy策略从中选择出动作 A</p></li><li><p>执行动作 A，由环境得到新状态 S‘ 对应的特征向量 ϕ(S’)、奖励 R、终止标志 is_end</p></li><li><p>将 <code>&#123; ϕ(S)，A，R，ϕ(S‘)，is_end &#125;</code> 这个五元组存入SumTree</p></li><li><p>前进一步：S = S’</p></li><li><p>从SumTree中<strong>依概率</strong> <code>P(j) = pj / ∑(pi)</code> 采集m个样本 <code>&#123; ϕ(Sj)，Aj，Rj，ϕ(Sj‘)，is_endj &#125;，j = 1,2,3.....,m</code>，用<strong>Q值与动作解耦的思想</strong>计算目标Q值 yj：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220110193225.png" alt="image-20220110193225013" style="zoom:33%;" /></li><li><p>用<strong>当前Q网络</strong>求Q估计值，由目标Q值和Q估计值求<strong>带优先权重因子wj的</strong>损失函数 Loss Function，然后梯度反向传播更新<strong>当前Q网络</strong>参数 w</p><p>优先权重因子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111145825.png" alt="image-20220111145825168" style="zoom:33%;" /><p>损失函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116162911.png" alt="image-20220116162911599" style="zoom:67%;" /></li><li><p>用更新参数后的当前Q网络重新计算经验池中每个样本的Q估计值，然后用目标Q值和新的Q估计值算出新的TD误差作为优先级更新SumTree</p></li><li><p>if i%C == 0：更新目标Q网络参数w’ = w</p></li><li><p>if  S’是终止状态，break；else 跳回步骤3.2</p></li></ol></li></ol><p>（注意，f步两个网络都用了、g步只用到了当前Q网络。另外，实际应用中为了算法较好的收敛，探索率ϵ需要随着迭代变小 ）</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This SumTree code is a modified version and the original code is from:</span></span><br><span class="line"><span class="string">    https://github.com/jaara/AI-blog/blob/master/SumTree.py</span></span><br><span class="line"><span class="string">    Story data with its priority in the tree.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data_pointer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity  <span class="comment"># for all priority values</span></span><br><span class="line">        self.tree = np.zeros(<span class="number">2</span> * capacity - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># [-------------Parent nodes------------][------leaves to recode priority------]</span></span><br><span class="line">        <span class="comment">#             size: capacity - 1                       size: capacity</span></span><br><span class="line">        self.data = np.zeros(capacity, dtype=<span class="built_in">object</span>)  <span class="comment"># for all transitions</span></span><br><span class="line">        <span class="comment"># [--------------data frame-------------]</span></span><br><span class="line">        <span class="comment">#             size: capacity</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, p, data</span>):</span></span><br><span class="line">        tree_idx = self.data_pointer + self.capacity - <span class="number">1</span></span><br><span class="line">        self.data[self.data_pointer] = data  <span class="comment"># update data_frame</span></span><br><span class="line">        self.update(tree_idx, p)  <span class="comment"># update tree_frame</span></span><br><span class="line"></span><br><span class="line">        self.data_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.data_pointer &gt;= self.capacity:  <span class="comment"># replace when exceed the capacity</span></span><br><span class="line">            self.data_pointer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, tree_idx, p</span>):</span></span><br><span class="line">        change = p - self.tree[tree_idx]</span><br><span class="line">        self.tree[tree_idx] = p</span><br><span class="line">        <span class="comment"># then propagate the change through tree</span></span><br><span class="line">        <span class="keyword">while</span> tree_idx != <span class="number">0</span>:    <span class="comment"># this method is faster than the recursive loop in the reference code</span></span><br><span class="line">            tree_idx = (tree_idx - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            self.tree[tree_idx] += change</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_leaf</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Tree structure and array storage:</span></span><br><span class="line"><span class="string">        Tree index:</span></span><br><span class="line"><span class="string">             0         -&gt; storing priority sum</span></span><br><span class="line"><span class="string">            / \</span></span><br><span class="line"><span class="string">          1     2</span></span><br><span class="line"><span class="string">         / \   / \</span></span><br><span class="line"><span class="string">        3   4 5   6    -&gt; storing priority for transitions</span></span><br><span class="line"><span class="string">        Array type for storing:</span></span><br><span class="line"><span class="string">        [0,1,2,3,4,5,6]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        parent_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:     <span class="comment"># the while loop is faster than the method in the reference code</span></span><br><span class="line">            cl_idx = <span class="number">2</span> * parent_idx + <span class="number">1</span>         <span class="comment"># this leaf&#x27;s left and right kids</span></span><br><span class="line">            cr_idx = cl_idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cl_idx &gt;= <span class="built_in">len</span>(self.tree):        <span class="comment"># reach bottom, end search</span></span><br><span class="line">                leaf_idx = parent_idx</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:       <span class="comment"># downward search, always search for a higher priority node</span></span><br><span class="line">                <span class="keyword">if</span> v &lt;= self.tree[cl_idx]:</span><br><span class="line">                    parent_idx = cl_idx</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    v -= self.tree[cl_idx]</span><br><span class="line">                    parent_idx = cr_idx</span><br><span class="line"></span><br><span class="line">        data_idx = leaf_idx - self.capacity + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> leaf_idx, self.tree[leaf_idx], self.data[data_idx]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_p</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.tree[<span class="number">0</span>]  <span class="comment"># the root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span>(<span class="params"><span class="built_in">object</span></span>):</span>  <span class="comment"># stored as ( s, a, r, s_ ) in SumTree</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This Memory class is modified based on the original code from:</span></span><br><span class="line"><span class="string">    https://github.com/jaara/AI-blog/blob/master/Seaquest-DDQN-PER.py</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    epsilon = <span class="number">0.01</span>  <span class="comment"># small amount to avoid zero priority</span></span><br><span class="line">    alpha = <span class="number">0.6</span>  <span class="comment"># [0~1] convert the importance of TD error to priority</span></span><br><span class="line">    beta = <span class="number">0.4</span>  <span class="comment"># importance-sampling, from initial value increasing to 1</span></span><br><span class="line">    beta_increment_per_sampling = <span class="number">0.001</span></span><br><span class="line">    abs_err_upper = <span class="number">1.</span>  <span class="comment"># clipped abs error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.tree = SumTree(capacity)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store</span>(<span class="params">self, transition</span>):</span></span><br><span class="line">        max_p = np.<span class="built_in">max</span>(self.tree.tree[-self.tree.capacity:])</span><br><span class="line">        <span class="keyword">if</span> max_p == <span class="number">0</span>:</span><br><span class="line">            max_p = self.abs_err_upper</span><br><span class="line">        self.tree.add(max_p, transition)   <span class="comment"># set the max p for new p</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        b_idx, b_memory, ISWeights = np.empty((n,), dtype=np.int32), np.empty(</span><br><span class="line">            (n, self.tree.data[<span class="number">0</span>].size)), np.empty((n, <span class="number">1</span>))</span><br><span class="line">        pri_seg = self.tree.total_p / n       <span class="comment"># priority segment</span></span><br><span class="line">        self.beta = np.<span class="built_in">min</span>(</span><br><span class="line">            [<span class="number">1.</span>, self.beta + self.beta_increment_per_sampling])  <span class="comment"># max = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for later calculate ISweight</span></span><br><span class="line">        min_prob = np.<span class="built_in">min</span>(</span><br><span class="line">            self.tree.tree[-self.tree.capacity:]) / self.tree.total_p</span><br><span class="line">        <span class="keyword">if</span> min_prob == <span class="number">0</span>:</span><br><span class="line">            min_prob = <span class="number">0.00001</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = pri_seg * i, pri_seg * (i + <span class="number">1</span>)</span><br><span class="line">            v = np.random.uniform(a, b)</span><br><span class="line">            idx, p, data = self.tree.get_leaf(v)</span><br><span class="line">            prob = p / self.tree.total_p</span><br><span class="line">            ISWeights[i, <span class="number">0</span>] = np.power(prob/min_prob, -self.beta)</span><br><span class="line">            b_idx[i], b_memory[i, :] = idx, data</span><br><span class="line">        <span class="keyword">return</span> b_idx, b_memory, ISWeights</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">batch_update</span>(<span class="params">self, tree_idx, abs_errors</span>):</span></span><br><span class="line">        abs_errors += self.epsilon  <span class="comment"># convert to abs and avoid 0</span></span><br><span class="line">        clipped_errors = np.minimum(abs_errors, self.abs_err_upper)</span><br><span class="line">        ps = np.power(clipped_errors, self.alpha)</span><br><span class="line">        <span class="keyword">for</span> ti, p <span class="keyword">in</span> <span class="built_in">zip</span>(tree_idx, ps):</span><br><span class="line">            self.tree.update(ti, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_total = <span class="number">0</span></span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line">        self.memory = Memory(capacity=REPLAY_SIZE)</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        self.ISWeights = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2 = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.Q_value = tf.matmul(h_layer, W2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line">            W2t = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">            b2t = self.bias_variable([self.action_dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layers</span></span><br><span class="line">            h_layer_t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line">            <span class="comment"># Q Value layer</span></span><br><span class="line">            self.target_Q_value = tf.matmul(h_layer_t, W2t) + b2t</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])</span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(</span><br><span class="line">            self.ISWeights * (tf.square(self.y_input - Q_action)))</span><br><span class="line">        self.abs_errors = tf.<span class="built_in">abs</span>(self.y_input - Q_action)</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_, done</span>):</span></span><br><span class="line">        transition = np.hstack((s, a, r, s_, done))</span><br><span class="line">        <span class="comment"># have high priority for newly arrived transition</span></span><br><span class="line">        self.memory.store(transition)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(state,one_hot_action,reward,next_state,done)</span></span><br><span class="line">        self.store_transition(state, one_hot_action, reward, next_state, done)</span><br><span class="line">        self.replay_total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.replay_total &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        tree_idx, minibatch, ISWeights = self.memory.sample(BATCH_SIZE)</span><br><span class="line">        state_batch = minibatch[:, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        action_batch = minibatch[:, <span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">        reward_batch = [data[<span class="number">6</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = minibatch[:, <span class="number">7</span>:<span class="number">11</span>]</span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        current_Q_batch = self.Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        max_action_next = np.argmax(current_Q_batch, axis=<span class="number">1</span>)</span><br><span class="line">        target_Q_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">11</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target_Q_value = target_Q_batch[i, max_action_next[i]]</span><br><span class="line">                y_batch.append(reward_batch[i] + GAMMA * target_Q_value)</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch,</span><br><span class="line">            self.ISWeights: ISWeights</span><br><span class="line">        &#125;)</span><br><span class="line">        _, abs_errors, _ = self.session.run([self.optimizer, self.abs_errors, self.cost], feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch,</span><br><span class="line">            self.ISWeights: ISWeights</span><br><span class="line">        &#125;)</span><br><span class="line">        self.memory.batch_update(tree_idx, abs_errors)  <span class="comment"># update priority</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;因为经验池使用SumTree结构导致计算量较大，训练起来很慢，不过600轮左右就收敛了，但后期同样有抖动</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117154635.png" alt="image-20220117154635353" style="zoom:50%;" /><p>&nbsp;</p><h2 id="Dueling-DQN算法"><a href="#Dueling-DQN算法" class="headerlink" title="Dueling DQN算法"></a>Dueling DQN算法</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Dueling DQN 也是DeepMind的大作之一。论文：<a href="https://lrk612.com/resources/Dueling%20Network%20Architectures%20for%20Deep%20Reinforcement%20Learning.pdf">Dueling Network Architectures for Deep Reinforcement Learning</a></p><h4 id="优化：从网络结构下手"><a href="#优化：从网络结构下手" class="headerlink" title="优化：从网络结构下手"></a>优化：从网络结构下手</h4><p>&emsp;&emsp;DDQN中通过优化目标Q值的计算来优化算法，Prioritized Replay DQN中通过优化经验回放池按权重采样来优化算法，而在Dueling DQN中通过优化神经网络的结构来优化算法。</p><p>&emsp;&emsp;Dueling DQN将Q网络增加了两部分：第一部分仅与状态S有关，与具体要采用的动作A无关，叫做价值函数部分，记做 <code>V(S,w,α)</code> ；第二部分同时与状态状态S和动作A有关，这部分叫做优势函数(Advantage Function)部分，记为 <code>A(S,A,w,β)</code>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20210718214253.png" alt="image-20210717102817738" style="zoom: 50%;" /><p>&emsp;&emsp;最终价值函数重新表示为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220111151330.png" alt="image-20220111151330160" style="zoom:33%;" /><p>（其中，w是公共部分的网络参数，而α是价值函数部分独有的网络参数，β是优势函数部分独有的网络参数 。注意最右边减去均值的操作是在对优势函数部分做中心化的处理 ）</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><strong>问题</strong></p><p>&emsp;&emsp;CartPole-v0游戏</p><p><strong>代码</strong></p><p>&emsp;&emsp;与Nature DQN代码只有两个Q网络的结构不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters for DQN</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># discount factor for target Q</span></span><br><span class="line">INITIAL_EPSILON = <span class="number">0.5</span>  <span class="comment"># starting value of epsilon</span></span><br><span class="line">FINAL_EPSILON = <span class="number">0.01</span>  <span class="comment"># final value of epsilon</span></span><br><span class="line">REPLAY_SIZE = <span class="number">10000</span>  <span class="comment"># experience replay buffer size</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span>  <span class="comment"># size of minibatch</span></span><br><span class="line">REPLACE_TARGET_FREQ = <span class="number">10</span>  <span class="comment"># frequency to update target Q network</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>():</span></span><br><span class="line">    <span class="comment"># DQN Agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="comment"># init experience replay</span></span><br><span class="line">        self.replay_buffer = deque()</span><br><span class="line">        <span class="comment"># init some parameters</span></span><br><span class="line">        self.time_step = <span class="number">0</span></span><br><span class="line">        self.epsilon = INITIAL_EPSILON</span><br><span class="line">        self.state_dim = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line">        self.action_dim = env.action_space.n</span><br><span class="line"></span><br><span class="line">        self.create_Q_network()</span><br><span class="line">        self.create_training_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Init session</span></span><br><span class="line">        self.session = tf.InteractiveSession()</span><br><span class="line">        self.session.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create Q network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># input layer</span></span><br><span class="line">        self.state_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.state_dim])</span><br><span class="line">        <span class="comment"># network weights</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;current_net&#x27;</span>):</span><br><span class="line">            W1 = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1 = self.bias_variable([<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer 1</span></span><br><span class="line">            h_layer_1 = tf.nn.relu(tf.matmul(self.state_input, W1) + b1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for state value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Value&#x27;</span>):</span><br><span class="line">                W21 = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">                b21 = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">                self.V = tf.matmul(h_layer_1, W21) + b21</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for action value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Advantage&#x27;</span>):</span><br><span class="line">                W22 = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">                b22 = self.bias_variable([self.action_dim])</span><br><span class="line">                self.A = tf.matmul(h_layer_1, W22) + b22</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Q Value layer</span></span><br><span class="line">                self.Q_value = self.V + \</span><br><span class="line">                    (self.A - tf.reduce_mean(self.A, axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;target_net&#x27;</span>):</span><br><span class="line">            W1t = self.weight_variable([self.state_dim, <span class="number">20</span>])</span><br><span class="line">            b1t = self.bias_variable([<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer 1</span></span><br><span class="line">            h_layer_1t = tf.nn.relu(tf.matmul(self.state_input, W1t) + b1t)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for state value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Value&#x27;</span>):</span><br><span class="line">                W2v = self.weight_variable([<span class="number">20</span>, <span class="number">1</span>])</span><br><span class="line">                b2v = self.bias_variable([<span class="number">1</span>])</span><br><span class="line">                self.VT = tf.matmul(h_layer_1t, W2v) + b2v</span><br><span class="line"></span><br><span class="line">            <span class="comment"># hidden layer  for action value</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;Advantage&#x27;</span>):</span><br><span class="line">                W2a = self.weight_variable([<span class="number">20</span>, self.action_dim])</span><br><span class="line">                b2a = self.bias_variable([self.action_dim])</span><br><span class="line">                self.AT = tf.matmul(h_layer_1t, W2a) + b2a</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Q Value layer</span></span><br><span class="line">                self.target_Q_value = self.VT + \</span><br><span class="line">                    (self.AT - tf.reduce_mean(self.AT, axis=<span class="number">1</span>, keep_dims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">        t_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;target_net&#x27;</span>)</span><br><span class="line">        e_params = tf.get_collection(</span><br><span class="line">            tf.GraphKeys.GLOBAL_VARIABLES, scope=<span class="string">&#x27;current_net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;soft_replacement&#x27;</span>):</span><br><span class="line">            self.target_replace_op = [</span><br><span class="line">                tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> <span class="built_in">zip</span>(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_training_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action_input = tf.placeholder(</span><br><span class="line">            <span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, self.action_dim])  <span class="comment"># one hot presentation</span></span><br><span class="line">        self.y_input = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>])  <span class="comment"># Q target</span></span><br><span class="line">        Q_action = tf.reduce_sum(tf.multiply(</span><br><span class="line">            self.Q_value, self.action_input), reduction_indices=<span class="number">1</span>)</span><br><span class="line">        self.cost = tf.reduce_mean(tf.square(self.y_input - Q_action))</span><br><span class="line">        self.optimizer = tf.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(self.cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replay bufffer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perceive</span>(<span class="params">self, state, action, reward, next_state, done</span>):</span></span><br><span class="line">        one_hot_action = np.zeros(self.action_dim)</span><br><span class="line">        one_hot_action[action] = <span class="number">1</span></span><br><span class="line">        self.replay_buffer.append(</span><br><span class="line">            (state, one_hot_action, reward, next_state, done))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; REPLAY_SIZE:</span><br><span class="line">            self.replay_buffer.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.replay_buffer) &gt; BATCH_SIZE:</span><br><span class="line">            self.train_Q_network()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train Q Network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_Q_network</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 1: obtain random minibatch from replay memory</span></span><br><span class="line">        minibatch = random.sample(self.replay_buffer, BATCH_SIZE)</span><br><span class="line">        state_batch = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        action_batch = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        reward_batch = [data[<span class="number">2</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line">        next_state_batch = [data[<span class="number">3</span>] <span class="keyword">for</span> data <span class="keyword">in</span> minibatch]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: calculate y</span></span><br><span class="line">        y_batch = []</span><br><span class="line">        Q_value_batch = self.target_Q_value.<span class="built_in">eval</span>(</span><br><span class="line">            feed_dict=&#123;self.state_input: next_state_batch&#125;)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, BATCH_SIZE):</span><br><span class="line">            done = minibatch[i][<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                y_batch.append(reward_batch[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_batch.append(reward_batch[i] +</span><br><span class="line">                               GAMMA * np.<span class="built_in">max</span>(Q_value_batch[i]))</span><br><span class="line"></span><br><span class="line">        self.optimizer.run(feed_dict=&#123;</span><br><span class="line">            self.y_input: y_batch,</span><br><span class="line">            self.action_input: action_batch,</span><br><span class="line">            self.state_input: state_batch</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the epsilon-greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">egreedy_action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        Q_value = self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= self.epsilon:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> random.randint(<span class="number">0</span>, self.action_dim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># epsilon gradually decreases</span></span><br><span class="line">            self.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / <span class="number">10000</span></span><br><span class="line">            <span class="keyword">return</span> np.argmax(Q_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output the greedy action</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.argmax(self.Q_value.<span class="built_in">eval</span>(feed_dict=&#123;</span><br><span class="line">            self.state_input: [state]</span><br><span class="line">        &#125;)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_target_q_network</span>(<span class="params">self, episode</span>):</span></span><br><span class="line">        <span class="comment"># update target Q netowrk</span></span><br><span class="line">        <span class="keyword">if</span> episode % REPLACE_TARGET_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.session.run(self.target_replace_op)</span><br><span class="line">            <span class="comment">#print(&#x27;episode &#x27;+str(episode) +&#x27;, target Q network params replaced!&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.truncated_normal(shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        initial = tf.constant(<span class="number">0.01</span>, shape=shape)</span><br><span class="line">        <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">ENV_NAME = <span class="string">&#x27;CartPole-v0&#x27;</span></span><br><span class="line">EPISODE = <span class="number">3000</span>  <span class="comment"># Episode limitation</span></span><br><span class="line">STEP = <span class="number">300</span>  <span class="comment"># Step limitation in an episode</span></span><br><span class="line">TEST = <span class="number">5</span>  <span class="comment"># The number of experiment test every 100 episode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># initialize OpenAI Gym env and dqn agent</span></span><br><span class="line">    env = gym.make(ENV_NAME)</span><br><span class="line">    agent = DQN(env)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(EPISODE):</span><br><span class="line">        <span class="comment"># initialize task</span></span><br><span class="line">        state = env.reset()</span><br><span class="line">        <span class="comment"># Train</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">            action = agent.egreedy_action(state)  <span class="comment"># e-greedy action for train</span></span><br><span class="line">            next_state, reward, done, _ = env.step(action)</span><br><span class="line">            <span class="comment"># Define reward for agent</span></span><br><span class="line">            reward = -<span class="number">1</span> <span class="keyword">if</span> done <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">            agent.perceive(state, action, reward, next_state, done)</span><br><span class="line">            state = next_state</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Test every 100 episodes</span></span><br><span class="line">        <span class="keyword">if</span> episode % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            total_reward = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TEST):</span><br><span class="line">                state = env.reset()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(STEP):</span><br><span class="line">                    env.render()</span><br><span class="line">                    action = agent.action(state)  <span class="comment"># direct action for test</span></span><br><span class="line">                    state, reward, done, _ = env.step(action)</span><br><span class="line">                    total_reward += reward</span><br><span class="line">                    <span class="keyword">if</span> done:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            ave_reward = total_reward/TEST</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;episode: &#x27;</span>, episode, <span class="string">&#x27;Evaluation Average Reward:&#x27;</span>, ave_reward)</span><br><span class="line">        agent.update_target_q_network(episode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>&emsp;&emsp;3000轮了都没收敛……</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220117152314.png" alt="image-20220117152314892" style="zoom:50%;" /><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;Dueling DQN使用了比较巧妙的方法，对状态的估值和独立于状态的动作优势估值进行解耦，从而使得网络能够学到更为准确的状态价值估值和动作优势估值。</p><p>&nbsp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这里一共总结了5种DQN算法：普通DQN、Nature DQN、DDQN、Prioritized Replay DQN、Dueling DQN，目前使用的比较主流的是后面三种算法思路，这三种算法思路也是可以混着一起使用的，相互并不排斥。</p><table><thead><tr><th>DQN算法族</th><th>特点</th></tr></thead><tbody><tr><td>NIPS DQN</td><td>第一个DQN算法，简单而有意义</td></tr><tr><td>Nature DQN</td><td>引入双网络结构，规避 <code>目标Q值的计算 </code>和 <code>待更新Q网络参数 </code>的过依赖</td></tr><tr><td>Double DQN</td><td>动作选择与动作估值解耦，规避过估计问题</td></tr><tr><td>Dueling DQN</td><td>优化神经网络的结构，将状态估值和动作优势估值解耦</td></tr><tr><td>Prioritized Replay DQN</td><td>在经验回放时引入优先级概念，提高网络学习效率</td></tr></tbody></table><p>&emsp;&emsp;当然DQN家族的算法远远不止这些，还有一些其他的DQN算法没有总结，比如使用一些较复杂的CNN和RNN网络来提高DQN的表达能力，又比如改进探索状态空间的方法等，主要是在DQN的基础上持续优化。</p><p>&emsp;&emsp;DQN算是深度强化学习的中的主流流派，代表了Value-Based这一大类深度强化学习算法。但是它也有自己的一些问题，就是绝大多数DQN只能处理离散的动作集合，不能处理连续的动作集合。虽然NAF DQN可以解决这个问题，但是方法过于复杂了。而深度强化学习的另一个主流流派Policy-Based而可以较好的解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计网课设】基于强化学习的TCP拥塞控制算法优化</title>
      <link href="/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
      <url>/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;我们使用mininet平台作为网络拓扑仿真工具，选择TCP拥塞控制算法作为研究对象，以项目组工作技术背景：5G无线通信场景中的强化学习作为切入点，对 Linux 内核搭载的经典 TCP 拥塞控制算法：Reno、Vegas、Veno、BBR、CUBIC进行调研学习，最终决定对超参数依赖性较强的TCP_Veno算法进行强化学习调优。期间我们把算法直接集成到Linux内核的拥塞控制模块，克服了内核态进程内存空间与用户态Python程序交互的映射问题，并使用C语言构造Python模块提高算法效率。同时，我们的强化学习环境也集成到了OpenAI Gym中。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116104456.png" alt="image-20220116104456599" style="zoom: 80%;" /><span id="more"></span><p>&nbsp;</p><h2 id="Linux-TCP拥塞控制算法"><a href="#Linux-TCP拥塞控制算法" class="headerlink" title="Linux TCP拥塞控制算法"></a>Linux TCP拥塞控制算法</h2><h3 id="Linux如何实现TCP拥塞控制"><a href="#Linux如何实现TCP拥塞控制" class="headerlink" title="Linux如何实现TCP拥塞控制"></a>Linux如何实现TCP拥塞控制</h3><p>&emsp;&emsp;其实在Linux内核代码中，拥塞控制包括4个部分：<code>拥塞控制框架</code>、<code>框架与 TCP 其余部分的接口</code>、<code>恢复状态机</code>、<code>不同拥塞的细节控制算法</code>，我们调研的重点是<strong>拥塞控制框架</strong>和<strong>框架与 TCP 其余部分的接口</strong>。</p><h4 id="TCP实现中的重要结构体-枚举类型"><a href="#TCP实现中的重要结构体-枚举类型" class="headerlink" title="TCP实现中的重要结构体/枚举类型"></a>TCP实现中的重要结构体/枚举类型</h4><h5 id="tcp-ca-state"><a href="#tcp-ca-state" class="headerlink" title="tcp_ca_state"></a>tcp_ca_state</h5><p>&emsp;&emsp;TCP 的拥塞控制实现中使用<strong>状态机</strong>来保持和在连接的不同状态之间切换，以用于恢复目的。这些不同的状态在 tcp.h 中的枚举类型中定义：</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Open</td><td>代表TCP连接处于正常状态，没有可疑事件。此状态下接收到的数据包通过快速路径。</td></tr><tr><td>Disorder</td><td>收到了ACK 或 dupACK，代表数据包乱序。此状态下一些处理从快路径移动到慢路径</td></tr><tr><td>CER</td><td>处理一些拥塞通知事件（例：ECN 或本地设备拥塞）时进入此状态</td></tr><tr><td>Recovery</td><td>这种状态表明拥塞窗口已经减小，连接处于快速重传阶段</td></tr><tr><td>Loss</td><td>这种状态表明由于 RTO 超时或 SACK 拒绝，拥塞窗口减小</td></tr></tbody></table><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tcp_ca_state</span> &#123;</span></span><br><span class="line">TCP_CA_Open = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Open(1&lt;&lt;TCP_CA_Open)</span></span><br><span class="line">TCP_CA_Disorder = <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span></span><br><span class="line">TCP_CA_CWR = <span class="number">2</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_CWR(1&lt;&lt;TCP_CA_CWR)</span></span><br><span class="line">TCP_CA_Recovery = <span class="number">3</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span></span><br><span class="line">TCP_CA_Loss = <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Loss(1&lt;&lt;TCP_CA_Loss)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h5 id="tcp-congestion-ops"><a href="#tcp-congestion-ops" class="headerlink" title="tcp_congestion_ops"></a>tcp_congestion_ops</h5><p>&emsp;&emsp;定义了用于不同可插拔拥塞控制算法的 TCP 拥塞处理接口，是一个函数调用指针的结构。在 tcp.h 文件中定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line">u32 key;</span><br><span class="line">u32 flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize private data (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*init)(struct sock *sk);</span><br><span class="line"><span class="comment">/* cleanup private data  (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*release)(struct sock *sk);</span><br><span class="line"><span class="comment">/* return slow start threshold (required) */</span></span><br><span class="line">u32 (*ssthresh)(struct sock *sk);</span><br><span class="line"><span class="comment">/* do new cwnd calculation (required) */</span></span><br><span class="line"><span class="keyword">void</span> (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);</span><br><span class="line"><span class="comment">/* call before changing ca_state (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*set_state)(struct sock *sk, u8 new_state);</span><br><span class="line"><span class="comment">/* call when cwnd event occurs (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*cwnd_event)(struct sock *sk, <span class="keyword">enum</span> tcp_ca_event ev);</span><br><span class="line"><span class="comment">/* call when ack arrives (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*in_ack_event)(struct sock *sk, u32 flags);</span><br><span class="line"><span class="comment">/* new value of cwnd after loss (required) */</span></span><br><span class="line">u32  (*undo_cwnd)(struct sock *sk);</span><br><span class="line"><span class="comment">/* hook for packet ack accounting (optional) */</span></span><br><span class="line"><span class="keyword">void</span> (*pkts_acked)(struct sock *sk, <span class="keyword">const</span> struct ack_sample *sample);</span><br><span class="line"><span class="comment">/* override sysctl_tcp_min_tso_segs */</span></span><br><span class="line">u32 (*min_tso_segs)(struct sock *sk);</span><br><span class="line"><span class="comment">/* returns the multiplier used in tcp_sndbuf_expand (optional) */</span></span><br><span class="line">u32 (*sndbuf_expand)(struct sock *sk);</span><br><span class="line"><span class="comment">/* call when packets are delivered to update cwnd and pacing rate,</span></span><br><span class="line"><span class="comment"> * after all the ca_state processing. (optional)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*cong_control)(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs);</span><br><span class="line"><span class="comment">/* get info for inet_diag (optional) */</span></span><br><span class="line"><span class="keyword">size_t</span> (*get_info)(struct sock *sk, u32 ext, <span class="keyword">int</span> *attr,</span><br><span class="line">   <span class="keyword">union</span> tcp_cc_info *info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[TCP_CA_NAME_MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中一些重要的函数说明如下：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>init()</td><td>在收到第一个确认(ACK)之后和第一次调用拥塞控制算法之前调用</td></tr><tr><td>pkts_acked()</td><td>收到确认某些新数据包的确认(ACK)时导致调用此函数，通过 num_acked 参数传递确认的数据包数</td></tr><tr><td>cong_avoid()</td><td>每次收到确认(ACK)并且拥塞控制状态允许拥塞窗口增加时调用此函数</td></tr><tr><td>undo_cwnd()</td><td>在检测到错误的丢失检测（由于错误的超时或数据包重新排序）时，返回流的拥塞窗口大小</td></tr></tbody></table><p>&nbsp;</p><h4 id="内核中-TCP-代码的主要文件"><a href="#内核中-TCP-代码的主要文件" class="headerlink" title="内核中 TCP 代码的主要文件"></a>内核中 TCP 代码的主要文件</h4><p>&emsp;&emsp;Linux Kernel中有关TCP的代码基本上都在<code>net/ipv4/</code>目录下，主要包括：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>tcp.h</td><td>包含TCP相关结构体的声明，在include/net/下</td></tr><tr><td>tcp.c</td><td>包含通用 TCP 代码、涵盖不同Socket之间的接口和TCP代码的其余部分</td></tr><tr><td>tcp_input.c</td><td>处理来自网络的传入数据包的最大和最重要的文件；包含恢复状态机的代码</td></tr><tr><td>tcp_output.c</td><td>处理向网络发送数据包；包含一些从拥塞控制框架调用的函数</td></tr><tr><td>tcp_ipv4.c</td><td>IPv4 TCP 特定代码；将相关数据包交给拥塞控制框架</td></tr><tr><td>tcp_timer.c</td><td>实现定时器管理功能</td></tr><tr><td>tcp_cong.c</td><td>实现可插拔 TCP 拥塞控制支持和拥塞控制的核心框架；默认使用 New Reno 机制</td></tr><tr><td>tcp_[name of algorithm].c</td><td>不同TCP拥塞控制算法文件，例如：tcp_vegas.c、tcp_cubic.c等</td></tr></tbody></table><p>&nbsp;</p><h4 id="TCP拥塞控制算法-注册-初始化-传参"><a href="#TCP拥塞控制算法-注册-初始化-传参" class="headerlink" title="TCP拥塞控制算法 注册-初始化-传参"></a>TCP拥塞控制算法 注册-初始化-传参</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>实现的算法可以通过实例化该结构体、调用注册函数实现算法的注册（例：bbr）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> <span class="title">tcp_bbr_cong_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.flags= TCP_CONG_NON_RESTRICTED,</span><br><span class="line">.name= <span class="string">&quot;bbr&quot;</span>,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.init= bbr_init,</span><br><span class="line">.cong_control= bbr_main,</span><br><span class="line">.sndbuf_expand= bbr_sndbuf_expand,</span><br><span class="line">.undo_cwnd= bbr_undo_cwnd,</span><br><span class="line">.cwnd_event= bbr_cwnd_event,</span><br><span class="line">.ssthresh= bbr_ssthresh,</span><br><span class="line">.min_tso_segs= bbr_min_tso_segs,</span><br><span class="line">.get_info= bbr_get_info,</span><br><span class="line">.set_state= bbr_set_state,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">bbr_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct bbr) &gt; ICSK_CA_PRIV_SIZE);</span><br><span class="line"><span class="keyword">return</span> tcp_register_congestion_control(&amp;tcp_bbr_cong_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li><p>算法的参数通常是定义在一个结构体里（例：cubic）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BIC TCP Parameters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> &#123;</span></span><br><span class="line">u32cnt;<span class="comment">/* increase cwnd by 1 after ACKs */</span></span><br><span class="line">u32last_max_cwnd;<span class="comment">/* last maximum snd_cwnd */</span></span><br><span class="line">u32last_cwnd;<span class="comment">/* the last snd_cwnd */</span></span><br><span class="line">u32last_time;<span class="comment">/* time when updated last_cwnd */</span></span><br><span class="line">u32bic_origin_point;<span class="comment">/* origin point of bic function */</span></span><br><span class="line">u32bic_K;<span class="comment">/* time to origin point</span></span><br><span class="line"><span class="comment">   from the beginning of the current epoch */</span></span><br><span class="line">u32delay_min;<span class="comment">/* min delay (msec &lt;&lt; 3) */</span></span><br><span class="line">u32epoch_start;<span class="comment">/* beginning of an epoch */</span></span><br><span class="line">u32ack_cnt;<span class="comment">/* number of acks */</span></span><br><span class="line">u32tcp_cwnd;<span class="comment">/* estimated tcp cwnd */</span></span><br><span class="line">u16unused;</span><br><span class="line">u8sample_cnt;<span class="comment">/* number of samples to decide curr_rtt */</span></span><br><span class="line">u8found;<span class="comment">/* the exit point is found? */</span></span><br><span class="line">u32round_start;<span class="comment">/* beginning of each round */</span></span><br><span class="line">u32end_seq;<span class="comment">/* end_seq of the round */</span></span><br><span class="line">u32last_ack;<span class="comment">/* last time when the ACK spacing is close */</span></span><br><span class="line">u32curr_rtt;<span class="comment">/* the minimum rtt of current round */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化函数中，算法申请私有空间，初始化参数</p></li><li><p>可以在算法模块中声明一些参数，并调<code>module_param(name,type,perm)</code>使得参数可以在insmod的时候传入（例：cubic）</p><ul><li>name 既是用户看到的参数名，又是模块内接受参数的变量</li><li>type 表示参数的数据类型，是下列之一：byte, short, ushort, int, uint, long, ulong, charp, bool, invbool;</li><li>perm 指定了在sysfs中相应文件的访问权限。访问权限与linux文件访问权限相同的方式管理，如0644，或使用stat.h中的宏如S_IRUGO表示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note parameters that are used for precomputing scale factors are read-only */</span></span><br><span class="line">module_param(fast_convergence, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(fast_convergence, <span class="string">&quot;turn on/off fast convergence&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><ul><li><p>根据上面的信息，我们知道算法的参数定义在结构体里</p></li><li><p>算法的每个步骤，都会从传入的socket得到一个算法结构体，这个过程是怎么实现的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***example cubic***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> *<span class="title">ca</span> =</span> inet_csk_ca(sk);</span><br><span class="line"><span class="comment">/***example bbr***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bbr</span> *<span class="title">bbr</span> =</span> inet_csk_ca(sk);</span><br></pre></td></tr></table></figure></li><li><p>首先从当前socket获取tcp socket结构体</p></li><li><ul><li>tcp_sock结构体定义于<code>/include/linux/tcp.h#L138</code></li><li>主要用来保存tcp相关的信息</li></ul></li><li><p>然后从socket获取算法结构体</p></li><li><ul><li>调用<code>inet_csk_ca</code>，获得<code>inet_csk(sk)-&gt;icsk_ca_priv</code></li><li><code>icsk_ca_priv</code>是<code>inet_connection_sock</code>结构体的一部分</li></ul></li></ul><p>&nbsp;</p><h3 id="Linux-内核拥塞控制算法浅析"><a href="#Linux-内核拥塞控制算法浅析" class="headerlink" title="Linux 内核拥塞控制算法浅析"></a>Linux 内核拥塞控制算法浅析</h3><h4 id="TCP-Vegas"><a href="#TCP-Vegas" class="headerlink" title="TCP Vegas"></a>TCP Vegas</h4><blockquote><p>REF:  <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p><p><em>A TCP sender can easily measure available bandwidth; the simplest measurement is cwnd/RTT (measured in packets/sec). Let us denote this bandwidth estimate by BWE; for the time being we will accept BWE as accurate, though see</em> <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html#ack-compression"><em>15.6.1  ACK Compression and Westwood+</em></a> <em>below. TCP Vegas estimates RTTnoLoad by the minimum RTT (RTTmin) encountered during the connection. The “ideal” cwnd that just saturates the bottleneck link is BWE×RTTnoLoad. Note that BWE will be much more volatile than RTTmin; the latter will typically reach its final value early in the connection, while BWE will fluctuate up and down with congestion (which will also act on RTT, but by increasing it).</em></p></blockquote><ul><li><p>特点：基于时延</p></li><li><p>拥塞判断标准：RTT增加</p></li><li><p>优点：较好地预测带宽</p></li><li><p>缺点：竞争性差。网络环境中有其他主机采用基于丢包的算法时，由于他们会尝试填满缓冲区，会导致Vegas估计地RTT增大，性能不断被挤占，只适用于<strong>只使用Vegas的网络环境</strong>中</p></li></ul><p>&nbsp;</p><h4 id="TCP-Veno"><a href="#TCP-Veno" class="headerlink" title="TCP Veno"></a>TCP Veno</h4><blockquote><p>REF:  <a href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p><ul><li><p><em>慢开始阶段</em></p><p><em>if Nqueue&lt;𝛽, cwnd = cwnd + 1 each RTT</em></p><p><em>if Nqueue≥𝛽, cwnd = cwnd + 0.5 each RTT</em></p></li><li><p><em>丢包发生时：</em></p><p><em>if Nqueue&lt;𝛽, the loss is probably not due to congestion; set cwnd = (4/5)×cwnd</em></p><p><em>if Nqueue≥𝛽, the loss probably is due to congestion; set cwnd = (1/2)×cwnd as usual</em></p></li></ul></blockquote><ul><li><p>特点：Reno + Vegas</p><ul><li><p>利用Vegas的RTT测量机制，同时保有Reno贪婪、线性增加的机制</p></li><li><p>遇到的丢包大部分是非拥塞产生时，Veno行为接近Reno</p></li></ul></li><li><p>优点：在<strong>时延带宽积适中的、丢包率高的链路</strong>表现好</p></li><li><p>缺点：不能解决长肥管道问题</p></li></ul><p>&nbsp;</p><h4 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h4><ul><li><p>特点：基于带宽和延迟（链路容量）</p></li><li><p>优点：</p><ul><li>避免Bufferfloat</li><li>丢包不作为拥塞控制信号，在长肥管道场景表现也很好，适用于<strong>高带宽、高时延、有一定丢包率的长肥网络</strong></li></ul></li><li><p>缺点：</p><ul><li>当网络设备缓存比较大的时候，竞争不过Cubic等激进算法</li><li>公平性问题：RTT越大，抢占能力越强</li></ul></li></ul><p>&nbsp;</p><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><ul><li><p>特点：</p><ul><li>基于丢包</li><li>AIMD（线性增乘性减）</li></ul></li><li><p>优点：</p><ul><li>在早期<strong>低带宽低时延</strong>网络中能很好发挥作用</li><li>公平性</li></ul></li><li><p>缺点：</p><ul><li>在高带宽高延时网络（long-fat pipe 长肥管道）中，RTT很大，ACK接收时延大，导致拥塞窗口增长慢</li></ul></li></ul><p>&nbsp;</p><h4 id="TCP-CUBIC"><a href="#TCP-CUBIC" class="headerlink" title="TCP CUBIC"></a>TCP CUBIC</h4><ul><li><p>特点：</p><ul><li>基于丢包</li><li>三次函数增加，乘性减小</li></ul></li><li><p>优点：</p><ul><li>Cubic算法的优点在于只要没有出现丢包，就不会主动降低自己的发送速度，可以最大程度的利用网络剩余带宽，提高吞吐量，在<strong>高带宽、低丢包率</strong>的网络中可以发挥较好的性能。</li></ul></li><li><p>缺点：</p><ul><li>无法区分拥塞丢包和传输错误丢包</li><li>过于激进，在没有出现丢包时会不停地增加拥塞窗口的大小，想要填满缓冲区，导致排队时延增加（Bufferbloat现象）</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116114931.png" alt="image-20220116114931639" style="zoom: 40%;" /><p>&nbsp;</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th><strong>名称</strong></th><th><strong>类型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>TCP Reno</td><td>基于丢包 AIMD</td><td>公平性</td><td>不适用于长肥网络</td></tr><tr><td>TCP Cubic</td><td>基于丢包   三次增乘性减</td><td>带宽利用率高</td><td>激进、Bufferbloat</td></tr><tr><td>TCP Vegas</td><td>基于时延RTT</td><td>较好预测带宽</td><td>竞争性差</td></tr><tr><td>TCP Veno</td><td>Reno + Vegas</td><td>折衷、综合以上优点</td><td>没解决长肥网络</td></tr><tr><td>TCP BBR</td><td>基于带宽和时延</td><td>避免Bufferbloat</td><td>公平性模糊</td></tr></tbody></table><p>&nbsp;</p><h2 id="强化学习改进Veno算法"><a href="#强化学习改进Veno算法" class="headerlink" title="强化学习改进Veno算法"></a>强化学习改进Veno算法</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h4 id="Veno算法核心"><a href="#Veno算法核心" class="headerlink" title="Veno算法核心"></a>Veno算法核心</h4><ol><li><p>根据拥塞窗口和往返时间估计当前队列堆积的报文个数N</p><blockquote><p>首先计算期望发送速率和实际速率：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115012.png" alt="image-20220116115012530" style="zoom: 67%;" /><p>二者差值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115023.png" alt="image-20220116115023138" style="zoom: 67%;" /><p>估计堆积报文个数N：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115036.png" alt="image-20220116115036767" style="zoom:67%;" /></blockquote></li><li><p>根据N值调整拥塞控制算法</p><blockquote><p>慢启动阶段：与Reno相同无变化</p><p>AIMD——加性增阶段：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115049.png" alt="image-20220116115049018" style="zoom:67%;" /><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;beta 是一个超参数、增速1、0.5也是超参</p><p>AIMD——乘性减阶段：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116115059.png" alt="image-20220116115059582" style="zoom: 60%;" /><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4/5、1/2也是超参</p></blockquote></li></ol><h4 id="强化学习设计思路"><a href="#强化学习设计思路" class="headerlink" title="强化学习设计思路"></a>强化学习设计思路</h4><p>目标：优化超参数（核心函数：tcp_veno_cong_avoid（））</p><p>输入：</p><ul><li><p>basertt</p></li><li><p>minrtt   # 在Veno中这个变量其实是实时rtt，并不是最小rtt</p></li></ul><p>输出：</p><ul><li><p>beta</p></li><li><p>threshold1（加性增时）</p></li></ul><p>注意，加性增时的”0.5“在源代码中不是通过变量表示的，而是通过标志位veno-&gt;cnt，所以需要重构代码：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116131249.png" alt="image-20220116131249660" style="zoom:50%;" /><p>模型框架：(基于DQN)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105019.png" alt="image-20220116105019402" style="zoom: 33%;" /><h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p>github：<a href="https://github.com/Gaopeili/lgd">Computer Network Course Design using Mininet simulator</a></p><p>&nbsp;</p><h3 id="实验观察"><a href="#实验观察" class="headerlink" title="实验观察"></a>实验观察</h3><h4 id="仿真环境"><a href="#仿真环境" class="headerlink" title="仿真环境"></a>仿真环境</h4><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul><li>Mininet 2.3.0</li><li>Linux kernel v5.4</li><li>KVM搭建的Mininet虚拟机</li></ul><h5 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h5><p>&emsp;&emsp;选择搭建经典的 <code>bottleneck</code> 结构，设置传输过程中某条链路带宽较小且延迟较大，发送方以较大比特率发送数据，来构建出网络拓扑模型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105214.png" alt="image-20220116105213972" style="zoom:75%;" /><h5 id="拥塞场景"><a href="#拥塞场景" class="headerlink" title="拥塞场景"></a>拥塞场景</h5><p>&emsp;&emsp;创建好网络拓扑之后，调整各个client的发送速率，使用命令行工具iperf来模拟客户端与服务端。Client1，Client2以100Mbps的速率发送TCP数据包，Client3以50Mbps的速率发送UDP数据包，使用wireshark工具观察拥塞现象，发现throughput发生了明显的下降、RTT明显增加并且出现了丢包现象。</p><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p>&emsp;&emsp;观察到拥塞现象后，我们使用Linux内核提供的各种算法进行拥塞控制。从iperf提供的输出观察到了cwnd慢启动、加性增乘性减的过程，并且对比了不同算法之间的异同：</p><h5 id="算法性能测试"><a href="#算法性能测试" class="headerlink" title="算法性能测试"></a>算法性能测试</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105121.png" alt="image-20220116105121283"></p><p>&emsp;&emsp;从图中可见，Reno、Veno、RL_Veno因为拥塞控制机制相似，所以实际算法性能指标曲线大致相似，但是Veno比Reno平均吞吐量更高；BBR与Vegas因为拥塞控制机制相似，所以实际算法性能指标曲线也大致相似；CUBIC使用三次方函数拟合曲线，性能曲线形状与其他几种算法都不同。</p><h5 id="Veno与RL-Veno对比"><a href="#Veno与RL-Veno对比" class="headerlink" title="Veno与RL_Veno对比"></a>Veno与RL_Veno对比</h5><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116105147.png" alt="image-20220116105147073"></p><p>&emsp;&emsp;Veno、RL_Veno因为拥塞控制机制一致，所以实际算法性能指标曲线大致相同，但是由于RL_Veno中我们由强化学习Actor网络动态计算阈值β，所以在探索性上显得更为激进，但同时由于强化学习反馈敏感的特性，RL_Veno在收敛速度上也更胜一筹。</p><p>&nbsp;</p><h2 id="环境配置与仿真平台"><a href="#环境配置与仿真平台" class="headerlink" title="环境配置与仿真平台"></a>环境配置与仿真平台</h2><h3 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h3><p>查看当前可用的拥塞算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如图，服务器上ubuntu下目前可使用的拥塞控制有<code>cubic</code>和<code>reno</code>：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115224959.png" alt="image-20220115224959598" style="zoom: 67%;" /><p>查看当前使用了哪种拥塞算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>目前是用的是<code>cubic</code>（默认）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115225127.png" alt="image-20220115225127025" style="zoom:67%;" /><p>设置当前使用的拥塞算法(为reno)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_congestion_control=reno</span><br></pre></td></tr></table></figure><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220115225212.png" alt="image-20220115225212546" style="zoom:67%;" /><p>&nbsp;</p><h3 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h3><p>&emsp;&emsp;Mininet是由斯坦福大学基于Linux <a href="https://so.csdn.net/so/search?q=Container&spm=1001.2101.3001.7020">Container</a>架构开发的一个进程虚拟化网络仿真工具，可以创建一个包含主机，交换机，控制器和链路的虚拟网络，其交换机支持OpenFlow，具备高度灵活的自定义软件定义网络。</p><p>官网：<a href="http://mininet.org/">Mininet</a></p><p>github仓库：<a href="https://github.com/mininet/mininet">mininet</a></p><h4 id="网络构建启动参数"><a href="#网络构建启动参数" class="headerlink" title="网络构建启动参数"></a>网络构建启动参数</h4><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>释放之前创建拓扑时占用的未释放资源</td></tr><tr><td>-h</td><td>查看帮助</td></tr><tr><td>–topo</td><td>定义创建的拓扑结构</td></tr><tr><td>–custom</td><td>创建自定义拓扑（python脚本）</td></tr><tr><td>–switch</td><td>定义要使用的交换机</td></tr><tr><td>–controller</td><td>定义要使用的控制器</td></tr><tr><td>–mac</td><td>自动设置设备的MAC地址</td></tr><tr><td>……</td><td></td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>dump</td><td>显示每个节点的接口设置和表示每个节点的进程PID</td></tr><tr><td>net</td><td>显示拓扑连接信息</td></tr><tr><td>nodes</td><td>显示节点信息</td></tr><tr><td>links</td><td>显示链路健壮性信息</td></tr><tr><td>dpctl</td><td>交换机流表控制</td></tr><tr><td>iperf</td><td>节点间tcp带宽测试</td></tr><tr><td>help</td><td>显示帮助信息</td></tr><tr><td>xterm</td><td>开启节点可视化操作界面(terminal)</td></tr><tr><td>py</td><td>执行后面python表达式</td></tr><tr><td>pingall</td><td>在网络中的所有主机之间执行ping测试</td></tr><tr><td>exit</td><td>退出mininet</td></tr></tbody></table><p>示例：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220116104916.png" alt="image-20220116104916505"></p><h4 id="Python自定义拓扑脚本"><a href="#Python自定义拓扑脚本" class="headerlink" title="Python自定义拓扑脚本"></a>Python自定义拓扑脚本</h4><p>&emsp;&emsp;mininet支持使用python脚本自定义网络拓扑结构和通信场景设置，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwesomeBottleneckTopo</span>(<span class="params">Topo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Build Awesome Topo for Computer Network Design&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, client_num=<span class="number">3</span>, server_num=<span class="number">3</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  awesome_client1                                    awesome_server1(5Mbps)</span></span><br><span class="line">        <span class="comment">#                  \ 40Mbps                 40Mbps   /</span></span><br><span class="line">        <span class="comment">#  awesome_client2 --------- s1 --------- s2 -------- awesome_server2(30Mbps)</span></span><br><span class="line">        <span class="comment">#                  /          35Mbps(20ms)           \</span></span><br><span class="line">        <span class="comment">#  awesome_client3                                    awesome_server3(20Mbps)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># TODO(gpl): add awesome topo</span></span><br><span class="line">        self.clients = [self.addHost(<span class="string">f&#x27;h<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(client_num)]</span><br><span class="line">        self.servers = [self.addHost(<span class="string">f&#x27;n<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(server_num)]</span><br><span class="line"></span><br><span class="line">        self.s1 = self.addSwitch(<span class="string">&#x27;awesome-s1&#x27;</span>)</span><br><span class="line">        self.s2 = self.addSwitch(<span class="string">&#x27;awesome-s2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        linkops = <span class="built_in">dict</span>(bw=<span class="number">35</span>, delay=<span class="string">&#x27;5ms&#x27;</span>,</span><br><span class="line">                       max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">        self.addLink(self.s1, self.s2, **linkops)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;clients:&quot;</span>, self.clients)</span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            <span class="built_in">print</span>(client)</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(client, self.s1, **linkops)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(server, self.s2, **linkops)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    backwnd = BottleneckBackend(AwesomeBottleneckTopo())</span><br></pre></td></tr></table></figure><h4 id="GUI界面构建拓扑"><a href="#GUI界面构建拓扑" class="headerlink" title="GUI界面构建拓扑"></a>GUI界面构建拓扑</h4><p>&emsp;&emsp;mininet支持使用GUI图形界面构造网络拓扑结构，执行<code>mininet/examples/miniedit.py</code>脚本即可。</p><p>&nbsp;</p><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h3 id="任务分工"><a href="#任务分工" class="headerlink" title="任务分工"></a>任务分工</h3><table><thead><tr><th><strong>任务</strong></th><th><strong>负责人</strong></th></tr></thead><tbody><tr><td>Mininet拓扑、强化学习环境搭建、OpenAI-gym集成</td><td>gpl</td></tr><tr><td>Linux源码阅读、算法调研、驱动模块</td><td>dhy</td></tr><tr><td>CPython模块、Linux内核/用户空间映射、算法调研、系统测试</td><td>lrk</td></tr></tbody></table><h3 id="突出亮点"><a href="#突出亮点" class="headerlink" title="突出亮点"></a>突出亮点</h3><ul><li>新的工具（Mininet，iperf，dcpctl，wireshark…）</li><li>真实环境（与内核交互，可与真实环境通信）</li><li>参考资料较少（原创性强，成就感较大）</li><li>适当修改后可作为项目组新人培训任务</li></ul><h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><ul><li>Mininet CLI和python API用法差别较大，有一丢丢大坑</li><li>翻看内核源码，内核态和用户态交互</li><li>强化学习环境自行搭建并集成到gym中</li></ul><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ul><li>时间紧张，消融学习有待改进</li><li>部分代码还需重构</li><li>强化学习算法设计</li></ul><p>&nbsp;</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h5 id="Linux-Kernel-中TCP拥塞控制实现机制"><a href="#Linux-Kernel-中TCP拥塞控制实现机制" class="headerlink" title="Linux Kernel 中TCP拥塞控制实现机制"></a>Linux Kernel 中TCP拥塞控制实现机制</h5><p><a href="https://lrk612.com/resources/TCP-CongestionControlFinal.pdf">TCP’s Congestion Control Implementation in Linux Kernel</a></p><p><a href="http://www.yonch.com/tech/linux-tcp-congestion-control-internals">Linux TCP congestion control internals </a></p><p><a href="https://elixir.bootlin.com/linux/v5.4/source">在线查看各版本 Linux Kernel 源码</a></p><h5 id="TCP拥塞控制算法分析"><a href="#TCP拥塞控制算法分析" class="headerlink" title="TCP拥塞控制算法分析"></a>TCP拥塞控制算法分析</h5><p><a href="https://lrk612.com/resources/Veno.pdf">TCP Veno: TCP Enhancement for Transmission Over Wireless Access NetworksCheng</a></p><h5 id="mininet仿真平台"><a href="#mininet仿真平台" class="headerlink" title="mininet仿真平台"></a>mininet仿真平台</h5><p><a href="https://www.bilibili.com/video/BV1ft4y1a7ip?p=11">b站 mininet 使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识总结</title>
      <link href="/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机网络知识点总结</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160706.png" alt="20201001111251542" style="zoom: 50%;" /><p>改自18级种子班“卢神”：<a href="http://lwdreamofly.love/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/">计算机网络考试复习</a></p><p>参考：<a href="https://www.icourse163.org/learn/HIT-154005?tid=1465409451#/learn/content">哈工大计网mooc</a>、<a href="https://blog.csdn.net/lydms/article/details/106736730?ops_request_misc=%7B%22request_id%22:%22164118867316780261951158%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164118867316780261951158&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-106736730.pc_search_insert_es_download_v2&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">计算机网络博客</a>、《计算机网络—系统方法》、华科电信计网教学PPT</p><span id="more"></span><p>&nbsp;</p><h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ul><li>计算机网络可以视为是 <code>计算机技术</code> 和 <code>通信技术</code> 的合成</li><li>计算机网络设计需求<ul><li>可拓展的连通性<ul><li>为每个结点定义一个地址，路由转发消息</li></ul></li><li>高性价比的资源共享<ul><li>分组交换而不是电路交换</li></ul></li><li>支持通用服务<ul><li>设计传输协议</li></ul></li><li>可管理性</li></ul></li><li>网络通信方式包括 <code>点到点</code> 、 <code>广播</code> 、 <code>点到多点</code> 、 <code>多点到多点</code></li><li>公用电话交换网（PSTN）中的交换设备提供 <code>电路交换</code> 方式</li><li>世界上第一个投入运行的分组交换网是 <code>ARPAnet</code></li><li><code>ARPAnet</code>是最早验证分组交换的网络之一</li><li>Internet起源于<code>ARPAnet</code></li><li>根据计算机网络的定义，其主要特征包括<code>支持计算机资源的共享</code>、<code>互联的计算机系统是自治的系统</code>、<code>联网的计算机系统之间需要遵循共同的网络协议</code></li><li>关于计算机网络的最简单定义是：一些相互连接的、以共享资源为目的的、自治的计算机的集合<ul><li>自治：无主从关系</li></ul></li><li>计算机网络按照网络规模大小可以分为：<code>PAN</code>、<code>LAN</code>、<code>MAN</code>、<code>WAN</code><ul><li>PAN：personal area network 个人区域网络<ul><li>无线连接：蓝牙、红外、NFC</li><li>有线连接：USB电缆</li><li>常用于传输小文件，如：音乐、照片、日历、约定等</li></ul></li><li>LAN：local area network 局域网<ul><li>基于广播技术发展而来</li><li>由一组设备组成，如：计算机+服务器+交换机+打印机、校园网、公司内网等</li><li>最常见的局域网类型是<code>以太网</code>，两台或多台计算机通过电缆连接到以太网交换机上</li></ul></li><li>MAN：metropolitan area network 城域网<ul><li>一种比校园网区域还大的网络</li><li>一种横跨一个城市或城镇的多个建筑的网络</li><li>通常使用高速连接，如：光缆</li><li>一种高速网路，能够在城市中共享数据和资源提供服务</li></ul></li><li>WAN：wide area network 广域网<ul><li>基于交换技术发展而来</li><li>WAN是最大的网络类型，一个WAN可以包含多个MAN、LAN、PAN</li></ul></li></ul></li><li>局域网LAN和广域网WAN的区别<ul><li>覆盖范围</li><li>协议</li></ul></li><li>网络分类方法：<code>局域网/广域网</code>、<code>有线网/无线网</code>、<code>环形网/星形网</code></li><li>常见的网络拓扑：<code>环形结构</code>、<code>总线结构</code>、<code>网状结构</code>、<code>星形结构</code>、<code>树形结构</code>、<code>混合性结构</code></li><li>网络结构<ul><li>网络边缘<ul><li>主机（端系统）、客户/服务器、对等（P2P）应用模型</li></ul></li><li>接入网络<ul><li>家庭接入网络、机构接入网络、</li><li>数字用户线路（DSL）、电缆网络、无线接入网络</li></ul></li><li>网络核心<ul><li>互联的路由器网络</li><li>关键功能：路由+转发</li></ul></li></ul></li></ul><h2 id="1-2-交换原理"><a href="#1-2-交换原理" class="headerlink" title="1.2 交换原理"></a>1.2 交换原理</h2><ul><li><p><code>虚电路</code>、<code>TCP</code>能提供面向连接的服务</p></li><li><p>三中交换方式：电路交换、报文交换、分组交换</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103184648.png" alt="image-20220103184648837" style="zoom:50%;" /></li><li><p>使用存储—转发技术的是：报文交换、分组交换</p></li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>在通信之前需要在通信双方间建立一条双方独占的物理信道，这个信道由双方之间的交换设备和链路逐段连接而建成的<ul><li>优点：<ul><li>带宽保证。数据直达，传输延迟小，具有很强的实时性</li><li>通信可靠。双方通信是有序的，不存在乱序问题，并且丢包概率低</li><li>路由机制简单。基于时分或频分复用，不需要进行数据包头部地址识别</li><li>既可以用于传输模拟信号，也可以用于传输数字信号</li><li>适用于实时和交互式通信</li></ul></li><li>缺点：<ul><li>建立连接平均时间较长，影响效率</li><li>对信道利用率低，建立的物理通路即使空闲仍占用通路</li><li>不同类型、规格、速率的终端难以相互进行通信，且易发生差错</li></ul></li></ul></li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul><li><p>以<code>报文</code>为数据交换的单位，报文中携带目标地址、源地址等信息</p></li><li><p>优点：</p><ul><li>不存在建立时延，可以即时发送</li><li>当某条传输路径发生故障时能够自动选择另一条路径进行传输，提高了传输稳定性</li><li>即使不同类型、规格、速率的终端也可以实现通信</li><li>可以多目标发送</li><li>交换方式会自动建立数据传输的优先级，提高信道利用率</li></ul></li><li><p>缺点：</p><ul><li>数据交换结点需要经历存储、转发这个过程，所以会引起转发时延</li><li>只能用于数字信号</li></ul></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>报文交换的升级版，仍采用<strong>存储转发</strong>的方式，但会将一个长报文先分割为若干个较短的分组，然后将短分组添加包头后逐个发送</p><ul><li>优点：<ul><li>不存在链路空闲时的带宽浪费，加速了数据的网络传输</li><li>简化了存储管理，从而减少了出错机率和重发数据量</li><li>由于其分组的特点，在优先级策略传输中更具优势</li><li>相较电路交换，更加适用于突发数据的传输</li></ul></li><li>缺点：<ul><li>时延问题仍存在，但得到减少</li><li>每个分组需要包含源地址和目的地址等信息的首部</li><li>存在乱序、分组丢失或重复问题</li><li>通信效率不高</li></ul></li></ul></li><li><p>报文交换以完整报文进行存储和转发，分组交换以分割后的报文分组进行存储和转发</p></li><li><p><strong>这里涉及报文交换和分组交换的时间计算题</strong></p><ul><li><p>分组交换时间计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164253.png" alt="image-20220102164253412" style="zoom: 33%;" /></li></ul></li><li><p>现有的公共数据网主要采用的技术是<code>分组交换</code>，包含：<code>数据报</code>、<code>信元交换</code>、<code>虚电路</code></p><ul><li><strong>信元交换</strong><ul><li>又叫做异步传输模式（Asynchronous Transfer Mode，ATM），是一种<strong>面向连接</strong>的快速分组交换技术，通过建立虚电路来进行数据传输</li></ul></li><li><strong>数据报服务</strong><ul><li>为网络层提供<strong>无连接方式</strong></li><li>无连接服务<ul><li>不事先为分组的传输确定一个具体的路径，每个分组会独立确定传输路径，不同分组传输路径可能不同</li><li>可能会乱序到达</li><li>主机<strong>不知道</strong>网络是否可以传送该分组</li></ul></li><li>发短消息时，数据报比虚电路报文分组交换甚至电路交换更快（不需要耗时建立连接）</li></ul></li><li><strong>虚电路服务</strong><ul><li>为网络层提供<strong>连接方式</strong></li><li>连接方式<ul><li>首先为分组的传输确定一个传输路径，即建立连接，然后沿着该连接对应的同一个传输路径传输系列分组</li></ul></li><li>健壮性不如数据报服务</li><li>分组不需要选择路由</li><li>电路交换需要在两站之间建立一条专用通路，但是虚电路服务不需要；虚电路的分组需要含电路号，但是电路交换不需要，电路交换不是分组</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103085634.png" alt="image-20220103085633946" style="zoom: 33%;" /><table><thead><tr><th></th><th>数据报服务</th><th>虚电路服务</th></tr></thead><tbody><tr><td>连接的建立</td><td>不需要</td><td>需要</td></tr><tr><td>目的地址</td><td>每个分组中都包含都有完整的目的地址</td><td>仅在建立连接时使用，之后每个分组使用长度较短的虚电路号判断路径即可，不需要包含目的地址</td></tr><tr><td>路由的选择</td><td>每个分组独立进行路由选择和转发</td><td>属于同一条虚电路所有分组按照同一路由转发</td></tr><tr><td>分组顺序</td><td>不保证分组有序到达</td><td>保证分组有序到达</td></tr><tr><td>可靠性</td><td>不保证可靠通信，可靠性由用户主机（更高层协议）保证</td><td>可靠性由网络保证</td></tr><tr><td>对网络故障的适应性</td><td>出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td><td>所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td>差错处理和流量控制</td><td>由用户主机进行流量控制，不保证数据报的可靠性</td><td>可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></li></ul></li></ul><h2 id="1-3-网络应用"><a href="#1-3-网络应用" class="headerlink" title="1.3 网络应用"></a>1.3 网络应用</h2><ul><li>计算机网络通信的显著特点：<code>间歇性</code>、<code>突发性</code></li><li>如果源端发送的每一个消息均希望被目的端接收，可以采用<code>请求/响应</code>的通信方式</li></ul><h2 id="1-4-网络体系架构"><a href="#1-4-网络体系架构" class="headerlink" title="1.4 网络体系架构"></a>1.4 网络体系架构</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>实体（Entity）</p><ul><li>定义：构成网络系统各个层次的抽象对象</li><li>向高层提供服务</li><li>通过调用底层实体提供的服务与远程计算机的对等实体进行通信<ul><li>对等实体：网络中不同主机（结点）的相同层次之间互为对等实体</li></ul></li></ul></li><li><p>协议（Protocol）</p><ul><li>定义：两个或多个网络对等实体之间通信所需遵从的特定规则</li><li>是为进行网络的数据交换和网络通信而建立的规则、标准或约定</li><li>向上层实体提供服务</li><li>协议三要素：<strong>语法</strong>、<strong>语义</strong>、<strong>时序</strong><ul><li>语法：数据与控制信息的结构或格式、信号电平</li><li>语义：需要发出何种控制信息、完成何种动作以及做出何种响应、差错控制</li><li>时序：事件顺序、速度匹配</li></ul></li></ul></li><li><p>实体的接口（Interface）</p><ul><li>垂直（向上）：服务接口</li><li>水平（对端）：与远程计算机对等实体的对等接口</li></ul></li><li><p>同一系统相邻两层的实体进行交互的地方称为：<strong>服务访问点</strong></p></li><li><p>网络体系结构是网络层次结构和各层协议的集合</p></li><li><p>协议与服务</p><ul><li>协议的实现保证了能够向上一层提供服务，要实现本层协议还需要使用下面一层所提供的服务</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务</li><li>协议是水平的，即协议是控制对等实体间通信的规则</li><li>服务是垂直的，即服务是下层向上层通过层间接口提供的</li></ul></li></ul><h3 id="层次化网络体系结构"><a href="#层次化网络体系结构" class="headerlink" title="层次化网络体系结构"></a>层次化网络体系结构</h3><ul><li><p>计算机网络架构的分层</p><ul><li>每一层都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面清晰，交互接口尽可能简单</li><li>下层对上层相对独立，上层调用下层提供的服务</li><li>各层的定义主要在功能方面，不应指定具体的实现方法</li></ul></li><li><p>计算机网络体系采用层次结构的主要原因</p><ul><li>使各层次的功能相对独立，使得各层次实现技术的进步不影响相邻层次，从而保证体系结构的完整性</li><li>层次结构的方法可以简化计算机网络的实现</li></ul></li><li><p>分层的实现</p><ul><li>封装<ul><li>通过封装，协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li><li>首部、尾部的加载和分离</li></ul></li><li>复用与解复用<ul><li>复用来自源结点不同高层实体的数据，将数据解复用至目的结点对应的高层实体</li><li>在发送端主机复用，在接收端主机解复用</li></ul></li></ul></li><li><p>下层协议的实现对上层的服务用户是透明的</p></li></ul><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><ul><li><p>在 OSI 参考模型中，第 N 层是第 N+1 层的服务提供者</p></li><li><p>在分层网络模型中，第N层提供的服务是利用第N-1层提供的服务和第N层协议，与对等实体交换信息实现的</p></li><li><p><strong>OSI七层网络体系</strong></p><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>为应用进程提供服务：文件传输、电子邮件、文件服务、虚拟终端</td><td>TFTP、HTTP、SNMP、DNS、Telnet等</td></tr><tr><td>表示层</td><td>数据格式转换、代码转换、数据加密</td><td>—</td></tr><tr><td>会话层</td><td>建立、管理和维护会话</td><td>—</td></tr><tr><td>传输层</td><td>建立、管理和维护端对端（进程间）的连接（可靠数据传输）</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>为数据包IP选址和路由</td><td>IP、ICMP、OSPF、EIGRP、IGMP等</td></tr><tr><td>数据链路层</td><td>帧传输及错误检测功能、提供介质访问和链路管理</td><td>SLIP、CSLIP、PPP、MTU</td></tr><tr><td>物理层</td><td>以二进制数据形式在物理媒介上传输数据</td><td>ISO2110、IEEE802、IEEE802.2</td></tr></tbody></table></li><li><p>示意图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164610.png" alt="image-20220102164610829" style="zoom:33%;" /></li><li><p>数据封装与通信过程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102164642.png" alt="image-20220102164642039" style="zoom: 33%;" /></li><li><p><strong>物理层（Physical）</strong></p><ul><li>透明地传输原始比特流</li><li>定义物理设备的标准，如：网线的接口类型、光纤的接口类型、各种传输介质的传输速率等</li><li>规定：比特编码、数据率、比特同步方式、传输模式</li></ul></li><li><p><strong>数据链路层（Data Link）</strong></p><ul><li>负责物理链路上相邻结点间的数据传输</li><li>物理层比特流数据组合成帧并利用协议发送帧</li><li>控制对物理介质的访问 </li><li>提供差错检测/纠正、流量控制</li></ul></li><li><p><strong>网络层（Network）</strong></p><ul><li>负责源主机到目的主机的数据分组（packet）交付</li><li>定义了IP地址，通过IP进行逻辑寻址，遵循IP协议</li><li>在不同网络之间实现路由+转发（交换机、路由器）</li></ul></li><li><p><strong>传输层（Transport）</strong></p><ul><li>提供源主机到目的主机（端到端进程间）的完整报文传输服务</li><li>连接控制、流量控制、差错控制</li></ul></li><li><p><strong>会话层（Session）</strong></p><ul><li>建立和管理应用程序之间的通信</li><li>建立/解除与物理其他接口的联系</li></ul></li><li><p><strong>表示层（Presentation）</strong></p><ul><li>数据格式化、代码转换、数据加密、数据压缩</li><li>解决不同系统之间的通信语法问题</li></ul></li><li><p><strong>应用层（Application）</strong></p><ul><li>文件传输、电子邮件、文件服务、虚拟终端</li><li>传输的数据根据应用层的协议进行服务</li></ul></li><li><p><strong>记忆口诀</strong></p><ul><li><strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>ell <strong>S</strong>tupid <strong>P</strong>eople <strong>A</strong>nything</li></ul></li></ul></li></ul><h3 id="TCP-IP四层体系结构"><a href="#TCP-IP四层体系结构" class="headerlink" title="TCP/IP四层体系结构"></a><strong>TCP/IP四层体系结构</strong></h3><ul><li><table><thead><tr><th>层次（自顶向下）</th><th>协议或组件</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、DNS、FTP</td></tr><tr><td>运输层（传输层）</td><td>TCP、UDP</td></tr><tr><td>网际层（IP层）</td><td>IP</td></tr><tr><td>网络接口层（网络接入层）</td><td>网络接口</td></tr></tbody></table></li><li><p>瘦腰结构</p></li><li><p>解决计算机之间通信问题是在：网际层（对应网络层）</p></li><li><p>TCP/IP协议族的网络层提供的是：<strong>无连接不可靠的数据报服务</strong></p></li><li><p>物理层、数据链路层、网络层传送的数据单位分别为：<code>比特</code>、<code>帧</code>、<code>分组</code></p></li><li><p>对比OSI七层参考模型</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103190907.png" alt="image-20220103190906970" style="zoom:50%;" /></li><li><p>七层——四层——五层</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104165049.png" alt="image-20220104165049457"></p></li></ul><h3 id="几种物理设备"><a href="#几种物理设备" class="headerlink" title="几种物理设备"></a>几种物理设备</h3><table><thead><tr><th>设备</th><th>功能</th><th>层级</th></tr></thead><tbody><tr><td>中继器 RP</td><td>根据输入端的信号重新生成原始信号，再通过输出端传送出去，扩大网络传输的距离</td><td>L1</td></tr><tr><td>集线器 Hub</td><td>将网线集中到一起的机器，也就是多台主机和设备的连接器</td><td>L1</td></tr><tr><td>网桥 Bridge</td><td>根据数据帧内容转发数据给其他相邻的网络；过滤/转发数据帧，拓展LAN</td><td>L2</td></tr><tr><td>交换机 Switch</td><td>MAC寻址，将数据帧转发到另一个目标MAC地址。和网桥的升级，具有集线器一样的集中连接功能，又具有网桥的数据交换功能</td><td>L2</td></tr><tr><td>路由器 Router</td><td>IP寻址，将分组报文转发到另一个目标路由器地址</td><td>L3</td></tr><tr><td>网关 Gateway</td><td>在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连</td><td>&gt;L3</td></tr></tbody></table><ul><li><p>集线器的缺点是：<strong>不能过滤网络流量</strong></p></li><li><p>连接在集线器上的结点<strong>共享</strong>集线器带宽（均分），连接在交换机上的结点独占交换机带宽</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125432.jpg" alt="img" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104125445.jpg" alt="img" style="zoom:33%;" /></li></ul><h2 id="1-5-网络性能评估"><a href="#1-5-网络性能评估" class="headerlink" title="1.5 网络性能评估"></a>1.5 网络性能评估</h2><h3 id="链路带宽"><a href="#链路带宽" class="headerlink" title="链路带宽"></a>链路带宽</h3><ul><li>指链路上每秒所能传输的比特数，单位bps</li><li>取决于链路时钟和信道编码</li><li>带宽往往大于吞吐量</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li><p>端到端时延</p><ul><li>将报文从网络一端传到另一端所花费的时间</li><li>= 处理时延 + 排队时延 + 传输时延 + 传播时延</li></ul></li><li><p>传输时延（发送时延）：</p><ul><li>主机或路由器发送数据帧所需的时间，即从帧的一个比特开始到最后一个比特发送完毕所需的时间</li><li>传输时延 = 分组长度 / 链路带宽</li></ul></li><li><p>传播时延</p><ul><li>电磁波在信道中传播一定距离所需的时间</li><li>与数据大小无关</li><li>传播时延 = 物理链路长度 / 电磁波传播速率（注意环境）</li></ul></li><li><p>处理时延</p><ul><li>主机或路由器在收到分组时分析首部、提取数据主体、差错检测等<strong>存储转发</strong>操作处理花费的时间</li></ul></li><li><p>排队时延</p><ul><li>分组通过网络传输时要经过很多路由器，进入路由器后要先输入队列中排队等待处理。在路由器确定了转发接口后还要在输出队列中等待转发</li></ul></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>等效于第一个比特到达接收方之前，发送方可以发送的比特数上限</li><li>是网络中能够保持的最大比特数</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103192043.png" alt="image-20220103192042971" style="zoom:50%;" /></li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><p>单位时间内发送方和接收方之间成功传输的数据量</p></li><li><p>受到各种因素影响，吞吐量小于带宽，带宽10Mbps的链路一吞吐量可能只能达到2Mbps左右</p></li><li><p><strong>链路吞吐量</strong>为：A端结点、B端结点、通信线路三者吞吐量的最小值</p></li><li><p><strong>网络设备吞吐量</strong></p><ul><li>单位时间内，网络设备各端口存储转发的比特数之<strong>和</strong></li><li>取决于输入输出端口硬件和程序算法设计</li><li>是没有帧丢失时，设备能接收并转发的最大数据速率</li></ul></li><li><p>计算机网络最主要的性能指标：<code>带宽</code>、<code>时延</code></p></li></ul><p>&nbsp;</p><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络适配器</p><ul><li>功能<ul><li>进行串行/并行转换</li><li>对数据进行缓存</li><li>设备驱动程序</li></ul></li><li>接口特性<ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>规程特性</li></ul></li></ul></li><li><p><code>链路</code>：物理传输媒质</p></li><li><p>信息传输速率单位：<code>bps</code></p></li><li><p>码元传输速率单位：<code>波特（Baud, 1/s）</code></p></li><li><p>承载信息量的基本信号单位：<code>码元</code></p></li><li><p>通信系统必备的三个基本要素：<code>信源</code>、<code>通信媒介</code>、<code>信宿</code></p></li><li><p><code>调制速率</code>：每秒钟载波调制状态改变的数值，单位：波特，又称为波特率，即码元的传输速率</p></li><li><p><code>比特率</code>：数据的传输速率，单位：bps</p></li><li><p>两台设备之间实现通信必备：<code>网卡</code>、<code>传输媒介</code>、<code>协议</code></p></li><li><p>链路层的数据封装和解封都由<code>网卡</code>完成</p></li><li><p>常见通信方式：</p><ul><li><p>单工通信（Simplex Communication）</p><p>信息只能单方向传输，发送端和接收端是固定的</p></li><li><p>半双工通信（Half-duplex Communication）</p><p>可以对调发送端和接收端，但是不能同时双边互发信息</p></li><li><p>全双工通信（Full-duplex Communication）</p><p>任意时刻都可以在双向同时传输信息</p></li></ul></li></ul><h3 id="网络通信编码"><a href="#网络通信编码" class="headerlink" title="网络通信编码"></a>网络通信编码</h3><ul><li><p>不归零（NRZ）</p><ul><li>编码方式<ul><li>1——&gt;高电平</li><li>0——&gt;低电平</li></ul></li><li>问题<ul><li>连续的0可能被误认为没有信号</li><li>连续的1可能导致基线漂移</li><li>时钟恢复困难</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194708.png" alt="image-20220103194708738" style="zoom: 50%;" /></li></ul></li><li><p>不归零反转（NRZI）</p><ul><li>编码方式<ul><li>1——&gt;信号跳变</li><li>0——&gt;信号保持</li></ul></li><li>问题<ul><li>可以解决连续1的问题，但是不能解决连续0的问题</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103194833.png" alt="image-20220103194833948" style="zoom:50%;" /></li></ul></li><li><p>曼彻斯特编码（Manchester）</p><ul><li>编码方式<ul><li>1——&gt;高到低跳变</li><li>0——&gt;低到高跳变</li></ul></li><li>问题<ul><li>信号跳变速率翻倍</li><li>比特率是信号跳变速率的一般，编码效率:50%</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195035.png" alt="image-20220103195035160" style="zoom:50%;" /></li></ul></li><li><p>4B/5B</p><ul><li>编码方式<ul><li>用5个比特对4个比特的数据进行编码, 其中每个代码(5个比特)中最多有1个前导0, 且末端最多有2个0</li><li>采用NRZI对5比特编码</li><li>编码效率：80%</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103195154.png" alt="image-20220103195154290" style="zoom: 67%;" /></li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><h2 id="3-1-相关概念"><a href="#3-1-相关概念" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h2><ul><li><p>链路层在每台主机的网络适配器（网卡）上实现，或者集成在芯片上</p></li><li><p>网络适配器之间的通信</p><ul><li>发送端<ul><li>将分组封装为数据帧</li><li>增加差错检测、可靠传输、流量控制等功能</li></ul></li><li>接收端<ul><li>完成差错检测、实施可靠传输、流量控制等</li><li>提取分组并交付至上层协议</li></ul></li></ul></li><li><p>链路层服务：</p><ul><li>组帧（framing）<ul><li>封装数据报构成数据帧，加首部和尾部</li><li>帧同步</li></ul></li><li>链路接入（link access）<ul><li>如果是共享介质，需要解决信道接入问题</li><li>帧首部中的MAC地址用于标识帧的源和目的</li></ul></li><li>相邻节点间可靠交付</li><li>流量控制</li><li>差错检测</li></ul></li><li><p>MAC地址</p><ul><li>又称为LAN地址、物理地址、以太网地址</li><li>局域网中每块网卡都有一个唯一的MAC地址，是硬件设备的唯一标识</li><li>作用：用于局域网标识一个帧从哪个接口发出，到达哪个物理相连的其他接口</li><li>48位MAC地址固化在网卡的ROM中，一般不会软件改动</li></ul></li><li><p>ARP地址解析</p><ul><li>ARP表<ul><li>LAN中每个IP结点（主机、路由器）维护一个表，存储某些LAN结点的IP/MAC地址映射关系</li><li>经过TTL时间后遗弃此映射关系（一般是20min）</li></ul></li><li>ARP即插即用，结点自主广播ARP查询分组，获得对应IP的主机应答其MAC地址，创建ARP表，超时（TTL）会自动刷新，无需干预</li></ul></li><li><p>透明传输1：传输的数据内容、格式、编码方式无限制</p></li></ul><h3 id="组帧（帧定界问题）"><a href="#组帧（帧定界问题）" class="headerlink" title="组帧（帧定界问题）"></a>组帧（帧定界问题）</h3><ul><li>面向字节的协议<ul><li>把每一帧看作一个字节集合</li><li>两种方法<ul><li>字符计数法</li><li>起止标记法</li></ul></li></ul></li><li>面向比特的协议<ul><li>把数据帧看作比特的集合</li><li>高级链路控制规程（HDLC）</li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>应用最广泛的LAN技术</p></li><li><p>网络速率:10Mbps——10Gbps</p></li><li><p>以太网的优点是：<code>可扩充性好</code>、<code>成本低</code>、<code>施工方便</code></p></li><li><p>以太网参考模型一般只包括：<code>物理层</code>和<code>数据链路层</code></p></li><li><p>以太网的碰撞窗口或争用期为：<strong>往返时延</strong></p></li><li><p>不可靠的服务：差错帧直接丢弃，丢弃帧中数据的恢复依靠高层协议（<strong>无确认</strong>）</p></li><li><p><strong>无连接</strong>的服务：发送帧的网卡与接受帧的网卡没有握手过程</p></li><li><p>MAC协议：二进制指数退避算法的CSMA/CD（不是必须）</p><ul><li>检测到冲突中止发送后，进入二进制指数退避</li></ul></li><li><p>以太网交换机：</p><ul><li>是链路层设备<ul><li>存储—转发以太网帧</li><li>检验到达帧的目的MAC地址，选择向一个或多个输出链路转发帧</li><li>利用CSMA/CD访问链路，发送帧</li></ul></li><li>透明：主机感受不到交换机的存在</li><li>即插即用</li><li>自学习，无需配置（目的帧不在交换表中时泛洪查找）</li><li>全双工通信</li><li>注意，交换机使用泛洪构建转发表；路由器则通过路由算法计算IP转发表</li><li>洪泛法的基本思想是：收到的信息都会往所有可能连接的路径上转发</li></ul></li><li><p>虚拟局域网VLAN：</p><ul><li>VLAN（Virtual Local Area Network）是由一些局域网网段构成的与物理位置无关的逻辑组</li><li>利用以太网交换机可以很方便地实现 VLAN</li><li>每一个 VLAN 的工作站可处在不同的局域网中</li></ul></li></ul><h3 id="无线局域网-IEEE802-11"><a href="#无线局域网-IEEE802-11" class="headerlink" title="无线局域网 IEEE802.11"></a>无线局域网 IEEE802.11</h3><ul><li><p>无线链路特性</p><ul><li>信号强度递减（路径损耗）</li><li>其他信号源干扰（各种频段）</li><li>多径传播（乱序到达）</li><li>隐藏终端问题（中间隔着障碍物）</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102214759.png" alt="image-20220102214759049" style="zoom:33%;" /></li><li><p>均使用CSMA/CA多路访问控制协议</p></li><li><p><strong>截断二进制指数</strong>类型退避算法解决了：站点检测到冲突后延迟发送的时间</p></li><li><p>无线局域网不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>是因为无线局域网：并非所有站点都能听见对方、无线介质传输特征复杂，存在隐藏终端、暴露终端等问题</p></li><li><p>无线通信网中，应对隐藏终端、暴露终端问题的方法是：<code>RTS/CTS 机制</code>（CSMA/CA）</p></li><li><p>无线局域网：</p><ul><li>无线局域网可分为两大类，即有固定基础设施的和无固定基础设施的</li><li>无固定基础设施的无线局域网又叫做自组织(AD HOC)网络</li><li>有固定基础设施的无线局域网，使用无线接入点（AP）作为基础设施</li></ul></li><li><p>无线局域网主要采用了<strong>预约信道</strong>方法解决数据帧的碰撞问题</p></li></ul><h3 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h3><ul><li>网桥<ul><li>实现：<code>过滤数据帧</code>、<code>转发数据帧</code>、<code>拓展LAN</code>功能</li><li>工作在<strong>数据链路层</strong></li><li>可以访问同一个网络中站点的<strong>物理</strong>地址</li><li>透明网桥是通过查找端口—地址表来决定转发路径的，而端口—地址表是网桥通过<strong>自学习算法</strong>生成的</li><li>通过将帧中的<strong>目的结点的物理地址</strong>和自己地址表中的信息比较，实现帧的转发和过滤</li></ul></li><li>交换机根据<code>数据报</code>、<code>虚电路</code>、<code>源路由</code>选择分组转发时的输出端口</li></ul><h2 id="3-2-差错检测"><a href="#3-2-差错检测" class="headerlink" title="3.2 差错检测"></a>3.2 差错检测</h2><ul><li><p>二维奇偶校验</p><ul><li>奇偶校验码可以检查出奇数个比特错误</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200424.png" alt="image-20220103200424868" style="zoom:50%;" /></li></ul></li><li><p>循环冗余校验（CRC）</p><ul><li><p>M(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200819.png" alt="image-20220103200819939" style="zoom:50%;" /></li><li><p>C(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200844.png" alt="image-20220103200844704" style="zoom:50%;" /></li><li><p>P(x)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103200907.png" alt="image-20220103200907613" style="zoom:50%;" /></li><li><p>判错条件：接收方判断P(x)是否可以整除C(x)</p></li><li><p>不同C(x)可以检测出特定的比特错误：</p><ul><li><p>所有1 &amp; 2-比特的错误</p></li><li><p>任意奇数个错误</p></li><li><p>任何小于k 比特的连续比特错误序列</p></li><li><p>部分大于 k 比特的连续比特错误序列</p></li></ul></li></ul></li><li><p>Internet校验和</p><ul><li>计算接受数据的校验和，并与发来的校验和字段内容比较是否一致</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151136.png" alt="image-20220103151136608" style="zoom: 33%;" /></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103151200.png" alt="image-20220103151200255" style="zoom:33%;" /></li></ul></li></ul><h2 id="3-3-可靠传输机制"><a href="#3-3-可靠传输机制" class="headerlink" title="3.3 可靠传输机制"></a>3.3 可靠传输机制</h2><ul><li><p>基本方法：<code>确认ACK</code>、<code>定时器超时</code>、<code>帧序号</code></p></li><li><p>核心机制：<code>差错检测CRC</code>、<code>ACK确认</code>、<code>定时器</code>、<code>超时重传</code>、<code>帧序号</code>、<code>滑动窗口</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204529.png" alt="image-20220103204529325" style="zoom:50%;" /></li></ul><h3 id="自动请求重传（ARQ）机制"><a href="#自动请求重传（ARQ）机制" class="headerlink" title="自动请求重传（ARQ）机制"></a>自动请求重传（ARQ）机制</h3><ul><li>采用ACK确认和超时定时器的可靠传输机制</li><li>接收方<ul><li>对数据帧进行差错检测</li><li>对正确帧进行确认, 丢失错误帧</li><li>丢弃禁止接收的数据帧</li></ul></li><li>发送方<ul><li>发送原始数据帧</li><li>对错误帧和丢失帧进行重传</li></ul></li></ul><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul><li><p>最简单的ARQ机制</p></li><li><p>内容</p><ul><li>每发送完一个数据帧, 发送方在继续发送下一个数据帧之前必须等待确认</li><li>如果在一定的时间范围内，发送方未收到确认(ACK), 则发送定时器超时激发, 发送方重传原始数据帧</li></ul></li><li><p>两种不同的帧丢失情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103201722.png" alt="image-20220103201722314" style="zoom:50%;" /></li><li><p>使用帧序号的目的是<strong>处理重复帧</strong></p></li><li><p>缺点</p><ul><li>链路带宽利用率低</li></ul></li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul><li>采取流水线设计，允许未收到确认，连续发送数据帧</li></ul><h4 id="后退N帧（Go-Back-N）"><a href="#后退N帧（Go-Back-N）" class="headerlink" title="后退N帧（Go-Back-N）"></a>后退N帧（Go-Back-N）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>接收方收到新数据帧时回传连续序号帧中的最大序号值（未必是当前接收帧的序号，因为可能是后发先到乱序 或者 前面有丢包）</p></li><li><p>如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202238.png" alt="image-20220103202238229" style="zoom:50%;" /></li></ul></li><li><p>优点: 接收方不需要缓存接收到的乱序帧，确认简单</p></li><li><p>缺点: 正确帧也可能被重传，效率较低</p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203815.png" alt="image-20220103203815365" style="zoom:67%;" /></li><li><p>例题：</p><ul><li><p>两台主机之间的数据链路层采用后退 N 帧协议传输数据，数据传输速率为 16kbps，单</p><p>向传播时延为 270ms，数据帧长度范围是 128-512 字节，接收方总是以与数据帧等长</p><p>的帧进行确认，为使信道利用率达到最高，帧序列的比特数至少为多少？</p><p>答：</p><p>&emsp;&emsp;即求从发送一个帧到接收到这个帧的确认为止的时间内最多可以发送数据帧的数量，对这个数量进行二进制编码所需的位数。</p><p>要尽可能多发帧，应以短的数据帧（传输时延短，发的快）计算，首先计算出发送一帧的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192243.png" alt="image-20220102192243529" style="zoom:50%;" /><p>发送一帧到收到确认的时间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103161327.png" alt="image-20220103161327331" style="zoom: 67%;" /><p>这段时间总共可以发送：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102192351.png" alt="image-20220102192351213" style="zoom:50%;" /><p>发送10个左右的帧，编号至少需要4位二进制数，因此至少4比特。</p></li></ul></li></ul><h4 id="选择性重传（SR）"><a href="#选择性重传（SR）" class="headerlink" title="选择性重传（SR）"></a>选择性重传（SR）</h4><ul><li><p>内容</p><ul><li><p>一次性发送N个数据帧</p></li><li><p>如果第k个帧丢失, 仅重传第k个帧</p></li><li><p>接收方对每一个帧进行确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202252.png" alt="image-20220103202252901" style="zoom:50%;" /></li></ul></li><li><p>优点: 链路利用率较高</p></li><li><p>缺点: 接收方更复杂</p></li><li><p><strong>发送窗口大小 == 接收窗口大小</strong></p></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203849.png" alt="image-20220103203849702" style="zoom:67%;" /></li><li><p>存在问题</p><ul><li><p>无法区分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204012.png" alt="image-20220103204012029" style="zoom:50%;" /></li><li><p>解决方法：（k为序号比特位数）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103204146.png" alt="image-20220103204146783" style="zoom:50%;" /></li></ul></li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><ul><li><p>引入滑动窗口对收发行为进行控制</p></li><li><p>基本思路</p><ul><li><p>发送方</p><ul><li><p>发送窗口大小：发送方在未收到确认前能够发送的数据帧的最大个数</p></li><li><p>发送方在未收到确认前最多可以发送多个数据帧 (受限于 发送窗口大小)</p></li><li><p>对未确认的数据帧缓存</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203220.png" alt="image-20220103203220318" style="zoom:50%;" /></li></ul></li><li><p>接收方</p><ul><li><p>接收窗口大小：接收方所能接收的乱序期望数据帧的最大个数</p></li><li><p>接收方通过ACK告知发送方下一次期望其传送的数据帧编号, 避免每次收到数据帧都发送确认</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203238.png" alt="image-20220103203238050" style="zoom:50%;" /></li></ul></li></ul></li><li><p>接收方行为</p><ul><li>接收数据帧<ul><li>如果一个数据帧到达(帧序号为SeqNum )</li><li>如果SeqNum ≤ LFR 或SeqNum &gt; LAF<ul><li>n数据帧落在接收窗口外, 则丢弃该数据帧</li></ul></li><li>如果LFR &lt; SeqNum ≤ LAF<ul><li>数据帧落在接收窗口内, 则接收</li></ul></li></ul></li><li>回复ACK<ul><li>SeqNumToAck = 未确认数据帧的最大SeqNum</li><li>接收方进确认 SeqNumToAck之前的数据帧, 即使更大序号的数据已接收</li><li>设置LFR = SeqNumToAck , 调整LAF = LFR + RWS</li></ul></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103203742.png" alt="image-20220103203742576" style="zoom: 67%;" /></li><li><p>优点</p><ul><li>不仅保证帧在物理链路上的可靠传输</li><li>而且保证帧传输的顺序</li><li>支持流量控制，接收方通过反馈机制可以抑制发送方速率</li></ul></li></ul><h2 id="3-4-媒质接入控制（MAC协议）"><a href="#3-4-媒质接入控制（MAC协议）" class="headerlink" title="3.4 媒质接入控制（MAC协议）"></a>3.4 媒质接入控制（MAC协议）</h2><ul><li>解决多路访问问题的前提是：<strong>寻址</strong></li></ul><h3 id="静态信道划分MAC协议"><a href="#静态信道划分MAC协议" class="headerlink" title="静态信道划分MAC协议"></a>静态信道划分MAC协议</h3><ul><li>多路复用技术<ul><li>时分复用（TDMA）</li><li>频分复用（FDMA）</li><li>码分复用（CDMA）</li><li>……</li></ul></li><li>网络负载重时效率高、公平，负载轻时效率低</li></ul><h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><ul><li>基本思想及特点<ul><li>信道不划分，允许冲突</li><li>采用冲突“恢复”机制</li><li>网络负载轻时效率高，负载重时冲突严重</li></ul></li></ul><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><ul><li>内容<ul><li>一旦数据帧到达, 立即发送 </li><li>如果发生冲突, 节点等待随机时间后重发数据直到发送成功</li></ul></li><li>效率 = 0.18</li></ul><h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><ul><li>内容<ul><li>当节点获得新的数据帧, 等待下一时隙到达开始发送</li><li>如果不存在冲突: 节点可以在下一时隙到达发送新的数据帧</li><li>如果发生冲突: 节点以概率p在每一个后续时隙内发送数据直到发送成功</li></ul></li><li>优点<ul><li>一个活跃节点可以持续以全速(信道带宽)发送数据帧</li><li>高度去中心化: 不需要中央调度</li><li>简单</li></ul></li><li>缺点<ul><li>存在冲突, 浪费时隙</li><li>存在空闲时隙</li><li>节点可能花费较长的时间进行冲突监测与退避重传</li><li>要求时钟同步</li></ul></li><li>效率 = 0.37</li></ul><h4 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h4><h5 id="普通CSMA"><a href="#普通CSMA" class="headerlink" title="普通CSMA"></a>普通CSMA</h5><ul><li><p>载波监听多路访问（Carrier Sensing Multiple Access）</p></li><li><p>内容</p><ul><li>发送前监听信道</li><li>如果信道空闲, 发送整个数据帧</li><li>如果信道忙, 延迟发送 </li></ul></li><li><p>冲突</p><ul><li><p>传播时延导致两个结点无法监听到对方的发送</p></li><li><p>导致整个数据帧被浪费</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103210353.png" alt="image-20220103210353350" style="zoom: 33%;" /></li></ul></li></ul><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><ul><li><p>要点：<code>冲突检测</code>、<code>多点接入</code>、<code>载波监听</code></p></li><li><p>机制：<strong>争用带宽</strong></p></li><li><p>内容</p><ul><li><p>边发边听，听到马上停止发送以减少信道浪费；不发就不听</p></li><li><p>有线局域网易实现；无线局域网难以实现（接收信号强度太低，无法与噪声区分）</p></li><li><p>为保证不发生碰撞，在传输时间内必须能收到最远端主机发送的信号（见下面最差冲突情况），即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102203719.png" alt="image-20220102203719361" style="zoom: 25%;" /></li></ul></li><li><p>冲突</p><ul><li><p>结点检测数据帧发送过程中是否发生冲突</p></li><li><p>如果发生冲突，则立即停止发送当前帧，改发送冲突信号广播通知其他结点，然后进行退避处理</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103224755.png" alt="image-20220103224755596" style="zoom: 50%;" /></li><li><p><strong>二进制退避算法</strong></p><ul><li>第k次冲突，则选择{0,1,2,…,2^k-1}中随机选择一个数乘以512bit，这个值对应的时延作为本次退避的等待时间</li><li>512bit对应51.2us，这是最初时最大覆盖以太网(2500米)往返最大时延</li></ul></li><li><p>冲突的最差情况</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225225.png" alt="image-20220103225225595" style="zoom: 67%;" /></li></ul></li><li><p>效率</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103225357.png" alt="image-20220103225357197" style="zoom:50%;" /></li><li><p><strong>以太网</strong>MAC协议用的就是这个</p></li><li><p>计算题</p><p>在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1Gbps，电缆中的信号传播速度是200000km/s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要______？</p><p>答：</p><p>&emsp;&emsp;本题隐藏条件是应该在最坏情况下计算，这样才能保证一定免数据帧冲突问题：（）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102194429.png" alt="image-20220102194429684" style="zoom:50%;" /><p>&emsp;&emsp;设传输线路的长度是L，那么信号在电缆中传输一个来回的时间是：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193852.png" alt="image-20220102193852730" style="zoom:50%;" /><p>&emsp;&emsp;设最短帧长度是：（最短帧长度 = 传播一个来回时间 * 传输速率）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102193926.png" alt="image-20220102193926664" style="zoom:50%;" /><p>&emsp;&emsp;所以如果MIN减小了800bit，则对应L需要<strong>减小80m</strong>。</p><p>&emsp;&emsp;标准答案：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211555.png" alt="image-20220103211555710" style="zoom: 50%;" /></li></ul><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><ul><li><p>机制：<strong>预约带宽</strong></p></li><li><p>思想</p><ul><li>无线信道传输存在隐藏终端和信道衰落问题，导致难以进行碰撞检测</li><li>与CSMA/CD不同，CSMA/CA目标不是监测碰撞，而是避免碰撞</li></ul></li><li><p>内容</p><ul><li><p>发送端</p><ul><li>如果监听到信道空闲<ul><li>将在一个被称作分布式帧间间隔（DIFS）的短时间段后发送该帧</li></ul></li><li>如果监听到信道正忙 <ul><li>选取一个随机回退值计时</li><li>当信道空闲时递减该值</li><li>当计数值减为0时，该站点发送整个数据帧并等待确认</li><li>如果未收到确认，增加回退值，重复第2步</li></ul></li></ul></li><li><p>接收端</p><ul><li>如果数据帧接收成功<ul><li>在SIFS时间后返回确认信息（确认信息在隐藏终端问题中是必须的）</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103233916.png" alt="image-20220103233916031" style="zoom:50%;" /></li><li><p>虚拟载波监听（预约信道）</p><ul><li><p>在发送数据帧之前交换控制信息</p><ul><li><p>发送方 询问 “Request-to-Send” (RTS)，包括数据帧长度</p></li><li><p>接收方 广播 “Clear-to-Send” (CTS)</p></li></ul></li><li><p>如果发送方收到 CTS，则开始发送数据 (指定长度)</p></li><li><p>其他节点收到 CTS，则认定信道在指定长度数据帧发送期间处于繁忙状态</p></li><li><p>如果多个节点同时检测到一个空闲链路并试图发送一个RTS，那么他们的RTS帧将彼此冲突。当发送端在一段时间内没有收到CTS帧时，节点知道发生冲突，会<strong>等待一段随机时间后</strong>再试</p></li><li><p>RTS、CTS都很短，因此开销小，并且可以完全避免数据帧碰撞</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103234630.png" alt="image-20220103234630447" style="zoom:50%;" /></li></ul></li></ul></li><li><p><strong>无线局域网</strong>MAC协议用的就是这个</p><ul><li>不使用<code>CSMA/CD</code>，而使用<code>CSMA/CA</code>的原因<ul><li>无线信道传输中并非所有站点都能听见对方、无线介质传输特征复杂，无线信道传输存在隐藏终端、暴露终端等问题</li><li>无线信道传输难以同时收发，接收信号强度明显弱于发送信号</li></ul></li></ul></li></ul><h3 id="轮转MAC协议"><a href="#轮转MAC协议" class="headerlink" title="轮转MAC协议"></a>轮转MAC协议</h3><ul><li><p>特点</p><ul><li>结点轮流发送</li><li>待发送数据量大的节点占用信道更长时间</li><li>无冲突</li></ul></li><li><p>方式一：轮询</p><ul><li><p>主节点 “邀请” 从节点轮流发送数据</p></li><li><p>典型应用于“dumb” 从设备</p></li><li><p>关注点：轮询开销、时延、主节点失效</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211115.png" alt="image-20220103211115624" style="zoom:50%;" /></li></ul></li><li><p>方式二：令牌传递</p><ul><li><p>控制<strong>令牌</strong>在节点之间依序传递.</p></li><li><p>令牌帧</p></li><li><p>关注点：令牌开销、时延、令牌丢失</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103211204.png" alt="image-20220103211204403" style="zoom:50%;" /></li><li><p>例：蓝牙、FDDI、令牌环网</p></li></ul></li></ul><h2 id="3-5-其他知识点"><a href="#3-5-其他知识点" class="headerlink" title="3.5 其他知识点"></a>3.5 其他知识点</h2><ul><li>IEEE802将数据链路层划分为两个子层，上为：<code>LLC</code>、下为：<code>MAC</code><ul><li>IEEE802 又称为LMSC（LAN /MAN Standards Committee， 局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）</li><li>IEEE802系列标准把数据链路层分成LLC（Logical Link Control，逻辑链路控制）和MAC（Media Access Control，媒介接入控制）两个子层。LLC子层在IEEE802.2标准中定义，为802标准系列共用；而MAC子层协议则依赖于各自的物理层</li></ul></li><li>10Mb/s和100Mb/s自适应系统是指：端口之间10Mb/s和100Mb/s传输率的自动匹配功能</li><li>局域网采用的拓扑结构包括：<code>总线型</code>、<code>星型</code></li><li>对于术语10base-T，base表示连接线上的信号时基带信号<ul><li>10base-T是双绞线以太网，1990年由IEEE新认可，编号IEEE802.3i，T表示采用双绞线，现10base-T采用的是非屏蔽双绞线（UTP）</li><li>技术指标<ul><li>数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Base表示基带传输，T代表双绞线</li><li>每段双绞线最大有效长度 100m，采用高质量的双绞线（5类线），最大长度可到<strong>150m</strong>(HUB与工作站间及两个HUB之间)</li><li>支持共享式和交换式两种组网方式</li><li>一条通路允许最大连接HUB数 4个</li><li>拓扑结构：星形或总线形</li><li>访问控制方式 CSMA/CD</li><li>帧长度可变，最大1518个字节</li><li>每个HUB可连接的工作站 96个</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络互联与路由器"><a href="#4-1-网络互联与路由器" class="headerlink" title="4.1 网络互联与路由器"></a>4.1 网络互联与路由器</h2><ul><li>网络层核心功能：转发+路由</li><li>面向无连接的IP协议的信息传输方式是：<code>数据报</code></li><li>路由器的功能<ul><li>解决异构网络之间的互联问题</li><li>路由选择</li><li>分组转发</li><li>数据分段</li><li>协议转换</li><li>数据封装</li><li>不包括流量控制</li></ul></li><li>路由器在能够开始向输出链路传输分组的第一bit之前，必须先接收到整个分组，这种机制称为：<strong>存储转发</strong></li><li><code>ARP</code>协议的作用是：将IP地址映射到数据链路层地址（MAC地址），反过来是<code>RARP</code></li><li>每台路由器都依赖<strong>ARP</strong>协议，否则无法正确工作</li><li><code>ARP</code>将IP地址转换为物理地址，<code>RARP</code>将物理地址转换为IP地址</li><li>路由器连接的<strong>异构网络</strong>指的是：<strong>数据链路层和物理层均不同</strong></li><li>路由器涉及Internet体系结构的<strong>网络接口层</strong>和<strong>网络层</strong></li><li>路由器可以隔离<code>ARP</code>广播帧</li><li><code>intranet</code>与<code>internet</code>互联，必须的互联设备是路由器</li><li>路由器 VS 交换机<ul><li>路由器第三层，交换机第二层</li><li>路由器：寻址，转发（依靠 IP 地址）<br>交换机：过滤，转发（依靠 MAC 地址）</li></ul></li></ul><h2 id="4-2-交换和桥接"><a href="#4-2-交换和桥接" class="headerlink" title="4.2 交换和桥接"></a>4.2 交换和桥接</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>定义<ul><li>有多个输入端和多个输出端的设备</li><li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口<ul><li>数据链路层交换机——交换——数据帧——mac地址</li><li>网络层交换机——转发——数据报datagram/数据包packet/分组——ip地址</li></ul></li><li>交换机各端口速率和交换机自身带宽一致，不论端口数量</li></ul></li><li>电路交换机（Circuit switch）<ul><li>不是直接相连的</li><li>每部电话连到一个交换设备：交换机</li><li>保证两部电话机建立单独的电路链接</li></ul></li><li>分组交换机（Packet switch）<ul><li>计算机连接到分组交换机</li><li>分组可从一台主机传输到另外一台主机</li><li>采取存储转发将分组从输入端口交换到正确的输出端口</li><li>每个端口发送速率和交换机本身带宽一直，相当于<strong>独占</strong>带宽</li></ul></li></ul><h3 id="交换网络"><a href="#交换网络" class="headerlink" title="交换网络"></a>交换网络</h3><ul><li><p>分类</p><ul><li><p>电路交换网络</p></li><li><p>分组交换网络：数据报、虚电路、源路由</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082156.png" alt="image-20220104082156187" style="zoom:50%;" /></li></ul></li></ul><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a><strong>数据报网络</strong></h4><ul><li>无连接</li><li>标识：每一个分组包含的目的地址</li><li>交换机决策：基于转发表<ul><li>交换机查询转发表确定分组的输出端口</li><li>转发表的构造与维护: 基于收集的桥接/路由信息</li></ul></li><li>数据报网络<ul><li>主机可以随时随地发送分组</li><li>主机无法知道网络是否可以传送该分组或目的主机是否可以接收</li><li>每个分组的转发均基于首部的目的地址, 分组之间相互独立</li><li>一台交换机或一条链路出现故障时, 并不会对通信产生任何严重的影响</li><li>实例：ARPnet</li></ul></li></ul><h4 id="虚电路（VC）网络"><a href="#虚电路（VC）网络" class="headerlink" title="虚电路（VC）网络"></a><strong>虚电路（VC）网络</strong></h4><ul><li><p>面向连接：预先建立连接</p></li><li><p>转发方式</p><ul><li><p>分组标识: 虚电路标识 (VCI)</p><ul><li>每一个分组包含一个 VCI</li></ul></li><li><p>交换机决策: 基于虚电路表</p><ul><li>交换机查询转发表确定分组的输出端口</li></ul></li><li><p>连接过程</p><ul><li>连接建立, 数据传输, 连接释放</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104074943.png" alt="image-20220104074943281" style="zoom:50%;" /></li></ul></li><li><p>虚电路的建立</p><ul><li>永久型虚电路（Permanent Virtual Circuit，PVC）<ul><li>网络管理员手工配置, 或由网络管理员产生信令探测形成</li><li>长期生存的虚电路</li></ul></li><li>交换型虚电路（Switched Virtual Circuit，SVC）<ul><li>主机动态发送信令建立连接</li><li>实际网络中SVC更为普遍</li><li>SVC信令<ul><li>建立<ul><li>源主机发送建立连接请求<ul><li>建立连接请求包含目的主机的完整地址</li></ul></li><li>中间交换机<ul><li>记录建立连接请求消息的输入端口</li><li>选择一个未使用的VCI值</li><li>确定输出端口</li><li>在虚电路表中插入一条记录</li><li>转发建立连接请求至下一个交换机</li></ul></li><li>目的主机<ul><li>选择一个可用的VCI值</li><li>沿着连接建立请求消息的路径反向发送确认消息</li></ul></li><li>中间交换机<ul><li>形成VC表记录</li></ul></li></ul></li><li>释放<ul><li>源主机发送释放连接消息</li><li>……</li></ul></li></ul></li></ul></li></ul></li><li><p>特点</p><ul><li>主机发送第一个数据分组前至少有一个RTT的时延, 用于连接建立</li><li>虽然建立连接请求包含目的主机的完整地址, 但每一个数据分组中仅带有一个很小的标识, 分组首部开销较小</li><li>如果一个连接上的交换机或链路出现故障, 连接就会被破坏, 需要建立新的连接</li><li>连接建立过程为虚电路提供了资源预留避免拥塞（对比：数据报网络是拥塞后恢复的策略）</li></ul></li></ul><h4 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a><strong>源路由</strong></h4><ul><li><p>源节点为每一个分组提供网络交换分组时所需的路由信息</p></li><li><p>源路由方法</p><ul><li>分组识别: 整条路径上所有交换机的端口序列<ul><li>分组首部包含从源节点到目的节点的整条路径的所有交换机的输出端口编号</li></ul></li><li>交换决策: 基于分组首部的路由<ul><li>交换机通过首部中的”下一个端口”指针读取下一个转发端口进行分组转发</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104075700.png" alt="image-20220104075700182" style="zoom:50%;" /></li><li><p>特点</p><ul><li>源节点知道全部的网络拓扑结构信息, 从而构造分组首部的源路由来指导交换机的分组转发</li><li>首部长度不固定, 由整条路径的跳数确定</li><li>源路由选择存在一个网络的规模性问题</li></ul></li></ul><h3 id="网桥和局域网交换机"><a href="#网桥和局域网交换机" class="headerlink" title="网桥和局域网交换机"></a>网桥和局域网交换机</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul><li>传统以太网局限性<ul><li>最多2500m的覆盖范围</li><li>最多容纳1024台主机</li></ul></li><li>拓展网络<ul><li>通过中继器再生放大信号</li><li>设计一种新的节点实现多个以太网之间的数据帧转发——&gt;网桥，有时通称为 以太网交换机</li></ul></li></ul><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><ul><li><p>是交换机的一种实现，实现了Ethernet的拓展</p></li><li><p>单一局域网的总通信量为10Mbps, 连接n个网桥的吞吐量最多能够达到<em>n</em> *10Mbps</p></li><li><p>在数据链路层拓展局域网使用网桥，在物理层拓展局域网使用转发器和集线器</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104081701.png" alt="image-20220104081701849" style="zoom:50%;" /></li></ul><h5 id="1-解决无脑全转发的问题：透明网桥"><a href="#1-解决无脑全转发的问题：透明网桥" class="headerlink" title="1. 解决无脑全转发的问题：透明网桥"></a>1. 解决无脑全转发的问题：透明网桥</h5><ul><li>网桥启动时, 转发表为空</li><li>通过<strong>逆向</strong>学习法构建<strong>端口—地址表</strong><ul><li>示例：洪泛法</li></ul></li><li>如果转发表中无对应记录, 则向所有其他端口转发数据帧</li><li>丢弃超时的记录(一段时间内未更新)，即 soft state</li><li>通过将帧中的目的结点的物理地址和自己地址表中的信息进行比较，实现帧的转发和过滤</li></ul><h5 id="2-解决网络环路问题：生成树算法"><a href="#2-解决网络环路问题：生成树算法" class="headerlink" title="2. 解决网络环路问题：生成树算法"></a>2. 解决网络环路问题：生成树算法</h5><ul><li>内容<ul><li>发送数据的源网桥的id</li><li>发送网桥认定的根网桥的id</li><li>从发送网桥到根网桥的距离 (跳数)</li><li>最初每个网桥认为自己是根节点</li><li>每个网桥生成配置消息并从每个端口发送出去</li><li>当网桥的某个端口收到新的配置消息后, 更新每个端口的配置消息</li><li>当网桥学习发现自己既不是根节点也不是指派节点时则停止发送配置信息</li><li>系统稳定时, 仅根网桥产生配置消息, 其他网桥仅在那些指派网桥的端口上转发这些配置消息</li><li>根节点周期性的发送配置消息</li><li>如果网桥在一段时间后仍未收到配置消息, 则重新宣布自己是根节点, 重新生成配置消息并转发</li></ul></li></ul><h5 id="3-解决广播和多播问题"><a href="#3-解决广播和多播问题" class="headerlink" title="3. 解决广播和多播问题"></a>3. 解决广播和多播问题</h5><ul><li>问题<ul><li>上述仅考虑了网桥的单播数据帧 </li><li>网桥的目标是透明的扩展局域网, 必须支持广播和多播</li></ul></li><li>解决<ul><li>广播：每个网桥将带有目标广播地址的数据帧传到除了接收它的端口以外的其他活动(选择)的端口</li><li>多播：扩展生成树算法用来裁减掉那些不需要转发多播帧的网络</li></ul></li></ul><h5 id="4-解决拓展性问题：虚拟局域网VLAN"><a href="#4-解决拓展性问题：虚拟局域网VLAN" class="headerlink" title="4. 解决拓展性问题：虚拟局域网VLAN"></a>4. 解决拓展性问题：虚拟局域网VLAN</h5><ul><li>拓展性差<ul><li>当连接网段的数量增加时, 生成树算法扩展性存在局限性</li><li>在一个大规模的网络中, 广播帧会影响网络的性能</li></ul></li><li>解决：虚拟局域网VLAN<ul><li>每一个虚拟局域网分配一个标识符</li><li>只有两个网段的标识符相同时, 才能完成数据帧的转发</li></ul></li></ul><h5 id="网桥-VS-交换机"><a href="#网桥-VS-交换机" class="headerlink" title="网桥 VS 交换机"></a>网桥 VS 交换机</h5><ul><li>网桥一般只有2个输入或输出端口，交换机有多个</li><li>网桥里的 MAC 地址表则是一个端口对应多个地址，交换机里则是一个端口对应一个 MAC 地址</li></ul><h3 id="共享式VS交换式以太网"><a href="#共享式VS交换式以太网" class="headerlink" title="共享式VS交换式以太网"></a>共享式VS交换式以太网</h3><h4 id="设备对比"><a href="#设备对比" class="headerlink" title="设备对比"></a>设备对比</h4><ul><li>共享式以太网：集线器Hub</li><li>交换式以太网：交换机Switch</li><li>以太网集线器——&gt;网桥——&gt;交换机<ul><li>集线器：在共享媒介局域网的核心设备，CSMA/CD</li><li>网桥：早期版本的交换机，用于局域网扩展，在不同网段之间转发数据帧</li><li>交换机：每个端口是个网桥，端口之间转发数据帧，不同端口之间可以传输隔离</li></ul></li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104082122.png" alt="image-20220104082122447" style="zoom:50%;" /><h4 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h4><ul><li>共享式：共享带宽，用CSMA/CD应对冲突</li><li>交换式：除非两个源端口发往同一目的端口，否则不存在冲突（专用带宽）</li></ul><h2 id="4-3-IP服务模型与协议"><a href="#4-3-IP服务模型与协议" class="headerlink" title="4.3 IP服务模型与协议"></a>4.3 IP服务模型与协议</h2><ul><li><p>IP协议提供的服务类型是：<strong>无连接的数据报服务</strong></p><ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li></ul></li><li><p>为了防止IP数据报在Internet上无限制地传递，告知路由器是否应该丢弃某个数据报，在IP数据报首部设置了<code>生存时间TTL</code>字段</p></li><li><p>IP服务模型</p><ul><li><p>数据报传输</p><ul><li><p><strong>尽力而为</strong>的不可靠传输服务</p></li><li><p>数据报的路由选择与转发</p><ul><li>无连接方式</li></ul></li><li><p>分段与重组</p><ul><li><p>最大传输单元MTU</p><ul><li><p>是链路层数据可封装数据的上限，不同链路不同</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103103928.png" alt="image-20220103103928162" style="zoom: 33%;" /></li><li><p>大IP分组向较小MTU链路转发时，可以被分片，用IP首部相关字段标识分片的序号</p></li></ul></li><li><p>IP数据报分片发生在<strong>路由器</strong>，而重组发生在<strong>目的主机</strong></p></li><li><p>如果某一个分段丢失, 目的主机将放弃重组进程并丢弃已收到的分段</p></li><li><p>计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104114.png" alt="image-20220103104114780" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104156.png" alt="image-20220103104156874" style="zoom: 33%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104222.png" alt="image-20220103104222098" style="zoom: 33%;" /></li></ul></li></ul></li></ul></li></ul><h2 id="4-4-IP地址及其划分"><a href="#4-4-IP地址及其划分" class="headerlink" title="4.4 IP地址及其划分"></a>4.4 IP地址及其划分</h2><h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><ul><li><p>IP地址是网络层中识别主机的<code>逻辑地址</code></p></li><li><p>层次化寻址：两级地址空间（网络号+主机号）</p></li><li><p>网络地址</p><ul><li>IP地址的网络号唯一标识一个网络</li><li>在同一个局域网上的主机或路由器的IP地址中的网络号必须一样</li><li>用网桥互连的网段仍然是一个局域网，只能有一个网络号</li><li>路由器总是具有两个或以上的IP地址</li><li>IP地址不能直接用来通信，在实际网络的链路上传送数据必须使用硬件地址（MAC）</li></ul></li><li><p>主机没有IP地址但要加入网络时，使用<code>DHCP</code>；主机发送数据但不知目的主机的硬件地址时，使用<code>ARP</code>；数据报传输过程中出现差错时，使用<code>ICMP</code></p></li></ul><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><ul><li><p>有类IP地址</p><ul><li><p>A类网络IP地址范围：1.0.0.1 - 127.255.255.254（<code>16777216-2</code>个主机/子网，2^24）</p></li><li><p>B类网络IP地址范围：128.0.0.1 - 191.255.255.254（<code>65536-2</code>个主机/子网，2^16）</p></li><li><p>C类网络IP地址范围：192.0.0.1 - 223.255.255.254（<code>256-2</code>个主机/子网，2^8）</p></li><li><p>D类网络IP地址范围：224.0.0.1 - 239.255.255.254（只用于多播）</p></li><li><p>E类网络IP地址范围：240.0.0.1 - 255.255.255.254（留给未来使用）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104634.png" alt="image-20220103104634464" style="zoom: 33%;" /></li></ul></li><li><p>私有IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104904.png" alt="image-20220103104904787" style="zoom: 25%;" /></li></ul><h3 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h3><ul><li><p>网络号与主机号</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104547.png" alt="image-20220103104547071" style="zoom: 33%;" /></li><li><p>特殊IP地址</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103104827.png" alt="image-20220103104827382" style="zoom:33%;" /></li><li><p>子网划分</p><ul><li><p>IP地址：原本的主机号高位比特改为子网号（SubID）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105116.png" alt="image-20220103105116448" style="zoom:25%;" /></li><li><p>子网掩码：NetID、SubID位全取1，用于表示利用多少位划分子网</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105245.png" alt="image-20220103105245490" style="zoom:33%;" /><ul><li><p>用于确定子网IP信息：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105333.png" alt="image-20220103105333288" style="zoom:33%;" /></li></ul></li><li><p>划分子网时，优先分配<strong>较大</strong>的子网</p></li><li><p>一个C类网络子网划分例子：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103105529.png" alt="image-20220103105529431" style="zoom:33%;" /></li><li><p>IP子网寻址示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085055.png" alt="image-20220104085055931" style="zoom:50%;" /></li><li><p>切记，子网中网络地址（全0）和广播地址（全1）占用了2个地址，因此子网主机数量实际上是<strong>可用主机号数量加2</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104085338.png" alt="image-20220104085338005" style="zoom: 50%;" /></li><li><p>已知网络类型和子网掩码，计算子网和主机数</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104150405.jpg" alt="img" style="zoom: 25%;" /><p>B类有16位（后16位）的主机位，依题，其中前10（8+2）位用作子网号，则子网有2^10=1024个，主机有2^6-2=62个</p></li></ul></li><li><p>优点</p><ul><li>提高了地址分配效率，加入一个新的物理网络时不需要用光B类或C类网络的所有地址</li><li>有利于信息聚合，减少路由器为了转发数据报到这些网络所需存储的信息量</li></ul></li></ul><h3 id="无分类编址CIDR与路由聚合"><a href="#无分类编址CIDR与路由聚合" class="headerlink" title="无分类编址CIDR与路由聚合"></a>无分类编址CIDR与路由聚合</h3><ul><li>CIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号，消除传统的A、B、C类网络地址界限</li><li>CIDR将网络前缀都相同的连续IP地址组成CIDR地址块</li><li>融合子网地址与子网掩码，方便子网划分<ul><li><p>无类地址格式：<code>a.b.c.d/x</code>，其中x是前缀长度（子网掩码里1的个数）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103110934.png" alt="image-20220103110927258" style="zoom: 33%;" /></li></ul></li><li>优点<ul><li><p>提高IPv4地址空间分配效率</p></li><li><p>提高路由效率，减少了路由表和转发表的记录数量（这是子网划分处理不了的）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103111123.png" alt="image-20220103111123578" style="zoom:33%;" /></li></ul></li><li>最长前缀匹配优先<ul><li><p>在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口</p></li><li><p>使用CIDR查找路由表时可能会得到多个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，路由就越具体</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104145741.jpg" alt="Screenshot_20220104-145630_Superstar" style="zoom: 25%;" /></li></ul></li></ul><h3 id="地址转换协议（ARP）"><a href="#地址转换协议（ARP）" class="headerlink" title="地址转换协议（ARP）"></a>地址转换协议（ARP）</h3><ul><li>给定目的主机的IP地址, ARP可以找到同属一个物理网络内部的目的主机的物理地址</li><li>ARP采用<strong>广播机制</strong>，路由器可以隔绝ARP广播</li><li>每一个主机维护一个ARP表：<ul><li>并不是由一个服务器来负责回答请求，而是“自给自足”</li><li>15分钟记录未更新则超时失效</li></ul></li><li>当ARP表中无目的IP地址的对应记录，则ARP协议开始启动</li><li>工作原理<ul><li>主机X广播一个 ARP请求报文来探寻未知的节点D的IP地址</li><li>节点D 向源节点反馈其物理地址<ul><li>D节点 在本地ARP表中增加或更新节点X对应的记录</li></ul></li><li>节点X将收到的信息写入其ARP表</li><li>同一网络内的其他主机<ul><li>如果本地的ARP表中已存在节点X的IP地址对应的记录, 则更新记录</li><li>否则，do nothing</li></ul></li></ul></li></ul><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><ul><li><p>DHCP协议在应用层实现，借助UDP数据报在链路层广播</p></li><li><p>DHCP允许主机自动从服务器获取：IP地址、子网掩码、默认网关地址、DNS服务器与IP地址</p></li><li><p>即插即用</p></li><li><p>允许地址重复使用</p></li><li><p>支持在用地址续租</p></li><li><p>支持移动用户加入网络</p></li><li><p>DHCP服务器会给出包含配置参数的提议供主机选择</p></li><li><p>新到主机（DHCP客户）获取IP地址的过程：</p><ul><li><p>主机广播：“DHCP discover”</p></li><li><p>DHCP服务器利用“DHCP offer”进行响应</p></li><li><p>主机请求IP地址：“DHCP request”</p></li><li><p>DHCP服务器分配IP地址：“DHCP ack”</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103135749.png" alt="image-20220103135749025" style="zoom: 33%;" /></li></ul></li></ul><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><ul><li><p>网络地址转换（NAT）</p></li><li><p>实现<code>本地设备IP地址</code>和<code>与外界通信时所用IP地址</code>之间的转换</p></li><li><p>本地网络内不同设备有不同IP地址，但是在对外交流时使用<strong>同一NAT IP地址</strong>的<strong>不同端口号</strong></p></li><li><p>内部网络设备对外界网络不可见，即外界无法直接寻址（安全）</p></li><li><p>本地网络IP地址的变更无需通告外界网络</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103140400.png" alt="image-20220103140400114" style="zoom:33%;" /></li></ul><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><ul><li><p>互联网控制报文协议（ICMP）</p></li><li><p><code>ping</code>发出的是ICMP报文，目的IP回复对应ICMP报文，用于检测网络连通性</p></li><li><p><code>traceroute</code>发出TTL=1的数据包，第一个接收到路由器回回传ICMP报文（TTL=0），然后<code>traceroute</code>发出TTL=2的数据包给第二个路由器，递推得到到达目的节点所经过的路由器序列</p></li><li><p>支持主机或服务器：差错检测、网络探寻</p></li><li><p>ICMP差错报文</p><ul><li><p>终点不可达</p><ul><li>终点不可达分为：网络不可达、主机不可达、协议不可达、端口不可达、需要分片但DF比特已置1、源路由失败，共6种情况，向源站发送对应的代码字段0~5的不可达报文</li></ul></li><li><p>端口不可达</p><ul><li>UDP的规则之一是：如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP报文</li></ul></li><li><p>源站抑制：</p><ul><li>当路由器或主机由于拥塞而丢弃数据报时，就向源站发送源站抑制报文，使源站知道应当将数据报发送速率放慢</li></ul></li><li><p>时间超时</p><ul><li>当路由器收到生存时间TTL为0的数据报时，除了丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送超时报文</li></ul></li><li><p>参数问题</p><ul><li>当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文</li></ul></li><li><p>改变路由（重定向）</p><ul><li>将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器</li></ul></li></ul></li><li><p>以下几种数据报不会导致产生ICMP差错报文：</p><ul><li>ICMP差错报文（但是ICMP查询报文可能会产生ICMP差错报文）</li><li>目的地址是广播地址或多播地址的数据报</li><li>作为链路层广播的数据报</li><li>不是IP分片的第1片</li><li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址</li></ul></li><li><p>ICMP网络探寻报文</p><ul><li>回声（Echo）请求与应答（Reply）报文</li><li>时间戳请求与应答报文</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul><li><p>RFC2373中详细定义了IPv6地址，按照定义，一个完整的IPv6地址的表示法：xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx<br>例如：2031:0000:1F1F:0000:0000:0100:11A0:ADDF（4位×8段）</p><p>为了简化其表示法，rfc2373提出<strong>每段中前面的0可以省略</strong> ；<strong>连续的0可省略为”::”，但只能出现一次</strong>。例如：</p><table><thead><tr><th>原地址</th><th>简写</th></tr></thead><tbody><tr><td>1080:0:0:0:8:800:200C:417A</td><td>1080::8:800:200C:417A</td></tr><tr><td>FF01:0:0:0:0:0:0:101</td><td>FF01::101</td></tr><tr><td>0:0:0:0:0:0:0:1</td><td>::1</td></tr><tr><td>0:0:0:0:0:0:0:0</td><td>::</td></tr></tbody></table></li><li><p>数据格式</p><ul><li>定长40字节报头</li><li>不允许片段</li></ul></li><li><p>IP隧道（IPv4向IPv6过渡）</p><ul><li><p>IPv4路由器中IPv6数据报作为IPv4数据报的负载</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104101322.png" alt="image-20220104101322686" style="zoom:50%;" /></li></ul></li></ul><h2 id="4-5-路由算法与协议"><a href="#4-5-路由算法与协议" class="headerlink" title="4.5 路由算法与协议"></a>4.5 路由算法与协议</h2><h3 id="转发-VS-路由"><a href="#转发-VS-路由" class="headerlink" title="转发 VS 路由"></a>转发 VS 路由</h3><ul><li><p>转发（数据平面）</p><ul><li>过程：获得一个分组, 查看其目的地址，查询本地转发表，将分组从输出端口发送出去</li><li>节点(路由器/交换机)本地执行</li></ul></li><li><p>路由（控制平面）</p><ul><li>转发表的构建过程</li><li>通常由基于复杂分布式算法的路由协议完成</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104084242.png" alt="image-20220104084242379" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104090244.png" alt="image-20220104090244257" style="zoom: 67%;" /></li></ul><h3 id="距离向量（DV）路由选择"><a href="#距离向量（DV）路由选择" class="headerlink" title="距离向量（DV）路由选择"></a>距离向量（DV）路由选择</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>与路由器直接连接的网络的距离值为0</li><li>每个节点构造一个包含到所有其他节点的”距离”(代价)的一维数组(一个向量)</li><li>并将该向量分发给其邻节点</li><li>节点根据接收到的距离向量计算到达其他所有节点的最短路径</li><li>经过距离向量的迭代交换和计算过程最终构造完整的路由表</li><li>注意，只能找到去每个网络的最短路径中的一条，不能所有都找到</li></ul></li><li><p>步骤</p><ul><li><p>步骤1：最初节点将向量中可直接到达的邻节点的代价设置为<strong>1</strong>，到所有其他节点的代价赋值为<strong>∞</strong></p></li><li><p>步骤2：节点将距离向量发送至直接可达的邻节点</p></li><li><p>步骤3：根据从邻节点<strong>Y</strong>收到的距离向量，节点<strong>X</strong></p><ul><li>计算本节点到达所有其他节点的距离：将来自<strong>Y</strong>的向量中到达所有其他节点的距离(例如 <strong>Z</strong>)加上本节点到<strong>Y</strong>的距离 (即<strong>1</strong>）</li><li>比较计算结果与本地向量中对应结果的大小：如果计算结果更小，则用该值替换本地距离向量的对应结果，并记录NextHop 为<strong>Y</strong></li></ul></li><li><p>示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091156.png" alt="image-20220104091156375" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091222.png" alt="image-20220104091222480" style="zoom:50%;" /></li></ul></li><li><p>链路代价变化</p><ul><li>节点检测到本地链路代价改变 </li><li>更新路由信息，重新计算距离矢量</li><li>如果DV发生改变，通知相应的邻居</li></ul></li><li><p>无穷计算问题</p><ul><li><p>场景</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104091516.png" alt="image-20220104091516434" style="zoom:50%;" /></li><li><p>方案A：采用最大跳数取代无穷大</p></li><li><p>方案B：水平分割</p><ul><li>不向提供路由的邻节点发送更新报文</li><li>例如：节点B不向节点A发送有关节点E的更新信息，因为节点B到达节点的用路由是从节点学习而来的</li></ul></li><li><p>方案C：带反向抑制的水平分割</p><ul><li>节点B通告到达节点E的代价为无穷大，以确保节点A最终不会使用节点B来到达节点E</li></ul></li><li><p>上述解决方案在路由循环超过3节点的网络环境中网络会失效</p></li></ul></li></ul><h4 id="路由选择信息协议（RIP）"><a href="#路由选择信息协议（RIP）" class="headerlink" title="路由选择信息协议（RIP）"></a>路由选择信息协议（RIP）</h4><ul><li>基于距离向量算法</li><li>30s更新一次距离向量</li><li>跳数最大值为15，16意味无穷大</li></ul><h3 id="链路状态（LS）路由选择"><a href="#链路状态（LS）路由选择" class="headerlink" title="链路状态（LS）路由选择"></a>链路状态（LS）路由选择</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li><p>基本思想</p><ul><li>每个节点都知道怎样到达它的邻节点(link state), 并向通告给其他所有节点, 因此<strong>每个节点都可以获得完整的网络信息</strong>来建立其路由表</li><li>链路状态的度量可以是：距离、带宽、时延、费用等</li></ul></li><li><p>依赖链路状态的<strong>可靠洪范</strong></p><ul><li>链路状态报文(Link State Message)<ul><li>链路状态分组, LSP (Link State Packet)</li><li>创建LSP的节点ID</li><li>与该节点直接相邻的节点信息列表 &lt;AdjacentNode, Cost&gt;, 其中包括到这些邻节点的链路代价</li><li>序号 Seq</li><li>LSP的生命周期</li></ul></li><li>保证链路状态分组的洪泛<ul><li>采用确认和重传机制</li><li>通过序号</li><li>不发回发送LSP的节点</li></ul></li><li>新的链路状态分组快速洪泛, 旧的分组快速被删除<ul><li>采用序列号和TTL</li><li>长序列号</li><li>逐跳递减TTL</li></ul></li><li>链路状态洪泛的触发器<ul><li>周期性计时器超时</li><li>拓扑结构变化</li></ul></li></ul></li><li><p>路由计算（基于Dijkstra算法）</p><ul><li><p>算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092709.png" alt="image-20220104092709471" style="zoom: 67%;" /></li><li><p>示例1</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104092448.png" alt="image-20220104092448663" style="zoom:50%;" /></li><li><p>示例2</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103100722.png" alt="image-20220103100722586" style="zoom: 33%;" /></li></ul></li><li><p>算法分析</p><ul><li>时间复杂度：O(n^2)，可优化为O(nlogn)</li><li>可能存在路由震荡（无穷计算）</li><li>优点<ul><li>快速稳定</li><li>不会产生过多的通信量</li><li>快速响应拓扑变化</li></ul></li><li>缺点<ul><li>节点存储的信息量大(所有其他节点的LSP)</li></ul></li></ul></li><li><p>如果在一个使用链路状态路由的互联网络中有5个路由器和6个网络，那么存在<code>5</code>个路由表，每个表中至少有<code>6</code>个表项，在路由器中存在<code>1</code>个不同的链路状态数据库</p></li><li><p>链路状态 VS 距离向量</p><ul><li>链路状态：每个节点只告诉所有其他节点与之<strong>相邻</strong>的链路状态</li><li>距离向量：每个节点只与直接相连的节点通信，但是包含到达<strong>所有</strong>节点的距离</li></ul></li></ul><h4 id="开放最短路径优先（OSPF）"><a href="#开放最短路径优先（OSPF）" class="headerlink" title="开放最短路径优先（OSPF）"></a>开放最短路径优先（OSPF）</h4><ul><li>基于链路状态算法</li><li>高级特征（RIP没有）<ul><li>安全性：所有OSPF报文需要认证 (避免恶意入侵)</li><li>允许多条相同代价的路径存在 (RIP中仅允许一条路径)</li><li>对一条链路而言，可以依据不同的TOS分配不同的代价值(例如：卫星链路从实时性考虑代价较大, 但从尽最大努力交付能力来说代价较小)</li><li>支持单播和多播<ul><li>多播OSPF (MOSPF)使用与OSPF相同的拓扑数据</li></ul></li><li>在一个较大的域内采用<strong>层次化</strong>OSPF</li></ul></li><li>OSPF协议将一个自治域划分成若干区域，有一种特殊区域叫做主干区域<ul><li>域之间通过边界路由器互联</li><li>在自治系统中有4中路由器：区域内部路由器、主干路由器、区域边界路由器、自治域边界路由器</li><li>主干路由器可以兼做区域边界路由器</li></ul></li></ul><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Internet将整个网络划分为许多较小单位AS：由同一个管理机构管理，使用统一的路由策略的路由器的集合</li><li>每一个自治系统(AS)在一个独立的管理实体的控制之下<ul><li>示例：校园网络、公司网络</li></ul></li><li>由此，路由协议也分为两大类：<strong>内部网关协议IGP</strong>、<strong>外部网关协议EGP</strong></li></ul><h4 id="内部网关协议（IGP）"><a href="#内部网关协议（IGP）" class="headerlink" title="内部网关协议（IGP）"></a>内部网关协议（IGP）</h4><ul><li>内部网关协议（Interior Gateway Protocol）是一个在自治网络内部网关（主机和路由器）间交换路由信息的协议。路由信息用于网间协议（IP）或者其他网络协议来说明路由传送是如何进行的</li><li>包括：RIP、OSPF、IS-IS、IGRP、EIGRP等</li><li>选路原则：优先级、开销、负载均衡</li><li>典型协议<ul><li>RIP协议<ul><li>RIP协议是一种内部网关协议，底层是贝尔曼福特算法，是一种动态路由选择协议。</li><li>基于<strong>距离向量</strong>算法，使用跳数来衡量到达目标地址的路由距离</li><li>运行在<strong>UDP</strong>协议之上，使用520端口，使用224.0.0.9作为组播地址向外组播路由信息</li><li>以跳数作为选择路由的度量标准，只适用于<strong>小区域</strong></li><li>通过广播UDP报文来交换信息，<strong>30s</strong>发送一次路由信息更新</li><li>最多支持的跳数为15，16及以上就表示为不可达</li><li>要求路由器维护从它到每个内部路由器的距离向量</li><li>使用<strong>毒性逆转</strong>法预防乒乓环路无穷计算，设置无穷大距离为16</li></ul></li><li>OSPF协议<ul><li>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议</li><li>基于<strong>链路状态</strong>路由协议</li><li>运行于<strong>IP</strong>协议之上</li><li>允许使用多条相同费用的路径（RIP只能选择一条）</li><li>以带宽、延迟作为选择路由的度量标准，适用于<strong>大中型</strong>网络</li></ul></li></ul></li></ul><h4 id="外部网关协议（EGP：BGP）"><a href="#外部网关协议（EGP：BGP）" class="headerlink" title="外部网关协议（EGP：BGP）"></a>外部网关协议（EGP：BGP）</h4><ul><li>外部网关协议（Exterior Gateway Protocol）是AS之间使用的路由协议，目前只有一个协议：BGP</li><li><strong>边界网关（BGP）协议</strong><ul><li>运行于<strong>TCP</strong>基础上</li><li>属于域间路由选择，“把互联网粘合在一起”</li><li>基于<strong>路径向量</strong>算法（不使用距离向量（收敛慢）、链路状态（强迫告知敏感信息，不安全））<ul><li>支持灵活的路由策略（商业要求）</li><li>避免无穷计算</li><li>核心思想: 通告整个路径<ul><li>路由表要包括分组到达目的网络的路径</li><li>所交换的网络可达性信息是：<strong>到达某个网络所经过的路径</strong></li></ul></li></ul></li><li>使用<strong>TCP</strong>作为传输层协议</li><li>内容：<ul><li>节点知道多条到达目的地的路径<ul><li>在路由表中存储所有的路由</li><li>采用策略选择一条最好的路由</li></ul></li><li>增量更新<ul><li>通告<ul><li>一旦选择一条新的路由, 则将节点id加入路径向量</li><li>… 并(有选择性的)通告其他邻居</li></ul></li><li>撤销<ul><li>如果路由不再有效</li><li>… 发送撤销路由消息</li></ul></li></ul></li></ul></li><li>主要功能是和其他的 BGP 系统交换网络可达信息</li><li>BGP的邻居关系（或称通信对端/对等实体）是通过人工配置实现的，对等实体之间通过TCP（端口179)会话交互数据</li><li>BGP路由器会周期地发送19字节的保持存活keep-alive消息来维护连接（默认周期为30秒）</li><li>热土豆路由<ul><li>有多个网关路由器可以到达目的子网时，选择最小费用路径的区域间路由器</li></ul></li></ul></li></ul><p><strong>直接封装RIP、OSPF、BGP报文的协议分别为：UDP、IP、TCP</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>又称为 组播，与一组主机进行通信，指多个接收者可以收到同一个或者同一组源节点发送的相同内容的分组</li><li>避免单播的低效和广播的无区分性</li><li>发送主机使用多播地址发送分组时不需要了解接收者的位置信息和状态信息</li><li>组播协议（IGMP）<ul><li>IGMP协议运行于主机与组播路由器之间，这描述了IGMP的应用场景</li><li>只有主机和路由器才会使用，如果是路由器和路由器之间，是不会使用IGMP的</li><li>IGMP提供了在转发组播数据包到目的地的最后阶段所需的信息，实现如下双向的功能：<ol><li>主机通过IGMP通知路由器希望接收或离开某个特定组播组的信息</li><li>路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护</li></ol></li></ul></li></ul><h4 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h4><ul><li>ISP使用</li><li>解决BGP的路由黑洞问题</li></ul><h4 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h4><ul><li>目的地址为家乡地址的IP分组，将会以标准的IP路由机制发送到家乡网络</li><li>家乡链路与外地链路比家乡网络与外地网络更精确地表示出移动结点接入点位置</li><li>家乡代理通过隧道将发送给移动节点的 IP 分组转发给移动节点</li><li>终端系统处理<ul><li>间接选路: 从通信者到漫游节点的通信，通过本地代理，然后被转发到漫游网络</li><li>直接选路: 通信者获得漫游节点的外部地址/转交地址, 直接发送给漫游节点</li></ul></li><li>三角路由（间接选路）<ul><li>通信者-本地网络-漫游节点</li></ul></li></ul><p>&nbsp;</p><h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><ul><li><p>网络层负责主机到主机的通信，传输层负责进程到进程的通信</p></li><li><p>基本理论和基本机制</p><ul><li><p>发送端多路复用，接收端解复用</p></li><li><p>复用/解复用</p><ul><li>无连接的解复用：UDP的Socket，用二元组（目的IP地址，目的端口号）标识</li><li>面向连接的解复用：TCP的Socket，用四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识</li></ul></li><li><p>可靠数据传输机制</p><ul><li>差错检测（校验和）</li><li>确认机制（含序号分组和ACK）</li><li>确认重传机制（ARQ协议）</li><li>停—等协议——&gt;流水线机制——&gt;滑动窗口协议：后退N帧（GBN）、选择性路由（SR）</li></ul></li></ul></li><li><p>TCP/IP协议族的层次中，解决计算机之间通信问题是在<strong>网络层</strong></p></li><li><p>在OSI参考模型中，提供流量控制功能的是：<strong>数据链路层</strong>、<strong>传输层</strong></p></li></ul><h2 id="5-2-用户数据报（UDP）协议"><a href="#5-2-用户数据报（UDP）协议" class="headerlink" title="5.2 用户数据报（UDP）协议"></a>5.2 用户数据报（UDP）协议</h2><ul><li>关于UDP的描述<ul><li>发送数据之前不需要建立连接（减少延迟）</li><li>没有拥塞控制，应用可以更好地控制发送时间和速率</li><li>相对于IP数据报服务，UDP在IP之上只增加了<strong>端口</strong>的功能和<strong>差错检测</strong>功能（校验和，checksum）</li><li>UDP用户数据报只能提供不可靠的交付，可能乱序、丢失</li></ul></li><li>关于端口的描述<ul><li>端口就是传输层服务访问点</li><li>端口号只具有本地意义，在Internet中不同计算机的相同端口号是没有联系的</li><li>Socket由IP地址和端口号组成</li></ul></li><li>UDP协议中，伪首部的作用是：为差错检测提供帮助</li><li>为解决UDP报文的可靠传输问题：<ul><li>在应用层增加可靠性机制</li><li>应用特定的错误恢复机制</li></ul></li><li>优点<ul><li>控制数据发送的内容和时间</li><li>不存在连接建立时延</li><li>无状态连接</li><li>报文首部开销较小</li></ul></li><li>缺点<ul><li>不保证报文的传送, 可能出现乱序到达</li><li>无拥塞控制</li><li>抑制TCP流</li></ul></li><li>应用<ul><li>域名解析系统：DNS</li><li>多媒体应用</li></ul></li></ul><h2 id="5-3-可靠字节流（TCP）协议"><a href="#5-3-可靠字节流（TCP）协议" class="headerlink" title="5.3 可靠字节流（TCP）协议"></a>5.3 可靠字节流（TCP）协议</h2><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><ul><li>面向连接<ul><li>终端主机在数据交换之前需要连接连接</li><li>全双工：数据可双向传输</li></ul></li><li>可靠性<ul><li>保证数据的传送</li><li>数据按序到达</li></ul></li><li>流量控制<ul><li>控制发送方的速率避免接收方过载</li><li>在链路层也存在流量控制</li></ul></li><li>拥塞控制<ul><li>控制发送方速率避免网络过载</li><li>拥塞控制由网络层和传输层协作解决</li></ul></li></ul><h4 id="TCP帧结构"><a href="#TCP帧结构" class="headerlink" title="TCP帧结构"></a>TCP帧结构</h4><ul><li>1 - 2 字节：源端口号</li><li>3 - 4 字节：目的端口号</li><li>5 - 8 字节：序列号Seq</li><li>9 - 12 字节：确认号ACK</li><li>14字节：标志位SYN</li><li>17 - 20 字节：缺省通告窗口AdvertisedWindow，描述接收方窗口大小</li><li>其中，AdvertisedWindow必须大于链路的时延带宽积；Sequence Number必须大于AdvertisedWindow的2倍，且大于链路带宽×数据段最大TTL（支持数据段最大生存期）</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220105074604.png" alt="image-20220104235736233" style="zoom: 33%;" /><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><ul><li><p>Client发送建立连接请求（SYN=1，Seq=x）至Server</p></li><li><p>Server回复确认前序请求（ACK=1，ack=x+1），同时捎带对发送进程的连接请求（SYN=1，Seq=y）——&gt;(ACK=1，ack=x+1，SYN=1，Seq=y)</p></li><li><p>Client回复确认前序请求（ACK=1，ack=y+1）</p></li><li><p>为什么三次握手？</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104103543.png" alt="image-20220104103543736" style="zoom: 67%;" /></li></ul><h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><ul><li>Client发送连接断开请求（FIN=1，Seq=u）至Server</li><li>Server回复确认前序请求（ACK=1，ack=u+1），同时继续发送待传输数据（Seq=v）</li><li>Server等待上层应用数据传输完毕之后，Server重复确认前序请求（ACK=1，Seq=u+1），同时发送连接断开请求（FIN=1，Seq=w）</li><li>Client回复确认前序请求（ACK=1，ack=w+1，Seq=u+1），继续等待2<code>MSL</code>时间后关闭</li></ul><h4 id="TCP数据报中变量"><a href="#TCP数据报中变量" class="headerlink" title="TCP数据报中变量"></a>TCP数据报中变量</h4><ul><li>建立连接阶段，seq=随机值；后续阶段，seq=对面发送数据报的序号</li><li>ack = 希望接收的数据报的序号 = 对方数据报seq值 + 1</li><li>ACK是标志位，= 1说明为ACK信号</li></ul><h2 id="5-4-TCP滑动窗口算法"><a href="#5-4-TCP滑动窗口算法" class="headerlink" title="5.4 TCP滑动窗口算法"></a>5.4 TCP滑动窗口算法</h2><ul><li><p>TCP采用改进的滑动窗口算法实现：</p><ul><li>保证数据的可靠传送</li><li>确保数据的有序传送</li><li><strong>流量控制</strong> (基于变化的 AdvertisedWindow 字段)</li></ul></li><li><p>滑动窗口算法采用变化的接收窗口大小</p><ul><li><p>接收方通知发送方其窗口大小，该值可能随时间变化</p></li><li><p>接收窗口大小通过TCP首部的AdvertisedWindow字段描述</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104104349.png" alt="image-20220104104349810" style="zoom:50%;" /></li></ul></li><li><p>ACK信息还包括期望接受的下一字节</p></li><li><p>触发传输</p><ul><li>当收集到的字节数达到MSS 时</li><li>发送进程明确要求TCP发送时</li><li>定时器激活</li></ul></li><li><p>超时重传</p><ul><li><p>采用自适应机制估计当前RTT作为定时依据</p></li><li><p>原始算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105042.png" alt="image-20220104105041940" style="zoom: 67%;" /></li><li><p>Karn/Partridge算法</p><ul><li>TCP重传时停止计算RTT样本值</li><li>每次重传后设置下次超时的值为上次的两倍（指数退避）</li></ul></li><li><p>Jacobson/Karn算法</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104105153.png" alt="image-20220104105153647" style="zoom:50%;" /></li></ul></li></ul><h2 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h2><ul><li><p>发送端限制发送速率</p><ul><li><p>拥塞窗口CongWin</p><ul><li><p>发送端的发送窗口上限值应取<strong>接收方窗口</strong>和<strong>拥塞窗口</strong>中的较小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143429.png" alt="image-20220103143429277" style="zoom: 33%;" /></li></ul></li><li><p>接收窗口 VS 拥塞窗口</p><ul><li>接受窗口用于流量控制，避免快速发送方使慢速接收方过载</li><li>拥塞窗口用于拥塞控制，避免多个发送方使网络过载</li></ul></li><li><p>发送窗口 = min（接收窗口，拥塞窗口，链路时延带宽积）</p></li></ul></li><li><p>拥塞事件</p><ul><li>超时</li><li>3个重复ACK</li></ul></li><li><p>调整发送速率</p><ul><li>加性增——乘性减：AIMD<ul><li>加性增：每个RTT将CongWin增大一个MSS——<strong>拥塞避免</strong></li><li>乘性减：发生拥塞事件后将CongWin减半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103143712.png" alt="image-20220103143712710" style="zoom: 50%;" /></li></ul></li><li>慢启动：SS<ul><li>TCP初始时，CongWin=1</li><li>开始阶段，指数性增长：每个RTT（收到ACK时）将CongWin翻倍</li><li>考虑在一个具有 10ms 往返时延的线路上采用慢启动拥塞机制。假设没有发生网络拥塞，该 TCP 的报文段大小为 2KB，接收方可用接收窗口为 24KB。那么发送方需要<code>40</code>ms 时间才能达到该接收窗口大小<ul><li>已知最大报文段式2KB，开始的突发量分别是2KB、4KB、8KB、16KB，接下来即为24KB，因为不能超过接收窗口，因此，需要40ms才能发送第一个完全窗口</li></ul></li></ul></li><li>状态切换：<ul><li>变量Threshold记录AIMD和SS切换的阈值</li><li>朴素思想：<ul><li>CongWin小于Threshold时采用SS，大于Threshold时采用AIMD</li><li>发生拥塞事件时Threshold置为拥塞事件瞬间CongWin大小的一半</li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144059.png" alt="image-20220103144059883" style="zoom:50%;" /></li></ul></li><li>实际规定：<ul><li>收到3个重复ACK时，<strong>快速恢复</strong><ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin减少一半</li><li>采用AIMD</li></ul></li><li>发生超时事件时<ul><li>Threshold置为当前CongWin大小的一半</li><li>CongWin置为1</li><li>采用SS</li><li>达到Threshold时再换为AIMD</li></ul></li><li><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103144605.png" alt="image-20220103144605452" style="zoom:50%;" /></li><li>设 TCP 的拥塞窗口的慢启动门限值初始为 12（单位为报文段），当拥塞窗口达到 16 时出现超时，再次进入慢启动过程。问从这时起，需要<code>12</code>次往返时延才能恢复到超时那时的拥塞窗口大小<ul><li>出现超时后，拥塞窗口设为1，拥塞避免门限为8<br>因此经过3个RTT后拥塞窗口增加为8<br>在经过8个RTT后拥塞窗口增加到16<br>因此共需要8+3=11个RTT才能使拥塞窗口恢复为超时时的16</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>快速重传</strong></p><ul><li>在收到3次重复ACK时，不必等待超时计时器，立刻重传对应序号的分组以避免超时</li></ul></li><li><p>公平性</p><ul><li><p>TCP具有公平性，带宽平均分配（原因：加性增、乘性减）</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104110059.png" alt="image-20220104110059041" style="zoom:50%;" /></li><li><p>但与UDP同时抢占资源时不占优势</p></li></ul></li><li><p>其他</p><ul><li>TCP协议中观察网络拥塞的办法是 <code>以超时作为网络拥塞的标志</code></li><li>在 TCP/IP 中，实施流量控制的目的是 <code>保证接收方总是来得及接收发送方发出的报文或分组</code></li><li>在 TCP 协议中，如果发送窗口直接按照接收方的通知窗口设置，其结果是 <code>突发流量导致分组无法到达接收方</code></li><li>在 TCP 协议中，如果发送方收到三个重复的 ACK 后, 发送方将会 <code>快速重传未被确认的报文段</code></li><li>多媒体应用经常不使用 TCP 的原因可能是 <code>不希望数据传输速率受限于拥塞窗口</code></li><li>主机 A 和主机 B 之间建立了一个 TCP 连接，TCP 最大的数据段长度为 1000 字节，若主机 A 当前的拥塞窗口为 4000 字节，在主机 A 向主机 B 连续发送两个最大段之后，成功收到主机 B 回复的第一段的确认，确认报文中通告的接收窗口大小为 2000 字节，则此时主机 A 还可以向主机 B 发送的最大字节数是 <code>1000</code><ul><li>第一个段的确认段中通告的接收窗口大小为2000字节，即表明在接受到第一个报文段后，还有2000字节的缓存空间可用。 由于发送方发送了二个报文段，第二个段将占用剩下的2000字节中的1000字节，即一共还有（ 2000-1000=1000 ）字节，因而，此时主机甲还可以向主机乙发送的最大字节数是1000字节</li></ul></li></ul></li></ul><p>&nbsp;</p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h3 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p>网络应用体系结构</p><ul><li>客户机/服务器（C/S）结构<ul><li>Web应用</li><li>Email应用</li><li>DNS应用</li></ul></li><li>点对点结构(P2P)结构<ul><li>BitTorrent、文件共享（电驴）、即时消息（QQ）</li></ul></li><li>混合型结构</li></ul></li><li><p>通过<code>IP地址</code>对主机进行寻址后通过<code>端口号</code>标识不同进程</p><ul><li>HTTP Server：80</li><li>Email Server：25</li></ul></li><li><p>在整个Internet上，使用<code>IP地址+端口号</code>唯一标识一个特定的应用进程</p></li><li><p>在 Internet 域名体系中，域的下面可以划分子域，各级域名用圆点分开，按照 <code>从右到左越来越小的方式分多层排列</code></p></li><li><p>当一台计算机从 FTP 服务器下载文件时，在该 FTP 服务器上对数据进行封装的五个转换步骤是 <code>消息，报文段，数据报，数据帧，比特</code></p></li><li><p>网络应用实例</p><ul><li>E-mail</li><li>Web</li><li>即时通信（QQ）</li><li>远程登陆（ssh、telnet）</li><li>P2P文件共享（BitTorrent）</li><li>IP电话（Skype）</li><li>……</li></ul></li></ul><h3 id="Web应用与HTTP协议"><a href="#Web应用与HTTP协议" class="headerlink" title="Web应用与HTTP协议"></a>Web应用与HTTP协议</h3><ul><li><p>万维网WWW（World Wide Web）</p><ul><li>浏览器是运行于计算机上的万维网客户端程序；万维网文档所驻留的计算机则运行服务器程序</li><li>WWW工作过程可简要描述为：<ul><li>浏览器于服务器之间建立TCP连接</li><li>浏览器发出HTTP请求报文</li><li>服务器给出HTTP响应报文</li><li>断开TCP连接</li><li>响应时间 = 2×RTT+文件传输时间</li></ul></li><li>一个超文本由多个信息源链接而成，利用一个链接可使用户找到因特网上的另一个文档<ul><li>超文本：含有链接到其他文本的链接点的文本</li></ul></li></ul></li><li><p>Web</p><ul><li>网页由某些<strong>对象</strong>组成</li><li>对象可以是HTML文件、JPEG图片、Java Applet、音频文件……</li><li>网页由包含以上某些对象的基本HTML文件构成</li><li>每个对象都由一个URL定位</li></ul></li><li><p>超文本传输协议（HTTP）</p><ul><li>网络的应用层协议</li><li>无状态协议，服务器不保存客户端之前请求的信息记录</li><li>客户机/服务器模型（C/S）<ul><li>客户机：浏览器请求和接收消息，显示web对象</li><li>服务器：Web 服务器发送对象给浏览器，作为对请求的响应</li></ul></li><li>使用TCP传输协议<ul><li>客户端发送连接请求（产生socket）给服务器的80端口</li><li>服务器接收从客户端发送来的<strong>TCP</strong>连接请求</li><li>浏览器（HTTP客户端）和Web服务器（HTTP服务器）之间交换HTTP 消息 (应用层协议消息)</li><li>关闭TCP连接</li></ul></li></ul></li><li><p>Web使用<code>HTTP</code>协议进行信息传输</p></li><li><p>用户—服务器状态：Cookies技术</p><ul><li><p>因为HTTP协议为无状态，所以为了保存上次浏览内容，引入Cookie技术</p></li><li><p>Client访问Server时带上Cookie编号，Server为每个编号Client维护后台数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103155836.png" alt="image-20220103155836735" style="zoom: 33%;" /></li></ul></li></ul><h3 id="域名解析服务DNS"><a href="#域名解析服务DNS" class="headerlink" title="域名解析服务DNS"></a>域名解析服务DNS</h3><ul><li><p>实现主机名到IP地址的映射</p><ul><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录</li><li>当客户请求域名服务器转换名字时，服务器首先按标准过程检查它是否被授权管理该名字</li><li>域名服务器向客户报告缓存中有关名字与地址的绑定(binding)信息</li></ul></li><li><p>采用分布式数据库</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220104111337.png" alt="image-20220104111337451" style="zoom:50%;" /></li><li><p>查询过程示例</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160151.png" alt="image-20220103160151420" style="zoom:33%;" /></li><li><p>例题</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103160126.png" alt="image-20220103160126557" style="zoom: 33%;" /></li></ul><h3 id="Email服务与SMTP协议"><a href="#Email服务与SMTP协议" class="headerlink" title="Email服务与SMTP协议"></a>Email服务与SMTP协议</h3><ul><li>Email应用组件<ul><li>邮件客户端</li><li>邮件服务器</li><li>SMTP协议（Simple Mail Transfer Protocol）、MIME、POP协议<ul><li>使用TCP协议从客户端向服务器可靠的发送电子邮件消息，端口号25</li><li>直接传输: 发送服务器到接收服务器</li><li>传输的三个阶段<ul><li>握手 (问候)</li><li>消息发送</li><li>终止</li></ul></li><li>命令/响应的交互<ul><li>命令：ASCII文本信息</li><li>响应：状态码与短语</li></ul></li><li>消息必须是7位ASCII码</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmap内存映射——用户空间与内核空间的直接交流</title>
      <link href="/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>/2022/01/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;<code>mmap</code>是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read()</code>、<code>write()</code>等系统调用函数。同时，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209123614.png" alt="image-20220209123614653" style="zoom: 30%;" /><span id="more"></span><p>&nbsp;</p><h2 id="Linux虚拟内存"><a href="#Linux虚拟内存" class="headerlink" title="Linux虚拟内存"></a>Linux虚拟内存</h2><p>&emsp;&emsp;进程的虚拟地址空间由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质空间，即具有同样特性的连续地址范围。下图中的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射都是一个独立的虚拟内存区域，而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092829.png" alt="image-20220102092829331" style="zoom:33%;" /><p>&emsp;&emsp;Linux内核使用<code>vm_area_struct</code>结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个<code>vm_area_struct</code>结构来表示不同类型的内存区域。各个<code>vm_area_struct</code>结构使用链表或者树形结构来链接，方便进程快速访问。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220101235153.png" alt="image-20220101235152947" style="zoom:50%;" /><p>&emsp;&emsp;<code>vm_area_struct</code>结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个<code>vm_ops</code>指针，其内部可引出所有针对这个区域能使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用的信息都可以从<code>vm_area_struct</code>中获得。<code>mmap</code>就是创建一个新的<code>vm_area_struct</code>结构并将其与文件的物理磁盘地址相连。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a>mmap内存映射</h2><h3 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h3><p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p><ol><li>进程在用户空间调用库函数<code>mmap()</code></li><li>在当前进程的虚拟地址空间中寻找一段空闲的满足要求的连续虚拟地址</li><li>为此虚拟地址分配一个<code>vm_area_struct</code>结构，并对其各域进行初始化</li><li>将新建的虚拟结构<code>vm_area_struct</code>插入进程的虚拟地址区域链表或树中</li></ol><p><strong>（二）调用内核空间的系统调用函数<code>mmap()</code>（不同于用户空间的<code>mmap()</code>），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p><ol><li>为映射分配新的虚拟地址后，通过映射的文件指针在文件描述符表中找到其对应的文件描述符，再通过文件描述符链接到内核“已打开文件集”中该文件的文件结构体<code>struct file</code>，每个文件结构体维护着这个已打开文件的各项相关信息</li><li>通过该文件的文件结构体链接到<code>file_operations</code>模块，调用内核函数<code>mmap()</code></li><li>内核<code>mmap()</code>函数通过虚拟文件系统<code>inode</code>模块定位到文件磁盘物理地址</li><li>通过<code>remap_pfn_range()</code>函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。注意：此时这片虚拟地址仍没有任何数据关联到主内存中</li></ol><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，接下来系统会自动实现文件内容到物理内存（主存)的拷贝</strong></p><ol><li>进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表发现这一段地址并不在物理页上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</li><li>缺页异常进行一系列判断，确定无非法操作后内核发起请求调页过程</li><li>调页过程现在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用<code>nopage()</code>函数把所缺页从磁盘装入主存中</li><li>之后进程即可对这片主存进行读或写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，即完成了写入文件的过程。</li></ol><p>注：修改过的脏页面不会立即更新到文件中而是有延迟，可以调用<code>msync()</code>函数强制同步</p><p>&nbsp;</p><h3 id="对比常规文件操作"><a href="#对比常规文件操作" class="headerlink" title="对比常规文件操作"></a>对比常规文件操作</h3><h4 id="常规文件操作"><a href="#常规文件操作" class="headerlink" title="常规文件操作"></a>常规文件操作</h4><ol><li>进程发起读取文件请求</li><li>内核通过查找进程文件符表，定位到内核“已打开文件集”上的文件信息，从而找到此文件的<code>inode</code></li><li><code>inode</code>在<code>address_space</code>上查找要请求的文件页是否已经缓存在页缓存中。<ul><li>如果在，则直接返回这片文件页的内容</li><li>如果不在，则通过<code>inode</code>定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程</li></ul></li></ol><p>&emsp;&emsp;总结来说常规文件操作需要从磁盘到页缓存再到用户主存两次数据拷贝。而<code>mmap</code>操控文件只需要从磁盘到用户主存一次数据拷贝过程。即<code>mmap</code>实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程，因此效率更高时延更小。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102002540.png" alt="image-20220102002540469" style="zoom:50%;" /><p>&nbsp;</p><h3 id="优点及作用"><a href="#优点及作用" class="headerlink" title="优点及作用"></a>优点及作用</h3><ol><li>对文件的读取操作跨过了页缓存，减少了数据拷贝次数和时间开销，用内存读写取代了I/O读写，提高文件读取效率</li><li>实现了内核空间和用户空间的高效交互方式，彼此的修改操作可以直接反映在映射的内存区域内并被对方空间捕捉</li><li>提供进程间共享内存的通信方式，并且进程A第一次读取地址内容时通过缺页从磁盘复制文件到页面中后，进程B再读同样地址内容时虽然也会缺页，但是不需要再从文件磁盘里复制，而是直接使用已保存在内存中的文件数据</li><li>可用于实现高效的大规模数据传输，避免了大量文件I/O操作的时间开销</li></ol><p>&nbsp;</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    start：映射区的开始地址</span></span><br><span class="line"><span class="function">    length：映射区长度</span></span><br><span class="line"><span class="function">    prot：期望的内存保护标志，不能与文件的打开模式冲突，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    PROT_READ：页内容可以被读取</span></span><br><span class="line"><span class="function">    PROT_WRITE：页可以被写入</span></span><br><span class="line"><span class="function">    PROT_EXEC：页内容可以被执行</span></span><br><span class="line"><span class="function">PROT_NONE：页不可访问</span></span><br><span class="line"><span class="function">   flags：指定映射对象的类型，映射选项和映射页是否可以共享，用<span class="keyword">or</span>运算组合</span></span><br><span class="line"><span class="function">    MAP_SHARED：与其它所有映射这个对象的进程共享映射空间</span></span><br><span class="line"><span class="function">    MAP_PRIVATE： 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</span></span><br><span class="line"><span class="function">    MAP_ANONYMOUS：匿名映射，映射区不与任何文件关联</span></span><br><span class="line"><span class="function">    fd：文件描述符，如果flags设定为MAP_ANONYMOUS，为了兼容问题，其值应为-1</span></span><br><span class="line"><span class="function">    offset：被映射对象内容的起点</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">在进程地址空间中解除一个映射关系，addr是调用<span class="title">mmap</span><span class="params">()</span>返回的地址，len是映射区大小，成功则返回0，失败返回-1。当映射关系解除后，对原来地址的访问会引发段错误。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    flags：</span></span><br><span class="line"><span class="function">    MS_ASYNC：采用异步写方式</span></span><br><span class="line"><span class="function">MS_SYNC：采用同步写方式</span></span><br><span class="line"><span class="function">MS_INVALIDATE：从文件中读回数据</span></span><br><span class="line"><span class="function">一般进程在映射空间对共享内存的改变不会直接回写到磁盘中，调用<span class="title">munmap</span><span class="params">()</span>后才同步，调用<span class="title">msync</span><span class="params">()</span>可以强制同步修改过的脏页面使其立即更新到磁盘文件中。</span></span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><code>mmap()</code>映射区域的大小必须是物理页大小（page_size）的整数倍（32位系统中通常是4k字节）。因为内存的最小粒度是页，而进程的虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，<code>mmap()</code>从磁盘到虚拟地址空间的映射也必须是页</li><li>内核可以跟踪被内存映射的底层对象（文件）大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的字节。如果文件大小一直在扩张，只要还在映射区域范围内就能够被合法访问到。但如果文件本身大小有限，则内存中写入的数据超过文件大小时，超出部分不会被写入文件</li><li>映射建立之后，即使文件关闭，映射也依然存在。因为映射的是磁盘地址而不是文件本身，和文件句柄无关。同时可用于进程通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射</li></ol><p>&nbsp;</p><h5 id="情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中"><a href="#情形一：一个文件大小是5000字节，mmap-函数从文件的起始位置开始，映射5000字节到虚拟内存中" class="headerlink" title="情形一：一个文件大小是5000字节，mmap()函数从文件的起始位置开始，映射5000字节到虚拟内存中"></a>情形一：一个文件大小是5000字节，<code>mmap()</code>函数从文件的起始位置开始，映射5000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;因为单位物理页的大小是4096字节，所以实际映射到虚拟内存区域的有8192个字节，5000~8192的字节部分用零填充。此时：</p><ul><li>读/写0~4999字节时会返回操作文件内容</li><li>读5000~8191字节时，结果全是0；写5000~8191字节时，进程不报错但是所写内容不会回写到文件中</li><li>读/写8192以外的磁盘部分时，返回<code>SIGSECV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102093046.png" alt="image-20220102093046402" style="zoom:33%;" /><p>&nbsp;</p><h5 id="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"><a href="#情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中" class="headerlink" title="情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中"></a>情形二：一个文件的大小是5000字节，mmap函数从文件的起始位置开始，映射15000字节到虚拟内存中</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;文件实际映射到虚拟内存区域的有8192个字节，对应两个物理页，因此这两个物理页都可以合法读写，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常：</p><ul><li>进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中</li><li>对于5000~8191字节，进程可以进行读写过程不报错，但是内容在写入前均为0，另外，写入后不会反映在文件中</li><li>对于8192~14999字节，进程不能对其进行读写，会报<code>SIGBUS</code>错误</li><li>对于15000以外的字节，进程不能对其读写，会引发<code>SIGSEGV</code>错误</li></ul><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102090515.png" alt="image-20220102090515453" style="zoom: 50%;" /><p>&nbsp;</p><h5 id="情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"><a href="#情形三：一个文件初始大小为0，使用mmap操作映射了1000-4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr" class="headerlink" title="情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr"></a>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr</h5><p><strong>分析：</strong></p><p>&emsp;&emsp;如果在建立之初就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，会返回<code>SIGBUS</code>错误。但是如果每次操作<code>ptr</code>前先增加文件大小，那么<code>ptr</code>在文件大小内部的操作就是合法的。这样方便随时扩充文件空间，不造成空间浪费。</p><p>&nbsp;</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>p1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">match_file</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">int</span> *length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *length = sb.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_mmap</span><span class="params">(<span class="keyword">char</span> *mmap, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read[%d]:  %s\n&quot;</span>, count++, mmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line">    mapped = match_file(argv[<span class="number">1</span>], &amp;length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每隔一秒查看存储映射区是否被修改 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read_mmap(mapped, length);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="keyword">char</span> *context[<span class="number">6</span>] = &#123;<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;てんどう万象&quot;</span>, <span class="string">&quot;today is Thursday&quot;</span>, <span class="string">&quot;Xi Nei&quot;</span>, <span class="string">&quot;54618888&quot;</span>, <span class="string">&quot;德丽莎世界第一可爱&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *mapped;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有文件映射将无法修改文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;read[%d]:  %s\n&quot;, count++, mapped);</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(mapped, <span class="string">&#x27;0&#x27;</span>, sb.st_size);</span><br><span class="line">            <span class="built_in">strcpy</span>(mapped, context[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wirte[%d]:  %s\n&quot;</span>, count++, context[i]);</span><br><span class="line"></span><br><span class="line">            msync(mapped, PAGE_SIZE, MS_ASYNC);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 间隔一秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，修改内容长度不能大于原文件长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220102092156.png" alt="image-20220102092156158"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C自定义Python内置模块</title>
      <link href="/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/12/31/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8C%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;Python 可以非常方便地和 C 进行相互的调用。</p><p>&emsp;&emsp;一般不会使用 C 去直接编写一个 Python 的模块。通常是需要把 C 的相关模块包装一下，然后在 Python 中可以直接调用它。或者是，把 Python 逻辑中的某一效率要求很高的部分使用 C 来实现。整个过程大概是：</p><ol><li>引入 Python.h 头文件</li><li>编写包装函数</li><li>函数中处理从 Python 传入的参数</li><li>实现功能逻辑</li><li>处理 C 中的返回值，包装成 Python 对象</li><li>在一个 PyMethodDef 结构体中注册需要的函数</li><li>在一个初始化方法中注册模块名</li><li>把这个 C 源文件编译成链接库</li></ol><span id="more"></span><p>&nbsp;</p><h3 id="用C写Python扩展模块的文件"><a href="#用C写Python扩展模块的文件" class="headerlink" title="用C写Python扩展模块的文件"></a>用C写Python扩展模块的文件</h3><h4 id="Step1：引入Python-h头文件"><a href="#Step1：引入Python-h头文件" class="headerlink" title="Step1：引入Python.h头文件"></a>Step1：引入Python.h头文件</h4><p>&emsp;&emsp;下面用到的函数都在该头文件中定义好了，并且它还包含了一些标准头文件: <code>&lt;stdio.h&gt;</code>，<code>&lt;string.h&gt;</code>，<code>&lt;errno.h&gt;</code> 和 <code>&lt;stdlib.h&gt;</code>。这个头文件一般位于 Python 的主目录中，例如在我ubuntu中是<code>/usr/include/Python3.8</code></p><h4 id="Step2：编写包装函数"><a href="#Step2：编写包装函数" class="headerlink" title="Step2：编写包装函数"></a>Step2：编写包装函数</h4><p>&emsp;&emsp;因为 Python 用到的函数与普通的 C 函数在输入和输出上会有一些不同，所以需要把普通的 C 做一些封装来给 Python 用。本质是定义暴露给<code>CPython</code>解析器的C函数</p><p>&emsp;&emsp;在实现功能的过程中可以先完全不考虑这东西是拿给 Python 用的，只专注于使用 C 把它写好就可以了。功能写好并测试没有问题之后再做 Python 封装的工作。包装函数一般声明成 static ，并且函数类型和传参都是<code>PyObject*</code>类型。这是因为Python是C语言实现的，在C语言中Python对象都由<code>PyObject</code>结构体表示。但虽然C语言是强类型语言，只用一种类型是没办法正常工作，但其实<code>PyObject</code>结构体内包含了大部分C语言数据类型的存储方式，通过不同的解析函数或者参数即可指定解析出对应C类型。</p><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>&emsp;&emsp;在C程序中，函数的定义统一用<code>PyObject</code>，并且无论原Python程序中对应函数传的参数有几个，统一写两个参数：<code>PyObject* self, PyObject* args</code>（若没有传参则都不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参解析"><a href="#传参解析" class="headerlink" title="传参解析"></a>传参解析</h5><p>&emsp;&emsp;上面说过，无论参数数量和类型，一律用<code>PyObject* self, PyObject* args</code>来声明，实际在函数定义中会使用Python的API函数<code>PyArg_ParseTuple()</code>来获得真正的参数，它会检查参数类型并将其转换为 C 值，使用模板字符串确定需要的参数类型以及存储被转换的值的 C 变量类型。当解析成功时返回<code>True</code>，若其传入参数无效则返回<code>False</code>并抛出<code>PyExc_TypeError</code>异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(count: <span class="keyword">int</span>, saying: <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数这样解析参数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> *saying;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PyArg_ParseTuple(args, <span class="string">&quot;is&quot;</span>, &amp;symbol, &amp;symbol) == False)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h5><p>&emsp;&emsp;注意函数在声明时和传参一样也是<code>PyObject*</code>类型，所以很自然能想到其返回值也是该类型。但与传参时相反，返回值是从C语言数据类型构造为<code>PyObject*</code>类型，这里使用的是另一个Python的API函数：<code>Py_BuildValue()</code>，它与<code>PyArg_ParseTuple()</code>类似，都是使用格式字符串解析参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设原Python函数是：</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(*args)</span> -&gt; <span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span>:</span></span><br><span class="line"><span class="function">···</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> count, saying</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">则C中对应定义的函数：</span></span><br><span class="line"><span class="function">PyObject* <span class="title">func</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;is&quot;</span>, count, saying);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用<code>Py_BuildValue()</code>的格式化字符串形式：</p><table><thead><tr><th>调用语句</th><th>解析值</th></tr></thead><tbody><tr><td>Py_BuildValue(“”)</td><td>None</td></tr><tr><td>Py_BuildValue(“i”, 123)</td><td>123</td></tr><tr><td>Py_BuildValue(“iii”, 123, 456, 789)</td><td>(123, 456, 789)</td></tr><tr><td>Py_BuildValue(“s”, “hello”)</td><td>‘hello’</td></tr><tr><td>Py_BuildValue(“y”, “hello”)</td><td>b’hello’</td></tr><tr><td>Py_BuildValue(“ss”, “hello”, “world”)</td><td>(‘hello’, ‘world’)</td></tr><tr><td>Py_BuildValue(“s#”, “hello”, 4)</td><td>‘hell’</td></tr><tr><td>Py_BuildValue(“y#”, “hello”, 4)</td><td>b’hell’</td></tr><tr><td>Py_BuildValue(“()”)</td><td>()</td></tr><tr><td>Py_BuildValue(“(i)”, 123)</td><td>(123,)</td></tr><tr><td>Py_BuildValue(“(ii)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“(i,i)”, 123, 456)</td><td>(123, 456)</td></tr><tr><td>Py_BuildValue(“[i,i]”, 123, 456)</td><td>[123, 456]</td></tr><tr><td>Py_BuildValue(“{s:i,s:i}”, “abc”, 123, “def”, 456)</td><td>{‘abc’: 123, ‘def’: 456}</td></tr><tr><td>Py_BuildValue(“((ii)(ii)) (ii)”, 1, 2, 3, 4, 5, 6)</td><td>(((1, 2), (3, 4)), (5, 6))</td></tr></tbody></table><p>&nbsp;</p><h4 id="Step3：把定义好的C函数注册为API"><a href="#Step3：把定义好的C函数注册为API" class="headerlink" title="Step3：把定义好的C函数注册为API"></a>Step3：把定义好的C函数注册为API</h4><p>&emsp;&emsp;注册API，需要用到一个<code>PyMethodDef</code>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_name;   <span class="comment">/* API被调用时的名称 */</span></span><br><span class="line">    PyCFunction ml_meth;    <span class="comment">/* 对应C函数的函数名 */</span></span><br><span class="line">    <span class="keyword">int</span>         ml_flags;   <span class="comment">/* 对应C函数传递的参数类型 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_doc;    <span class="comment">/* 函数说明 */</span></span><br><span class="line">&#125;PyMethodDef;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在C程序中定义一个由<code>PyMethodDef</code>类型成员组成的数组，每个成员对应一个定义好的C函数。这里需要注意第三个参数<code>ml_flags</code>，它代表C函数传参的规范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">METH_VARARGS：</span><br><span class="line">这是最常用的ml_flags值，代表该C函数需要两个 PyObject* 类型参数。第一个是此方法的 self 对象（对于模块函数，它是模块本身(class)，对于非模块函数，它是NULL）；第二个参数（通常称为 args）是一个表示所有参数的元组对象。此参数通常使用 PyArg_ParseTuple() 或 PyArg_UnpackTuple() 处理。</span><br><span class="line"></span><br><span class="line">METH_KEYWORDS：</span><br><span class="line">表示接受关键字参数。这种情况下C函数需要接受第三个 PyObject * 对象，表示字典参数，使用 PyArg_ParseTupleAndKeywords() 来解析出参数。</span><br><span class="line"></span><br><span class="line">METH_FASTCALL：</span><br><span class="line">仅支持位置参数的快速调用约定。第一个参数是 self，第二个参数是 PyObject* 值的 C 数组，指示参数，第三个参数是参数的数量（数组的长度）</span><br><span class="line"></span><br><span class="line">METH_NOARGS：</span><br><span class="line">表示第一个参数通常命名为 self 并将保存对模块或对象实例的引用。在所有情况下，第二个参数将为 NULL。</span><br><span class="line"></span><br><span class="line">更多类型详见：https://docs.python.org/3/c-api/structures.html#c.PyMethodDef</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func1</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">func2</span><span class="params">(PyObject* self, PyObject* args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyMethodDef my_methods[] </span>= &#123;</span><br><span class="line">    &#123; <span class="string">&quot;name1&quot;</span>, func1, METH_VARARGS, <span class="string">&quot;description of func1&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name2&quot;</span>, func2, METH_VARARGS, <span class="string">&quot;description of func2&quot;</span> &#125;</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step4：把注册好的API注册到模块中"><a href="#Step4：把注册好的API注册到模块中" class="headerlink" title="Step4：把注册好的API注册到模块中"></a>Step4：把注册好的API注册到模块中</h4><p>&emsp;&emsp;&emsp;与注册API类似，注册模块也用到一个结构体<code>PyModuleDef</code>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span>&#123;</span></span><br><span class="line">  PyModuleDef_Base m_base;<span class="comment">/* 通常都填为PyModuleDef_HEAD_INIT */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_name; <span class="comment">/* Python导入时用的模块名&lt;module_name&gt; */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_doc; <span class="comment">/* 对模块的说明，Python调用时通过__doc__查看 */</span></span><br><span class="line">  Py_ssize_t m_size;<span class="comment">/* 填 -1 */</span></span><br><span class="line">  PyMethodDef *m_methods;<span class="comment">/* 这里填上面注册API的PyMethodDef类型数组 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef_Slot</span>* <span class="title">m_slots</span>;</span></span><br><span class="line">  traverseproc m_traverse;</span><br><span class="line">  inquiry m_clear;</span><br><span class="line">  freefunc m_free;</span><br><span class="line">&#125;PyModuleDef;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;LrkModule&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lrk’s module&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="Step5：定义构造函数PyInit-lt-ModuleName-gt"><a href="#Step5：定义构造函数PyInit-lt-ModuleName-gt" class="headerlink" title="Step5：定义构造函数PyInit_&lt;ModuleName&gt;"></a>Step5：定义构造函数<code>PyInit_&lt;ModuleName&gt;</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;中后半部分必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_LrkModule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="方法一：直接编译"><a href="#方法一：直接编译" class="headerlink" title="方法一：直接编译"></a>方法一：直接编译</h4><p>注意链接<code>Python.h</code>所在的目录，并指定输出.so文件名称，后续调用此模块的python文件导入时用的就是这个名字：</p><p><code>gcc LrkModule.c -I /usr/include/python3.8 -shared -o LrkModule.so</code></p><h4 id="方法二：用编译脚本"><a href="#方法二：用编译脚本" class="headerlink" title="方法二：用编译脚本"></a>方法二：用编译脚本</h4><p>写一个编译此文件的Python脚本setup.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行<code>python setup.py install</code>编译生成build/目录并装载下面的.so文件</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><code>my_module.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">echo</span><span class="params">(PyObject* self, PyObject* args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* what;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> count;</span><br><span class="line">    PyArg_ParseTuple(args, <span class="string">&quot;si&quot;</span>, &amp;what, &amp;count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Python said: %s %d\n&quot;</span>, what, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> feedback = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;i&quot;</span>, feedback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PyMethodDef 是一个结构体</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef my_methods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;echo&quot;</span>, echo, METH_VARARGS, <span class="string">&quot;echo something&quot;</span> &#125;, </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">my_module</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;lrk&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    my_methods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 PyInit_&lt;module name&gt;后面必须是模块的名字！！！</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_lrk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;my_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">                    define_macros = [(<span class="string">&#x27;MAJOR_VERSION&#x27;</span>, <span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">                                     (<span class="string">&#x27;MINOR_VERSION&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)],</span><br><span class="line">                    sources = [<span class="string">&#x27;my_module.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;LrkModule&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       author = <span class="string">&#x27;lrk&#x27;</span>,</span><br><span class="line">       author_email = <span class="string">&#x27;1842604700@qq.com&#x27;</span>,</span><br><span class="line">       url = <span class="string">&#x27;https://docs.python.org/extending/building&#x27;</span>,</span><br><span class="line">       long_description = <span class="string">&#x27;&#x27;&#x27;This is really just a demo package.&#x27;&#x27;&#x27;</span>,</span><br><span class="line">       ext_modules = [module1]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lrk</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="built_in">print</span>(lrk.echo(<span class="string">&quot;hello\n&quot;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br><span class="line">python test.py</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p><strong>References</strong><br><a href="https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function">https://docs.python.org/3.7/extending/extending.html#the-module-s-method-table-and-initialization-function</a><br><a href="https://docs.python.org/3/c-api/index.html">https://docs.python.org/3/c-api/index.html</a><br><a href="https://www.python.org/dev/peps/pep-0007/">https://www.python.org/dev/peps/pep-0007/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】时序差分模型：SARSA &amp; Q-Learning</title>
      <link href="/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/"/>
      <url>/2021/12/29/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86%EF%BC%9ASarsa&amp;Q-Lreaning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;时序差分法是求解强化学习问题的重要方法，按照在线学习和离线学习可以分为两大类，其中最基础的两个代表算法就是 SARSA 和 Q-Learning</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229105335.png" alt="image-20211229105335429"></p><span id="more"></span><p>&nbsp;</p><h2 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h2><h3 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>&emsp;&emsp;Sarsa是一种使用时序差分法求解强化学习控制问题的经典方法，即给定强化学习的5个要素：状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ，求解最优的动作价值函数q∗和最优策略π∗。</p><p>&emsp;&emsp;作为一种时序差分法模型，Sarsa是不基于环境模型的Model-free算法，它对控制问题的求解和蒙特卡罗法类似，都是价值迭代，即通过价值函数的更新，来更新当前的策略，再通过新的策略，来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;时序差分法的控制问题可以分为两类：</p><ul><li><p>在线控制(on policy)：</p><p>​        一直使用同一个策略来更新价值函数和选择新的动作</p></li><li><p>离线控制(off policy)：</p><p>​        会使用两个不同的控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数</p></li></ul><p>​        Sarsa属于在线控制类，即一直使用一个策略来更新价值函数和选择新的动作，而这个策略就是ϵ−greedy法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084500.png" alt="image-20211229084500896" style="zoom: 50%;" /><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>&emsp;&emsp;Sarsa的名字其实包含了其算法执行流程，Sarsa = S(状态)+A(动作)+R(奖励)+S‘(新状态)+A’(新动作)</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084714.png" alt="image-20211229084714235" style="zoom:50%;" /><p><strong>迭代</strong></p><p>&emsp;&emsp;首先基于ϵ−greedy算法在当前状态<code>S</code>选择一个动作<code>A</code>，这样系统会转到一个新的状态<code>S′</code>，同时给一个即时奖励<code>R</code>，在新的状态<code>S′</code>下基于ϵ−greedy算法在状态<code>S‘</code> 选择一个动作<code>A′</code>，但是注意这时候并不执行这个动作<code>A′</code>，只是用来更新价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 67%;" /><p>&emsp;&emsp;其中，<code>γ</code>是衰减因子，<code>α</code>是迭代步长。这里和蒙特卡罗法求解在线控制问题的迭代公式的区别主要是，收获<code>Gt</code>的表达式不同，对于时序差分，收获<code>Gt</code>的表达式是<code>R+γQ(S′,A′)</code>。除了收获<code>Gt</code>的表达式不同，Sarsa算法和蒙特卡罗在线控制算法基本类似。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229090934.png" alt="image-20211229090934145"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A</p></li><li><p>执行动作A，由环境得到新状态S‘ 和奖励R</p></li><li><p>依据ϵ−greedy算法对状态S‘ 选出动作A’</p></li><li><p>对当前状态S和动作A，更新价值函数Q（S，A）：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229084907.png" alt="image-20211229084907741" style="zoom: 50%;" /></li><li><p>前进一步：S = S’，A = A‘</p></li><li><p>if  S’是终止状态，break；else 跳回步骤b</p></li></ol></li></ol><p>（注意：步长α一般需要随着迭代逐渐变小，这样才能保证动作价值函数Q可以收敛。当Q收敛时，策略ϵ−greedy算法也就收敛了）</p><p>&nbsp;</p><h4 id="示例一：Windy-GridWorld"><a href="#示例一：Windy-GridWorld" class="headerlink" title="示例一：Windy GridWorld"></a>示例一：Windy GridWorld</h4><p><strong>问题</strong></p><p><strong>问题</strong></p><p>&emsp;&emsp;一个10×7的长方形格子世界，标记有一个起始位置 S 和一个终止目标位置 G，格子下方的数字表示对应的列中一定强度的风。当个体进入该列的某个格子时，会按图中箭头所示的方向自动移动数字表示的格数，借此来模拟世界中风的作用。同样格子世界是有边界的，个体任意时刻只能处在世界内部的一个格子中。个体并不清楚这个世界的构造以及有风，也就是说它不知道格子是长方形的，也不知道边界在哪里，也不知道自己在里面移动移步后下一个格子与之前格子的相对位置关系，当然它也不清楚起始位置、终止目标的具体位置。但是个体会记住曾经经过的格子，下次在进入这个格子时，它能准确的辨认出这个格子曾经什么时候来过。格子可以执行的行为是朝上、下、左、右移动一步，每移动一步只要不是进入目标位置都给予一个 -1 的惩罚，直至进入目标位置后获得奖励 0 同时永久停留在该位置。现在要求解的问题是个体应该遵循怎样的策略才能尽快的从起始位置到达目标位置。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># world height</span></span><br><span class="line">WORLD_HEIGHT = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># world width</span></span><br><span class="line">WORLD_WIDTH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wind strength for each column</span></span><br><span class="line">WIND = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># possible actions</span></span><br><span class="line">ACTION_UP = <span class="number">0</span></span><br><span class="line">ACTION_DOWN = <span class="number">1</span></span><br><span class="line">ACTION_LEFT = <span class="number">2</span></span><br><span class="line">ACTION_RIGHT = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># probability for exploration</span></span><br><span class="line">EPSILON = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sarsa step size</span></span><br><span class="line">ALPHA = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reward for each step</span></span><br><span class="line">REWARD = -<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">START = [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">GOAL = [<span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">ACTIONS = [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">state, action</span>):</span></span><br><span class="line">    <span class="comment"># (i, j) is bird&#x27;s location, i++ while go down and j++ while go right</span></span><br><span class="line">    i, j = state</span><br><span class="line">    <span class="keyword">if</span> action == ACTION_UP:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - <span class="number">1</span> - WIND[j], <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_DOWN:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(<span class="built_in">min</span>(i + <span class="number">1</span> - WIND[j], WORLD_HEIGHT - <span class="number">1</span>), <span class="number">0</span>), j]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_LEFT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="keyword">elif</span> action == ACTION_RIGHT:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(i - WIND[j], <span class="number">0</span>), <span class="built_in">min</span>(j + <span class="number">1</span>, WORLD_WIDTH - <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># play for an episode</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">episode</span>(<span class="params">q_value</span>):</span></span><br><span class="line">    <span class="comment"># track the total time steps in this episode</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize state</span></span><br><span class="line">    state = START</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose an action based on epsilon-greedy algorithm</span></span><br><span class="line">    <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">        action = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_ = q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], :]</span><br><span class="line">        action = np.random.choice([action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">            values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># keep going until get to the goal state</span></span><br><span class="line">    <span class="keyword">while</span> state != GOAL:</span><br><span class="line">        next_state = step(state, action)</span><br><span class="line">        <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, EPSILON) == <span class="number">1</span>:</span><br><span class="line">            next_action = np.random.choice(ACTIONS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            values_ = q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], :]</span><br><span class="line">            next_action = np.random.choice(</span><br><span class="line">                [action_ <span class="keyword">for</span> action_, value_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(values_) <span class="keyword">if</span> value_ == np.<span class="built_in">max</span>(values_)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sarsa update</span></span><br><span class="line">        q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action] += \</span><br><span class="line">            ALPHA * (REWARD + q_value[next_state[<span class="number">0</span>], next_state[<span class="number">1</span>], next_action] -</span><br><span class="line">                     q_value[state[<span class="number">0</span>], state[<span class="number">1</span>], action])</span><br><span class="line">        state = next_state</span><br><span class="line">        action = next_action</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sarsa</span>():</span></span><br><span class="line">    q_value = np.zeros((WORLD_HEIGHT, WORLD_WIDTH, <span class="number">4</span>))</span><br><span class="line">    episode_limit = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    steps = []</span><br><span class="line">    ep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ep &lt; episode_limit:</span><br><span class="line">        steps.append(episode(q_value))</span><br><span class="line">        <span class="comment"># time = episode(q_value)</span></span><br><span class="line">        <span class="comment"># episodes.extend([ep] * time)</span></span><br><span class="line">        ep += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    steps = np.add.accumulate(steps)</span><br><span class="line"></span><br><span class="line">    plt.plot(steps, np.arange(<span class="number">1</span>, <span class="built_in">len</span>(steps) + <span class="number">1</span>))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Time steps&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Episodes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.savefig(<span class="string">&#x27;./sarsa.png&#x27;</span>)</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the optimal policy</span></span><br><span class="line">    optimal_policy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_HEIGHT):</span><br><span class="line">        optimal_policy.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, WORLD_WIDTH):</span><br><span class="line">            <span class="keyword">if</span> [i, j] == GOAL:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            bestAction = np.argmax(q_value[i, j, :])</span><br><span class="line">            <span class="keyword">if</span> bestAction == ACTION_UP:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_DOWN:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_LEFT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> bestAction == ACTION_RIGHT:</span><br><span class="line">                optimal_policy[-<span class="number">1</span>].append(<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Optimal policy is:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> optimal_policy:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wind strength for each column:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>([<span class="built_in">str</span>(w) <span class="keyword">for</span> w <span class="keyword">in</span> WIND]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sarsa()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229092057.png" alt="image-20211229092057649" style="zoom:67%;" /><h4 id="示例二：3×3迷宫"><a href="#示例二：3×3迷宫" class="headerlink" title="示例二：3×3迷宫"></a>示例二：3×3迷宫</h4><p><strong>代码</strong></p><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa/Sarsa_maze">github</a></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="Sarsa-λ-算法"><a href="#Sarsa-λ-算法" class="headerlink" title="Sarsa(λ)算法"></a>Sarsa(λ)算法</h3><blockquote><p><strong>关键词：</strong>时序差分、model-free、on-policy、ϵ-greedy、价值迭代</p></blockquote><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​        多步时序差分TD(λ)的价值函数迭代方法对应就是SARSA(λ)在线控制算法。TD(λ)有前向和后向这两种等价的价值函数迭代方式，在控制问题的求解时，基于反向认识的 SARSA(λ)算法将可以有效地在线学习，数据学习完即可丢弃。因此SARSA(λ)算法默认都是基于反向来进行价值函数迭代。</p><p><strong>状态价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p><strong>动作价值更新</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100235.png" alt="image-20211229100235740" style="zoom:50%;" /><p>&emsp;&emsp;除了状态价值函数<code>Q(S,A)</code>的更新方式，多步参数λ以及反向认识引入的效用迹<code>E(S,A)</code>，其余算法思想和SARSA类似。</p><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100839.png" alt="image-20211229100839670"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ、多步参数λ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li><p>初始化S为当前状态序列的第一个状态，依据ϵ−greedy算法对当前状态S 选出动作A，初始化所有状态动作的效用迹E为0</p></li><li><p>执行动作A，由环境得到新状态S‘ 和奖励R</p></li><li><p>依据ϵ−greedy算法对状态S‘ 选出动作A’</p></li><li><p>更新效用迹函数E(S, A) 和 误差 δ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101924.png" alt="image-20211229101924200" style="zoom:50%;" /></li><li><p>对当前序列中<strong>所有</strong>状态S和对应动作A，更新价值函数Q(S, A)和效用迹函数E(S, A) ：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229101944.png" alt="image-20211229101944186" style="zoom:50%;" /></li><li><p>前进一步：S = S’，A = A‘</p></li><li><p>if  S’是终止状态，break；else 跳回步骤b</p></li></ol></li></ol><p>（注意：对于步长α，和Sarsa一样，一般也需要随着迭代的进行逐渐变小才能保证动作价值函数Q收敛）</p><p>&nbsp;</p><h4 id="示例：3×3迷宫"><a href="#示例：3×3迷宫" class="headerlink" title="示例：3×3迷宫"></a>示例：3×3迷宫</h4><p><strong>代码</strong></p><p>&emsp;&emsp;<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Sarsa(lamda)/Sarsa_lamda_maze">github</a></p><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229094439.png" alt="image-20211229094438992" style="zoom:50%;" /><p>&nbsp;</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;SARSA算法和动态规划法比起来，不需要环境的状态转换模型，和蒙特卡罗法比起来，不需要完整的状态序列，因此比较灵活。在传统的强化学习方法中使用比较广泛。</p><p>&emsp;&emsp;但是SARSA算法也有一个传统强化学习方法共有的问题，就是无法求解太复杂的问题。在 SARSA 算法中，Q(S,A) 的值使用一张大表来存储的，如果状态和动作都达到百万乃至千万级，需要在内存里保存的这张大表会超级大，甚至溢出，因此不是很适合解决规模很大的问题。当然，对于不是特别复杂的问题，使用SARSA还是很不错的一种强化学习问题求解方法。</p><p>&nbsp;&nbsp;</p><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><blockquote><p>关键词：时序差分、model-free、off-policy、ϵ-greedy、价值迭代</p></blockquote><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>&emsp;&emsp;Q-Learning也是一种使用时序差分求解强化学习控制问题的方法，它通过价值函数的更新来更新策略，通过策略来产生新的状态和即时奖励，进而更新价值函数。一直进行下去，直到价值函数和策略都收敛。</p><p>&emsp;&emsp;它与Sarsa最大的区别在于Q-Learning是离线控制(off-policy)算法，会使用两个控制策略，一个策略用于选择新的动作，另一个策略用于更新价值函数。具体而言，Q-Learning会使用ϵ−greedy算法来选择新的动作，这部分和SARSA完全相同。但是对于价值函数的更新，Q-Learning使用的是greedy法，而不是SARSA的ϵ−greedy法。这一点就是SARSA和Q-Learning本质区别。</p><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>算法思想</strong></p><p>&emsp;&emsp;Q-Learning是强化学习算法中value-based的算法，Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取动作a (a∈A)能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward，所以算法的主要思想就是将State与Action构建成一张Q-Table来存储Q值，然后根据Q值来选取能够获得最大的收益的动作。</p><table><thead><tr><th>Q-Table</th><th>A1</th><th>A2</th><th>…</th></tr></thead><tbody><tr><td>s1</td><td>q(s1,a1)</td><td>q(s1,a2)</td><td>…</td></tr><tr><td>s2</td><td>q(s2,a1)</td><td>q(s2,a2)</td><td>…</td></tr><tr><td>s3</td><td>q(s3,a1)</td><td>q(s3,a2)</td><td>…</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p><strong>算法拓扑图</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103423.png" alt="image-20211229103423423" style="zoom: 33%;" /><p>&emsp;&emsp;首先基于状态S，用ϵ−greedy策略选择到动作<code>A</code>，然后执行动作<code>A</code>，得到奖励<code>R</code>，并进入状态<code>S′</code>，此时如果是Sarsa，会继续基于状态<code>S′</code>，用ϵ−greedy策略选择<code>A′</code>，然后来更新价值函数。但是Q-Learning则不同。对于Q-Learning，它基于状态<code>S′</code>，没有使用ϵ−greedy策略而是使用贪婪策略选择<code>A′</code>，也就是说，选择使Q(S′,a)最大的<code>a</code>作为<code>A′</code>来更新价值函数而不存在探索的可能：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229103904.png" alt="image-20211229103904453" style="zoom:50%;" /><p>&emsp;&emsp;对应拓扑图中最下面三个黑球中选择一个使<code>Q(S&#39;,a)</code>最大的动作<code>A&#39;</code>，此时选择的动作只会参与价值函数的更新，不会真正的执行。价值函数更新后，新的执行动作需要基于状态<code>S′</code>，用ϵ−greedy法重新选择得到。这一点也和SARSA稍有不同。对于SARSA，价值函数更新使用的<code>A′</code>会作为下一阶段开始时候的执行动作。</p><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229091010.png" alt="image-20211229091010771"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代轮数T、状态集S、动作集A、步长α、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的状态和动作对应的价值Q</span><br></pre></td></tr></table></figure><p>流程：</p><ol><li><p>随机初始化所有的状态和动作对应的价值Q，终止状态的Q初始化为0</p></li><li><p>for i in [ 1, T ]：</p><ol><li>初始化S为当前序列的第一个状态</li><li>用ε-greedy策略在当前状态S选择出动作A</li><li>执行动作A，由环境得到新状态S’ 和奖励R</li><li>按公式更新价值函数</li><li>前进一步：S = S’</li><li>if  S’是终止状态，break；else 跳回步骤b</li></ol></li></ol><h3 id="示例：直线寻宝"><a href="#示例：直线寻宝" class="headerlink" title="示例：直线寻宝"></a>示例：直线寻宝</h3><p><strong>问题</strong></p><p>&emsp;&emsp;宝藏在长度为6的直线的另一端，训练一个不知环境的小车以最短步数到达宝藏处。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)  <span class="comment"># reproducible</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N_STATES = <span class="number">6</span>   <span class="comment"># the length of the 1 dimensional world</span></span><br><span class="line">ACTIONS = [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>]     <span class="comment"># available actions</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>   <span class="comment"># greedy police</span></span><br><span class="line">ALPHA = <span class="number">0.1</span>     <span class="comment"># learning rate</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>    <span class="comment"># discount factor</span></span><br><span class="line">MAX_EPISODES = <span class="number">10</span>   <span class="comment"># maximum episodes</span></span><br><span class="line">FRESH_TIME = <span class="number">0.08</span>    <span class="comment"># fresh time for one move</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span>(<span class="params">n_states, actions</span>):</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, <span class="built_in">len</span>(actions))),     <span class="comment"># q_table initial values</span></span><br><span class="line">        columns=actions,    <span class="comment"># actions&#x27;s name</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># print(table)    # show table</span></span><br><span class="line">    <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">state, q_table</span>):</span></span><br><span class="line">    <span class="comment"># This is how to choose an action</span></span><br><span class="line">    state_actions = q_table.iloc[state, :]</span><br><span class="line">    <span class="comment"># act non-greedy or state-action have no value</span></span><br><span class="line">    <span class="keyword">if</span> (np.random.uniform() &gt; EPSILON) <span class="keyword">or</span> ((state_actions == <span class="number">0</span>).<span class="built_in">all</span>()):</span><br><span class="line">        action_name = np.random.choice(ACTIONS)</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># act greedy</span></span><br><span class="line">        <span class="comment"># replace argmax to idxmax as argmax means a different function in newer version of pandas</span></span><br><span class="line">        action_name = state_actions.idxmax()</span><br><span class="line">    <span class="keyword">return</span> action_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_env_feedback</span>(<span class="params">S, A</span>):</span></span><br><span class="line">    <span class="comment"># This is how agent will interact with the environment</span></span><br><span class="line">    <span class="keyword">if</span> A == <span class="string">&#x27;right&#x27;</span>:    <span class="comment"># move right</span></span><br><span class="line">        <span class="keyword">if</span> S == N_STATES - <span class="number">2</span>:   <span class="comment"># terminate</span></span><br><span class="line">            S_ = <span class="string">&#x27;terminal&#x27;</span></span><br><span class="line">            R = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S + <span class="number">1</span></span><br><span class="line">            R = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># move left</span></span><br><span class="line">        R = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">            S_ = S  <span class="comment"># reach the wall</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_ = S - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> S_, R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span>(<span class="params">S, episode, step_counter</span>):</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">&#x27;-&#x27;</span>]*(N_STATES-<span class="number">1</span>) + [<span class="string">&#x27;T&#x27;</span>]   <span class="comment"># &#x27;---------T&#x27; our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">        interaction = <span class="string">&#x27;Episode %s: total_steps = %s&#x27;</span> % (</span><br><span class="line">            episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r                                &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">&#x27;o&#x27;</span></span><br><span class="line">        interaction = <span class="string">&#x27;&#x27;</span>.join(env_list)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(interaction), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rl</span>():</span></span><br><span class="line">    <span class="comment"># main part of RL loop</span></span><br><span class="line">    q_table = build_q_table(N_STATES, ACTIONS)</span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(MAX_EPISODES):</span><br><span class="line">        step_counter = <span class="number">0</span></span><br><span class="line">        S = <span class="number">0</span></span><br><span class="line">        is_terminated = <span class="literal">False</span></span><br><span class="line">        update_env(S, episode, step_counter)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_terminated:</span><br><span class="line"></span><br><span class="line">            A = choose_action(S, q_table)</span><br><span class="line">            <span class="comment"># take action &amp; get next state and reward</span></span><br><span class="line">            S_, R = get_env_feedback(S, A)</span><br><span class="line">            q_predict = q_table.loc[S, A]</span><br><span class="line">            <span class="keyword">if</span> S_ != <span class="string">&#x27;terminal&#x27;</span>:</span><br><span class="line">                <span class="comment"># next state is not terminal</span></span><br><span class="line">                q_target = R + GAMMA * q_table.iloc[S_, :].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q_target = R     <span class="comment"># next state is terminal</span></span><br><span class="line">                is_terminated = <span class="literal">True</span>    <span class="comment"># terminate this episode</span></span><br><span class="line"></span><br><span class="line">            q_table.loc[S, A] += ALPHA * (q_target - q_predict)  <span class="comment"># update</span></span><br><span class="line">            S = S_  <span class="comment"># move to next state</span></span><br><span class="line"></span><br><span class="line">            update_env(S, episode, step_counter+<span class="number">1</span>)</span><br><span class="line">            step_counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> q_table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q_table = rl()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nQ-table:\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(q_table)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229104502.png" alt="image-20211229104502770" style="zoom: 67%;" /><p>其他示例见<a href="https://github.com/Sharp-rookie/RL-learning/tree/main/Q-Learning">github</a></p><h3 id="Q-Learning-vs-Sarsa"><a href="#Q-Learning-vs-Sarsa" class="headerlink" title="Q-Learning  vs  Sarsa"></a>Q-Learning  vs  Sarsa</h3><p>&emsp;&emsp;Q-Learning直接学习的是最优策略，而Sarsa在学习最优策略的同时还在做探索。这导致在学习最优策略的时候，如果用Sarsa，为了保证收敛，需要制定一个策略，使ϵ−greedy策略的超参数ϵ在迭代的过程中逐渐变小。Q-Learning没有这个烦恼。</p><p>&emsp;&emsp;另外一个就是Q-Learning直接学习最优策略，但是最优策略会依赖于训练中产生的一系列数据，所以受样本数据的影响较大，因此受到训练数据方差的影响很大，甚至会影响Q函数的收敛。Q-Learning的深度强化学习版Deep Q-Learning也有这个问题。</p><p>&emsp;&emsp;在学习过程中，Sarsa在收敛的过程中鼓励探索，这样学习过程会比较平滑，不至于过于激进，导致出现像Q-Learning可能遇到一些特殊的最优“陷阱”。比如经典的强化学习问题”Cliff Walk”。</p><p>&emsp;&emsp;在实际应用中，如果是在模拟环境中训练强化学习模型，推荐使用Q-Learning，如果是在线生产环境中训练模型，则推荐使用SARSA。</p><h3 id="Double-Q-Learning"><a href="#Double-Q-Learning" class="headerlink" title="Double Q-Learning"></a>Double Q-Learning</h3><p>&emsp;&emsp;为了规避Q-Learning中贪婪策略带来的过估计问题，DeepMind团队在2015年发表的论文 <a href="https://lrk612.com/resources/Deep%20Reinforcement%20Learning%20with%20Double%20Q-learning.pdf">Deep Reinforcement Learning with Double Q-learning</a> 中提出双评估器的思想，其关键在于将 <code>目标Q值动作的选择</code> 和 <code>目标Q值的估计</code> 这两步进行解耦，从而规避过估计的弊端。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209120640.png" alt="image-20220209120640642"></p><p>其中，和Q-Learning的主要区别有两点：</p><ul><li><p>采用双估计器，每个epoch开头依概率选择一个作为Q估计器，另一个用于计算目标Q值</p></li><li><p>更新Q估计器的Q表时，公式变为：</p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220209121130.png" alt="image-20220209121130121" style="zoom:60%;" /><p>  意味着Q值不再是用Q估计器直接给出，而是先用Q估计器结合贪婪策略选出动作，然后由另二个估计器给出该动作的Q值</p></li></ul><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyper Parameters</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span>                   <span class="comment"># learning rate</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>               <span class="comment"># greedy policy</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>                 <span class="comment"># reward discount</span></span><br><span class="line">TARGET_REPLACE_ITER = <span class="number">100</span>   <span class="comment"># target update frequency</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">320</span></span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)</span><br><span class="line">env = env.unwrapped</span><br><span class="line">N_ACTIONS = env.action_space.n</span><br><span class="line">N_STATES = env.observation_space.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, </span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># class torch.nn.Linear(in_features, out_features, bias=True)</span></span><br><span class="line">        self.fc1 = nn.Linear(N_STATES, <span class="number">10</span>)</span><br><span class="line">        self.fc1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)   <span class="comment"># initialization</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">10</span>, N_ACTIONS)</span><br><span class="line">        self.out.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)   <span class="comment"># initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        actions_value = self.out(x)</span><br><span class="line">        <span class="keyword">return</span> actions_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.eval_net, self.target_net = Net(), Net()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># for target updating</span></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span></span><br><span class="line">        <span class="comment"># for storing memory</span></span><br><span class="line">        self.memory_counter = <span class="number">0</span></span><br><span class="line">        <span class="comment"># initialize memory</span></span><br><span class="line">        self.memory = np.zeros((MEMORY_CAPACITY, N_STATES * <span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = Variable(torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>))</span><br><span class="line">        <span class="comment"># input only one sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:   <span class="comment"># greedy</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()[</span><br><span class="line">                <span class="number">0</span>]     <span class="comment"># return the argmax</span></span><br><span class="line">            <span class="comment"># torch.max(input, dim, keepdim=False, out=None) -&gt; (Tensor, LongTensor)</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># random</span></span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, N_ACTIONS)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span>(<span class="params">self, s, a, r, s_</span>):</span></span><br><span class="line">        <span class="comment"># set s,a,r,s_ the arrary of 1*N</span></span><br><span class="line">        transition = np.hstack((s, [a, r], s_))</span><br><span class="line">        <span class="comment"># another type of the hstack , the result is the same</span></span><br><span class="line">        another_result = np.hstack((s, a, r, s_))</span><br><span class="line">        <span class="comment"># use % can loop from 0 to 2000</span></span><br><span class="line">        index = self.memory_counter % MEMORY_CAPACITY</span><br><span class="line">        <span class="comment"># save the info_this_step into memory</span></span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.memory_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># target parameter update</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_REPLACE_ITER == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># by random , choose the row&#x27;s number from memory_capacity , total row&#x27;s number is batch_size(32)</span></span><br><span class="line">        sample_index = np.random.choice(MEMORY_CAPACITY, BATCH_SIZE)</span><br><span class="line">        b_memory = self.memory[sample_index, :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># in the memory, the 1st---4th column is state_now , the 5th is action , the 6th is reward</span></span><br><span class="line">        <span class="comment"># the final 4 column is state_next</span></span><br><span class="line">        b_s = Variable(torch.FloatTensor(b_memory[:, :N_STATES]))</span><br><span class="line">        b_a = Variable(torch.LongTensor(</span><br><span class="line">            b_memory[:, N_STATES:N_STATES+<span class="number">1</span>].astype(<span class="built_in">int</span>)))</span><br><span class="line">        b_r = Variable(torch.FloatTensor(b_memory[:, N_STATES+<span class="number">1</span>:N_STATES+<span class="number">2</span>]))</span><br><span class="line">        b_s_ = Variable(torch.FloatTensor(b_memory[:, -N_STATES:]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># q_eval w.r.t the action in experience</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>, b_a)  <span class="comment"># shape (batch, 1)</span></span><br><span class="line"></span><br><span class="line">        q_eval_test = self.eval_net(b_s)</span><br><span class="line">        <span class="comment"># argmax axis = 0 means column , 1 means row</span></span><br><span class="line">        <span class="comment"># we choose the max acion value , the action is column , so axis = 1</span></span><br><span class="line">        Q1_argmax = np.argmax(q_eval_test.data.numpy(), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># q_next = self.target_net(b_s_).detach()     # detach from graph, don&#x27;t backpropagate</span></span><br><span class="line">        q_next = self.target_net(b_s_)</span><br><span class="line"></span><br><span class="line">        q_next_numpy = q_next.data.numpy()</span><br><span class="line"></span><br><span class="line">        q_update = np.zeros((BATCH_SIZE, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> iii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            q_update[iii] = q_next_numpy[iii, Q1_argmax[iii]]</span><br><span class="line"></span><br><span class="line">        q_update = GAMMA * q_update</span><br><span class="line">        q_update = torch.FloatTensor(q_update)</span><br><span class="line"></span><br><span class="line">        variable11 = Variable(q_update)</span><br><span class="line">        q_target = b_r + variable11</span><br><span class="line">        <span class="comment"># q_target = b_r + GAMMA * q_next.max(1)[0]   # shape (batch, 1)</span></span><br><span class="line">        loss = self.loss_func(q_eval, q_target)</span><br><span class="line"></span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dqn = DQN()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nCollecting experience...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i_episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):</span><br><span class="line">    observation = env.reset()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># render environment</span></span><br><span class="line">        env.render()</span><br><span class="line">        <span class="comment"># choose action</span></span><br><span class="line">        action = dqn.choose_action(observation)</span><br><span class="line">        <span class="comment"># take action</span></span><br><span class="line">        obeservation_, reward, done, info = env.step(action)</span><br><span class="line">        <span class="comment"># store data</span></span><br><span class="line">        dqn.store_transition(observation, action, reward, obeservation_)</span><br><span class="line">        <span class="comment"># data is enough then do the RL</span></span><br><span class="line">        <span class="keyword">if</span> dqn.memory_counter &gt; MEMORY_CAPACITY:</span><br><span class="line">            dqn.learn()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># state update</span></span><br><span class="line">        observation = obeservation_</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;对于Q-Learning和Sarsa这样的时序差分算法，对于小型的强化学习问题是非常灵活有效的，但是在大数据时代，异常复杂的状态和可选动作，使Q-Learning和Sarsa要维护的Q表异常的大，甚至远远超出内存，这限制了时序差分算法的应用场景。在深度学习兴起后，基于深度学习的强化学习开始占主导地位。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习】强化学习基础模型及求解</title>
      <link href="/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/12/28/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;强化学习 (Reinforcement Learning) 是一个机器学习大家族中的分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用。比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事。强化学习让程序从对当前环境完全陌生, 成长为一个在环境中游刃有余的高手。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150606.png" alt="image-20220126150606364" style="zoom: 67%;" /><span id="more"></span><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="在机器学习中的位置"><a href="#在机器学习中的位置" class="headerlink" title="在机器学习中的位置"></a>在机器学习中的位置</h3><p>&emsp;&emsp;强化学习是和监督学习，非监督学习并列的第三种机器学习方法，是机器学习中的一个独立领域。与后两者相同，强化学习有自己一套比较完整的数据处理、建模、训练、调优的套路，成为了一种方法论或模型体系。</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>&emsp;&emsp;监督学习是比较传统的一个机器学习领域，简而言之是给定（输入，输出）对，反向推导从输入到输出这个映射中的参数值或组合，即给定映射形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150457.png" alt="image-20220126110940334" style="zoom: 67%;" /><p>然后根据已有数据集(x, y)键值对推导参数 <code>θ</code> ，这个过程称为训练。</p><h4 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h4><p>&emsp;&emsp;非监督学习也是比较传统的一个机器学习领域，比较常见的是聚类模型，例如：K-Means算法，只给定输入 x，输出并没有给定目标值。</p><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>&emsp;&emsp;强化学习和监督学习最大的区别是它没有监督学习已经准备好的训练数据输出值。强化学习只有奖励值，但是这个奖励值和监督学习的输出值不一样，它不是事先给出的，而是延后给出的。同时，强化学习的每一步与时间顺序前后关系紧密。而监督学习的训练数据之间一般都是独立的，没有这种前后的依赖关系。</p><p>&emsp;&emsp;强化学习和非监督学习的区别。也还是在奖励值这个地方。非监督学习是没有输出值也没有奖励值的，它只有数据特征。同时和监督学习一样，数据之间也都是独立的，没有强化学习这样的前后依赖关系。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229085342.png" alt="image-20211229085342314" style="zoom:50%;" /><p>&nbsp;</p><h3 id="强化学习建模"><a href="#强化学习建模" class="headerlink" title="强化学习建模"></a>强化学习建模</h3><h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>Agent / Brain</td><td>强化学习中做决策的智能体(机器人)</td></tr><tr><td>Environment</td><td>被学习的环境或对象，一般对Agent是未知的“黑盒子”</td></tr><tr><td>State 、 Observation</td><td>Agent对Environment的感知，是做出决策的信息来源</td></tr><tr><td>Action</td><td>Agent基于感知信息和决策算法，对决定在当下对Environment执行的动作</td></tr><tr><td>Reward</td><td>Environment对Agent执行Action的反馈</td></tr></tbody></table><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227234235.png" alt="image-20211227234234718" style="zoom: 33%;" /><p>&emsp;&emsp;由上，强化学习模型其实就是智能体<code>Agent</code>观测环境<code>Environment</code>后得到环境当前所处的状态信息<code>State</code>，然后基于自身决策算法决定对环境执行一个动作<code>Action</code>，这个动作使环境的状态发生了变化，并由此反馈给智能体一个信息<code>Reward</code>，以告知其动作的好坏，智能体基于反馈优化自己做决策的算法。不断重复这个过程，从而让智能体形成能够带来最大价值的决策算法。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>&emsp;&emsp;注意这里说的模型与强化学习本身数学模型并不是同一个概念，这里的模型是指环境Environment，通常用两个式子就可以描述一个模型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126113400.png" alt="image-20220126113400549" style="zoom:67%;" /><p>&emsp;&emsp;第一个公式表示<code>t</code>时刻状态为<code>s</code>，执行动作<code>a</code>后转换为状态<code>s’</code>的概率；第二个公式表示<code>t</code>时刻状态为<code>s</code>，执行动作<code>a</code>的奖励的期望值（因为可能转换到不同的状态）。如果知道这两个环境的这两个公式，那么这个环境对于智能体来说就不是“黑盒子”，因为它的一切输入、输出及奖励都可以直接数学推导得出，而不再需要通过试错的方式来观察。因此，最佳策略算法的问题转化为最优化问题，不止或者不再需要用强化学习来求解，使用其他机器学习算法都可以解决。</p><h5 id="Model-Based"><a href="#Model-Based" class="headerlink" title="Model-Based"></a>Model-Based</h5><p>&emsp;&emsp;顾名思义，Model-Based的强化学习算法就是必须已知环境的上述两个信息才能求解。但这时完全可以用其他更优的算法代替强化学习了。</p><h5 id="Model-Free"><a href="#Model-Free" class="headerlink" title="Model-Free"></a>Model-Free</h5><p>&emsp;&emsp;Model-Free的强化学习算法不需要已知环境模型就可以求解，而这也是实际工程中最常用的，是强化学习的价值所在。</p><p>&nbsp;</p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>&emsp;&emsp;强化学习模型求解过程本质就是智能体在不断与环境交互，产生序列：<code>S0,A0,R1,S1,A1,R2,...</code>，并在这个过程中推导出最优的决策算法，从而实现价值最大化。</p><h4 id="直接法（基于策略）"><a href="#直接法（基于策略）" class="headerlink" title="直接法（基于策略）"></a>直接法（基于策略）</h4><p>&emsp;&emsp;直接法的前提是策略形式为： <code>a=π(s|θ)</code> ，即由参数 <code>θ</code> 描述策略，优化策略就是优化参数 <code>θ</code>。那么既然是要优化，就一定有优化的目标或评价函数，在这里是所有状态State下动作Action的奖励期望值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150458.png" alt="image-20220126115026053" style="zoom:70%;" /><p>&emsp;&emsp;但实际上，大多策略都不是仅靠参数<code>θ</code>就能描述的，因此强化学习的优化用的主要是下面的间接法。</p><h4 id="间接法（基于价值）"><a href="#间接法（基于价值）" class="headerlink" title="间接法（基于价值）"></a>间接法（基于价值）</h4><p>&emsp;&emsp;间接法的思想就是，计算出各个状态在策略<code>π</code>下的价值，然后决策时选择能够达到最大价值的下一状态的动作，这就是最优策略。其中，状态价值公式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085646.png" alt="image-20211228085646607" style="zoom: 50%;" /><center>γ是折扣因子，反映价值的远见性</center><p>&emsp;&emsp;可见，优化策略的问题转化为了如何根据公式计算每个状态价值的问题。事实上，后面的三种经典求解强化学习的算法思想也都是在间接法求最优策略，使用不同的方法计算状态价值。</p><h4 id="On-Line-和-Off-Line-学习"><a href="#On-Line-和-Off-Line-学习" class="headerlink" title="On-Line 和 Off-Line 学习"></a>On-Line 和 Off-Line 学习</h4><p>&emsp;&emsp;强化学习的有两种学习方式，在线学习是指Agent一边与环境交互收集样本，一遍更新策略；离线学习是指Agent事先像监督学习一样得到完整的训练，然后用最终策略与环境交互。虽然离线学习在现成数据集下可以快速训练得到较好的策略，不需要像在线学习那样一个动作得到一次反馈，然后花时间更新策略，训练地较慢。但是在现实场景中，并没有机会存储足够多的样本供离线学习训练，绝大多数基于时间差分法的强化学习训练都倾向于在线学习。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="动态规划DP（Model-Based）"><a href="#动态规划DP（Model-Based）" class="headerlink" title="动态规划DP（Model-Based）"></a>动态规划DP（Model-Based）</h2><p>&emsp;&emsp;动态规划是一门相对独立的学科，是运筹学的一个分支。运筹学本身的学科体系就比较复杂且不断壮大，包括：线性规划、非线性规划、组合规划、图论、决策分析、排队论、博弈论、搜索论等，动态规划关注如何用数学方法求解一个决策过程的最优化问题。将问题的最优解分解为若干小问题的最优解，即通过寻找子问题的最优解之间的递推关系来得到问题的最优解。而动态规划求解强化学习的算法是建立在马尔可夫决策过程基础上的。</p><p>&nbsp;</p><h3 id="马尔可夫决策过程MDP"><a href="#马尔可夫决策过程MDP" class="headerlink" title="马尔可夫决策过程MDP"></a>马尔可夫决策过程MDP</h3><p>&emsp;&emsp;在强化学习中，agent与environment一直在互动。在每个时刻t，agent会接收到来自环境的状态s，基于这个状态s，agent会做出动作a，然后这个动作作用在环境上，于是agent可以接收到一个奖赏Rt+1，并且agent就会到达新的状态。所以，其实agent与environment之间的交互就是产生了一个序列：<code>S0,A0,R1,S1,A1,R2,...</code></p><p>&emsp;&emsp;称这个为序列决策过程。而马尔科夫决策过程（Morkov Decision Process）就是一个典型的序列决策过程的一种公式化。有了马尔科夫的假设，才能推导出状态价值的贝尔曼方程式，从而用递推的方式计算状态价值。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&emsp;&emsp;下一个状态的产生只和当前的状态有关，即：<code>P(St+1 | St) = P(St+1 | S1,...,St)</code></p><p>&emsp;&emsp;直观上讲，下一个状态的产生跟所有历史状态是有关的，也就是等式右边所示。但是Markov的定义则是忽略掉历史信息，只保留了当前状态的信息来预测下一个状态，这称为无后效性/马尔可夫性。一个 MDP 可以由一个 5 元组表示为 <code>M = &lt;S,A,P(s&#39;|s,a),R,γ&gt;</code>：</p><blockquote><p><strong>S</strong> → 一个状态（state）的集合<br><strong>P</strong> → 一个受行为影响的状态转移概率矩阵<br><strong>A</strong> →一个有限动作集<br><strong>R</strong> →  一个用于计算回报的函数<br><strong>γ</strong> → 一个折扣因子，用于做未来回报计算时的衰减系数，γ ∈ ( 0 , 1 )</p></blockquote><p>&nbsp;</p><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><p><strong>状态转移概率Pss′a</strong></p><p>对于一个具体的状态s和它的下一个状态s’，它们的状态转移概率(就是从s转移到s’的概率)定义为：</p><p>&emsp;&emsp;<code>Pss′a = P(St+1=s′|St=s,At=a)</code></p><p>也就是说，下一个状态的产生只受到当前状态和动作的影响。</p><p><strong>策略π</strong></p><p>&emsp;&emsp;<code>Policy： π(a|s) = P(At=a|St=s)</code></p><p>policy π表示的是在给定的state下，一个关于action的概率分布。即表示在一个状态s下，agent接下来可能会采取的任意一个action的概率分布（可能一开始不知道概率是多少）。对于每一个状态s都会有这样一个π(a|s)，所有状态的π(a|s）就形成整体策略π。策略π是指所有状态都要使用这个策略，不是单独指某一个状态。</p><p>无论怎样，我们的目标是最大化累积奖赏，所以我们可以通过不断地改进我们的策略，使得我们最后能够获得最大累积奖赏。</p><p><strong>状态价值函数Vπ</strong></p><p>定义式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085646.png" alt="image-20211228085646607" style="zoom: 50%;" /><p>递推形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /><p>计算机通常使用递推式迭代地求出MDP中每个状态的价值函数，而不是用定义式硬算。</p><p><strong>动作价值函数<em>Qπ</em></strong></p><p>定义式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085745.png" alt="image-20211228085745128" style="zoom:50%;" /><p>​                                                                              <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085806.png" alt="image-20211228085806768" style="zoom:50%;" /></p><p>递推形式：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>计算机通常使用递推式迭代地求出MDP中每个状态的价值函数，而不是用定义式硬算。</p><p><strong>状态价值与动作价值的递推关系</strong></p><p>状态价值函数是所有动作价值函数基于策略π的期望：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085947.png" style="zoom:50%;" /><p>利用上递推式，也很容易从状态价值函数vπ(s)表示动作价值函数qπ(s,a)，即：</p><p>​                                                                    <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090008.png" style="zoom:50%;" /></p><p>二者转化关系如图：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090154.png" alt="image-20211228090154012" style="zoom: 33%;" /><p>&emsp;&emsp;总而言之，状态 / 动作价值有两部分相加组成，第一部分是即时奖励，第二部分是环境所有可能出现的下一个状态的概率乘以该下一状态的状态价值，最后求和，并加上衰减。两式联立得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090245.png" alt="image-20211228090244956" style="zoom:50%;" /><center>这两个表达式又称为贝尔曼方程</center><p>&nbsp;</p><h4 id="最优价值函数"><a href="#最优价值函数" class="headerlink" title="最优价值函数"></a>最优价值函数</h4><p>&emsp;&emsp;根据间接法的思想，解决强化学习问题意味着要寻找一个最优的策略让个体在与环境交互过程中获得始终比其它策略都要多的收获，这个最优策略可以用 π∗表示。一旦找到这个最优策略π∗，那么就解决了这个强化学习问题。而策略的优劣可由价值函数反映，因此最优策略问题转化为最优价值函数问题。</p><ol><li><p><strong>最优状态价值函数</strong>是所有策略下产生的众多状态价值函数中的最大者：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090541.png" alt="image-20211228090541867" style="zoom:50%;" /></li><li><p><strong>最优动作价值函数</strong>是所有策略下产生的众多动作状态价值函数中的最大者：</p> <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228090616.png" alt="image-20211228090616747" style="zoom: 50%;" /></li></ol><p><strong>转化关系：</strong></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228091126.png" alt="image-20211228091126423" style="zoom: 50%;" /><p>&nbsp;</p><h3 id="策略迭代-求解强化学习"><a href="#策略迭代-求解强化学习" class="headerlink" title="策略迭代 求解强化学习"></a>策略迭代 求解强化学习</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140030.png" alt="image-20211228140030255"></p><p>&emsp;&emsp;根据之前基于任意一个给定策略<code>π</code>与环境进行交互，然后用贝尔曼方程计算状态价值，然后根据状态价值调整动作策略<code>π</code>，这个方法叫做策略迭代(Policy Iteration)。最简单的调整方法就是贪婪法：个体在某个状态下选择的行为是其能够到达后续所有可能的状态中状态价值最大的那个状态。</p><p><strong>流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用当前策略π∗与环境交互，用贝尔曼方程计算当前策略π*对应的状态价值v∗</span><br><span class="line">2. 根据刚刚计算的状态价值v∗以一定的方法（比如贪婪法）更新策略π∗</span><br><span class="line">3. 重复第1、2步，一直迭代下去，直到策略π∗和状态价值v∗收敛为止</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="价值迭代-求解强化学习"><a href="#价值迭代-求解强化学习" class="headerlink" title="价值迭代 求解强化学习"></a>价值迭代 求解强化学习</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228140047.png" alt="image-20211228140046899"></p><p>&emsp;&emsp;相比策略迭代，价值迭代不需要等到状态价值收敛才调整策略，而是随着状态价值的迭代及时调整策略, 这样可以大大减少迭代次数。此时的状态价值的更新方法也和策略迭代不同，此时贝尔曼方程迭代式如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228092413.png" alt="image-20211228092413197" style="zoom: 25%;" /><p>&emsp;&emsp;可见由于策略调整，现在价值每次更新倾向于贪婪法选择的最优策略对应的后续状态价值，这样收敛更快。</p><p><strong>流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用当前策略π∗与环境交互，用贝尔曼方程计算当前策略π*对应的状态价值v∗</span><br><span class="line">2. 根据刚刚计算的状态价值v∗以上述公式更新策略v∗</span><br><span class="line">3. 重复第1、2步，一直迭代下去，直到状态价值v∗收敛为止</span><br><span class="line">4. 根据收敛的v*，以贪婪思想更新得到最优策略π∗</span><br></pre></td></tr></table></figure><p>对比策略迭代可知，价值迭代中，策略π始终不变，更新的只有价值v*，等到v*收敛后才更新策略π，一步到位；</p><p>而策略迭代中，更新的主体的策略π，每轮更新后计算新的价值v*，然后继续更新π，直到策略π收敛。</p><p>&nbsp;</p><h3 id="异步动态规划"><a href="#异步动态规划" class="headerlink" title="异步动态规划"></a>异步动态规划</h3><p>&emsp;&emsp;上面几个都是<strong>同步动态规划算法</strong>，即每轮迭代会计算出所有的状态价值并保存起来，在下一轮中使用这些保存起来的状态价值来计算新一轮的状态价值。另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。</p><p><strong>原位动态规划 (in-place DP)</strong></p><p>&emsp;&emsp;此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。</p><p><strong>优先级动态规划 (prioritized sweeping DP)</strong></p><p>&emsp;&emsp;该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。</p><p><strong>实时动态规划 (real-time DP)</strong></p><p>&emsp;&emsp;实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。</p><p>&nbsp;</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;动态规划算法主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此还需要寻找其他的针对复杂问题的强化学习问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="蒙特卡罗法MC（Model-free）"><a href="#蒙特卡罗法MC（Model-free）" class="headerlink" title="蒙特卡罗法MC（Model-free）"></a>蒙特卡罗法MC（Model-free）</h2><p>&emsp;&emsp;蒙特卡罗法又叫做统计模拟方法，是一种以概率统计理论为指导的数值计算方法。其核心思想是：多次实验逼近客观分布真实值。</p><p>&nbsp;</p><h3 id="不基于模型的强化学习问题"><a href="#不基于模型的强化学习问题" class="headerlink" title="不基于模型的强化学习问题"></a>不基于模型的强化学习问题</h3><p>&emsp;&emsp;在上面动态规划法中，模型状态转化概率矩阵P始终是已知的，即MDP已知，一般称这样的强化学习问题为Model-based的强化学习问题。Model-based强化学习问题可以通过动态规划来评估一个给定的策略，通过不断迭代最终得到最优价值函数，具体的做法有两个：一个是策略迭代，一个是值迭代。</p><p>&emsp;&emsp;然而有很多强化学习问题没有办法事先得到模型状态转化概率Pss’a，即不基于模型的<strong>Model-free</strong>强化学习（面向黑盒子学习），为了能够从环境中学习，需要让agent与environment交互，得到一些经历（样本）。然后通过这些经历来进行策略评估与策略迭代，从而最终得到最优策略。这种做法的理论是从蒙特卡罗方法（Monte-Carlo）中来的。</p><p>&nbsp;</p><h3 id="蒙特卡罗思想"><a href="#蒙特卡罗思想" class="headerlink" title="蒙特卡罗思想"></a>蒙特卡罗思想</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135735.png" alt="image-20211228135716095"></p><p>&emsp;&emsp;通过采样若干个<code>经历完整的状态序列(episode)</code>后求均值来估计状态的真实价值。所谓的经历完整，就是这个序列<strong>必须是达到终点</strong>的，这样才能拿到最终回报。比如下棋问题要分出输赢，驾车问题要成功到达终点或者失败。有了很多组这样经历完整的状态序列，不需要借助模型本身就可以近似的估计状态价值，进而求解预测和控制问题。</p><p>&emsp;&emsp;采样得到的完整序列示例：<code>S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</code></p><p>&emsp;&emsp;借助大数定律思想以统计的方式算出状态价值后，策略的优化基本和动态规划一样，用<strong>价值迭代</strong>。</p><p><strong>对比动态规划</strong></p><ul><li>关键区别是状态价值的计算方法不同</li><li>不依赖于模型状态转化概率</li><li>从经历过的完整序列学习，完整的经历越多，学习效果越好</li></ul><p><strong>首次访问与每次访问</strong></p><p>&emsp;&emsp;同样一个状态可能在一个完整的状态序列（episode）中重复出现，第一种应对方法是仅把状态序列中第一次出现该状态时的收获值纳入到收获平均值的计算中；另一种是针对一个状态序列中每次出现的该状态，都计算对应的收获值并纳入到收获平均值的计算中。两种方法对应的蒙特卡罗法分别称为：<strong>首次访问(first visit)</strong> 和<strong>每次访问(every visit)</strong> 蒙特卡罗法。第二种方法比第一种的计算量要大一些，但是在完整的经历样本序列少的场景下会比第一种方法适用。</p><p><strong>累进更新平均值（incremental mean)</strong></p><p>&emsp;&emsp;按照蒙特卡洛求平均值来代表状态价值的公式里，每个状态都需要维护一个计数器和累加器，分别保存其出现次数和价值之和用于最后求平均，这样浪费了太多的存储空间：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126150459.png" alt="image-20220126143115081" style="zoom: 67%;" /><p>注意，这里的 <code>Gt</code> 不能用贝尔曼方程计算，只能由采样的奖励值序列按定义式计算：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228095500.png" alt="image-20211228095500637" style="zoom:50%;" /><p>&emsp;&emsp;数学上的优化方法是在迭代计算收获均值，即每次保存上一轮迭代得到的收获均值与次数，当计算得到当前轮的收获时，即可计算当前轮收获均值和次数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220126143244.png" alt="image-20220126143244239" style="zoom:67%;" /><p>其中，<code>k</code>采样序列episode的个数，可以证明这样计更新价值V和上面的结果是一致的，但大大节省空间。</p><p>&nbsp;</p><h3 id="价值迭代"><a href="#价值迭代" class="headerlink" title="价值迭代"></a>价值迭代</h3><p>&emsp;&emsp;蒙特卡罗法求解强化学习问题的思路和动态规划价值迭代的的思路类似。区别在于价值vk(s)的计算方法（蒙特卡洛使用采样然后取平均来算），然后基于据一定的方法（比如贪婪法）更新当前策略π。最后得到最优价值函数v∗和最优策略π∗。</p><p><strong>对比动态规划：</strong></p><p>​        1.  状态价值的计算方法不同，动态规划用贝尔曼方程迭代，蒙特卡罗法用采样数据求平均</p><p>​        2. 蒙特卡罗法一般是优化最优动作价值函数q∗，而不是状态价值函数v∗</p><p>​        3. 动态规划一般基于贪婪法更新策略，而蒙特卡罗法一般采用<strong>ϵ−greedy</strong>法更新：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228141900.png" alt="image-20211228141900761" style="zoom: 18%;" /><center>m是可选行动的个数</center><p>在实际求解时，为了使算法可以收敛，一般ϵ会随着算法的迭代过程逐渐减小并趋于0。这样在迭代前期，鼓励探索；而后期由于已经有了足够的探索量，开始趋于保守，以贪婪为主，使算法可以稳定收敛。</p><p><strong>算法：（以every-visit为例）</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态集S、动作集A、即时奖励R、衰减因子γ、探索率ϵ</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最有动作价值函数q∗、最优策略π∗</span><br></pre></td></tr></table></figure><p>流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化所有的动作价值Q(s, a)=0，状态次数N(s, a)=0，采样次数k=0，随机初始化一个策略π</span><br><span class="line">2. k=k+1，基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:</span><br><span class="line">S1,A1,R2,S1,A2,R3,...St,At,Rt+1,...,RT,ST</span><br><span class="line">3. 对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：</span><br><span class="line">    Gt = 对n累加到T[(γ^(t-n))*(Rt+n)]</span><br><span class="line">    N(s, a) ++</span><br><span class="line">    Q(s, a) += (Gt-Q(s, a))/N(s,a)</span><br><span class="line">4. 基于新计算出的动作价值，更新当前的ϵ−greedy策略：</span><br><span class="line">    ϵ = 1/k</span><br><span class="line">    π = ϵ−greedy()</span><br><span class="line">5. 若所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗，对应的策略π(a|s)即为最优策略π∗，否则转到第二步</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;蒙特卡罗法是不基于模型的强化问题求解方法，它可以避免动态规划求解过于复杂，同时不需要事先知道环境转化模型，因此常用于海量数据和复杂模型。但是它每次采样都需要一个完整的状态序列，如果没有完整的状态序列，或者很难拿到较多的完整的状态序列，因此在实际问题中蒙特卡罗法用的不多，所以还需要寻找其他的更灵活的不基于模型的强化问题求解方法。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="时序差分法TD（Model-free）"><a href="#时序差分法TD（Model-free）" class="headerlink" title="时序差分法TD（Model-free）"></a>时序差分法TD（Model-free）</h2><h3 id="时序差分法"><a href="#时序差分法" class="headerlink" title="时序差分法"></a>时序差分法</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135332.png" alt="image-20211228135332814"></p><p>&emsp;&emsp;时序差分法和蒙特卡罗法类似，都是不基于模型的强化学习问题求解方法。蒙特卡罗法中<code>Gt</code>的计算需要完整序列，而时序差分法没有完整的状态序列，只有部分的状态序列，由贝尔曼方程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228085858.png" alt="image-20211228085858501" style="zoom:50%;" /><p>可知，可以用<code>Rt+1+γv(St+1)</code>来近似的代替收获Gt。</p><p>一般我们把<code>Rt+1+γV(St+1)</code>称为<strong>目标值</strong>，<code>Rt+1+γV(St+1)−V(St)</code>称为<strong>TD误差</strong>，将用目标值近似代替收获G(t)的过程称为<strong>引导</strong>(bootstrapping)。这样只需要两个连续的状态与对应的奖励，就有了近似收获Gt的表达式，可以去求解时序差分的预测问题和控制问题了。</p><p>&nbsp;</p><p><strong>对比蒙特卡洛法：</strong></p><p>时序差分的预测问题求解和蒙特卡罗法类似，但是主要有两个不同点：</p><ul><li><p>收获Gt的表达式不同</p><ul><li>蒙特卡罗 G(t) 需要遍历完整过程才能得出：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228102751.png" alt="image-20211228102751434" style="zoom: 50%;" /></li><li>时序差分 G(t)记录连续两个状态就可得出，称为 <strong>TD Target</strong> ：<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110419.png" alt="image-20211228110419330" style="zoom: 50%;" /></li></ul></li><li><p>迭代式子的系数不同，时序差分没有完整的序列，也就没有对应的次数N(St, At)，一般用一个[0,1]的系数α代替：</p><ul><li><p>蒙特卡罗:    </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110505.png" alt="image-20211228110505164" style="zoom:50%;" /></li><li><p>时序差分: </p>  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228110514.png" alt="image-20211228110514567" style="zoom:50%;" /></li></ul></li></ul><p>&emsp;&emsp;（并且蒙特卡罗法一般只优化动作价值函数Q，时序差分状态价值、动作价值函数都会优化）</p><ul><li>时序差分法在知道最终结果之前就可以学习，甚至没有最终结果也可以学习，还可以在持续进行的环境中学习。而蒙特卡罗法则要等到最后结果才能学习，因此时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。</li><li>时序差分法在更新状态价值时使用的是<strong>TD目标值</strong>，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的<strong>有偏估计</strong>，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的<strong>无偏估计</strong>，这一点蒙特卡罗法占优。</li><li>虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。</li></ul><p>&nbsp;</p><h3 id="n步时序差分："><a href="#n步时序差分：" class="headerlink" title="n步时序差分："></a>n步时序差分：</h3><p>&emsp;&emsp;上面用TD Target代替收获Gt的公式中，St只向前一步到St+1，若用向前2步、n步来近似代替Gt，则为n步时序差分：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228105615.png" alt="image-20211228105615429" style="zoom: 33%;" /><p>&emsp;&emsp;（当n越来越大，趋于无穷，或者说趋于使用完整的状态序列时，n步时序差分就等价于蒙特卡罗法了）</p><p>&nbsp;</p><h3 id="TD-λ"><a href="#TD-λ" class="headerlink" title="TD(λ)"></a>TD(λ)</h3><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112323.png" alt="image-20211228112323589"></p><p>&emsp;&emsp;n步时序差分选择多少步数是一个超参数调优问题(一般3~10比较好)。为了能在不增加计算复杂度的情况下综合考虑所有步数的预测，引入一个[0,1]新的参数λ，定义收获是n从1到∞所有步的收获乘以权重的和：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211229100620.png" alt="image-20211229100620726" style="zoom:50%;" /><p>每一步的权重是<code>(1−λ)*λ^(n−1)</code></p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228112010.png" alt="image-20211228112009881" style="zoom: 33%;" /><p>&emsp;&emsp;进而有价值函数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228142817.png" alt="image-20211228142817279" style="zoom:25%;" /><p>&emsp;&emsp;从前向来看，一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时，就是上面的普通时序差分法；当λ=1时，就是蒙特卡罗法。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111541.png" alt="image-20211228111540959" style="zoom:25%;" /><p>&emsp;&emsp;从反向来看，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为<strong>频率启发(frequency heuristic) 式</strong>；而把电击归因于最近少数几次状态的影响，则称为<strong>就近启发(recency heuristic) 式</strong>。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228111604.png" alt="image-20211228111604749" style="zoom:25%;" /><p><strong>效用迹E</strong></p><p>&emsp;&emsp;给每一个状态引入一个数值：<strong>效用值</strong> 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发(同事反映二者)。而所有状态的效用值总称为**效用迹(eligibility traces, ES)**。定义为：</p><p>​                        <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228135203.png" alt="image-20211228135203250" style="zoom:25%;" />    </p><p>&emsp;&emsp;此时价值函数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228134525.png" alt="image-20211228134525809" style="zoom: 25%;" /><p>&nbsp;</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;时序差分和蒙特卡罗法比它更加灵活，学习能力更强，因此是目前主流的强化学习求解问题的方法，现在绝大部分强化学习乃至深度强化学习的求解都是以时序差分的思想为基础的。</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token Bucket最优参数的数学推导</title>
      <link href="/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/"/>
      <url>/2021/12/27/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Network%20Traffic%20%20Characterization%20%20Using%20Token%20%20Bucket%20%20Model/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文研究了从两种情况下观察到的网络数据流的流量模式中导出<strong>令牌桶参数</strong>的问题：</p><ul><li>给定数据流对应一组令牌桶参数，所有数据包都立即传送，不产生任何延迟或丢失</li><li>在上述模型中添加一个缓存队列，以临时存储在桶中积累足够的令牌之前无法立即传送的数据包。队列具有平滑流量的效果，因此对令牌桶参数的要求较低，同时还使得派生的令牌桶参数随时间的波动较小。</li></ul><p>然后对两个模型严格分析了给定数据流的队列大小和令牌桶参数之间的关系，计算数据流中每个数据包的排队延迟并用于描述调整后的排队后流量模式。</p><p>并且就两个模型分别介绍了用于推导基于测量的流量规范 (MBTS) 的简单高效算法以及经验结果。这种 MBTS 技术减轻了用户为在综合服务网络中保留网络资源而预先明确表征流量的需要。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Network%20traffic%20characterization%20using%20token%20bucket%20model.pdf">Network traffic characterization using token bucket model</a></p><span id="more"></span><p>&nbsp;</p><h2 id="令牌桶概念及问题"><a href="#令牌桶概念及问题" class="headerlink" title="令牌桶概念及问题"></a>令牌桶概念及问题</h2><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>&emsp;&emsp;假设一个流存在于一个时间间隔 [t0 , tn ] 中并且由 n 个数据包 p1, p2, … ，pn 组成。它的流量模式 P = { ( p i , ti）|1&lt;i &lt;n}，其中 t0&lt;t1&lt;t2&lt; … &lt; tn, 表示在时间[t0, tn]内，pi由主机中的应用程序生成，表示第 i 个数据包的字节数。</p><h3 id="无缓存队列的令牌桶"><a href="#无缓存队列的令牌桶" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶是一个非负计数器，它以恒定速率 r 累积令牌，直到计数器达到其容量 b 。到达后，一个数据包将被发送出去，令牌计数器减少了数据包大小（以字节为单位），前提是该数据包有足够的令牌。否则，数据包将被丢弃或排队，直到令牌桶积累了足够的令牌以将数据包发送出去。当流空闲或以较低的速率运行，使得令牌计数器达到上限 b 时，令牌的累积将暂停，直到下一个数据包到达。请注意，令牌桶不是数据包的物理容器，而是用于调度数据包释放时间的令牌数字计数器。令牌桶由其令牌补充率 r 和令牌桶大小 b 参数化。</p><p>&emsp;&emsp;流量表征的一个关键问题是，对于时间间隔 [t0, tn] 中模式 P 的数据流，如何从观察到的流量模式导出合适的令牌桶参数 (r, b) ，以便所有数据包在到达时立即发送出去。在这种情况下，我们说数据流符合由 (r, b) 参数化的令牌桶模型。</p><h3 id="含缓存队列的令牌桶"><a href="#含缓存队列的令牌桶" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>&emsp;&emsp;令牌桶模型可以通过向其添加缓存队列来扩展。该缓存队列用于在数据包流等待足够的令牌以在存储桶中累积时保存数据包流。通过排队，突发流量可以被平滑，因此派生的令牌桶参数变得比无缓存队列情况下的要求更低，从而导致网络中更有效的资源分配。另一方面，通过添加缓存队列，给定的令牌桶模型将能够以牺牲存储空间和数据源的数据包延迟为代价来适应更多变化的流量模式。</p><p>对带有队列的令牌桶有如下问题：</p><ol><li>对于给定的数据流和令牌桶模型，最小队列大小 q 应该为多少才能保证数据流不会丢包？</li><li>如果给定令牌速率r、桶容量b之一和队列大小 q，那么另一个参数的最佳选择是什么？</li><li>对于排队情况下的每个数据包，排队延迟是多少？</li><li>如果指定了最大排队延迟，那么应该如何确定最小队列大小和对应的令牌桶参数？</li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="两种模型下的参数求解"><a href="#两种模型下的参数求解" class="headerlink" title="两种模型下的参数求解"></a>两种模型下的参数求解</h2><h3 id="无缓存队列的令牌桶-1"><a href="#无缓存队列的令牌桶-1" class="headerlink" title="无缓存队列的令牌桶"></a>无缓存队列的令牌桶</h3><p>本文Part 2通过严格的数学证明和有效的算法：</p><ul><li><p>找到了 b 和 r 的下限和上限，以便所有满足无时延和丢包要求的合法 ( r , b ) 对都落在这些范围内</p></li><li><p>对任何给定有效的 r ，可以确定最优的（即与 r 耦合最小的） b 以便不丢弃任何数据包这个最优 b 明确表示为 r 的函数，它是单调递减和分段线性的</p></li><li><p>提出了两种有效的算法来计算b(r)函数和相关经验结果</p></li></ul><p>&nbsp;</p><h4 id="r的有效范围"><a href="#r的有效范围" class="headerlink" title="r的有效范围"></a>r的有效范围</h4><p>一方面，如果 r 太小，则无论 b 的容量有多大，桶中都不会为传入的数据包生成足够的令牌。因此满足无延迟要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194837.png" alt="image-20211226194836980" style="zoom:50%;" /><p>c0是t0时刻桶中初始令牌数，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194540.png" alt="image-20211226194540110" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；</p><p>另一方面，也没有必要使 r 无限大，最大 r 恰满足能使一个时间间隔内的所有数据包都被发送即可：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226194822.png" alt="image-20211226194822619" style="zoom:50%;" /><p>pk是第k个时间间隔内的数据包流量，从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195012.png" alt="image-20211226195012336" style="zoom:50%;" /><p>这是<strong>r的上限</strong>。（文中已证明其必大于r的下限）</p><p>&nbsp;</p><h4 id="b的有效范围"><a href="#b的有效范围" class="headerlink" title="b的有效范围"></a>b的有效范围</h4><p>由上可推出<strong>最大数据速率</strong>为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201839.png" alt="image-20211226201839313" style="zoom:50%;" /><p>当时间间隔k内数据速来p大于rmax且初始令牌数c00时，得到最小桶的容量：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195603.png" alt="image-20211226195603013" style="zoom:50%;" /><p>这是<strong>b的下限</strong>；</p><p>当满足上面r的限定范围时，每个时间间隔k过后内桶中会积累的令牌数量为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226195806.png" alt="image-20211226195806153" style="zoom:50%;" /><p>因此桶的大小必须至少能够容下ck的最大值：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226201417.png" alt="image-20211226201417539" style="zoom:50%;" /><p>这是<strong>b的上限</strong>，可见b的范围是r的函数。</p><p>&nbsp;</p><h4 id="b和r的关系"><a href="#b和r的关系" class="headerlink" title="b和r的关系"></a>b和r的关系</h4><p>给定r，求解满足无时延和丢包前提下的最小b值</p><p>记delta k表示第k个时间间隔大小，ck表示第k个数据包到达前时刻的桶中令牌数量（即上一个时间间隔结尾时刻的），则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224424.png" alt="image-20211226224424621" style="zoom:50%;" /><p>（注意到这里的ck(r,b)不同于前面的ck(r)，ck(r,b)小于等于ck(r)，仅当b大于等于bmax时取等号）</p><p>因为满足无时延和丢包，即：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224657.png" alt="image-20211226224657804" style="zoom:50%;" /><p>递推得到：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224838.png" alt="image-20211226224838298" style="zoom:50%;" /><p>因此，满足无时延和丢包前提下，给定r时的最优（最小）b为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226224920.png" alt="image-20211226224920764" style="zoom:50%;" /><p>若取初始令牌数c0==b，即桶一开始是满的，则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226225532.png" alt="image-20211226225532241" style="zoom:50%;" /><p>&nbsp;</p><h4 id="降低b-r-时间复杂度"><a href="#降低b-r-时间复杂度" class="headerlink" title="降低b(r)时间复杂度"></a>降低b(r)时间复杂度</h4><p>&emsp;&emsp;由上可知，求解最优b值是至少要在 n(n-1)/2 个数字中取最大值，评估所有这些 O ( n 2 ) 数的成本太高了。文章中提出了两种有效的算法来计算给定 r 的 最优b值。第一个算法只解析一次输入模式 P ，复杂度为 O ( n ) 。第二个是multi-pass算法，复杂度为 O ( n log n)，但是可以推广到排队情况。</p><h5 id="算法-1-简单数学推导"><a href="#算法-1-简单数学推导" class="headerlink" title="算法 1    简单数学推导"></a>算法 1    简单数学推导</h5><p>&emsp;&emsp;这里省去论文中的推导，直接记录结论。</p><p>&emsp;&emsp;由递推公式  <img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226231637.png" alt="image-20211226231637615" style="zoom:50%;" /></p><p>&emsp;&emsp;可以计算出以P={(pk,tk) | 1&lt;k&lt;n}为流量模式的情况下，给定r后b的最优值。</p><p>&emsp;&emsp;此算法不仅由于 O(n) 复杂度而具有 CPU 效率，而且在内存方面也很高效。只需要分配两个整数 d 和 b 作为 dk 和 bk 序列的占位符，不需要存储模式数据 P，因为这是一种一次性算法，它可以与到达的数据包流一起实时进行。</p><h5 id="算法-2-二分查找"><a href="#算法-2-二分查找" class="headerlink" title="算法 2    二分查找"></a>算法 2    二分查找</h5><p>&emsp;&emsp;第二种算法没有利用 b(r)的显式解。相反它对其范围内的最小 b 进行二分搜索，使得对所有 k 都有ck(r,b) &gt;= pk。该算法的优点在于它可以推广并激发Part 3中的排队情况解决方案，同时也可以作为我们实验中检查第一个算法的正确性和性能的参考。</p><p>&emsp;&emsp;用 [bl , bu] 表示b 的范围，其中 l 代表下限，u 代表上限。最初设置 bl = bmin、bu=bmax 和 b = 1/2*(bl + bu)。在初始满桶(c0=b)的情况下，选择归纳计算 ck(r,b) 并将其值与 pk 进行比较。如果对任何k都有pk &lt;= ck(r,b)，则设置 bu  = b 和 b = 1/2*(bl + bu) 。否则，当遇到的第一个pk &gt; ck(r,b)的 k 时，我们设置 bl = b 和 b = 1/2*(bl + bu)。重复上述步骤直到 bl = bu。</p><p>&emsp;&emsp;由于用于二分搜索的 b 的初始范围最多为 O ( n ) ，因此 b 上恰好有 O(logn) 次更新。对于 b 的每次更新，最多需要遍历 (pk , tk) 的列表一次。在最坏的情况下也只需要时间 O (n) ，因此二分查找算法的复杂度是 O (n logn) 。</p><h5 id="算法-3-Send-Now算法"><a href="#算法-3-Send-Now算法" class="headerlink" title="算法 3    Send-Now算法"></a>算法 3    Send-Now算法</h5><p>&emsp;&emsp;这是作者提到他们在一个tb程序中看见的算法，可以达到和算法 1相似的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226233525.png" alt="image-20211226233525702" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="含缓存队列的令牌桶-1"><a href="#含缓存队列的令牌桶-1" class="headerlink" title="含缓存队列的令牌桶"></a>含缓存队列的令牌桶</h3><p>本文Part 3通过严格的数学证明和有效的算法：</p><ul><li>确定了给定缓存队列大小 q 的有效 r 和 b 的边界。发现对于给定的流量模式，在有时延但无丢包情况下，最小缓存队列大小q是 ( r , b ) 对的二元函数，且这个函数 q(r, b ) 是 r 和 b 的减函数</li><li>提出了给定的缓存队列大小 q时最优 b 和 r 之间关系的计算算法。后者实际上是对无缓存队列情况的一般化，如果将缓存队列大小设置为0，则将退化为Part 2中的结果</li><li>明确计算了给定令牌桶模型的数据流中每个数据包的排队延迟。从而推导出数据流的最大和平均排队延迟，以及调整后的排队后流量模式</li><li>提出了在指定最大延迟或平均延迟的上限时确定满足延迟界限的令牌桶模型（r，b）集的算法，并分析了算法的时间复杂度</li></ul><p>&nbsp;</p><h4 id="不考虑容量b的情况"><a href="#不考虑容量b的情况" class="headerlink" title="不考虑容量b的情况"></a>不考虑容量b的情况</h4><h5 id="r的有效范围-1"><a href="#r的有效范围-1" class="headerlink" title="r的有效范围"></a>r的有效范围</h5><p>假定桶容量b无穷大，从而简化推导。记缓存队列大小为q，则满足无丢包要求的必要条件：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110252.png" alt="image-20211227110252037" style="zoom:50%;" /><p>其中<img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110336.png" alt="image-20211227110336667" style="zoom:50%;" />从而得：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227110351.png" alt="image-20211227110351617" style="zoom:50%;" /><p>这是<strong>r的下限</strong>；至于<strong>r的上限</strong>则和上面无缓存队列情况时一致。</p><p>&nbsp;</p><h5 id="b的有效范围-1"><a href="#b的有效范围-1" class="headerlink" title="b的有效范围"></a>b的有效范围</h5><p>注意，在有缓存队列情况下，每个时间间隔内损耗的令牌数不只是时间间隔内新来的数据包pk大小，还包括缓存队列中多个delay的旧数据包。第k个时间间隔内delay的旧数据包大小为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111522.png" alt="image-20211227111522588" style="zoom:50%;" /><p>记 I(k) 为使</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111738.png" alt="image-20211227111738322" style="zoom: 50%;" /><p>成立的最小 k’ 值，即 I(k) 是在pk到达之前令牌桶已经发出的数据包的数量。</p><p>则有：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227111920.png" alt="image-20211227111920444" style="zoom:50%;" /><p>因为有了缓存队列，令牌数不够用时数据包放入缓冲队列，此时的令牌数就是ck。</p><p>数据包pk到达后缓存队列中剩余的字节数为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227112321.png" alt="image-20211227112321614" style="zoom:50%;" /><p>即令牌数不够用时放入缓冲队列的数据包总大小。</p><p>（这里文章给出了 “ <em>当r&gt;rmin时，必有qk&lt;q（即缓存队列不会溢出）且无丢包</em> ” 的证明，感兴趣可以自己查阅）</p><p>由上述推导得数据包时延为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124037.png" alt="image-20211227124037294" style="zoom:50%;" /><p><strong>b的下限</strong>和上面无缓存队列情况时一致，<strong>b的上限</strong>则为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227124447.png" alt="image-20211227124447620" style="zoom:50%;" /><p>注意其中ck(r)的值有两种情况( I(t) &lt; 或 &gt; pk)，所以用max()函数表述。</p><p>&nbsp;</p><h4 id="考虑桶容量b的情况"><a href="#考虑桶容量b的情况" class="headerlink" title="考虑桶容量b的情况"></a>考虑桶容量b的情况</h4><p>&emsp;&emsp;上面研究了不受 b 限制的排队情况，现在考虑一般情况，即缓存队列q和令牌桶大小 b 都起作用。假设我们给出了位于无延迟 TB 曲线下方的值 ( r , b )，我们想知道这个令牌桶的最小队列大小及其相应的排队后的交通模式P。</p><h5 id="q的有效范围"><a href="#q的有效范围" class="headerlink" title="q的有效范围"></a>q的有效范围</h5><p>I(k) 定义为使得</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125435.png" alt="image-20211227125435320" style="zoom:50%;" /> <p>恒成立的最大 k‘ 值，即在 pk 到达之前已经发出而不是存入缓存队列的数据包的数量</p><p>ck(r, b)定义为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125547.png" alt="image-20211227125547219" style="zoom:50%;" /><p>qk 定义为需要在 pk到达后立即排队的字节数：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125652.png" alt="image-20211227125652836" style="zoom:50%;" /><p>则最小队列长qmin为：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227125756.png" alt="image-20211227125756422" style="zoom:50%;" /><h5 id="q一定时，求b-r"><a href="#q一定时，求b-r" class="headerlink" title="q一定时，求b(r)"></a>q一定时，求b(r)</h5><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>&emsp;&emsp;同上面类似，只不过搜索时的有效条件改为</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227131254.png" alt="image-20211227131254110" style="zoom:50%;" />，时间复杂度为O(n logn)&gt;</p><h6 id="Send-Smooth算法"><a href="#Send-Smooth算法" class="headerlink" title="Send-Smooth算法"></a>Send-Smooth算法</h6><p>&emsp;这是作者上面提到他们在一个tb程序中看见的算法，可以达到O(n)的性能效果：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211228182254.png" alt="image-20211228182254925" style="zoom:67%;" /><p>&nbsp;</p><h4 id="数据包时延"><a href="#数据包时延" class="headerlink" title="数据包时延"></a>数据包时延</h4><p>这边实在没看懂它这1999年的老论文里说的是什么混乱逻辑，反正项目后面做NSRRM时delay直接测实际值不需要计算获得，不管了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Token Bucket </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题与启发式算法</title>
      <link href="/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/27/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91NP%E9%97%AE%E9%A2%98%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</p><p>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据组合，也许永远不会在现实世界出现。因此现实世界中启发式算法常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。</p><p>有一类的通用启发式策略称为元启发式算法，通常使用乱数搜寻技巧。他们可以应用在非常广泛的问题上，但不能保证效率。</p><span id="more"></span><p>&nbsp;</p><h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><h3 id="多项式时间（polynomial-time）"><a href="#多项式时间（polynomial-time）" class="headerlink" title="多项式时间（polynomial time）"></a>多项式时间（polynomial time）</h3><p>&emsp;&emsp;时间复杂度是指当程序所处理的问题规模扩大后，程序需要的时间长度对应增长得有多快。根据增量的量级划分，可以分为：</p><ul><li>多项式复杂度：O(1)、O(log(n))、O(n^a)等</li><li>非多项式复杂度：O(a^n)、O(n!)等</li></ul><p>&emsp;&emsp;非多项式复杂度的程序当问题规模扩大时，计算机将无法承受运算时间开销，因此通常使用的算法都是多项式级的复杂度。</p><p>&nbsp;</p><h3 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，在算法的整个执行过程中，每一步都能得到一个确定的解，这样的算法就是确定性算法。</p><h3 id="非确定性算法"><a href="#非确定性算法" class="headerlink" title="非确定性算法"></a>非确定性算法</h3><p>&emsp;&emsp;设A是求解问题B的一个解决算法，它将问题分解成两部分，分别为猜测阶段和验证阶段，其中</p><ul><li>猜测阶段：对问题的一个特定的输入实例x产生一个任意字符串y，在算法的每一次运行时，y的值可能不同，因此，猜测以一种非确定的形式工作。</li><li>验证阶段：用一个确定性算法（有限时间内）验证。<ul><li>检查在猜测阶段产生的y是否是合适的形式，如果不是，则算法停下来并得到no；</li><li>如果y是合适的形式，则验证它是否是问题的解，如果是，则算法停下来并得到yes，否则算法停下来并得到no。它是验证所猜测的解的正确性。</li></ul></li></ul><p>&nbsp;</p><h3 id="规约-约化"><a href="#规约-约化" class="headerlink" title="规约/约化"></a>规约/约化</h3><p>&emsp;&emsp;问题A可以约化为问题B，称为“问题A可规约为问题B”，可以理解为问题B的解一定就是问题A的解，因此解决A不会难于解决B。由此可知问题B的时间复杂度一定大于等于问题A。</p><p>&emsp;&emsp;从规约的定义中我们看到，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断规约，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。</p><p>&nbsp;</p><h3 id="P-NP-NPC-NP-Hard问题"><a href="#P-NP-NPC-NP-Hard问题" class="headerlink" title="P/NP/NPC/NP-Hard问题"></a>P/NP/NPC/NP-Hard问题</h3><h4 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h4><p>&emsp;&emsp;能在多项式时间内可解的问题</p><h4 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h4><p>&emsp;&emsp;在多项式时间内”可验证“的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。</p><h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p>&emsp;&emsp;存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：</p><ul><li>是一个NP问题</li><li>所有NO问题都能规约到它</li></ul><h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>&emsp;&emsp;满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130636.png" alt="image-20211227130636049" style="zoom:67%;" /><p>&nbsp;</p><p>&nbsp;</p><h2 id="启发式算法（Heuristic-algorithm）"><a href="#启发式算法（Heuristic-algorithm）" class="headerlink" title="启发式算法（Heuristic algorithm）"></a>启发式算法（Heuristic algorithm）</h2><p>&emsp;&emsp;实际工程中有许多优化问题是NP-Hard问题，其最优算法通常因为复杂度过高而效率低下，或者就是没有最优化算法可以用。启发式算法是相对于最优化算法提出的基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解（次优解），该可行解与最优解的偏离程度一般不能被预计。</p><ul><li>无法保证得到某优化问题的全局最优解</li><li>为了快速地求解那些不存在或者暂时未找到多项式时间内算法的问题而提出</li></ul><p><strong>元启发式算法（Metaheuristic algorithm）</strong></p><p>&emsp;&emsp;元启发式算法主要指一类通用型的启发式算法，这类算法的优化机理不过分依赖于算法的组织结构信息（不依赖特定问题，而是具有通用性的策略），可以广泛的应用到函数的组合优化和函数计算中。</p><p><strong>超启发算法（Hyper-heuristic algorithm）</strong></p><p>&emsp;&emsp;超启发式算法提供了某种高层策略（High-Level Strategy，HLS），通过操纵或管理一组低层启发式算法（Low-Level Heuristics, LLH），以获得新启发式算法。这些新启发式算法则被运用于求解各类NP-难解问题。</p><p>&nbsp;</p><h3 id="常用的启发式算法"><a href="#常用的启发式算法" class="headerlink" title="常用的启发式算法"></a>常用的启发式算法</h3><h4 id="模拟退火算法（SA）"><a href="#模拟退火算法（SA）" class="headerlink" title="模拟退火算法（SA）"></a>模拟退火算法（SA）</h4><p>&emsp;&emsp;模拟退火算法(Simulated Annealing, SA)的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化温度T(充分大)，温度下限Tmin(充分小)，初始解X，每个T值迭代次数L</span><br><span class="line"></span><br><span class="line">2. 随机生成临域解x_new;</span><br><span class="line"></span><br><span class="line">3. 设f(x)函数来计算用来计算解得好坏，计算出f(x_new)-f(x);</span><br><span class="line"></span><br><span class="line">4. 如果f(x_new)-f(x)&gt;0，说明新解比原来的解好，则无条件接受，如果f(x_new)-f(x)&lt;0，则说明旧解比新解好，则以概率exp((f(xnew)-f(x))/k*T)接受x_new作为解。</span><br><span class="line"></span><br><span class="line">5. 如果当前温度&lt;Tmin时，则退出循环，输出当前结果，否则减少当前温度，回到第2步继续循环，常用的降温方法为T= a*T (0&lt;a&lt;1)，一般a取接近1的值</span><br></pre></td></tr></table></figure><p>实例：求解函数最小值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211227130659.png" alt="image-20211227130659835" style="zoom: 67%;" /><p>其中-100&lt;=x&lt;=100，给定任意y值，求x为多少时，F(x)最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">2000</span>;        <span class="comment">// 初始化温度</span></span><br><span class="line"><span class="keyword">double</span> Tmin = <span class="number">1</span>;     <span class="comment">// 温度的下界</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">100</span>;         <span class="comment">// 迭代的次数</span></span><br><span class="line"><span class="keyword">double</span> delta = <span class="number">0.98</span>; <span class="comment">// 温度的下降率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x取值范围 0~100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span>) / <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评价函数的值,即对应上文中的f(x)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x目标函数中的一个参数</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的另一个参数</span></span><br><span class="line"><span class="comment"> * @return函数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getFuncResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">5</span> * <span class="built_in">pow</span>(x, <span class="number">2</span>) - <span class="built_in">cos</span>(<span class="number">2</span> * x) * y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟退火算法的过程</span></span><br><span class="line"><span class="comment"> * @param y目标函数中的指定的参数</span></span><br><span class="line"><span class="comment"> * @return最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSA</span><span class="params">(<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x_min = <span class="number">0</span>; <span class="comment">// 初始化最优值点</span></span><br><span class="line">    <span class="keyword">double</span> f_x = <span class="number">0</span>;   <span class="comment">// 初始化函数值</span></span><br><span class="line">    <span class="keyword">double</span> *x = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) * k);</span><br><span class="line">    <span class="comment">// 初始化初始解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="built_in">getX</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代的过程</span></span><br><span class="line">    <span class="keyword">while</span> (T &gt; Tmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算此时的函数结果</span></span><br><span class="line">            <span class="keyword">double</span> funTmp = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">            <span class="comment">// 在邻域内产生新的解</span></span><br><span class="line">            <span class="keyword">double</span> x_new = x[i] + (<span class="keyword">double</span>)(<span class="built_in">rand</span>() % <span class="number">10000</span> - <span class="number">5000</span>) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 判断新的x不能超出界</span></span><br><span class="line">            <span class="keyword">if</span> (x_new &gt;= <span class="number">-100</span> &amp;&amp; x_new &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;debug x=%f\n&quot;</span>, x_new);</span><br><span class="line">                <span class="keyword">double</span> funTmp_new = <span class="built_in">getFuncResult</span>(x_new, y);</span><br><span class="line">                <span class="keyword">if</span> (funTmp_new - funTmp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 替换</span></span><br><span class="line">                    x[i] = x_new;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 以概率替换</span></span><br><span class="line">                    <span class="keyword">double</span> p = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-(funTmp_new - funTmp) / T));</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">rand</span>() % <span class="number">100</span>) / <span class="number">100</span> &lt; p)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x[i] = x_new;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T = T * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f_x &gt; <span class="built_in">getFuncResult</span>(x[i], y))</span><br><span class="line">        &#123;</span><br><span class="line">            x_min = x[i];</span><br><span class="line">            f_x = <span class="built_in">getFuncResult</span>(x[i], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置y的值</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="built_in">getSA</span>(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%4.2f时，有f(x)最小值为 %5.3f\n&quot;</span>, x, <span class="built_in">getFuncResult</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="遗传算法（GA）"><a href="#遗传算法（GA）" class="headerlink" title="遗传算法（GA）"></a>遗传算法（GA）</h4><p>&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 对潜在问题进行编码，初始化基因组，并根据基因组随机初始化种群，并指定繁衍代数。</span><br><span class="line"></span><br><span class="line">2. 计算种群中每个个体的适应度，选择一定数目的留下，其余淘汰。</span><br><span class="line"></span><br><span class="line">3. 在留下的个体中，随机繁衍，对分母基因进行交叉（极小概率变异），产生下一代。</span><br><span class="line"></span><br><span class="line">4. 回到第2步进行循环。直到达到指定的繁衍代数</span><br></pre></td></tr></table></figure><p><strong>相关术语</strong></p><p>编码(coding)：将物体的表现型用编码的方式转为程序可控的基因型</p><blockquote><p>比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给 它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津-&gt;新疆-&gt;北京-&gt;广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。<br>（1）二进制编码，基因用0或1表示（常用于解决01背包问题）</p><p>如：基因A：00100011010 (代表一个个体的染色体)</p><p>（2）互换编码（用于解决排序问题，如旅行商问题和调度问题）</p><p>如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。</p></blockquote><p>解码(decoding)：基因型到表现型的映射</p><p>基因型(genotype)：参数的因子</p><p>表现型(phenotype)：根据不同因子最终展现的形态</p><p>适应度(fitness)：度量某个结果的好坏</p><p>进化(evolution)：不断剔除差的结果，最终逐步留下好的结果</p><p>选择(selection)：以一定的概率从种群中选择若干个个体留下，并繁殖。选择过程是一种基于适应度的优胜劣汰的过程</p><p>复制(reproduction)：将父本、母本的基因复制，以便产生下一代</p><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交</p><blockquote><p>（1）单交叉点法 （用于二进制编码）</p><p>选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。</p><p>如：交叉前：</p><p>00000|01110000000010000</p><p>11100|00000111111000101</p><p>交叉后：</p><p>00000|00000111111000101</p><p>11100|01110000000010000</p><p>（2）双交叉点法 （用于二进制编码）</p><p>选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.</p><p>如：交叉前：</p><p>01 |0010| 11</p><p>11 |0111| 01</p><p>交叉后：</p><p>11 |0010| 01</p><p>01 |0111| 11</p><p>（3）基于“ 与/或 ”交叉法 （用于二进制编码）</p><p>对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .</p><p>如：交叉前：</p><p>01001011</p><p>11011101</p><p>交叉后：</p><p>01001001</p><p>11011111</p><p>（4）单交叉点法 （用于互换编码）</p><p>选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。</p><p>如：交叉前：</p><p>87213 | 09546</p><p>98356 | 71420</p><p>交叉后：</p><p>87213 | 95640</p><p>98356 | 72104</p><p>（5）部分匹配交叉（PMX）法（用于互换编码）</p><p>先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。</p><p>父代A：872 | 130 | 9546</p><p>父代B：983 | 567 | 1420    变为：</p><p>TEMP A: 872 | 567 | 9546</p><p>TEMP B: 983 | 130 | 1420</p><p>对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1&lt;——&gt;５　３&lt;——&gt;６　７&lt;——&gt;０</p><p>子代Ａ：802 | 567 | 9143</p><p>子代Ｂ：986 | 130 | 5427</p><p>（6）顺序交叉法(OX) （用于互换编码）</p><p>从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。</p><p>父代A: 872 | 139 | 0546</p><p>父代B: 983 | 567 | 1420</p><p>交叉后：</p><p>子代A: 856 | 139 | 7420</p><p>子代B: 821 | 567 | 3904</p><p>（7）循环交叉（CX）（用于互换编码）</p><p>CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。</p><p>父代A：1 2 3 4 5 6 7 8 9</p><p>父代B：5 4 6 9 2 3 7 8 1</p><p>可得循环基因：1-&gt;5-&gt;2-&gt;4-&gt;3-&gt;6-&gt;9-&gt;7-&gt;8</p><p>子代Ｂ的编码同理。（循环基因 5-&gt;1-&gt;4-&gt;2-&gt;6-&gt;3-&gt;9-&gt;7-&gt;8）</p></blockquote><p>变异(mutation)：交叉后可能（很小的概率）对染色体进行更改，来防止算法过早收敛而陷入局部最优解中</p><blockquote><p>变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。</p><p>（1）基本位变异算子（用于二进制编码）</p><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。</p><p>变异前：</p><p>000001110000000010000</p><p>变异后：</p><p>000001110001000010000</p><p>（2）逆转变异算子（用于互换编码）（源代码中使用类似此方法）</p><p>在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。</p><p>变异前：</p><p>1346798205</p><p>变异后：</p><p>1246798305</p></blockquote><p>个体（individual）：指染色体带有特征的实体</p><p>种群（population）：个体的集合，该集合内个体数称为种群的大小</p><p>&nbsp;</p><h4 id="蚁群算法（ACO）"><a href="#蚁群算法（ACO）" class="headerlink" title="蚁群算法（ACO）"></a>蚁群算法（ACO）</h4><p>&emsp;&emsp;蚁群优化算法（Ant Colony Optimization, ACO）来源于自然界觅食的最短路径原理。根据昆虫学家的观察，蚂蚁可以在没有任何提示的情况下找到从食物源到巢穴的最短路径，并且能在环境发生变化(如原有路径上有了障碍物)后，自适应地搜索新的最佳路径。这样由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化蚂蚁数量、可行路段、每条路段距离、每条路段的初始信息素大小等信息</span><br><span class="line"></span><br><span class="line">2. 设定蚂蚁的起点、终点。</span><br><span class="line"></span><br><span class="line">3. 蚂蚁从起点出发根据信息素浓度，有一定的概率性选择路段，浓度越高，概率越大，逐步回到终点。</span><br><span class="line"></span><br><span class="line">4. 在蚂蚁走过的路径上，根据每条路段的长度按比例释放信息素，短的路段释放的信息素多，长的路段释放的信息素少。</span><br><span class="line"></span><br><span class="line">5. 对所有路段的信息素进行挥发。</span><br><span class="line"></span><br><span class="line">6. 回到第二步进行循环，直到蚂蚁数量迭代完。</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="粒子群算法（PSO）"><a href="#粒子群算法（PSO）" class="headerlink" title="粒子群算法（PSO）"></a>粒子群算法（PSO）</h4><p>&emsp;&emsp;粒子群优化算法(PSO：Particle swarm optimization) 来源于对鸟群捕食的行为研究。通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step：</span><br><span class="line"></span><br><span class="line">1. 初始化离子的速度和位置</span><br><span class="line"></span><br><span class="line">2. 计算粒子适应度</span><br><span class="line"></span><br><span class="line">3. 获取粒子个体的最优值</span><br><span class="line"></span><br><span class="line">4. 获取全体的历史最优值</span><br><span class="line"></span><br><span class="line">5. 更新速度和位置</span><br><span class="line"></span><br><span class="line">6. 若不满足结束条件，则重复2~5</span><br></pre></td></tr></table></figure><p><strong>参数设定</strong></p><ul><li>种群数量：粒子群算法的最大特点就是速度快，因此初始种群取50-1000都是可以的，虽然初始种群越大收敛性会更好，不过太大了也会影响速度；</li><li>迭代次数：一般取100~4000，太少解不稳定，太多浪费时间。对于复杂问题，进化代数可以相应地提高；</li><li>惯性权重：该参数反映了个体历史成绩对现在的影响，一般取0.5~1；</li><li>学习因子：一般取0~4，此处要根据自变量的取值范围来定，并且学习因子分为个体和群体两种；</li><li>空间维数：粒子搜索的空间维数即为自变量的个数。</li><li>位置限制：限制粒子搜索的空间，即自变量的取值范围，对于无约束问题此处可以省略。</li><li>速度限制：如果粒子飞行速度过快，很可能直接飞过最优解位置，但是如果飞行速度过慢，会使得收敛速度变慢，因此设置合理的速度限制就很有必要了<br>&nbsp;</li></ul><p>实例：求解函数最大值</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220103202937.png" alt="image-20211227130748742" style="zoom:67%;" /><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line"><span class="comment">%% 初始化种群</span></span><br><span class="line">f= @(x)x .* <span class="built_in">sin</span>(x) .* <span class="built_in">cos</span>(<span class="number">2</span> * x) - <span class="number">2</span> * x .* <span class="built_in">sin</span>(<span class="number">3</span> * x); <span class="comment">% 函数表达式</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);ezplot(f,[<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">20</span>]);</span><br><span class="line">N = <span class="number">50</span>;                         <span class="comment">% 初始种群个数</span></span><br><span class="line">d = <span class="number">1</span>;                          <span class="comment">% 空间维数</span></span><br><span class="line">ger = <span class="number">100</span>;                      <span class="comment">% 最大迭代次数     </span></span><br><span class="line">limit = [<span class="number">0</span>, <span class="number">20</span>];                <span class="comment">% 设置位置参数限制</span></span><br><span class="line">vlimit = [<span class="number">-1</span>, <span class="number">1</span>];               <span class="comment">% 设置速度限制</span></span><br><span class="line">w = <span class="number">0.8</span>;                        <span class="comment">% 惯性权重</span></span><br><span class="line">c1 = <span class="number">0.5</span>;                       <span class="comment">% 自我学习因子</span></span><br><span class="line">c2 = <span class="number">0.5</span>;                       <span class="comment">% 群体学习因子 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:d</span><br><span class="line">    x = limit(<span class="built_in">i</span>, <span class="number">1</span>) + (limit(<span class="built_in">i</span>, <span class="number">2</span>) - limit(<span class="built_in">i</span>, <span class="number">1</span>)) * <span class="built_in">rand</span>(N, d);<span class="comment">%初始种群的位置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">v = <span class="built_in">rand</span>(N, d);                  <span class="comment">% 初始种群的速度</span></span><br><span class="line">xm = x;                          <span class="comment">% 每个个体的历史最佳位置</span></span><br><span class="line">ym = <span class="built_in">zeros</span>(<span class="number">1</span>, d);                <span class="comment">% 种群的历史最佳位置</span></span><br><span class="line">fxm = <span class="built_in">zeros</span>(N, <span class="number">1</span>);               <span class="comment">% 每个个体的历史最佳适应度</span></span><br><span class="line">fym = -<span class="built_in">inf</span>;                      <span class="comment">% 种群历史最佳适应度</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(xm, f(xm), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;初始状态图&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">%% 群体更新</span></span><br><span class="line">iter = <span class="number">1</span>;</span><br><span class="line">record = <span class="built_in">zeros</span>(ger, <span class="number">1</span>);          <span class="comment">% 记录器</span></span><br><span class="line"><span class="keyword">while</span> iter &lt;= ger</span><br><span class="line">     fx = f(x) ; <span class="comment">% 个体当前适应度   </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N      </span><br><span class="line">        <span class="keyword">if</span> fxm(<span class="built_in">i</span>) &lt; fx(<span class="built_in">i</span>)</span><br><span class="line">            fxm(<span class="built_in">i</span>) = fx(<span class="built_in">i</span>);     <span class="comment">% 更新个体历史最佳适应度</span></span><br><span class="line">            xm(<span class="built_in">i</span>,:) = x(<span class="built_in">i</span>,:);   <span class="comment">% 更新个体历史最佳位置</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> fym &lt; <span class="built_in">max</span>(fxm)</span><br><span class="line">        [fym, nmax] = <span class="built_in">max</span>(fxm);   <span class="comment">% 更新群体历史最佳适应度</span></span><br><span class="line">        ym = xm(nmax, :);      <span class="comment">% 更新群体历史最佳位置</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    v = v * w + c1 * <span class="built_in">rand</span> * (xm - x) + c2 * <span class="built_in">rand</span> * (<span class="built_in">repmat</span>(ym, N, <span class="number">1</span>) - x);<span class="comment">% 速度更新</span></span><br><span class="line">    <span class="comment">% 边界速度处理</span></span><br><span class="line">    v(v &gt; vlimit(<span class="number">2</span>)) = vlimit(<span class="number">2</span>);</span><br><span class="line">    v(v &lt; vlimit(<span class="number">1</span>)) = vlimit(<span class="number">1</span>);</span><br><span class="line">    x = x + v;<span class="comment">% 位置更新</span></span><br><span class="line">    <span class="comment">% 边界位置处理</span></span><br><span class="line">    x(x &gt; limit(<span class="number">2</span>)) = limit(<span class="number">2</span>);</span><br><span class="line">    x(x &lt; limit(<span class="number">1</span>)) = limit(<span class="number">1</span>);</span><br><span class="line">    record(iter) = fym;<span class="comment">%最大值记录</span></span><br><span class="line">     x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;状态位置变化&#x27;</span>)</span><br><span class="line">     pause(<span class="number">0.1</span>)</span><br><span class="line">    iter = iter+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);<span class="built_in">plot</span>(record);title(<span class="string">&#x27;收敛过程&#x27;</span>)</span><br><span class="line">x0 = <span class="number">0</span> : <span class="number">0.01</span> : <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);<span class="built_in">plot</span>(x0, f(x0), <span class="string">&#x27;b-&#x27;</span>, x, f(x), <span class="string">&#x27;ro&#x27;</span>);title(<span class="string">&#x27;最终状态位置&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最大值：&#x27;</span>,num2str(fym)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;变量取值：&#x27;</span>,num2str(ym)]);</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;启发式算法其实是一种试探法，相对于梯度下降法等类似方法而言，它更体现了随机性；相对于盲目搜索算法而言，它又具有一定的方向性。</p><p><strong>5个基本要素</strong></p><ul><li>随机初始化可行解</li><li>评价函数或目标函数的确定</li><li>新解的产生机制</li><li>新解的接受机制</li><li>终止准则</li></ul><p><strong>本质</strong></p><p>&emsp;&emsp;试探法的本质是并行、随机、有一定方向的搜索方法。综合试探法的要素和本质可以看出，试探法中新解的产生机制和接受机制对于算法的全局收敛能力十分重要，有助于克服局部最优问题。</p><blockquote><p>并行性的体现：</p><ul><li>遗传算法中每代种群具备一定数量</li><li>蚁群算法中蚂蚁的数量</li><li>模拟退火算法中内循环的体现（要求降温过程足够缓慢）</li><li>粒子群算法中粒子的数量</li></ul><p>随机性的体现：</p><ul><li>遗传算法中新解的产生机制（交叉和变异）</li><li>蚁群算法中新解的产生机制（释放信息素）</li><li>模拟退火算法中新解的产生机制</li><li>粒子群算法中新解的产生机制（自身经验和他人信息前面的随机系数r1和r2）</li></ul><p>方向性的体现（逐渐向最优解逼近）：</p><ul><li>遗传算法中新解的接受机制（精英保留策略、轮盘赌）</li><li>蚁群算法中新解的接受机制（新解的产生来自于所有蚂蚁留下信息素的引导）</li><li>模拟退火算法中新解的接受机制（Metropolis准则：绝对接受更优解，以一定概率接受较差的解，且随着温度的降低，接受较差解的概率降低，即开始降温过程搜索空间大，增强全局收敛能力，接近稳定状态，更不易接受较差解，使局部搜索更为精确）</li><li>粒子群算法中新解的产生机制（新解的产生来自于粒子本身最优解和所有粒子最优解的引导）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 优化问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G网络切片资源分配文献综述</title>
      <link href="/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/"/>
      <url>/2021/12/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Resource_Allocation_for_Network_Slicing_in_5G_Telecommunication_Networks_A_Survey_of_Principles_and_Models/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;随着网络需求的快速持续增长，5G网络需要为传统网络运营商、垂直行业、OTT、第三方满足不同服务质量 (QoS)、服务水平协议 (SLA) 和关键绩效指标 (KPI)的要求，在这种情况下，第四代 (4G) 电信网络的“一刀切”和“一网通”类型不再适用。</p><p>&emsp;&emsp;网络切片是一种很有前途的技术，它可以建立包含专用和共享资源的定制端到端逻辑网络，通过利用 SDN 和 NFV，可以定制与资源相关的网络切片，以满足不同的 QoS 和 SLA。网络切片的资源分配在负载均衡、资源利用率和网络性能方面起着举足轻重的作用。</p><p><strong>主要内容</strong></p><ul><li>SDN 和 NFV 的原理及其对网络切片的影响</li><li>网络切片的基本管理和编排（MO）架构</li><li>RAN和CN切片中的资源类型和相应的隔离级别</li><li>5G 网络切片资源分配算法的原理和数学模型</li><li>提出网络切片的几个开放问题以及潜在的解决方案</li></ul><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/Resource%20Allocation%20for%20Network%20Slicing%20in%205G%20Telecommunication%20Networks%20A%20Survey%20of%20Principles%20and%20Models.pdf">Resource Allocation for Network Slicing in 5G Telecommunication Networks A Survey of Principles and Models</a></p><span id="more"></span><p>&nbsp;</p><h2 id="网络切片"><a href="#网络切片" class="headerlink" title="网络切片"></a>网络切片</h2><p>&emsp;&emsp;作为 5G 中很有前途的技术之一，网络切片在电信网络基础设施上创建了端到端（即从无线电接入网络 (RAN) 到核心网络 (CN)）逻辑上独立的网络。每个逻辑上独立的网络称为网络切片，是为特定需求而设计的，由从底层通信和网络资源中抽象出来的若干网络功能和资源组成。网络切片的基本思想与云计算中的基础设施（即服务 IaaS） 的基本思想密切相关。 IaaS 在不同租户之间共享计算、存储和网络资源，并提供由软件定义网络 (SDN) 和网络功能虚拟化 (NFV) 支持的全功能虚拟网络。事实上，SDN和NFV被认为是5G背景下网络切片的关键技术。 SDN依靠控制平面和数据平面的分离来增强数据转发效率和网络可编程性，NFV 使虚拟网络功能 (VNF) 能够在通用硬件上运行以降低部署成本。网络切片作为多个 VNF 的组合，不仅可以提供灵活、可扩展和可编程的网络服务，还可以通过高效编排和管理 VNF 来降低资本支出 (CAPEX) 和运营支出 (OPEX)</p><p>&emsp;&emsp;作为5G电信网络的一个主要问题，网络切片的资源分配面临隔离、定制、弹性、端到端协调等诸多挑战。具体而言，在资源隔离方面，由于通信环境的变化，网络切片的共享和隔离资源并不简单。例如，无线电资源的严格隔离可能导致低复用增益。定制化实现网络切片的高效资源利用，满足特定的网络服务需求。如何将网络服务需求有效地转化为所需的网络资源，需要在不同层面进行更多的考虑，包括控制层面、数据平面层面、网络层面。例如，在时变数据流量下无法直接获得具有相应计算、存储和网络资源的虚拟机（VM）的确切数量。共享资源的动态分配可能会影响网络切片的网络性能。端到端资源分配必须跨越不同的域，例如 CN、RAN 和传输网络 (TN)。在不同网络层的异构技术之间实现新的协调并不容易。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="SDN-amp-NFV"><a href="#SDN-amp-NFV" class="headerlink" title="SDN &amp; NFV"></a>SDN &amp; NFV</h2><h4 id="software-defined-networking"><a href="#software-defined-networking" class="headerlink" title="software defined networking"></a>software defined networking</h4><p>&emsp;&emsp;在SDN的框架中，控制平面与数据平面完全分离，数据平面移动到一个由SDN控制器（Controller）实现的集中位置。 SDN控制器根据手头应用的需求，在链路探索、拓扑管理、策略部署、流表下发等方面生成不同的规则并发送给数据平面。数据平面中的转发设备，例如交换机和路由器，只需应用并执行这些规则。</p><h4 id="Network-Function-Virtualization"><a href="#Network-Function-Virtualization" class="headerlink" title="Network Function Virtualization"></a>Network Function Virtualization</h4><p>&emsp;&emsp;与传统电信设备中网络功能和专有硬件之间的紧密耦合不同，NFV 使网络功能能够以软件设备的形式在通用服务器上运行。为了在电信网络中高效灵活地利用虚拟资源和管理 VNF，欧洲电信标准协会 (ETSI) 提出了 NFV 管理和编排器 NFV-MANO，它由 NFV 编排 (NFVO)、VNF管理器 (VNFM) 和虚拟化基础设施管理器 (VIM)组成。 NFV-MANO 通过 VNFM 和 VIM 管理 VNF 的生命周期。 NFVO 负责编排与外部运营/业务支持系统 (BSS/OSS) 相结合的网络服务。</p><p>&emsp;&emsp;由于其可编程性、可扩展性和灵活性，SDN 和 NFV 被认为是网络切片的关键推动因素。例如，受SDN启发，演进分组核心（EPC）实现了控制面和用户面的分离，从而实现了网络功能的灵活部署。此外，因为 NFV-MANO 管理 VM 或容器对网络功能的创建、更新和终止，网络切片可以以低成本进行初始化和修改。 NFVO 可以在不同的网络环境中调整 VNF 与 VNFM 和 VIM 的资源分配，例如数据流量的波动、网络切片中用户的变化等。此外，当某些 VNF 发生故障时，SDN 数据平面中的路由器和交换机可以根据 SDN 控制器配置的流表或调度策略重新路由数据流量。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="MO架构"><a href="#MO架构" class="headerlink" title="MO架构"></a>MO架构</h2><p>&emsp;&emsp;Management and Orchestration Architecture of Network Slicing</p><p>&emsp;&emsp;网络切片的基本问题包括网络切片需求的描述和网络切片的部署及其生命周期管理。为了解决这些问题，第三代合作伙伴计划 (3GPP) 提出了具有相应网络功能的基本 MO 架构，包括通信服务管理功能 (CSMF)、网络切片管理功能 (NSMF) 和网络切片子网管理功能 (NSSMF) ，每个子网都有一个 NSSMF，例如：RAN、CN。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226105342.png" alt="image-20211226105335500" style="zoom: 50%;" /><p>&emsp;&emsp;在这种架构下，特定网络服务的需求由CMSF转换为网络切片的需求（即网络切片需求描述），传递给NSMF。然后，NSMF 将网络切片的需求分解为不同子网的需求。不同子网中的 NSSMF 管理和编排相应子网中的网络切片。例如，CN 中的 NSSMF 可以根据从 NSMF 接收到的网络服务的需求，求解出计算、存储和网络资源（即 VM 的资源）相关联的 VNF 的数量。然后，基本的 VNF 由 NFV-MANO 初始化，如图左侧所示。资源分配依赖于带有NFV-MANO的NSSMF，可以根据网络服务的需求计算所需的资源。此外，带有 NFV-MANO 的 NSSMF 可以通过升级或扩展网络功能来动态调整资源分配，这些功能由流量波动或网络切片需求的变化触发。在网络切片的 MO 架构下，隔离级别和数学模型在资源分配中扮演着重要的角色。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Resouce-Type-and-Isolation"><a href="#Resouce-Type-and-Isolation" class="headerlink" title="Resouce Type and Isolation"></a>Resouce Type and Isolation</h2><h4 id="RAN-Slicing"><a href="#RAN-Slicing" class="headerlink" title="RAN Slicing"></a>RAN Slicing</h4><p>&emsp;&emsp;频谱是 RAN 切片的基本无线资源，在长期演进 (4G LTE) 系统中，频谱资源被提取为资源块 (RB) 或物理资源块 (PRB)。具有专用 PRB 的网络切片严格确保所需的 QoS/SLA，而公共媒体访问控制 (MAC) 调度程序可以分配和管理共享 PRB 以适应弹性流量、变化的信道条件和 QoS 要求，从而增强资源弹性和复用增益。除了频谱资源以外，其他基本物理资源还有：包括传输功率和基站（BS）的缓存空间等。</p><p>&emsp;&emsp;基于 PRB 隔离，数据包调度作为一种高级隔离，负责决定使用空闲 PRB 处理数据流量的时间。最高级别的资源隔离是<strong>准入控制</strong>，它通过估计网络资源使用状态来确定是否在用户和 CN（即无线接入承载）之间建立数据传送服务。更一般地，准入控制还包括确定是否允许用户访问网络或是否接受网络切片请求。此外，<strong>用户关联</strong>是RAN切片中资源分配的重要步骤，它决定了用户是否与特定的BS相关联。用户关联发生在数据传输之前和用户准入控制之后。很难为用户关联确定不同的隔离级别，但值得注意的是它在负载平衡、无线电频谱效率和网络效率方面起着关键作用。</p><p>&emsp;&emsp;与传统的RAN架构相比，Cloud-RAN（C-RAN）将基带过程和远程无线接入分离。集中式基带单元 (BBU) 池、分布式多个远程射频头 (RRH)、通过光链路连接 BBU 池和 RRH 的前传网络以及将 BBU 池连接到 CN 的回程网络是 C-RAN的四个基本部分。 BBU池用于基带处理，建立在具有虚拟化技术的高性能通用硬件上，可以运行在虚拟机或容器上，以提高物理资源（如计算、存储、网络资源）的利用率。由于部署成本低，分布式 RRH 通过天线为用户提供无线接入，以低 CAPEX 和 OPEX 覆盖大面积区域。在设计资源分配算法时，BBU 池和具有前传带宽的 RRH 的容量是重要因素。此外，用户关联和回程容量也会影响资源分配。下图左侧总结了与 RAN 切片的资源类型相关的隔离级别。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226123601.png" alt="image-20211226123601454" style="zoom:67%;" /><h4 id="CN-Slicing"><a href="#CN-Slicing" class="headerlink" title="CN Slicing"></a>CN Slicing</h4><p>&emsp;&emsp;与4G中的EPC相比，5G核心网采用更加模块化的架构，将网络划分为更细粒度的网络功能。每个网络功能都可以以VM或容器的方式部署在虚拟平台上，由SDN和NFV进行管理和编排，提供灵活、可扩展、可编程的网络服务。CN 切片中的高级资源隔离可以是 VM 或容器，这意味着网络运营商利用 VM 或容器粒度的扩展/扩展操作来初始化或调整资源分配。</p><p>&emsp;&emsp;在NFV-MANO的框架下，一个CN切片由多个VNF组成，形成一个运行在底层网络上的虚拟网络。在这种情况下，CN 切片的资源分配被转换为虚拟网络嵌入 (VNE) 问题。VNE 提出了两个问题：将虚拟节点映射到物理节点，将连接虚拟节点的虚拟链路映射到连接物理节点的路径。物理节点和路径代表计算、存储和网络资源。在我们看来，VNE 可用于对 CN 切片以及 C-RAN 切片的某些部分（例如，BBU 容量的虚拟化）中的资源分配问题进行建模。 </p><p>CN 切片中的隔离级别和资源类型：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135025.png" alt="CN 切片中的隔离级别和资源类型" style="zoom: 67%;" /><p>无线资源管理、VNE和网络切片的资源分配之间的关系：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226135101.png" alt="image-20211226135101482" style="zoom:50%;" /><p>&nbsp;</p><h2 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h2><h4 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h4><p>&emsp;&emsp;很自然地将网络切片的资源分配问题表述为线性规划 (LP) 问题或非线性规划 (NLP) 问题，优化目标包括网络切片的吞吐量、资源利用率、下一次分配的剩余物理资源等。一般的约束是基站的传输功率、基于服务合同的每个网络切片的最小PRB数量、不同网络切片之间的分配公平性等，这些可能会因网络环境的变化和网络切片的多样化需求而变得复杂。因此，一些一般的优化问题很难在<strong>多项式时间</strong>内解决。采用结合多个隔离级别的<strong>启发式方法</strong>来推导出具有低计算复杂性的近乎最优的解决方案。</p><h5 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h5><blockquote><p>Dynamic Network Slicing for Multitenant Heterogeneous Cloud Radio Access Networks</p><p>“ This paper proposes a dynamic network slicing scheme for multitenant H-CRANs, which takes into account tenants’ priority, baseband resources, fronthaul and backhaul capacities, quality of service (QoS) and interference. The framework of the network slicing scheme consists of an upper-level, which manages admission control, user association and baseband resource allocation; and a lower-level, which performs radio resource allocation among users. ”</p></blockquote><p>如前所述，C-RAN 通过 BBU 池集中基带处理能力，BBU 池通过前传网络连接到多个 RRH，并通过回程网络连接到 CN。因此，BBU 池和前传/回传网络的容量作为新的约束，被用于 C-RAN 切片的一般优化问题的框架中。此文中的作者提出了一种分层资源分配方案，以最大化 C-RAN中所有网络切片的网络吞吐量。分层方案包括准入控制、用户关联、虚拟BBU容量分配作为上层分配，以及相应网络切片中每个用户的PRB和传输功率分配作为下层分配。当上层分配的最佳结果用于下层分配时，计算负担和大的信令开销会显着减轻。</p><p>&nbsp;</p><h5 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h5><blockquote><p>A Service-Oriented Deployment Policy of End-to-End  Network  Slicing  Based  on  Complex  Network  Theory</p><p>“  In this paper, a mathematical model is used to construct network slice requests and map them to the infrastructure network. The mapping process consists of two steps: the placement of virtual network functions and the selection of link paths chaining them. To efficiently utilize the limited physical resources, we pay attention to the service-oriented deployment by offering different deployment policies for three typical slices: eMBB slices, mMTC slices, and uRLLC slices. Furthermore, we adopt complex network theory to obtain the topological information of slices and infrastructure network. With the topological information, we define a node importance metric to rank the nodes in node mapping. To evaluate the performance of deployment policy we proposed, extensive simulations have been conducted.  ”</p></blockquote><p>此文中利用通用数学模型探索了端到端网络切片的资源分配。 RAN、传输网络(TN) 和CN 中的资源被抽象为计算和带宽资源。然后，将资源分配问题转化为VNE问题，根据不同的网络切片类型有不同的目标。例如，优化目标是最小化超可靠和低延迟通信 (uRLLC) 网络切片的数据包延迟。在为海量机器类型通信（mMTC）网络切片分配资源时，应最大化当前网络切片部署后剩余的物理链路数量。</p><p>&nbsp;</p><h4 id="博弈论经济模型"><a href="#博弈论经济模型" class="headerlink" title="博弈论经济模型"></a>博弈论经济模型</h4><blockquote><p>价格差异化是一种基于经济和博弈模型的简单方法，它根据不同的网络切片的特点，如流量模型、资源容量、所需资源数量、网络切片优先级等，为不同的网络切片分配不同的价格。一个典型的优化目标是基础设施提供商的收入。</p></blockquote><p>&emsp;&emsp;网络切片为传统网络运营商、垂直行业和第三方提供了新的商业机会。在5G网络切片的场景中，典型的参与者有3个：网络运营商、网络切片的租户、网络切片的用户。网络运营商（例如基础设施提供商）提供包括物理资源和虚拟资源在内的网络基础设施，并建立网络切片以满足网络服务的要求;网络切片的租户（即网络服务提供商）向网络运营商提出网络服务需求，并为用户提供网络服务;用户（例如，用户设备UE）使用网络切片提供的网络服务。与上面讨论的一般模型相比，经济模型和博弈模型提供了复杂而有效的方法来描述这三个参与者之间的关系，可以制定优化问题，例如网络资源分配的公平性、网络的利润最大化。网络切片的运营商或租户，以及网络切片用户的成本最小化。例如，预算、成本、收入、利润和价格等经济因素对这些玩家在游戏过程中的资源分配有显着影响。经济和博弈模型可以在不牺牲资源分配公平性的前提下，为基础设施提供商的收入或利润最大化提供可行的解决方案。</p><h5 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h5><blockquote><p>Optimising 5G infrastructure markets: The business of network slicing</p><p>“ In this paper, we address this issue by designing an algorithm for the admission and allocation of network slices requests that (i) maximises the infrastructure provider’s revenue and (ii) ensures that the service guarantees provided to tenants are satisfied. Our key contributions include: (i) an analytical model for the admissibility region of a network slicing-capable 5G Network, (ii) the analysis of the system (modelled as a Semi-Markov Decision Process) and the optimisation of the infrastructure provider’s revenue, and (iii) the design of an adaptive algorithm <strong>(based on Q-learning)</strong> that achieves close to optimal performance. ”</p></blockquote><p>网络切片根据其流量模型定价不同，包括<strong>弹性</strong>和<strong>非弹性</strong>数据流量模型 。本文进一步推导出弹性网络切片和非弹性网络切片数量之间的关系，该关系在最大接纳非弹性网络切片数量和非弹性网络切片和弹性网络切片的固定总和的限制下。基于关系和价格差异，提出了一种结合半马尔可夫决策过程（SMDP）的价值迭代算法来搜索网络切片请求的最佳准入控制，以最大化基础设施提供商的收入。</p><p>&nbsp;</p><h5 id="example-4"><a href="#example-4" class="headerlink" title="example 4"></a>example 4</h5><blockquote><p>Network Slicing Games: Enabling Customization in Multi-Tenant Mobile Networks</p><p>“ This paper provides an analysis of a well-known model for resource sharing, the share-constrained proportional allocation mechanism, to realize network slicing. This mechanism enables tenants to reap the performance benefits of sharing, while retaining the ability to customize their own users’ allocation. This results in a network slicing game in which each tenant reacts to the user allocations of the other tenants so as to maximize its own utility. We show that, for elastic traffic, the game associated with such strategic behavior converges to a Nash equilibrium. At the Nash equilibrium, a tenant always achieves the same or better performance than that of a static partitioning of resources, thus providing the same level of protection as static partitioning. We further analyze the efficiency and fairness of the resulting allocations, providing tight bounds for the price of anarchy and envy-freeness. Our analysis and extensive simulation results confirm that the mechanism provides a comprehensive practical solution to realize network slicing. Our theoretical results also fills a gap in the analysis of this resource allocation model under strategic players. ”</p></blockquote><p>费雪（Fisher）市场作为一种著名的经济模型，被用来研究用户和网络切片之间的公平性。 Fisher 市场中预算固定的购买者映射成共享网络资源的网络切片租户、买家的出价被映射成网络切片租户的偏好。在 5G 网络切片场景中，网络切片的租户可以根据资源拥塞情况动态调整其偏好，以最大化自身效用。在这种情况下，资源分配问题转化为如何通过<strong>非合作博弈</strong>共同考虑网络切片的偏好和用户公平性来为网络切片分配资源。</p><p>&nbsp;</p><h5 id="example-5"><a href="#example-5" class="headerlink" title="example 5"></a>example 5</h5><blockquote><p>Coalitional Game for the Creation of Efficient Virtual Core Network Slices in 5G Mobile Systems</p><p>“ Our contribution in this paper is twofold. First, we devise an algorithm that derives the optimal number of virtual instances of 4G (MME, SGW, and PGW) or 5G (AMF, SMF, and AUSF) core network elements to meet the requirements of a specific mobile traffic. Second, we propose an algorithm for the placement of these virtual instances over a federated cloud. While the first algorithm is based on mixed integer linear programming, the second is based on coalition formation game, wherein the aim is to build coalitions of cloud networks to host the virtual instances of the vEPC/5G core elements. ”</p></blockquote><p>与预测和分析非合作博弈中每个玩家的行为不同，<strong>合作博弈</strong>调查由单个玩家或外部强制（例如合同规则）形成的玩家之间的联盟。联盟的组成、联盟产生时的联合行动、联盟已经形成时的集体收益是合作博弈的研究兴趣。以CN切片为例。 VNF放置问题在合作博弈的框架下通过两步解决。首先，在同一个云网络中，制定了一个优化问题，旨在通过调整 VNF 的数量来最小化 VNF 的创建成本。然后讨论如何将这些 VNF 放置在不同的云网络中，以保证 QoS/SLA 并最大化每个云网络的利润。事实上，部署了 VNF 的不同云网络可以形成不同的联盟。</p><p>&nbsp;</p><h4 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h4><p>&emsp;&emsp;预测模型用于根据经验知识或历史信息预测适当或最佳的资源数量。预测对象包括:用户到达率、网络切片中的数据流量、网络切片请求等。简单的预测方法直接使用经验数据或一些众所周知的概率模型。</p><h5 id="example-6"><a href="#example-6" class="headerlink" title="example 6"></a>example 6</h5><blockquote><p>Conformal Mapping  for  Optimal  Network  Slice  Planning  Based  on  Canonical   Domains</p><p>“ This paper addresses this issue by mapping the non-uniform distribution of signaling messages in the physical domain to a new uniform environment (i.e., canonical domain) whereby the placement of core functions is more feasible and efficient by means of Schwartz-Christoffel conformal mappings. The experimentation results, compared to some baseline approaches, have proven the efficiency of the conformal mapping based placement in allocating the virtual resources (i.e., virtual CPU and virtual storage) with regard to the optimal end-to-end delay, cost and activated virtual machines. Another interesting contribution is that all placement decisions are based on a realistic spatio-temporal user-centric model, which defines both the mobility of user equipments and the underlying service usage. “</p></blockquote><p>与使用合作博弈的 VNF 放置不同，VNF 的位置由会话请求到达率的<strong>概率分布</strong>决定。假设会话请求的到达率在物理域中遵循非均匀分布，通过 Schwarz-Christoffel 映射将其转换为规范域中的均匀分布。然后根据会话请求的数量和会话请求的到达率，很容易推导出规范域中 VNF 的最佳数量和位置。而VNFs在物理域中的对应位置可以通过逆空间变换函数得到。</p><p>&nbsp;</p><h5 id="example-7"><a href="#example-7" class="headerlink" title="example 7"></a>example 7</h5><blockquote><p>Mobile Traffic Forecasting for Maximizing 5G Network Slicing Resource Utilization</p><p>“ This paper focuses on the design of three key network slicing building blocks responsible for (i) traffic analysis and prediction per network slice, (ii) admission control decisions for network slice requests, and (iii) adaptive correction of the forecasted load based on measured deviations. Our results show very substantial potential gains in terms of system utilization as well as a trade-off between conservative forecasting configurations versus more aggressive ones (higher gains, SLA risk). ”</p></blockquote><p>基于时间序列的预测模型作为回归预测，根据过去的观察以及<strong>时间序列预测</strong>网络切片中的统计特征。与经验知识相比，基于时间序列的预测模型更实用，适用于不同的网络环境。 Holt-Winters (HW) 模型优于基本模型和双指数平滑模型，作为一种复杂的时间序列模型，不仅可以捕捉数据趋势，还可以捕捉数据季节性。在本文中，当用户数量固定时，HW模型用于分析网络切片中未来的流量请求。此外，当用户在多蜂窝环境中移动时，网络切片的流量模型也由 HW 模型预测。值得注意的是，每个被接纳的网络切片都设计了反馈机制，以提高硬件模型的预测精度。</p><p>&nbsp;</p><h5 id="example-8"><a href="#example-8" class="headerlink" title="example 8"></a>example 8</h5><blockquote><p>Information Prediction and Dynamic Programming Based RAN Slicing for Mobile Edge Computing</p><p>“ In this letter, the work is focused on the RAN slicing between MEC services and traditional services. An information prediction and dynamic programming based RAN slicing algorithm is proposed. It guarantees the inter-slice isolation and realizes the intra-slice customization. Furthermore, it can optimize the network utility with high fairness in polynomial time complexity. ”</p></blockquote><p>机器学习根据历史数据和决策生成最优或次优策略，适用于没有统一概率分布的场景。例如，支持向量回归（SVR）作为机器学习中的典型分类算法，用于预测时分双工(FDD)-OFDMA无线网络中网络切片的统计特征值。更具体地说，本文中的作者针对不同的上行/下行配置实现了移动边缘计算（MEC）和传统网络服务的RAN切片的资源分配。该配置被表述为具有网络切片统计特征的封闭式表达式，包括能量开销、运行时开销以及上下行链路的流量和数据速率。MEC 和传统网络服务的最佳配置是从封闭形式的表达式中导出的，其中包含 SVG 预测的统计特征值。</p><p>&nbsp;</p><h4 id="鲁棒性和故障恢复模型"><a href="#鲁棒性和故障恢复模型" class="headerlink" title="鲁棒性和故障恢复模型"></a>鲁棒性和故障恢复模型</h4><p>&emsp;&emsp;网络切片的资源分配算法不仅要提高资源利用效率，还要处理不可预测的网络事件，以实现电信网络的高可用性。不可预知的网络事件包括网络拥塞（由大量数据流量引起）或网络功能故障（由软件或硬件意外故障引起）。冗余资源预留和网络功能重新映射是两种有效的方法。</p><h5 id="example-9"><a href="#example-9" class="headerlink" title="example 9"></a>example 9</h5><blockquote><p>Optimisation  Models  for  Robust  and Survivable Network Slice Design: A Comparative Analysis</p><p>“ In this work, we first outline a mathematical model for the general network slice design problem and extend it to cope with traffic uncertainties. We employ the Γ-robust uncertainty set [1], [2] to model the uncertainties in the traffic demands. Furthermore, we add survivability aspects to our model by protecting the network slice against single substrate network element (node/link) failures. Finally, both survivability and traffic robustness approaches are considered simultaneously and we present two different optimisation models. A performance evaluation is carried out comparing the different robust and survivable models with their non-robust non-survivable counterpart using network topology examples from SNDlib. ”</p></blockquote><p>冗余资源预留为网络切片提供额外资源，例如多个 VNF 实例，以避免网络功能故障。网络切片的不确定流量由机会约束模型 [14] 表示为对称和随机变量。该变量作为保护级别，分别加入到虚拟节点和虚拟链路的容量约束中，以保证网络切片的鲁棒性。网络功能的重新映射通过将失败的 VNF 映射到好的 VNF 并重新路由失败的虚拟链接来恢复网络服务。</p><p>&nbsp;</p><h5 id="example-10"><a href="#example-10" class="headerlink" title="example 10"></a>example 10</h5><blockquote><p>Protocol Function Block Mapping of Software Defined Protocol for 5G Mobile Networks</p><p>“ In this paper, we propose software-defined protocol (SDP) technique to facilitate flexible service-oriented protocol stack deployment for providing high-throughput, low-latency and elastic mobile services based on platform virtualization and functionality modularization. We first elaborate the principle of SDP and then address one of the most important issues in SDP, namely SDP request mapping (SDPM), where an SDP request is fulfilled by mapping a set of required SDP function blocks and virtual links onto underlying SDP servers. We formulate the SDPM problem as a mixed integer programming (MIP). To address the NP-hardness and scalability of SDPM problem, we propose a decomposition algorithm which breaks down the SDPM problem into inter-block link and block mapping problems to accomplish the upper bound (UB) and lower bound (LB) of the MIP solution, respectively. The optimality can be achieved when the UB and the LB converges by using iterations. We employ LTE Layer-2 data-plane processing as a benchmark for validating the effectiveness of the SDP technique and evaluate the performance of SDPM algorithm. Numerical results show that SDP is effective to provide elastic low-latency mobile services and the proposed SDPM algorithm significantly outperforms the benchmark in stack processing delay, mapping cost, and resource utilization. “</p></blockquote><p>优化目标是在重新映射期间最小化总带宽消耗。</p><p>&nbsp;</p><h3 id="4种模型对比"><a href="#4种模型对比" class="headerlink" title="4种模型对比"></a>4种模型对比</h3><p>图中说明了四种数学模型之间的关系，每个饼图中每种方法的比例代表了相应的研究潜力：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161345.png" alt="image-20211226161345382" style="zoom: 33%;" /><p>表中根据目标、资源类型、场景和关键描述总结了所讨论的算法：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211226161507.png" alt="image-20211226161507843" style="zoom:50%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="网络切片潜力研究方向"><a href="#网络切片潜力研究方向" class="headerlink" title="网络切片潜力研究方向"></a>网络切片潜力研究方向</h3><h4 id="资源分配的更新周期"><a href="#资源分配的更新周期" class="headerlink" title="资源分配的更新周期"></a>资源分配的更新周期</h4><p>&emsp;&emsp;为了尽可能降低资源分配算法的计算复杂度，前面提出了启发式方法以提供具有低计算复杂度的次优解决方案。而<strong>多级资源分配</strong>则是另一种方式，包括准入控制、用户关联等。然而，很少有研究报告或出版物讨论资源分配算法的更新周期。合适的更新间隔不仅可以提高资源利用率，还可以减少信令开销和计算负担。在example1中，作者指出分配PRB的周期不能短于信道条件报告的周期。较长的更新周期在慢变通道中是可行的解决方案，但在快变通道中可能无法实现高性能。此外，在设计资源分配更新周期时，可以综合考虑用户数量的变化、数据流量的波动以及网络功能故障的平均周期。</p><p>&nbsp;</p><h4 id="无线电接入技术-RATs-的异质性"><a href="#无线电接入技术-RATs-的异质性" class="headerlink" title="无线电接入技术 (RATs) 的异质性"></a>无线电接入技术 (RATs) 的异质性</h4><p>&emsp;&emsp;5G 预计将跨越和聚合多种异构 RAT，例如 3G、4G、LTE 和 WiFi。 5G网络切片中不同RAT的协作变得尤为重要，应满足网络切片的多样化需求。例如，车联网 (V2X) 网络切片中的车载信息娱乐应用依赖 LTE 和 WiFi 来提高网络吞吐量。在 mMTC 网络切片上运行的窄带物联网 (NB-IoT) 应用可能需要多种 RAT 来增强网络连接。当前的算法侧重于密集的异构无线网络，并研究宏蜂窝和小蜂窝之间的合作，对于不同的网络切片，可以在无缝切换、流量隔离和网络切片公平性等方面进一步研究多制式的资源分配，以增强用户体验，提高资源利用率。</p><p>&nbsp;</p><h4 id="端到端网络切片的资源分配"><a href="#端到端网络切片的资源分配" class="headerlink" title="端到端网络切片的资源分配"></a>端到端网络切片的资源分配</h4><p>&emsp;&emsp;大多数当前的资源分配算法都集中在单个子网，例如 RAN 或 CN。除了example2中的解决方案，很少有研究人员考虑端到端的网络切片。无线电和虚拟机的资源分别抽象为带宽和计算资源，在为特定的网络切片类型设计资源分配方案时只考虑其中之一。事实上，SLA 分解和多子网协调是端到端网络切片资源分配的主要挑战。由于缺乏基本的通信知识，网络切片的租户可能只向 NSMF 提供端到端的 SLA，而不需要每个子网。因此，如何将端到端的 SLA 分解为各个子网的需求是资源分配的必然步骤。SLA分解不仅要考虑端到端的容量，还要考虑每个子网的容量。多个子网之间的协调也很重要，尤其是在更新资源分配时。每个子网应定期通过 NSSMF 向 NSMF 报告其剩余容量，NSMF 可以实现资源分配的适当调整，以适应不断变化的网络环境。例如，如果某些子网过载，则应向 NSMF 报告，然后允许剩余的子网获得更多资源以保证所需的端到端 SLA。潜在的数学模型应该基于多运营商核心网（MOCN）和网关核心网（GWCN）精心设计，这是不同子网之间资源共享的两种基本架构。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每月歌单</title>
      <link href="/2021/12/09/test/"/>
      <url>/2021/12/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分享每月歌单</p><span id="more"></span><h5 id="2021-12"><a href="#2021-12" class="headerlink" title="2021-12"></a>2021-12</h5><p># 歌曲模板</p>    <div id="aplayer-QUJNlHiI" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p># 歌单模板</p>    <div id="aplayer-ICqIjRYT" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于令牌桶算法的LTE下行链路调度器设计</title>
      <link href="/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/"/>
      <url>/2021/12/03/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91DL%20Packet%20Scheduler%20by%20Token%20Bucket%20Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&emsp;&emsp;LTE网络支持共享无线接入和核心网络资源的不同类型的服务，包括：尽力而为、延迟敏感和实时（RT）服务。每种服务在比特率、延迟和分组丢失方面都有不同的QoS要求。</p><p>&emsp;&emsp;基站eNB的第一个目标是为UE提供高频谱效率，使更多的活跃用户可以在网络中接收服务。第二个目标是用户对接收的服务质量（QoS）的满意度。为了实现这些目标，eNB中的资源分配必须知道信道条件、UE请求的服务类型和其他参数。</p><p>&emsp;&emsp;eNB将一个小区中的可用无线电资源分配给活动用户（Active UE）。因此需要设计合适的调度算法来支持具有不同QoS要求的业务，尤其是RT业务。</p><p><strong>原文</strong></p><p><a href="https://lrk612.com/resources/A%20QoS%20aware%20Downlink%20Packet%20Scheduler%20Using%20Token%20Bucket%20Algorithm%20for%20LTE%20Systems.pdf">A QoS aware Downlink Packet Scheduler Using Token Bucket Algorithm for LTE Systems</a></p><span id="more"></span><p>&nbsp;</p><h3 id="现有调度算法研究"><a href="#现有调度算法研究" class="headerlink" title="现有调度算法研究"></a>现有调度算法研究</h3><ol><li><p>LTE下行链路中指数/比例公平（EXP/PF）和改进的最大加权延迟优先（M-LDWF）</p><p>都只在一个域中执行调度过程</p><p>带宽为5MHz的系统中，M-LDWF比EXP/PF提供了更多的吞吐量，但是EXP/PF满足了更多用户的QoS要求（RT用户所需的带宽因素所导致）</p><p>建议在低负载网络中使用M-LDWF，在网络负载增加时使用EXP/PF[2]</p></li><li><p>利用CQI反馈发送来自用户的空闲缓冲区值的报告以及实时和非实时服务的QoS需求，比PF具有更高的吞吐量，并且降低了丢包概率。[3]</p></li><li><p>VOIP流量调度的一些算法满足了该服务的QoS要求，并防止了由于优先考虑网络中的VOIP服务引起的不良影响。它通过分组丢弃来调整给予VOIP的优先级的持续时间。[4]</p></li><li><p>有的算法使用了时域和频域两级调度器，在用户之间保证了公平性，时域（TD）调度器提供用户所需的QoS参数，而频域（FD）调度器根据TD调度器给定的输入实现最高的频谱效率。[8]</p><p>该论文的另一个结论是，TD-BET/FD-TA调度器在平均小区吞吐量和小区覆盖率方面优于TD-PF/FD-PF调度器。</p></li><li><p>另一个算法也是时域和频域两级调度器，在时域中使用PF算法来实现用户之间的公平性，而在FD中比较不同的算法。结论：与TD-PF调度器相比，TD-PF/FD-PF两级调度器具有更好的吞吐量和公平性。[9]</p></li><li><p>还有一个算法也是时域和频域两级调度器，将业务划分为两类：GBR类和nGBR类。时域中用PF算法列出应调度的用户，然后频域通过PF算法分配资源，可满足多个流量场景所需的QoS。[12]</p></li></ol><p>&emsp;&emsp;在之前的工作中，与GBR相关的流量通常在eNB中处理的优先级最高。虽然保障了GBR业务的时延性能，但是会导致小区的整体性能降低。</p><p>&emsp;&emsp;本论文提出了一种QoS感知的调度方法，包含时域和频域。先使用经典的五元组将不同的流映射到不同的载波。将VOIP和video流量分为GBR类、FTP和HTTP分为nGBR类。在GBR类中利用令牌桶算法来阻止其使用所有资源。这种不仅保证了两个类间资源分配的公平性，还提高了系统的总吞吐量。</p><p>&nbsp;</p><h3 id="LTE下行链路调度器"><a href="#LTE下行链路调度器" class="headerlink" title="LTE下行链路调度器"></a>LTE下行链路调度器</h3><p>&emsp;&emsp;正交频分多址（OFDMA）将分布在整个频谱中的一组子载波专用于用户。带宽被划分为180kHz的子信道，包括12个连续的子载波。时间/频率无线电资源扩展到时域中的两个时隙和频域中的一个子信道上，称为资源块（RB），是LTE中用于资源分配的最小单元。RBs的数量取决于系统带宽，例如，对于5 MHz系统，RBs数量为25，而在10 MHz系统中，RBs数量为50。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20220120200737.png" alt="image-20220120200737207" style="zoom:50%;" /><center>RB就是图中的小方块</center><p>&emsp;&emsp;eNB使用信道状态信息获取每个用户链路上的信息。用户在每个TTI中向eNB报告其下行链路流状态。数据包优先级由eNB的调度器根据数据包延迟、下行链路状态、缓冲区状态、流量类型等参数确定。而特定数据包流的专用RB数量取决于调度器中使用的资源分配算法。以前大多数工作中的数据包调度器有两个阶段。先是时域调度器基于调度算法（自行设计）的输入参数选出请求服务的用户，然后频域调度器按照算法（自行设计）将资源分配给时域中选择出的用户。分组调度器使用CQI获取所有rb中的每个信道的质量信息。</p><p>&nbsp;</p><h3 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h3><h5 id="业务分类"><a href="#业务分类" class="headerlink" title="业务分类"></a>业务分类</h5><p>&emsp;&emsp;VOIP、Conversational Video 归为 GBR业务</p><p>&emsp;&emsp;FTP、HTTP 归为 nGBR业务</p><h5 id="时域调度"><a href="#时域调度" class="headerlink" title="时域调度"></a>时域调度</h5><p>&emsp;&emsp;TD调度器最重要的功能是根据QoS参数和信道的当前状态选择请求资源的活动用户（Activate UE）。</p><p>&emsp;&emsp;在没有资源分配给用户的第一阶段，TD调度器确定不同类别的活动Bearer（activate bearers），并根据不同的需求对它们进行优先级排序。由于TD调度器没有关于分配给每个用户的RBs的信息，因此利用所有RBs上的用户cqi的平均值来比较用户的信道条件，获取最大度量值的用户具有最高优先级。TD调度器创建用户和活动Bearer，分为GBR组和nGBR组并按优先级排序，并向FD调度器发送这两个单独的列表。</p><h6 id="GBR"><a href="#GBR" class="headerlink" title="GBR"></a>GBR</h6><p>&emsp;&emsp;GBR Bearer必须保证数据速率，与对延迟敏感的应用相关。本算法中GBR Bearer的QoS参数计算如下：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080439.png" alt="image-20211201173407839" style="zoom:50%;" /><p>&emsp;&emsp;注意，在eNB缓冲区中花费更多时间的数据包具有更高的服务交付优先级。</p><h6 id="nGBR"><a href="#nGBR" class="headerlink" title="nGBR"></a>nGBR</h6><p>&emsp;&emsp;nGBR Bearer通常包括尽力而为的服务，对延迟不敏感。nGBR类的不同活动Bearer根据不同的条件进行优先级排序。优先级排序使用nGBR的优先级因子完成，其行为类似于WPF算法，做了一些轻微的修改。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184317.png" alt="image-20211201184317270" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201184346.png" alt="image-20211201184346056" style="zoom:50%;" /><p>&emsp;&emsp;参数 r 较大的nGBR用户在资源分配中优先于其他用户。</p><p>&nbsp;</p><h5 id="频域调度"><a href="#频域调度" class="headerlink" title="频域调度"></a>频域调度</h5><p>&emsp;&emsp;FD调度器负责将RBs分配给不同的Active UE。FD调度器根据TD调度器发来的候选列表来确定在特定TTI中必须服务哪些Bearer。FD调度器优先服务于GBR Bearer，然后服务于nGBR Bearer。通过令牌桶算法确定允许分配资源的GBR Bearer，然后使用改进的LWDF、M-LWDFS对这些Bearer进行调度。<strong>（这里与流程图不符，流程图是PF算法调度）</strong></p><p>&emsp;&emsp;当GBR流量或相关令牌分配完后，FD调度器开始将资源分配给nGBR用户。采用了PF算法，在用户公平性和小区整体性能之间取得了较好的平衡。该算法计算用户信道的当前状态和先前接收的服务但是却不考虑QoS，因此PF适合非RT流量而不适合RT流量。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201185426.png" alt="image-20211201185425952" style="zoom:50%;" /><p>&emsp;&emsp;FD完整流程：</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201191306.png" alt="image-20211201191306507" style="zoom:50%;" /><p>&nbsp;</p><h3 id="仿真比较结果"><a href="#仿真比较结果" class="headerlink" title="仿真比较结果"></a>仿真比较结果</h3><p>&emsp;&emsp;为了研究提出的调度器在RT流量情况下对资源分配系统的影响，文章还模拟了TD-PF/FD-PF算法以及无令牌桶的情况。TD-PF/FD-PF算法虽然依据信道状态和服务质量，但是却并不考虑QoS，因此在RT流量业务的表现不佳。无令牌桶调度虽然考虑了QoS性能，但是由于GBR Bearer的优先级高于nGBR Bearer的优先级，而没有令牌桶对流量进行限制，因此当BGR业务需求较高时，nBGR业务无法顾及导致小区整体吞吐量降低。含令牌桶的调度是二者的折中，即维护了小区整体的吞吐量，又对RT流量业务的时延性能有所保证。</p><h6 id="三种业务情景"><a href="#三种业务情景" class="headerlink" title="三种业务情景"></a>三种业务情景</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192306.png" alt="image-20211201192305975" style="zoom:50%;" /><h6 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h6><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211203080440.png" alt="image-20211201192342289" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192359.png" alt="image-20211201192359425" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192413.png" alt="image-20211201192413873" style="zoom:50%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211201192430.png" alt="image-20211201192430785" style="zoom:50%;" /><p>&nbsp;</p><h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>&emsp;&emsp;其实这个令牌桶算法没有什么精巧的地方，无非是限制了对GBR业务资源分配，这样就能发论文，虽然是很多年前的了，但是一下让我觉得发论文也不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network Slice </tag>
            
            <tag> Token Bucket </tag>
            
            <tag> Resource Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab音频滤波</title>
      <link href="/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/02/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91Matlab%20%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Matlab-音频信号处理"><a href="#Matlab-音频信号处理" class="headerlink" title="Matlab 音频信号处理"></a>Matlab 音频信号处理</h2><p>&emsp;&emsp;现有原始音频文件<code>SunshineSquare.wav</code>，后半段音频被人为加上了多频段的噪音，使用matlab工具对其进行分析并消除噪音还原出无噪音频文件。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><span id="more"></span><p>&nbsp;</p><h3 id="Step1：分析原始音频文件"><a href="#Step1：分析原始音频文件" class="headerlink" title="Step1：分析原始音频文件"></a>Step1：分析原始音频文件</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[audio_data, fs] = audioread(<span class="string">&#x27;../../SunshineSquare.wav&#x27;</span>);</span><br><span class="line">L = <span class="built_in">length</span>(audio_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一听该音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br></pre></td></tr></table></figure><h4 id="绘制时域图"><a href="#绘制时域图" class="headerlink" title="绘制时域图"></a>绘制时域图</h4><p>&emsp;&emsp;从下面时域图中可以看出，源音频文件时长11秒左右，从第8秒左右开始为一段强噪声。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Original&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = (<span class="number">1</span> : L) * <span class="number">1</span>/fs;</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="built_in">plot</span>(tt, audio_data);grid;</span><br><span class="line">title(<span class="string">&#x27;Time Domain&#x27;</span>);xlabel(<span class="string">&#x27;时间（s）&#x27;</span>);ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143427.png" alt="image-20211128143420786"></p><h4 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h4><p>&emsp;&emsp;使用快速傅里叶变换FFT对时域信号进行频谱分析，绘制的频域图反映出有四段噪声频段，后续消除噪声工作就是对这四个频段进行滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="number">2</span>^<span class="built_in">nextpow2</span>(L); <span class="comment">% 先从原始信号长度确定下一个 2 次幂的新长度,用尾随零填充信号以改善 fft 的性能</span></span><br><span class="line">Spectrum = fft(audio_data,L); <span class="comment">% 快速傅里叶变换，转换为频域</span></span><br><span class="line">f_x = fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L; <span class="comment">% 定义频域，即变换横坐标量纲为频率</span></span><br><span class="line">mag_FFT_audio_data = <span class="built_in">abs</span>(Spectrum / L); <span class="comment">% 取幅值，并归一化</span></span><br><span class="line">ang_FFT_audio_data = <span class="built_in">angle</span>(Spectrum)*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="built_in">plot</span>(f_x,mag_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="built_in">plot</span>(f_x,ang_FFT_audio_data(<span class="number">1</span> : L/<span class="number">2</span>+<span class="number">1</span>)) </span><br><span class="line">title(<span class="string">&#x27;Frequency Domain&#x27;</span>);xlabel(<span class="string">&#x27;频率（Hz）&#x27;</span>);ylabel(<span class="string">&#x27;ang&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143455.png" alt="image-20211128143455368"></p><h4 id="绘制声谱图"><a href="#绘制声谱图" class="headerlink" title="绘制声谱图"></a>绘制声谱图</h4><p>&emsp;&emsp;声谱图能够以颜色反映各频段信号强度随时间的变化和分布情况，如图所示，从第8秒左右开始有4个频段的强度持续较高，这就是上面频域分析出的4个噪声频段。但需要注意到，在噪声的开始和结束时刻，所有频段的强度都很高，在图中显示为两条垂直的黄线，这两条线仅靠滤波无法消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">spectrogram(audio_data,hann(<span class="number">256</span>),<span class="number">250</span>,<span class="number">256</span>,fs,<span class="string">&#x27;yaxis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128143558.png" alt="image-20211128143558882"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step2：滤波"><a href="#Step2：滤波" class="headerlink" title="Step2：滤波"></a>Step2：滤波</h3><h4 id="滤波法1——手动衰减"><a href="#滤波法1——手动衰减" class="headerlink" title="滤波法1——手动衰减"></a>滤波法1——手动衰减</h4><p>&emsp;&emsp;手动衰减各个噪声频段的幅度，注意FFT变换后的频谱图为偶对称，所以共有4对（8个）频段，逐一消除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第一个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第二个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第三个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第四个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第五个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第六个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第七个噪声频段</span></span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">max</span>(Spectrum)</span><br><span class="line">Spectrum(n<span class="number">-850</span>: n+<span class="number">850</span>) = <span class="number">0</span>; <span class="comment">% 第八个噪声频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆fft获得处理后的音频</span></span><br><span class="line">ifft_data = <span class="built_in">real</span>(ifft(Spectrum, L));</span><br><span class="line">audio_data = ifft_data(<span class="number">1</span>:<span class="built_in">length</span>(audio_data));</span><br></pre></td></tr></table></figure><h5 id="滤波效果"><a href="#滤波效果" class="headerlink" title="滤波效果"></a>滤波效果</h5><p>&emsp;&emsp;绘制滤波后音频信号的时域图、频域图、声谱图，可看见时域图上噪声被消除，频谱图上4个频段的信号全部被消除，声谱图有四条水平的消磨痕迹。</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211130213111.png" alt="image-20211130213111056"></p><p>&nbsp;</p><h4 id="滤波法2——数字滤波器"><a href="#滤波法2——数字滤波器" class="headerlink" title="滤波法2——数字滤波器"></a>滤波法2——数字滤波器</h4><p>&emsp;&emsp;设计梳状滤波器，因为有4个噪声频段，所以设计4个带阻滤波器逐一滤波。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%h1[n] = [1,-2,1];</span></span><br><span class="line">h1 = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>];</span><br><span class="line">h2 = [<span class="number">1</span>,<span class="number">-1.24698</span>,<span class="number">1</span>];</span><br><span class="line">h3 = [<span class="number">1</span>,<span class="number">0.44504</span>,<span class="number">1</span>];</span><br><span class="line">h4 = [<span class="number">1</span>,<span class="number">1.80194</span>,<span class="number">1</span>];</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波过程</span></span><br><span class="line">audio_data_h1 = filter(h1,a,audio_data);</span><br><span class="line">audio_data_h2 = filter(h2,a,audio_data_h1);</span><br><span class="line">audio_data_h3 = filter(h3,a,audio_data_h2);</span><br><span class="line">audio_data_h4 = filter(h4,a,audio_data_h3);</span><br><span class="line"></span><br><span class="line">audio_data = audio_data_h4;</span><br></pre></td></tr></table></figure><h6 id="滤波器分析"><a href="#滤波器分析" class="headerlink" title="滤波器分析"></a>滤波器分析</h6><p>&emsp;&emsp;绘制4个滤波器的幅频、相频、衰减及每次滤波后的信号时域图。</p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145815.png" alt="image-20211128145815600" style="zoom: 25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145835.png" alt="image-20211128145835590" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128153455.png" alt="image-20211128145856791" style="zoom:25%;" /><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128145920.png" alt="image-20211128145920683" style="zoom:25%;" /><p>&nbsp;</p><p>&nbsp;</p><h3 id="Step3：后续处理"><a href="#Step3：后续处理" class="headerlink" title="Step3：后续处理"></a>Step3：后续处理</h3><p>&emsp;&emsp;上面已分析，在噪声开始和结束时刻都有全频段的高强度信号，不是滤波能消除的，这里采用时域衰减，即在时域采用同第一种滤波方法相同的思想，手动衰减这两个时刻的信号强度。随后输出处理过的音频文件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第一个高音时段</span></span><br><span class="line">[m, n] = <span class="built_in">max</span>(audio_data);</span><br><span class="line">audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>) = <span class="number">0.0001</span> * audio_data(n<span class="number">-200</span>: n+<span class="number">200</span>); <span class="comment">% 衰减第二个高音频段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 听一下处理后的音频</span></span><br><span class="line"><span class="comment">% soundsc(audio_data, fs);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出音频文件</span></span><br><span class="line">audiowrite(<span class="string">&#x27;SunshineSquare_Processed.wav&#x27;</span>,audio_data,fs); </span><br></pre></td></tr></table></figure><p>使用滤波法2的最终输出信号的分析如下：</p><p><img src="https://gitee.com/lrk612/md_picture/raw/master/img/20211128150059.png" alt="image-20211128150059309"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="对数字信号处理的认识"><a href="#对数字信号处理的认识" class="headerlink" title="对数字信号处理的认识"></a>对数字信号处理的认识</h2><p>&emsp;&emsp;《数字信号处理》这门课我觉得其实是两大主题，第一是信号分析，第二是信号处理。</p><p>&emsp;&emsp;信号分析在《信号与线性系统》中有所讲解，但是那时所研究的是连续时间信号的傅里叶级数或傅里叶变换，离散时间信号的傅里叶变换，它们的特点都是：信号无限长，导致计算机无法处理。而为了使用计算机工具帮助对信号进行分析，《数字信号处理》这门课引入了采样、增/减采样和离散傅里叶变换DFT的概念。后续考虑到DFT算法的时间复杂度太高，因此又提出快速傅里叶变换FFT来代替之。</p><p>&emsp;&emsp;信号处理在这门课中主要指滤波。低通、高通、带通、带阻、全通，《信号与线性系统》中共提出过五种模拟滤波器，如何根据所需指标将其转化为对应的数字滤波器来在计算机上使用，是这门课的第二个重点。</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>&emsp;&emsp;模拟信号经过采样、抽取（减采样）后成为计算机可以处理的有限长离散信号。采样后，仍是连续时间信号，但频域上是原始模拟信号频域的周期延拓和幅度放缩。抽取后，变为有限长离散信号，频域点数和时域相同，但横坐标频率被按比例压缩在 0~2pi 范围内，幅值和采样后的一样。</p><h5 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h5><p>&emsp;&emsp;在傅里叶变换中，离散/连续 和 周期/非周期 相对偶，离散周期序列的傅里叶变换仍是离散周期序列。因为计算机容量有限，其处理的信号长度有限，因此从离散周期信号中取一个周期来代替整个信号分析是一种行之有效的方法。DFT也正是在这种思想下被引出，重点在于循环卷积、旋转因子、各种变换性质。</p><p>&emsp;&emsp;但是，用定义计算DFT的时间复杂度太高，计算机效率低。借助公式中“旋转因子”的周期性，长序列的DFT可以不断分解至一组组两点DFT的组合，大大减少了计算量，这就是FFT算法。</p><h5 id="数字滤波器"><a href="#数字滤波器" class="headerlink" title="数字滤波器"></a>数字滤波器</h5><p>&emsp;&emsp;数字滤波器有很多值得关注的地方，首先是截止频率、纹波幅度等性能指标，然后是幅频特性、相频特性，还有系统函数的极零点、信号流图等。根据冲激响应长度可分为有限脉冲响应滤波器FIR和无限脉冲响应滤波器IIR。从模拟滤波器转换为数字滤波器的方法有冲激响应不变法、双线性变换法。常用的滤波器有巴特沃斯滤波器、切比雪夫滤波器、椭圆滤波器等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大二一年</title>
      <link href="/2021/12/02/%E3%80%90%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/"/>
      <url>/2021/12/02/%E3%80%90%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F%E3%80%91%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;在华科度过了两年时间里，我看过东九楼前路边的银杏一夜间被北风吹去满树黄叶，也曾在凌晨五点的晨雾中从百景园自习区一路徒步走回韵苑。回想大一大二的时光，涌上我心头的并不是特别的成就感，亦不是其他大喜大悲，而是平淡与坦然。如果要用一句话概括这一年，我想用大物老师曾提到过的——看山不是山。</p><span id="more"></span><p>&emsp;&emsp;现在看来，大一一年里我只做了两件对现在仍有影响的事，一是熟悉了大学的学习方式，把加权拉得很高；二是认识到，每天都在自习室度过，这样和高中没太大区别，我不喜欢只是这样的大学生活。大二开学那阵，我因为加权高并且也有一些课外的成绩所以拿到了国奖，有些自傲，那是心里总觉得大学生活怎么和高中没什么区别呀，无非是可以用iPad记笔记、带手机上课罢了。禅宗里描述有三种境界，“看山是山，看山不是山，看山还是山。”第一次听到这句话是在大物老师的课上，我发觉自己对华科这所学校和大学本身的认识也只是在“看山是山”的层面上，我还没有发现它真正的精彩。</p><p>&emsp;&emsp;大一下学期因为疫情所以一学期都在家，期间不能出门，所以从高中坚持到大学的夜跑习惯也丢掉了，但是也恰好喜欢上了室内健身，大二来到学校后，在一位朋友的影响下去了一学期的健身房，每周会有三四天专门去锻炼。一整天没课时会和这位朋友专门去主图自习，中午步行穿过青年园到百景园或西边小吃城用餐，吃完回来会在图书馆外草地边讨论一些很有意思的话题，时间似乎都变得慢了下来。大一的每天是做不完的事情，时间匆匆流过，却总觉得自己什么都没做，而大二上就这样以一种比较悠闲的节奏度过，虽然加权没有大一时那么高，但那相差的那几点几分换来了我对大学、对自己的另一种认识。</p><p>&emsp;&emsp;大二上的国奖答辩期间认识了不少优秀的同学，寒假我和其中两位同学组队参加了美赛，比赛期间我们异地合作，每天都连麦从天还没亮肝到晚上凌晨，最后一晚通宵修改论文，没有人是在划水摸鱼。对比其他许多队伍我发现，能够遇到值得信任的靠谱队友是多么重要。我们虽然都是第一次接触数模，但是扎实的功底和高效的合作帮助我们出乎意料地最终取得了特等奖提名，其实奖项只是次要的，弥足珍贵的是经历和友谊。</p><p>&emsp;&emsp;大二下在两位队友的建议下，我加入了电信学院大名鼎鼎的科创团队——Dian团队。其实大一就知道Dian团队，但是当时一心只读圣贤书，两耳不闻东九窗外事，没有想过加入这样的团队，算是一个小小的遗憾。不过悟已往之不谏，知来者之可追，加入团队的半年里认识了许多优秀的同学，也学到了好玩并实用的项目知识和技能。在智慧交通项目组我接触到了计算机视觉与实际应用的结合，我们组与萍乡市警方合作设计了用于重点车辆检测的软件，申请到了国家版权局的软件著作权。虽然到了大二下期末，我的总成绩从半年前刚分完专业时的专业第一掉到了第二，学年成绩更是滑落不少，但想象中的懊悔与失落并没有如期而至，倒不如说是现在的我看开了，有些东西和成绩一样重要。</p><p>&emsp;&emsp;代表大二学年尾声的暑假对我而言也是一段不平凡的记忆。七月基本上是在团队中度过的，原本AI组的项目已经结题了，我转到团队与Intel亚太研发有限公司合作的项目中，一直在补习无线通信方面的知识。七月末我本着走入社会、感悟基层的初衷，又一次参与到了暑期社会实践当中，我们到河南洛阳的一家养老院展开调研，却碰上了百年难得一遇的暴雨，火车高铁停运，我也被困回不到郑州的家或学校。后续终于返校，但是因为河南疫情爆发，我被学校组织隔离了28天。被放出来后的第一件事就是去当疫苗接种志愿者，毕竟自己是一名预备党员，只是可惜没能给涝疫同至的家乡献一份力。</p><p>&emsp;&emsp;最后一个比较有意义的事就是去火车站迎新了，以前高中课上老师激励我们说，每年开学期间各个城市的大学都会在火车站设迎新点，越是有名的大学迎新点也越大。虽然最后一句在我当时来到武汉站看见华科的迎新点后就不信了，但是它带给我的归属感却一直萦绕在我心头，所以今年我也要把这种关怀传承下去。</p><p>&emsp;&emsp;其实大二这一年还经历过好多事情，我心里明白自己和一年前不一样了。再一次走向国奖答辩的讲台，我已不再是一年前那患得患失、喜忧参半的心态。既然我的成绩支持我站在这里，那么我所走过的路、感悟到的事情足够让我自信地向台下展示出自己。因为没有刻意把国奖当作目标，也不需要用它来证明什么，毕竟身边有许多同样如此的朋友。</p>]]></content>
      
      
      <categories>
          
          <category> 心得感悟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Love actually is all around</title>
      <link href="/2021/12/01/hello-world/"/>
      <url>/2021/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hello World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
