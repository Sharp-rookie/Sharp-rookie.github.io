<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sharp-rookie.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script> 
   (function(){
          if(''){
              if (prompt('请输入文章密码') !== ''){
                  alert('密码错误！');
                  history.back();
              }
          }
      })();
  </script>
  <meta name="description" content="&amp;emsp;&amp;emsp;我们使用mininet平台作为网络拓扑仿真工具，选择TCP拥塞控制算法作为研究对象，以项目组工作技术背景：5G无线通信场景中的强化学习作为切入点，对 Linux 内核搭载的经典 TCP 拥塞控制算法：Reno、Vegas、Veno、BBR、CUBIC进行调研学习，最终决定对超参数依赖性较强的TCP_Veno算法进行强化学习调优。期间我们把算法直接集成到Linux内核的拥塞控">
<meta property="og:type" content="article">
<meta property="og:title" content="【计网课设】基于强化学习的TCP拥塞控制算法优化">
<meta property="og:url" content="https://sharp-rookie.github.io/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/index.html">
<meta property="og:site_name" content="最忆是江南">
<meta property="og:description" content="&amp;emsp;&amp;emsp;我们使用mininet平台作为网络拓扑仿真工具，选择TCP拥塞控制算法作为研究对象，以项目组工作技术背景：5G无线通信场景中的强化学习作为切入点，对 Linux 内核搭载的经典 TCP 拥塞控制算法：Reno、Vegas、Veno、BBR、CUBIC进行调研学习，最终决定对超参数依赖性较强的TCP_Veno算法进行强化学习调优。期间我们把算法直接集成到Linux内核的拥塞控">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116104456.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116114931.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116115012.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116115023.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116115036.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116115049.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116115059.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116131249.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116105019.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116105214.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116105121.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116105147.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220115224959.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220115225127.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220115225212.png">
<meta property="og:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116104916.png">
<meta property="article:published_time" content="2022-01-16T03:37:44.868Z">
<meta property="article:modified_time" content="2022-04-25T03:39:28.349Z">
<meta property="article:author" content="Lrk612">
<meta property="article:tag" content="Reinforcement Learning">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-picture-1311448338.file.myqcloud.com/img/20220116104456.png">

<link rel="canonical" href="https://sharp-rookie.github.io/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【计网课设】基于强化学习的TCP拥塞控制算法优化 | 最忆是江南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
        <a target="_blank" rel="noopener" href="https://github.com/Sharp-rookie" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">最忆是江南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Love actually is all around</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-list fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-papers">

    <a href="/papers/" rel="section"><i class="fa fa-book fa-fw"></i>论文阅读</a>

  </li>
        <li class="menu-item menu-item-friendlink">

    <a href="/friendlink/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sharp-rookie.github.io/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Lrk612">
      <meta itemprop="description" content="Lrk's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最忆是江南">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【计网课设】基于强化学习的TCP拥塞控制算法优化
        </h1>

        <div class="post-meta">
         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-16 11:37:44" itemprop="dateCreated datePublished" datetime="2022-01-16T11:37:44+08:00">2022-01-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">知识分享</span></a>
                </span>
            </span>

          
            <span id="/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/" class="post-meta-item leancloud_visitors" data-flag-title="【计网课设】基于强化学习的TCP拥塞控制算法优化" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&emsp;&emsp;我们使用mininet平台作为网络拓扑仿真工具，选择TCP拥塞控制算法作为研究对象，以项目组工作技术背景：5G无线通信场景中的强化学习作为切入点，对 Linux 内核搭载的经典 TCP 拥塞控制算法：Reno、Vegas、Veno、BBR、CUBIC进行调研学习，最终决定对超参数依赖性较强的TCP_Veno算法进行强化学习调优。期间我们把算法直接集成到Linux内核的拥塞控制模块，克服了内核态进程内存空间与用户态Python程序交互的映射问题，并使用C语言构造Python模块提高算法效率。同时，我们的强化学习环境也集成到了OpenAI Gym中。</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116104456.png" alt="image-20220116104456599" style="zoom: 80%;" />

<span id="more"></span>

<p>&nbsp;</p>
<h2 id="Linux-TCP拥塞控制算法"><a href="#Linux-TCP拥塞控制算法" class="headerlink" title="Linux TCP拥塞控制算法"></a>Linux TCP拥塞控制算法</h2><h3 id="Linux如何实现TCP拥塞控制"><a href="#Linux如何实现TCP拥塞控制" class="headerlink" title="Linux如何实现TCP拥塞控制"></a>Linux如何实现TCP拥塞控制</h3><p>&emsp;&emsp;其实在Linux内核代码中，拥塞控制包括4个部分：<code>拥塞控制框架</code>、<code>框架与 TCP 其余部分的接口</code>、<code>恢复状态机</code>、<code>不同拥塞的细节控制算法</code>，我们调研的重点是<strong>拥塞控制框架</strong>和<strong>框架与 TCP 其余部分的接口</strong>。</p>
<h4 id="TCP实现中的重要结构体-枚举类型"><a href="#TCP实现中的重要结构体-枚举类型" class="headerlink" title="TCP实现中的重要结构体/枚举类型"></a>TCP实现中的重要结构体/枚举类型</h4><h5 id="tcp-ca-state"><a href="#tcp-ca-state" class="headerlink" title="tcp_ca_state"></a>tcp_ca_state</h5><p>&emsp;&emsp;TCP 的拥塞控制实现中使用<strong>状态机</strong>来保持和在连接的不同状态之间切换，以用于恢复目的。这些不同的状态在 tcp.h 中的枚举类型中定义：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Open</td>
<td>代表TCP连接处于正常状态，没有可疑事件。此状态下接收到的数据包通过快速路径。</td>
</tr>
<tr>
<td>Disorder</td>
<td>收到了ACK 或 dupACK，代表数据包乱序。此状态下一些处理从快路径移动到慢路径</td>
</tr>
<tr>
<td>CER</td>
<td>处理一些拥塞通知事件（例：ECN 或本地设备拥塞）时进入此状态</td>
</tr>
<tr>
<td>Recovery</td>
<td>这种状态表明拥塞窗口已经减小，连接处于快速重传阶段</td>
</tr>
<tr>
<td>Loss</td>
<td>这种状态表明由于 RTO 超时或 SACK 拒绝，拥塞窗口减小</td>
</tr>
</tbody></table>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tcp_ca_state</span> &#123;</span></span><br><span class="line">	TCP_CA_Open = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Open	(1&lt;&lt;TCP_CA_Open)</span></span><br><span class="line">	TCP_CA_Disorder = <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span></span><br><span class="line">	TCP_CA_CWR = <span class="number">2</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_CWR	(1&lt;&lt;TCP_CA_CWR)</span></span><br><span class="line">	TCP_CA_Recovery = <span class="number">3</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span></span><br><span class="line">	TCP_CA_Loss = <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPF_CA_Loss	(1&lt;&lt;TCP_CA_Loss)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h5 id="tcp-congestion-ops"><a href="#tcp-congestion-ops" class="headerlink" title="tcp_congestion_ops"></a>tcp_congestion_ops</h5><p>&emsp;&emsp;定义了用于不同可插拔拥塞控制算法的 TCP 拥塞处理接口，是一个函数调用指针的结构。在 tcp.h 文件中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">	u32 key;</span><br><span class="line">	u32 flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize private data (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*init)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* cleanup private data  (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*release)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* return slow start threshold (required) */</span></span><br><span class="line">	u32 (*ssthresh)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* do new cwnd calculation (required) */</span></span><br><span class="line">	<span class="keyword">void</span> (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);</span><br><span class="line">	<span class="comment">/* call before changing ca_state (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*set_state)(struct sock *sk, u8 new_state);</span><br><span class="line">	<span class="comment">/* call when cwnd event occurs (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*cwnd_event)(struct sock *sk, <span class="keyword">enum</span> tcp_ca_event ev);</span><br><span class="line">	<span class="comment">/* call when ack arrives (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*in_ack_event)(struct sock *sk, u32 flags);</span><br><span class="line">	<span class="comment">/* new value of cwnd after loss (required) */</span></span><br><span class="line">	u32  (*undo_cwnd)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* hook for packet ack accounting (optional) */</span></span><br><span class="line">	<span class="keyword">void</span> (*pkts_acked)(struct sock *sk, <span class="keyword">const</span> struct ack_sample *sample);</span><br><span class="line">	<span class="comment">/* override sysctl_tcp_min_tso_segs */</span></span><br><span class="line">	u32 (*min_tso_segs)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* returns the multiplier used in tcp_sndbuf_expand (optional) */</span></span><br><span class="line">	u32 (*sndbuf_expand)(struct sock *sk);</span><br><span class="line">	<span class="comment">/* call when packets are delivered to update cwnd and pacing rate,</span></span><br><span class="line"><span class="comment">	 * after all the ca_state processing. (optional)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> (*cong_control)(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs);</span><br><span class="line">	<span class="comment">/* get info for inet_diag (optional) */</span></span><br><span class="line">	<span class="keyword">size_t</span> (*get_info)(struct sock *sk, u32 ext, <span class="keyword">int</span> *attr,</span><br><span class="line">			   <span class="keyword">union</span> tcp_cc_info *info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> 		name[TCP_CA_NAME_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> 	*<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中一些重要的函数说明如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>init()</td>
<td>在收到第一个确认(ACK)之后和第一次调用拥塞控制算法之前调用</td>
</tr>
<tr>
<td>pkts_acked()</td>
<td>收到确认某些新数据包的确认(ACK)时导致调用此函数，通过 num_acked 参数传递确认的数据包数</td>
</tr>
<tr>
<td>cong_avoid()</td>
<td>每次收到确认(ACK)并且拥塞控制状态允许拥塞窗口增加时调用此函数</td>
</tr>
<tr>
<td>undo_cwnd()</td>
<td>在检测到错误的丢失检测（由于错误的超时或数据包重新排序）时，返回流的拥塞窗口大小</td>
</tr>
</tbody></table>
<p>&nbsp;</p>
<h4 id="内核中-TCP-代码的主要文件"><a href="#内核中-TCP-代码的主要文件" class="headerlink" title="内核中 TCP 代码的主要文件"></a>内核中 TCP 代码的主要文件</h4><p>&emsp;&emsp;Linux Kernel中有关TCP的代码基本上都在<code>net/ipv4/</code>目录下，主要包括：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>tcp.h</td>
<td>包含TCP相关结构体的声明，在include/net/下</td>
</tr>
<tr>
<td>tcp.c</td>
<td>包含通用 TCP 代码、涵盖不同Socket之间的接口和TCP代码的其余部分</td>
</tr>
<tr>
<td>tcp_input.c</td>
<td>处理来自网络的传入数据包的最大和最重要的文件；包含恢复状态机的代码</td>
</tr>
<tr>
<td>tcp_output.c</td>
<td>处理向网络发送数据包；包含一些从拥塞控制框架调用的函数</td>
</tr>
<tr>
<td>tcp_ipv4.c</td>
<td>IPv4 TCP 特定代码；将相关数据包交给拥塞控制框架</td>
</tr>
<tr>
<td>tcp_timer.c</td>
<td>实现定时器管理功能</td>
</tr>
<tr>
<td>tcp_cong.c</td>
<td>实现可插拔 TCP 拥塞控制支持和拥塞控制的核心框架；默认使用 New Reno 机制</td>
</tr>
<tr>
<td>tcp_[name of algorithm].c</td>
<td>不同TCP拥塞控制算法文件，例如：tcp_vegas.c、tcp_cubic.c等</td>
</tr>
</tbody></table>
<p>&nbsp;</p>
<h4 id="TCP拥塞控制算法-注册-初始化-传参"><a href="#TCP拥塞控制算法-注册-初始化-传参" class="headerlink" title="TCP拥塞控制算法 注册-初始化-传参"></a>TCP拥塞控制算法 注册-初始化-传参</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>实现的算法可以通过实例化该结构体、调用注册函数实现算法的注册（例：bbr）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> <span class="title">tcp_bbr_cong_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.flags		= TCP_CONG_NON_RESTRICTED,</span><br><span class="line">	.name		= <span class="string">&quot;bbr&quot;</span>,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.init		= bbr_init,</span><br><span class="line">	.cong_control	= bbr_main,</span><br><span class="line">	.sndbuf_expand	= bbr_sndbuf_expand,</span><br><span class="line">	.undo_cwnd	= bbr_undo_cwnd,</span><br><span class="line">	.cwnd_event	= bbr_cwnd_event,</span><br><span class="line">	.ssthresh	= bbr_ssthresh,</span><br><span class="line">	.min_tso_segs	= bbr_min_tso_segs,</span><br><span class="line">	.get_info	= bbr_get_info,</span><br><span class="line">	.set_state	= bbr_set_state,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">bbr_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct bbr) &gt; ICSK_CA_PRIV_SIZE);</span><br><span class="line">	<span class="keyword">return</span> tcp_register_congestion_control(&amp;tcp_bbr_cong_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li><p>算法的参数通常是定义在一个结构体里（例：cubic）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BIC TCP Parameters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> &#123;</span></span><br><span class="line">	u32	cnt;		<span class="comment">/* increase cwnd by 1 after ACKs */</span></span><br><span class="line">	u32	last_max_cwnd;	<span class="comment">/* last maximum snd_cwnd */</span></span><br><span class="line">	u32	last_cwnd;	<span class="comment">/* the last snd_cwnd */</span></span><br><span class="line">	u32	last_time;	<span class="comment">/* time when updated last_cwnd */</span></span><br><span class="line">	u32	bic_origin_point;<span class="comment">/* origin point of bic function */</span></span><br><span class="line">	u32	bic_K;		<span class="comment">/* time to origin point</span></span><br><span class="line"><span class="comment">				   from the beginning of the current epoch */</span></span><br><span class="line">	u32	delay_min;	<span class="comment">/* min delay (msec &lt;&lt; 3) */</span></span><br><span class="line">	u32	epoch_start;	<span class="comment">/* beginning of an epoch */</span></span><br><span class="line">	u32	ack_cnt;	<span class="comment">/* number of acks */</span></span><br><span class="line">	u32	tcp_cwnd;	<span class="comment">/* estimated tcp cwnd */</span></span><br><span class="line">	u16	unused;</span><br><span class="line">	u8	sample_cnt;	<span class="comment">/* number of samples to decide curr_rtt */</span></span><br><span class="line">	u8	found;		<span class="comment">/* the exit point is found? */</span></span><br><span class="line">	u32	round_start;	<span class="comment">/* beginning of each round */</span></span><br><span class="line">	u32	end_seq;	<span class="comment">/* end_seq of the round */</span></span><br><span class="line">	u32	last_ack;	<span class="comment">/* last time when the ACK spacing is close */</span></span><br><span class="line">	u32	curr_rtt;	<span class="comment">/* the minimum rtt of current round */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化函数中，算法申请私有空间，初始化参数</p>
</li>
<li><p>可以在算法模块中声明一些参数，并调<code>module_param(name,type,perm)</code>使得参数可以在insmod的时候传入（例：cubic）</p>
<ul>
<li>name 既是用户看到的参数名，又是模块内接受参数的变量</li>
<li>type 表示参数的数据类型，是下列之一：byte, short, ushort, int, uint, long, ulong, charp, bool, invbool;</li>
<li>perm 指定了在sysfs中相应文件的访问权限。访问权限与linux文件访问权限相同的方式管理，如0644，或使用stat.h中的宏如S_IRUGO表示。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note parameters that are used for precomputing scale factors are read-only */</span></span><br><span class="line">module_param(fast_convergence, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(fast_convergence, <span class="string">&quot;turn on/off fast convergence&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><ul>
<li><p>根据上面的信息，我们知道算法的参数定义在结构体里</p>
</li>
<li><p>算法的每个步骤，都会从传入的socket得到一个算法结构体，这个过程是怎么实现的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***example cubic***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bictcp</span> *<span class="title">ca</span> =</span> inet_csk_ca(sk);</span><br><span class="line"><span class="comment">/***example bbr***/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bbr</span> *<span class="title">bbr</span> =</span> inet_csk_ca(sk);</span><br></pre></td></tr></table></figure></li>
<li><p>首先从当前socket获取tcp socket结构体</p>
</li>
<li><ul>
<li>tcp_sock结构体定义于<code>/include/linux/tcp.h#L138</code></li>
<li>主要用来保存tcp相关的信息</li>
</ul>
</li>
<li><p>然后从socket获取算法结构体</p>
</li>
<li><ul>
<li>调用<code>inet_csk_ca</code>，获得<code>inet_csk(sk)-&gt;icsk_ca_priv</code></li>
<li><code>icsk_ca_priv</code>是<code>inet_connection_sock</code>结构体的一部分</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3 id="Linux-内核拥塞控制算法浅析"><a href="#Linux-内核拥塞控制算法浅析" class="headerlink" title="Linux 内核拥塞控制算法浅析"></a>Linux 内核拥塞控制算法浅析</h3><h4 id="TCP-Vegas"><a href="#TCP-Vegas" class="headerlink" title="TCP Vegas"></a>TCP Vegas</h4><blockquote>
<p>REF:  <a target="_blank" rel="noopener" href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p>
<p><em>A TCP sender can easily measure available bandwidth; the simplest measurement is cwnd/RTT (measured in packets/sec). Let us denote this bandwidth estimate by BWE; for the time being we will accept BWE as accurate, though see</em> <a target="_blank" rel="noopener" href="http://intronetworks.cs.luc.edu/1/html/newtcps.html#ack-compression"><em>15.6.1  ACK Compression and Westwood+</em></a> <em>below. TCP Vegas estimates RTTnoLoad by the minimum RTT (RTTmin) encountered during the connection. The “ideal” cwnd that just saturates the bottleneck link is BWE×RTTnoLoad. Note that BWE will be much more volatile than RTTmin; the latter will typically reach its final value early in the connection, while BWE will fluctuate up and down with congestion (which will also act on RTT, but by increasing it).</em></p>
</blockquote>
<ul>
<li><p>特点：基于时延</p>
</li>
<li><p>拥塞判断标准：RTT增加</p>
</li>
<li><p>优点：较好地预测带宽</p>
</li>
<li><p>缺点：竞争性差。网络环境中有其他主机采用基于丢包的算法时，由于他们会尝试填满缓冲区，会导致Vegas估计地RTT增大，性能不断被挤占，只适用于<strong>只使用Vegas的网络环境</strong>中</p>
</li>
</ul>
<p>&nbsp;</p>
<h4 id="TCP-Veno"><a href="#TCP-Veno" class="headerlink" title="TCP Veno"></a>TCP Veno</h4><blockquote>
<p>REF:  <a target="_blank" rel="noopener" href="http://intronetworks.cs.luc.edu/1/html/newtcps.html">http://intronetworks.cs.luc.edu/1/html/newtcps.html</a></p>
<ul>
<li><p><em>慢开始阶段</em></p>
<p><em>if Nqueue&lt;𝛽, cwnd = cwnd + 1 each RTT</em></p>
<p><em>if Nqueue≥𝛽, cwnd = cwnd + 0.5 each RTT</em></p>
</li>
<li><p><em>丢包发生时：</em></p>
<p><em>if Nqueue&lt;𝛽, the loss is probably not due to congestion; set cwnd = (4/5)×cwnd</em></p>
<p><em>if Nqueue≥𝛽, the loss probably is due to congestion; set cwnd = (1/2)×cwnd as usual</em></p>
</li>
</ul>
</blockquote>
<ul>
<li><p>特点：Reno + Vegas</p>
<ul>
<li><p>利用Vegas的RTT测量机制，同时保有Reno贪婪、线性增加的机制</p>
</li>
<li><p>遇到的丢包大部分是非拥塞产生时，Veno行为接近Reno</p>
</li>
</ul>
</li>
<li><p>优点：在<strong>时延带宽积适中的、丢包率高的链路</strong>表现好</p>
</li>
<li><p>缺点：不能解决长肥管道问题</p>
</li>
</ul>
<p>&nbsp;</p>
<h4 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h4><ul>
<li><p>特点：基于带宽和延迟（链路容量）</p>
</li>
<li><p>优点：</p>
<ul>
<li>避免Bufferfloat</li>
<li>丢包不作为拥塞控制信号，在长肥管道场景表现也很好，适用于<strong>高带宽、高时延、有一定丢包率的长肥网络</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>当网络设备缓存比较大的时候，竞争不过Cubic等激进算法</li>
<li>公平性问题：RTT越大，抢占能力越强</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><ul>
<li><p>特点：</p>
<ul>
<li>基于丢包</li>
<li>AIMD（线性增乘性减）</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>在早期<strong>低带宽低时延</strong>网络中能很好发挥作用</li>
<li>公平性</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>在高带宽高延时网络（long-fat pipe 长肥管道）中，RTT很大，ACK接收时延大，导致拥塞窗口增长慢</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4 id="TCP-CUBIC"><a href="#TCP-CUBIC" class="headerlink" title="TCP CUBIC"></a>TCP CUBIC</h4><ul>
<li><p>特点：</p>
<ul>
<li>基于丢包</li>
<li>三次函数增加，乘性减小</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>Cubic算法的优点在于只要没有出现丢包，就不会主动降低自己的发送速度，可以最大程度的利用网络剩余带宽，提高吞吐量，在<strong>高带宽、低丢包率</strong>的网络中可以发挥较好的性能。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>无法区分拥塞丢包和传输错误丢包</li>
<li>过于激进，在没有出现丢包时会不停地增加拥塞窗口的大小，想要填满缓冲区，导致排队时延增加（Bufferbloat现象）</li>
</ul>
</li>
</ul>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116114931.png" alt="image-20220116114931639" style="zoom: 40%;" />

<p>&nbsp;</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TCP Reno</td>
<td>基于丢包 AIMD</td>
<td>公平性</td>
<td>不适用于长肥网络</td>
</tr>
<tr>
<td>TCP Cubic</td>
<td>基于丢包   三次增乘性减</td>
<td>带宽利用率高</td>
<td>激进、Bufferbloat</td>
</tr>
<tr>
<td>TCP Vegas</td>
<td>基于时延RTT</td>
<td>较好预测带宽</td>
<td>竞争性差</td>
</tr>
<tr>
<td>TCP Veno</td>
<td>Reno + Vegas</td>
<td>折衷、综合以上优点</td>
<td>没解决长肥网络</td>
</tr>
<tr>
<td>TCP BBR</td>
<td>基于带宽和时延</td>
<td>避免Bufferbloat</td>
<td>公平性模糊</td>
</tr>
</tbody></table>
<p>&nbsp;</p>
<h2 id="强化学习改进Veno算法"><a href="#强化学习改进Veno算法" class="headerlink" title="强化学习改进Veno算法"></a>强化学习改进Veno算法</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h4 id="Veno算法核心"><a href="#Veno算法核心" class="headerlink" title="Veno算法核心"></a>Veno算法核心</h4><ol>
<li><p>根据拥塞窗口和往返时间估计当前队列堆积的报文个数N</p>
<blockquote>
<p>首先计算期望发送速率和实际速率：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116115012.png" alt="image-20220116115012530" style="zoom: 67%;" />

<p>二者差值：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116115023.png" alt="image-20220116115023138" style="zoom: 67%;" />

<p>估计堆积报文个数N：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116115036.png" alt="image-20220116115036767" style="zoom:67%;" /></blockquote>
</li>
<li><p>根据N值调整拥塞控制算法</p>
<blockquote>
<p>慢启动阶段：与Reno相同无变化</p>
<p>AIMD——加性增阶段：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116115049.png" alt="image-20220116115049018" style="zoom:67%;" />

<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;beta 是一个超参数、增速1、0.5也是超参</p>
<p>AIMD——乘性减阶段：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116115059.png" alt="image-20220116115059582" style="zoom: 60%;" />

<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4/5、1/2也是超参</p>
</blockquote>
</li>
</ol>
<h4 id="强化学习设计思路"><a href="#强化学习设计思路" class="headerlink" title="强化学习设计思路"></a>强化学习设计思路</h4><p>目标：优化超参数（核心函数：tcp_veno_cong_avoid（））</p>
<p>输入：</p>
<ul>
<li><p>basertt</p>
</li>
<li><p>minrtt   # 在Veno中这个变量其实是实时rtt，并不是最小rtt</p>
</li>
</ul>
<p>输出：</p>
<ul>
<li><p>beta</p>
</li>
<li><p>threshold1（加性增时）</p>
</li>
</ul>
<p>注意，加性增时的”0.5“在源代码中不是通过变量表示的，而是通过标志位veno-&gt;cnt，所以需要重构代码：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116131249.png" alt="image-20220116131249660" style="zoom:50%;" />

<p>模型框架：(基于DQN)</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116105019.png" alt="image-20220116105019402" style="zoom: 33%;" />

<h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p>github：<a target="_blank" rel="noopener" href="https://github.com/Gaopeili/lgd">Computer Network Course Design using Mininet simulator</a></p>
<p>&nbsp;</p>
<h3 id="实验观察"><a href="#实验观察" class="headerlink" title="实验观察"></a>实验观察</h3><h4 id="仿真环境"><a href="#仿真环境" class="headerlink" title="仿真环境"></a>仿真环境</h4><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul>
<li>Mininet 2.3.0</li>
<li>Linux kernel v5.4</li>
<li>KVM搭建的Mininet虚拟机</li>
</ul>
<h5 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h5><p>&emsp;&emsp;选择搭建经典的 <code>bottleneck</code> 结构，设置传输过程中某条链路带宽较小且延迟较大，发送方以较大比特率发送数据，来构建出网络拓扑模型：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116105214.png" alt="image-20220116105213972" style="zoom:75%;" />

<h5 id="拥塞场景"><a href="#拥塞场景" class="headerlink" title="拥塞场景"></a>拥塞场景</h5><p>&emsp;&emsp;创建好网络拓扑之后，调整各个client的发送速率，使用命令行工具iperf来模拟客户端与服务端。Client1，Client2以100Mbps的速率发送TCP数据包，Client3以50Mbps的速率发送UDP数据包，使用wireshark工具观察拥塞现象，发现throughput发生了明显的下降、RTT明显增加并且出现了丢包现象。</p>
<h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p>&emsp;&emsp;观察到拥塞现象后，我们使用Linux内核提供的各种算法进行拥塞控制。从iperf提供的输出观察到了cwnd慢启动、加性增乘性减的过程，并且对比了不同算法之间的异同：</p>
<h5 id="算法性能测试"><a href="#算法性能测试" class="headerlink" title="算法性能测试"></a>算法性能测试</h5><p><img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116105121.png" alt="image-20220116105121283"></p>
<p>&emsp;&emsp;从图中可见，Reno、Veno、RL_Veno因为拥塞控制机制相似，所以实际算法性能指标曲线大致相似，但是Veno比Reno平均吞吐量更高；BBR与Vegas因为拥塞控制机制相似，所以实际算法性能指标曲线也大致相似；CUBIC使用三次方函数拟合曲线，性能曲线形状与其他几种算法都不同。</p>
<h5 id="Veno与RL-Veno对比"><a href="#Veno与RL-Veno对比" class="headerlink" title="Veno与RL_Veno对比"></a>Veno与RL_Veno对比</h5><p><img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116105147.png" alt="image-20220116105147073"></p>
<p>&emsp;&emsp;Veno、RL_Veno因为拥塞控制机制一致，所以实际算法性能指标曲线大致相同，但是由于RL_Veno中我们由强化学习Actor网络动态计算阈值β，所以在探索性上显得更为激进，但同时由于强化学习反馈敏感的特性，RL_Veno在收敛速度上也更胜一筹。</p>
<p>&nbsp;</p>
<h2 id="环境配置与仿真平台"><a href="#环境配置与仿真平台" class="headerlink" title="环境配置与仿真平台"></a>环境配置与仿真平台</h2><h3 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h3><p>查看当前可用的拥塞算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>如图，服务器上ubuntu下目前可使用的拥塞控制有<code>cubic</code>和<code>reno</code>：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220115224959.png" alt="image-20220115224959598" style="zoom: 67%;" />



<p>查看当前使用了哪种拥塞算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>目前是用的是<code>cubic</code>（默认）：</p>
<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220115225127.png" alt="image-20220115225127025" style="zoom:67%;" />



<p>设置当前使用的拥塞算法(为reno)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_congestion_control=reno</span><br></pre></td></tr></table></figure>

<img src="https://my-picture-1311448338.file.myqcloud.com/img/20220115225212.png" alt="image-20220115225212546" style="zoom:67%;" />

<p>&nbsp;</p>
<h3 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h3><p>&emsp;&emsp;Mininet是由斯坦福大学基于Linux <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Container&spm=1001.2101.3001.7020">Container</a>架构开发的一个进程虚拟化网络仿真工具，可以创建一个包含主机，交换机，控制器和链路的虚拟网络，其交换机支持OpenFlow，具备高度灵活的自定义软件定义网络。</p>
<p>官网：<a target="_blank" rel="noopener" href="http://mininet.org/">Mininet</a></p>
<p>github仓库：<a target="_blank" rel="noopener" href="https://github.com/mininet/mininet">mininet</a></p>
<h4 id="网络构建启动参数"><a href="#网络构建启动参数" class="headerlink" title="网络构建启动参数"></a>网络构建启动参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>释放之前创建拓扑时占用的未释放资源</td>
</tr>
<tr>
<td>-h</td>
<td>查看帮助</td>
</tr>
<tr>
<td>–topo</td>
<td>定义创建的拓扑结构</td>
</tr>
<tr>
<td>–custom</td>
<td>创建自定义拓扑（python脚本）</td>
</tr>
<tr>
<td>–switch</td>
<td>定义要使用的交换机</td>
</tr>
<tr>
<td>–controller</td>
<td>定义要使用的控制器</td>
</tr>
<tr>
<td>–mac</td>
<td>自动设置设备的MAC地址</td>
</tr>
<tr>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>dump</td>
<td>显示每个节点的接口设置和表示每个节点的进程PID</td>
</tr>
<tr>
<td>net</td>
<td>显示拓扑连接信息</td>
</tr>
<tr>
<td>nodes</td>
<td>显示节点信息</td>
</tr>
<tr>
<td>links</td>
<td>显示链路健壮性信息</td>
</tr>
<tr>
<td>dpctl</td>
<td>交换机流表控制</td>
</tr>
<tr>
<td>iperf</td>
<td>节点间tcp带宽测试</td>
</tr>
<tr>
<td>help</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>xterm</td>
<td>开启节点可视化操作界面(terminal)</td>
</tr>
<tr>
<td>py</td>
<td>执行后面python表达式</td>
</tr>
<tr>
<td>pingall</td>
<td>在网络中的所有主机之间执行ping测试</td>
</tr>
<tr>
<td>exit</td>
<td>退出mininet</td>
</tr>
</tbody></table>
<p>示例：</p>
<p><img src="https://my-picture-1311448338.file.myqcloud.com/img/20220116104916.png" alt="image-20220116104916505"></p>
<h4 id="Python自定义拓扑脚本"><a href="#Python自定义拓扑脚本" class="headerlink" title="Python自定义拓扑脚本"></a>Python自定义拓扑脚本</h4><p>&emsp;&emsp;mininet支持使用python脚本自定义网络拓扑结构和通信场景设置，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwesomeBottleneckTopo</span>(<span class="params">Topo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Build Awesome Topo for Computer Network Design&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, client_num=<span class="number">3</span>, server_num=<span class="number">3</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  awesome_client1                                    awesome_server1(5Mbps)</span></span><br><span class="line">        <span class="comment">#                  \ 40Mbps                 40Mbps   /</span></span><br><span class="line">        <span class="comment">#  awesome_client2 --------- s1 --------- s2 -------- awesome_server2(30Mbps)</span></span><br><span class="line">        <span class="comment">#                  /          35Mbps(20ms)           \</span></span><br><span class="line">        <span class="comment">#  awesome_client3                                    awesome_server3(20Mbps)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># TODO(gpl): add awesome topo</span></span><br><span class="line">        self.clients = [self.addHost(<span class="string">f&#x27;h<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(client_num)]</span><br><span class="line">        self.servers = [self.addHost(<span class="string">f&#x27;n<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(server_num)]</span><br><span class="line"></span><br><span class="line">        self.s1 = self.addSwitch(<span class="string">&#x27;awesome-s1&#x27;</span>)</span><br><span class="line">        self.s2 = self.addSwitch(<span class="string">&#x27;awesome-s2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        linkops = <span class="built_in">dict</span>(bw=<span class="number">35</span>, delay=<span class="string">&#x27;5ms&#x27;</span>,</span><br><span class="line">                       max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">        self.addLink(self.s1, self.s2, **linkops)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;clients:&quot;</span>, self.clients)</span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> self.clients:</span><br><span class="line">            <span class="built_in">print</span>(client)</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(client, self.s1, **linkops)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">            linkops = <span class="built_in">dict</span>(bw=<span class="number">40</span>, max_queue_size=<span class="number">1000</span>, use_htb=<span class="literal">True</span>)</span><br><span class="line">            self.addLink(server, self.s2, **linkops)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    backwnd = BottleneckBackend(AwesomeBottleneckTopo())</span><br></pre></td></tr></table></figure>

<h4 id="GUI界面构建拓扑"><a href="#GUI界面构建拓扑" class="headerlink" title="GUI界面构建拓扑"></a>GUI界面构建拓扑</h4><p>&emsp;&emsp;mininet支持使用GUI图形界面构造网络拓扑结构，执行<code>mininet/examples/miniedit.py</code>脚本即可。</p>
<p>&nbsp;</p>
<h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h3 id="任务分工"><a href="#任务分工" class="headerlink" title="任务分工"></a>任务分工</h3><table>
<thead>
<tr>
<th><strong>任务</strong></th>
<th><strong>负责人</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Mininet拓扑、强化学习环境搭建、OpenAI-gym集成</td>
<td>gpl</td>
</tr>
<tr>
<td>Linux源码阅读、算法调研、驱动模块</td>
<td>dhy</td>
</tr>
<tr>
<td>CPython模块、Linux内核/用户空间映射、算法调研、系统测试</td>
<td>lrk</td>
</tr>
</tbody></table>
<h3 id="突出亮点"><a href="#突出亮点" class="headerlink" title="突出亮点"></a>突出亮点</h3><ul>
<li>新的工具（Mininet，iperf，dcpctl，wireshark…）</li>
<li>真实环境（与内核交互，可与真实环境通信）</li>
<li>参考资料较少（原创性强，成就感较大）</li>
<li>适当修改后可作为项目组新人培训任务</li>
</ul>
<h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><ul>
<li>Mininet CLI和python API用法差别较大，有一丢丢大坑</li>
<li>翻看内核源码，内核态和用户态交互</li>
<li>强化学习环境自行搭建并集成到gym中</li>
</ul>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ul>
<li>时间紧张，消融学习有待改进</li>
<li>部分代码还需重构</li>
<li>强化学习算法设计</li>
</ul>
<p>&nbsp;</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h5 id="Linux-Kernel-中TCP拥塞控制实现机制"><a href="#Linux-Kernel-中TCP拥塞控制实现机制" class="headerlink" title="Linux Kernel 中TCP拥塞控制实现机制"></a>Linux Kernel 中TCP拥塞控制实现机制</h5><p><a target="_blank" rel="noopener" href="https://lrk612.com/resources/TCP-CongestionControlFinal.pdf">TCP’s Congestion Control Implementation in Linux Kernel</a></p>
<p><a target="_blank" rel="noopener" href="http://www.yonch.com/tech/linux-tcp-congestion-control-internals">Linux TCP congestion control internals </a></p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4/source">在线查看各版本 Linux Kernel 源码</a></p>
<h5 id="TCP拥塞控制算法分析"><a href="#TCP拥塞控制算法分析" class="headerlink" title="TCP拥塞控制算法分析"></a>TCP拥塞控制算法分析</h5><p><a target="_blank" rel="noopener" href="https://lrk612.com/resources/Veno.pdf">TCP Veno: TCP Enhancement for Transmission Over Wireless Access NetworksCheng</a></p>
<h5 id="mininet仿真平台"><a href="#mininet仿真平台" class="headerlink" title="mininet仿真平台"></a>mininet仿真平台</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ft4y1a7ip?p=11">b站 mininet 使用教程</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Lrk612
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://sharp-rookie.github.io/2022/01/16/%E3%80%90%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%E3%80%91Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6/" title="【计网课设】基于强化学习的TCP拥塞控制算法优化">https://sharp-rookie.github.io/2022/01/16/【计网课设】Linux-TCP拥塞控制研究/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reinforcement-Learning/" rel="tag"># Reinforcement Learning</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/03/%E3%80%90%E7%9F%A5%E8%AF%86%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="prev" title="计算机网络知识总结">
      <i class="fa fa-chevron-left"></i> 计算机网络知识总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/16/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADQN%E7%AE%97%E6%B3%95%E6%97%8F/" rel="next" title="【强化学习】深度强化学习：DQN算法族">
      【强化学习】深度强化学习：DQN算法族 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text">Linux TCP拥塞控制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">Linux如何实现TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">TCP实现中的重要结构体&#x2F;枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tcp-ca-state"><span class="nav-text">tcp_ca_state</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tcp-congestion-ops"><span class="nav-text">tcp_congestion_ops</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%B8%AD-TCP-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%87%E4%BB%B6"><span class="nav-text">内核中 TCP 代码的主要文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%B3%A8%E5%86%8C-%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%BC%A0%E5%8F%82"><span class="nav-text">TCP拥塞控制算法 注册-初始化-传参</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-text">注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82"><span class="nav-text">传参</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90"><span class="nav-text">Linux 内核拥塞控制算法浅析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-Vegas"><span class="nav-text">TCP Vegas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-Veno"><span class="nav-text">TCP Veno</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-BBR"><span class="nav-text">TCP BBR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-Reno"><span class="nav-text">TCP Reno</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-CUBIC"><span class="nav-text">TCP CUBIC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-text">对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9BVeno%E7%AE%97%E6%B3%95"><span class="nav-text">强化学习改进Veno算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-text">设计思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Veno%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="nav-text">Veno算法核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-text">强化学习设计思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93"><span class="nav-text">代码仓库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%82%E5%AF%9F"><span class="nav-text">实验观察</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83"><span class="nav-text">仿真环境</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC"><span class="nav-text">软件版本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="nav-text">拓扑结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E5%9C%BA%E6%99%AF"><span class="nav-text">拥塞场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94"><span class="nav-text">效果对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-text">算法性能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Veno%E4%B8%8ERL-Veno%E5%AF%B9%E6%AF%94"><span class="nav-text">Veno与RL_Veno对比</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0"><span class="nav-text">环境配置与仿真平台</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF"><span class="nav-text">查看内核信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mininet"><span class="nav-text">Mininet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%9E%84%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="nav-text">网络构建启动参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%93%E6%89%91%E8%84%9A%E6%9C%AC"><span class="nav-text">Python自定义拓扑脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GUI%E7%95%8C%E9%9D%A2%E6%9E%84%E5%BB%BA%E6%8B%93%E6%89%91"><span class="nav-text">GUI界面构建拓扑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93"><span class="nav-text">工作总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B7%A5"><span class="nav-text">任务分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%81%E5%87%BA%E4%BA%AE%E7%82%B9"><span class="nav-text">突出亮点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9A%BE%E7%82%B9"><span class="nav-text">工作难点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-text">不足之处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-text">Reference</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux-Kernel-%E4%B8%ADTCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux Kernel 中TCP拥塞控制实现机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">TCP拥塞控制算法分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mininet%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0"><span class="nav-text">mininet仿真平台</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lrk612"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lrk612</p>
  <div class="site-description" itemprop="description">Lrk's blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">arXiv</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ieeexplore.ieee.org/Xplore/home.jsp" title="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;Xplore&#x2F;home.jsp" rel="noopener" target="_blank">IEEE Xplore</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <!-- 访问量 -->

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<!-- 版权 -->
<div class="copyright">
  
  &copy; 2021-12-1 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lrk612</span>
</div>

<!-- ICP备案 -->
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">ICP备案 </a>
      <img src="https://my-picture-1311448338.file.myqcloud.com/img/20211209170739.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2021035798" rel="noopener" target="_blank">豫ICP备2021035798号 </a>
  </div>

<!-- 不知道是什么 -->
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fH6OdGBcCG8D6jC8NeeJlX9b-gzGzoHsz',
      appKey     : '1UoIb6vszMw6wl0n7kreb4Xz',
      placeholder: "Just go go ^_^",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
  }, window.Valine);
});
</script>

</body>
</html>
